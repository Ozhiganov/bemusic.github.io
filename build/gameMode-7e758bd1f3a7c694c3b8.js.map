{"version":3,"sources":["webpack:///gameMode-7e758bd1f3a7c694c3b8.js","webpack:///../~/debug/browser.js?c176**","webpack:///../~/ramda/dist/ramda.js?f819**","webpack:///../~/co/index.js?5989**","webpack:///../~/webpack/~/node-libs-browser/~/process/browser.js?a2a2**","webpack:///./progress/utils.js?8e3b*","webpack:///./read-blob/index.js?2651*","webpack:///../~/audio-context/index.js?af50*","webpack:///../~/babel-core/lib/babel/polyfill.js?4b68**","webpack:///../~/babel-core/~/core-js/shim.js?6ba2**","webpack:///../~/babel-core/~/regenerator-babel/runtime.js?a7cc**","webpack:///../~/babel-core/polyfill.js?f7ef**","webpack:///./polyfill/index.js?fe58**","webpack:///../~/bluebird/js/browser/bluebird.js?9cae**","webpack:///../~/debug/debug.js?2509**","webpack:///../~/debug/~/ms/index.js?5d08**","webpack:///./sampling-master/index.js?b6e4*","webpack:///../~/data-structure/index.js?12c8","webpack:///../~/webpack/~/node-libs-browser/~/buffer/index.js?d66e*","webpack:///../~/audio-context/~/global/window.js?bfdb*","webpack:///./download/index.js?cd97*","webpack:///../~/webpack/~/node-libs-browser/~/url/url.js?234c*","webpack:///../~/webpack/buildin/module.js?17a8*","webpack:///../~/bms/~/bemuse-chardet/match.js","webpack:///../~/webpack/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js?e143*","webpack:///../~/webpack/~/node-libs-browser/~/buffer/~/ieee754/index.js?2e40*","webpack:///../~/webpack/~/node-libs-browser/~/buffer/~/is-array/index.js?a57a*","webpack:///../~/webpack/~/node-libs-browser/~/punycode/punycode.js?1544*","webpack:///../~/bms/bms/chart.js","webpack:///../~/bms/bms/headers.js","webpack:///../~/bms/bms/objects.js","webpack:///../~/bms/speedcore/index.js","webpack:///../~/bms/time-signatures/index.js","webpack:///../~/bms/util/match.js","webpack:///../~/webpack/~/node-libs-browser/~/util/util.js","webpack:///./game/audio-loader.js?857d","webpack:///./resources/bemuse-package.js?fbbf","webpack:///../~/bms/compiler/index.js","webpack:///../~/bms/notes/index.js","webpack:///../~/bms/notes/note.js","webpack:///../~/bms/speedcore/segment.js","webpack:///../~/bms/timing/index.js","webpack:///../~/lazy-property/lazyProperty.js?e3b4","webpack:///../~/throat/index.js?4627","webpack:///./game/index.js","webpack:///./game/game-loader.js","webpack:///./game/loading-scene/index.js","webpack:///./resources/url.js","webpack:///./scene-manager/index.js","webpack:///./view/index.js","webpack:///../~/bms/index.js","webpack:///../~/bms/keysounds/index.js","webpack:///../~/bms/~/bemuse-chardet/bemuse-chardet.js","webpack:///../~/bms/~/bemuse-chardet/encoding/iso2022.js","webpack:///../~/bms/~/bemuse-chardet/encoding/mbcs.js","webpack:///../~/bms/~/bemuse-chardet/encoding/sbcs.js","webpack:///../~/bms/~/bemuse-chardet/encoding/unicode.js","webpack:///../~/bms/~/bemuse-chardet/encoding/utf8.js","webpack:///../~/bms/~/lodash/index.js","webpack:///../~/bms/reader/index.web.js","webpack:///../~/bms/song-info/index.js","webpack:///../~/bytes/index.js","webpack:///./game/loading-scene/style.scss","webpack:///../assets/bg/a.jpg","webpack:///./game/loading-scene/view.jade?c50a","webpack:///../~/ractive/ractive.js","webpack:///./game/loading-scene/style.scss?9570","webpack:///../~/webpack/~/node-libs-browser/~/events/events.js","webpack:///../~/webpack/~/node-libs-browser/~/path-browserify/index.js","webpack:///../~/webpack/~/node-libs-browser/~/util/~/inherits/inherits_browser.js","webpack:///../~/webpack/~/node-libs-browser/~/util/support/isBufferBrowser.js","webpack:///./game/loading-scene/view.jade"],"names":["webpackJsonp",5,"module","exports","__webpack_require__","useColors","document","documentElement","style","window","console","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","arguments","this","namespace","humanize","diff","c","color","concat","Array","prototype","slice","call","index","lastC","replace","splice","log","Function","apply","save","namespaces","storage","removeItem","debug","e","load","r","chrome","local","localStorage","colors","formatters","j","v","JSON","stringify","enable",10,"__","ramda","_add","a","b","_all","fn","list","idx","length","_any","_compose","f","g","_concat","set1","set2","len1","len2","result","_containsWith","pred","x","len","_createMaxMinBy","comparator","valueComputer","computedCurrent","winner","computedWinner","_filter","_filterIndexed","_foldl","acc","_forEach","_functionsWith","obj","key","_gt","_indexOf","item","from","Math","max","_isArray","isArray","val","Object","toString","_isInteger","Number","isInteger","n","_isThenable","value","then","_lastIndexOf","min","_lt","_map","_multiply","_noArgsException","TypeError","_nth","_pCompose","context","_pairWith","_path","paths","_pickAll","names","copy","name","_prepend","el","_satisfiesSpec","spec","parsedSpec","testObj","fnLen","objLen","_slice","to","always","arity","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","Error","cond","pairs","converge","after","fns","flip","fromPairs","out","func","funcName","identity","isArrayLike","String","nodeType","hasOwnProperty","isEmpty","isNil","isSet","keysIn","prop","ks","memoize","cache","position","arg","nAry","not","nthArg","once","called","prependTo","p","propOf","reverse","toPairsIn","trim","ws","zeroWidth","hasProtoTrim","str","beginRx","endRx","type","undefined","unapply","unary","valuesIn","vs","F","I","T","_append","_baseCopy","refFrom","refTo","copiedValue","Date","_checkForMethod","methodname","callBound","_contains","_createComposer","composeFunction","_createMaxMin","initialVal","computed","_createPartialApplicator","_curry2","_curry3","_hasMethod","methodName","_makeFlat","recursive","flatt","jlen","ilen","_pickBy","test","props","_pluck","add","all","and","any","append","appendTo","binary","bind","thisObj","clone","compose","containsWith","createMapEntry","curryN","recurry","newArgs","dec","difference","first","second","firstLen","differenceWith","containsPred","drop","dropWhile","empty","eq","eqProps","obj1","obj2","filter","filterIndexed","find","findIndex","findLast","findLastIndex","flatten","foldl","foldlIndexed","foldr","foldrIndexed","forEach","forEachIndexed","functionsIn","get","groupBy","elt","has","hasIn","ifElse","condition","onTrue","onFalse","inc","indexOf","target","insert","insertAll","elts","invoker","method","initialArgs","is","Ctor","constructor","join","keys","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","nIdx","lPartial","lastIndexOf","NaN","lens","set","lns","map","mapAccumL","tuple","mapAccumR","mapIndexed","mapObj","mapObjIndexed","Infinity","maxBy","minBy","multiply","negate","nth","of","container","omit","op","_op","or","pCompose","pPipe","partition","push","pathEq","path","split","pathOn","sep","pick","pickAll","pickBy","pipe","pluck","prepend","product","propEq","propOr","ps","rPartial","range","floor","ceil","reject","rejectIndexed","remove","start","count","regex","replacement","scanl","sort","sortBy","aa","bb","strIndexOf","strLastIndexOf","substring","substringFrom","substringTo","subtract","sum","tail","take","takeWhile","tap","times","toLower","toPairs","toUpper","unfoldr","seed","pair","uniq","uniqWith","unnest","values","vals","where","wrap","wrapper","xprod","zip","rv","zipObj","zipWith","_ap","ap","_eqDeep","stackA","stackB","typeA","source","global","ignoreCase","multiline","sticky","unicode","getTime","keysA","pop","_extend","destination","other","_predicateWrap","predPicker","preds","predIterator","predicate","allPass","anyPass","assoc","assocPath","setParts","parts","current","chain","charAt","charCodeAt","commuteMap","consF","ftor","contains","countBy","counts","curry","divide","eqDeep","evolve","transformations","object","functions","gt","gte","head","init","installTo","R","intersection","list1","list2","intersectionWith","results","invert","invertObj","last","liftN","lifted","lt","lte","mathMod","m","mixin","modulo","repeat","union","unionWith","useWith","transformers","tlen","commute","constructN","Fn","inst","ret","Temp","lift","project","construct",11,"co","gen","ctx","Promise","resolve","onFulfilled","res","next","onRejected","err","done","toPromise","isPromise","isGeneratorFunction","isGenerator","thunkToPromise","arrayToPromise","isObject","objectToPromise","defer","promise","promises","i","proto","displayName","nameLooksRight","methodsLooksRight",13,"noop","process","nextTick","canSetImmediate","setImmediate","canMutationObserver","MutationObserver","canPost","postMessage","addEventListener","queue","hiddenDiv","createElement","observer","queueList","observe","attributes","setAttribute","ev","data","stopPropagation","shift","setTimeout","title","browser","env","argv","on","addListener","off","removeListener","removeAllListeners","emit","binding","cwd","chdir",14,"fixed","total","progress","loaded","report","extra","wrapPromise","watch","defineProperty",18,"readBlob","blob","as","reader","FileReader","onload","onerror","readAsArrayBuffer","readAsText",19,"Context","AudioContext","webkitAudioContext",20,"_babelPolyfill",21,"framework","it","isFunction","setToStringTag","tag","stat","PROTOTYPE","SYMBOL_TAG","hidden","cof","classof","O","part","assertFunction","_","holder","_args","that","_length","invoke","un","argumentsList","instance","create","ObjectProto","toObject","ES5Object","assertDefined","returnIt","returnThis","ownKeys","assertObject","getSymbols","getNames","keyOf","getKeys","array","createArrayMethod","isMap","isFilter","isSome","isEvery","isFindIndex","noholes","callbackfn","self","toLength","createArrayContains","isContains","toIndex","sameNaN","generic","A","B","number","toInteger","isNaN","trunc","MAX_SAFE_INTEGER","createReplacer","regExp","isStatic","replacer","createPointAt","pos","s","l","assert","msg1","msg2","assertInstance","Constructor","descriptor","bitmap","enumerable","configurable","writable","simpleSet","createDefiner","DESC","uid","SYMBOL","sid","random","TO_STRING","getWellKnownSymbol","setter","Symbol","safeSymbol","DOT","assignHidden","src","setSpecies","C","isNative","SYMBOL_SPECIES","setIterator","SYMBOL_ITERATOR","SUPPORT_FF_ITER","FF_ITERATOR","createIterator","NAME","IteratorPrototype","defineIterator","DEFAULT","iter","iterProto","getPrototypeOf","Iterators","defineStdIterators","Base","IS_SET","createIter","kind","entries","KEY","VALUE","$define","PROTO","FORCED","BUGGY_ITERATORS","iterResult","isIterable","hasExt","ITERATOR","getIterator","ext","getIter","stepCall","forOf","iterable","step","iterator","own","exp","isGlobal","GLOBAL","STATIC","core","BIND","WRAP","param","SIMPLE","REFERENCE_GET","OBJECT","FUNCTION","ARRAY","STRING","NUMBER","REGEXP","DATE","MAP","SET","WEAKMAP","WEAKSET","PROMISE","MATH","ARGUMENTS","CONSTRUCTOR","TO_STRING_TAG","HAS_OWN","FOR_EACH","PROCESS","CREATE_ELEMENT","Map","Set","WeakMap","WeakSet","RangeError","clearImmediate","isFinite","html","define","ArrayProto","FunctionProto","setPrototypeOf","getOwnDescriptor","defineProperties","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","isFrozen","assign","S","unshift","pow","abs","SYMBOL_UNSCOPABLES","ArrayUnscopables","ITER","NATIVE_ITERATORS","exportGlobal","NODE","old","amd","noConflict","TAG","SymbolRegistry","AllSymbols","description","sym","symbolStatics","for","keyFor","species","toStringTag","unscopables","pure","useSetter","useSimple","tmp","objectStatic","y","buggy","__proto__","wrapObjectMethod","MODE","o","_Number","NumberProto","toNumber","toPrimitive","valueOf","EPSILON","isSafeInteger","MIN_SAFE_INTEGER","parseFloat","asinh","sqrt","expm1","E","sign","acosh","atanh","cbrt","clz32","cosh","fround","Float32Array","hypot","larg","imul","UInt16","xn","yn","xl","yl","log1p","log10","LN10","log2","LN2","sinh","tanh","fromCharCode","assertNotRegExp","fromCodePoint","code","raw","callSite","sln","codePointAt","endsWith","searchString","endPosition","end","includes","startsWith","arrayLike","mapfn","mapping","copyWithin","fin","fill","endPos","at","iterated","k","point","RegExpProto","_RegExp","assertRegExpWrapper","pattern","flags","ONREADYSTATECHANGE","run","id","listner","event","channel","port","MessageChannel","counter","importScripts","port2","port1","onmessage","appendChild","removeChild","asap","DEF","isThenable","notify","def","msg","ok","state","react","cb","fail","P","rej","getConstructor","executor","catch","remaining","race","getCollection","methods","commonMethods","isWeak","initFromIterable","ADDER","fixSVZ","buggyZero","Native","UID","O1","SIZE","LAST","FIRST","entry","fastKey","getEntry","prev","defWeak","leakStore","WEAK","LEAK","collectionMethods","clear","delete","weakMethods","freeze","Enumerate","reflectGet","propertyKey","receiver","desc","reflectSet","V","existingDescriptor","ownDesc","isExtensible","reflect","deleteProperty","enumerate","preventExtensions","Reflect","createObjectToArray","isEntries","escape","REFERENCE","setMapMethods","MapProto","REFERENCE_SET","REFERENCE_DELETE","referenceGet","referenceSet","referenceDelete","arrayStatics","setArrayStatics","NodeList",22,"innerFn","outerFn","tryLocsList","Generator","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","GenStateExecuting","GenStateCompleted","doneResult","delegate","record","info","GenStateSuspendedYield","resultName","nextLoc","GenStateSuspendedStart","sent","dispatchException","abrupt","ContinueSentinel","generator","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iteratorMethod","iteratorSymbol","hasOwn","inModule","runtime","regeneratorRuntime","Gp","genFun","ctor","mark","async","callNext","callThrow","tempName","tempIndex","stop","rootEntry","rootRecord","rval","handle","loc","caught","hasCatch","hasFinally","_findFinallyEntry","complete","finish","thrown","delegateYield",23,24,"_interopRequire","__esModule","_toConsumableArray","arr","arr2","Bluebird","DEBUG","_len","_key",25,"t","u","_dereq_",1,"SomePromiseArray","setHowMany","setUnwrap","_SomePromiseArray",2,"Async","_isTickUsed","_lateQueue","Queue","_normalQueue","drainQueues","_drainQueues","_schedule","schedule","firstLineError","_process","haveItemsQueued","_withDomain","domain","throwLater","invokeLater","_queueTick","invokeFirst","settlePromises","_pushOne","_drainQueue","_settlePromises","_reset","./queue.js","./schedule.js",3,"INTERNAL","tryConvertToPromise","rejectThis","_reject","targetRejected","promiseRejectionQueued","bindingPromise","_then","bindingResolved","thisArg","_setBoundTo","_isPending","_resolveCallback","bindingRejected","maybePromise","_propagateFrom","_target","_progress","_bitField","_boundTo","_isBound",4,"bluebird","./promise.js","cr","callerCache","getterCache","ensureMethod","message","util","classString","caller","namedGetter","indexedGetter","getGetter","canEvaluate","isIdentifier","$_len","$_i","propertyName","getter","isIndex","maybeGetter","./util.js",6,"errors","CancellationError","_cancel","reason","isCancellable","parent","promiseToReject","_cancellationParent","_unsetCancellable","_rejectCallback","cancel","cancellable","_cancellable","_setCancellable","uncancellable","fork","didFulfill","didReject","didProgress","./async.js","./errors.js",7,"CapturedTrace","_parent","captureStackTrace","uncycle","reconstructStack","stacks","removeDuplicateOrEmptyJumps","removeCommonRoots","currentLastIndex","currentLastLine","commonRootMeetPoint","line","cleanStack","stack","isTraceLine","stackFramePattern","isInternalFrame","shouldIgnore","indentStackFrames","stackFramesAsArray","error","formatNonError","ruselessToString","newStr","snip","maxChars","substr","parseLineInfo","matches","parseLineInfoRegex","fileName","warn","bluebirdFramePattern","formatStack","inherits","nodes","stackToIndex","node","currentStack","cycleEdgeNode","currentChildLength","hasParent","attachExtraTrace","__stackCleaned__","parsed","parseStackAndMessage","trace","notEnumerableProp","formatAndLogError","unhandledRejection","isSupported","fireRejectionEvent","localHandler","localEventFired","globalEventFired","fireGlobalEvent","domEventFired","fireDomEvent","setBounds","lastLineError","firstFileName","lastFileName","firstStackLines","lastStackLines","firstIndex","lastIndex","v8stackFramePattern","v8stackFormatter","stackTraceLimit","ignoreUntil","hasStackAfterThrow","isNode","customEventWorks","anyEventWorks","CustomEvent","createEvent","initCustomEvent","dispatchEvent","detail","bubbles","cancelable","toWindowMethodNameMap","stderr","isTTY","write",8,"NEXT_FILTER","CatchFilter","instances","callback","_instances","_callback","_promise","safePredicate","safeObject","retfilter","errorObj","safeKeys","doFilter","boundTo","itemIsErrorType","shouldHandle","./es5.js",9,"isDebugging","_trace","peekContext","createContext","contextStack","_pushContext","_popContext","_peekContext","unhandledRejectionHandled","possiblyUnhandledRejection","Warning","canAttachTrace","debugging","_ensurePossibleRejectionHandled","_setRejectionIsUnhandled","_notifyUnhandledRejection","_notifyUnhandledRejectionIsHandled","_isRejectionUnhandled","_getCarriedStackTrace","_settledValue","_setUnhandledRejectionIsNotified","_unsetUnhandledRejectionIsNotified","_isUnhandledRejectionNotified","_unsetRejectionIsUnhandled","_setCarriedStackTrace","capturedTrace","_fulfillmentHandler0","_isCarryingStackTrace","_captureStackTrace","_attachExtraTrace","ignoreSelf","_warn","warning","onPossiblyUnhandledRejection","onUnhandledRejectionHandled","longStackTraces","hasLongStackTraces","isPrimitive","wrapsPrimitiveReceiver","returner","thrower","action","thenReturn","thenThrow",12,"PromiseReduce","reduce","each","subError","nameProperty","defaultMessage","SubError","OperationalError","cause","_TypeError","_RangeError","es5","Objectfreeze","TimeoutError","AggregateError","level","indent","lines","errorTypes","RejectionError","isES5","getDescriptor","propertyIsWritable","ObjectKeys","ObjectGetDescriptor","ObjectDefineProperty","ObjectFreeze","ObjectGetPrototypeOf","ArrayIsArray",15,"PromiseMap","options",16,"throwThis","return$","throw$","promisedFinally","reasonOrValue","isFulfilled","finallyHandler","handler","isRejected","tapHandler","_passThroughHandler","isFinally","promiseAndHandler","lastly",17,"apiRejection","promiseFromYieldHandler","yieldHandlers","traceParent","PromiseSpawn","generatorFunction","yieldHandler","_stack","_generatorFunction","_receiver","_generator","_yieldHandlers","_run","_next","_continue","_throw","coroutine","PromiseSpawn$","spawn","addYieldHandler","PromiseArray","spread","MappingPromiseArray","limit","constructor$","_preservedValues","_limit","_inFlight","_queue","EMPTY_ARRAY","_init$","concurrency","PENDING","_init","_promiseFulfilled","_values","preservedValues","_isResolved","_proxyPromiseArray","_isFulfilled","_reason","_value","totalResolved","_totalResolved","_resolve","booleans","_resolveFromSyncValue","attempt","spreadAdapter","nodeback","successAdapter","errorAdapter","newReason","nodeify","adapter","progressed","progressValue","_isFollowingOrFulfilledOrRejected","_progressUnchecked","_progressHandlerAt","_progressHandler0","_doProgressWith","progression","_promiseAt","_receiverAt","_promiseProgressed","resolver","_rejectionHandler0","_promise0","_receiver0","_resolveFromResolver","fillTypes","makeSelfResolutionError","PromiseInspection","APPLY","PromiseResolver","nodebackForPromise","_nodebackForPromise","catchInstances","catchFilter","_setIsFinal","isResolved","toJSON","fulfillmentValue","rejectionReason","originatesFromRejection","fromNode","pending","cast","_fulfillUnchecked","fulfilled","rejected","setScheduler","internalData","haveInternalData","_setIsMigrated","callbackIndex","_addCallbacks","_isSettlePromisesQueued","_settlePromiseAtPostResolution","_settlePromiseAt","_isFollowing","_setLength","_setFulfilled","_setRejected","_setFollowing","_isFinal","_unsetIsMigrated","_isMigrated","_fulfillmentHandlerAt","_rejectionHandlerAt","_migrateCallbacks","follower","fulfill","base","_setProxyHandlers","promiseSlotValue","promiseArray","shouldBind","_fulfill","propagationFlags","_setFollowee","_rejectUnchecked","synchronous","shouldNotMarkOriginatingFromRejection","markAsOriginatingFromRejection","ensureErrorObject","hasStack","_settlePromiseFromHandler","_isRejected","_followee","_cleanValues","carriedStackTrace","_clearCallbackDataAtIndex","_promiseRejected","_setSettlePromisesQueued","_unsetSettlePromisesQueued","_queueSettlePromises","_rejectUncheckedCheckError","_makeSelfResolutionError","toFastProperties","./any.js","./bind.js","./call_get.js","./cancel.js","./captured_trace.js","./catch_filter.js","./context.js","./debuggability.js","./direct_resolve.js","./each.js","./filter.js","./finally.js","./generators.js","./join.js","./map.js","./method.js","./nodeify.js","./progress.js","./promise_array.js","./promise_resolver.js","./promisify.js","./props.js","./race.js","./reduce.js","./settle.js","./some.js","./synchronous_inspection.js","./thenables.js","./timers.js","./using.js","toResolutionValue","resolveValueIfEmpty","__hardReject__","_resolveEmptyArray","getActualLength","shouldCopyValues","isUntypedError","wrapAsOperationalError","rErrorKey","wrapped","maybeWrapAsError","haveGetters","asCallback","timeout",26,"propsFilter","noCopyPropsPattern","isPromisified","__isPromisified__","hasPromisified","suffix","getDataPropertyOrDefault","defaultPromisified","checkValid","suffixRegexp","keyWithoutAsyncSuffix","promisifiableMethods","inheritedDataKeys","passesDefaultFilter","defaultFilter","makeNodePromisifiedClosure","promisified","THIS","defaultThis","withAppended","promisifyAll","promisifier","escapeIdentRegex","promisifiedKey","makeNodePromisified","promisify","makeNodePromisifiedEval","defaultSuffix","isClass","copyDescriptors","./errors",27,"PropertiesPromiseArray","castValue","keyOffset",28,"arrayMove","srcIndex","dst","dstIndex","capacity","_capacity","_front","_willBeOverCapacity","size","_checkCapacity","_unshiftOne","front","wrapMask","_resizeTo","oldCapacity","moveItemsCount",29,"raceLater",30,"ReductionPromiseArray","accum","_each","_zerothIsAccum","_gotAccum","_reducingIndex","_valuesPhase","_accum","initialValue","valuesPhaseIndex","isEach","gotAccum","valuesPhase",31,"version","versions","div","classList","toggle",32,"SettledPromiseArray","_promiseResolved","inspection","settle",33,"_howMany","_unwrap","_initialized","some","howMany","isArrayResolved","_canPossiblyFulfill","_getRangeError","_addFulfilled","_fulfilled","_addRejected","_rejected",34,"isPending",35,"isAnyBluebirdPromise","getThen","doThenable","hasProp","resolveFromThenable","rejectFromThenable","progressFromThenable",36,"successClear","clearTimeout","failureClear","afterTimeout","afterValue","delay","ms",37,"inspectionMapper","inspections","castPreservingDisposable","thenable","_isDisposable","_getDisposer","_setDisposable","dispose","resources","tryDispose","disposerSuccess","disposerFail","Disposer","_data","_context","FunctionDisposer","maybeUnwrapDisposer","isDisposer","resource","doDispose","_unsetDisposable","d","using","disposer","_disposer",38,"tryCatcher","tryCatchTarget","maybeError","safeToString","appendee","defaultValue","rident","filledRange","prefix","ignore","Child","Parent","oProto","visitedKeys","selectColor","prevColor","disabled","enabled","curr","prevTime","coerce","format","formatter","logFn","skips","disable","parse","exec","h","short","round","long","plural","_prototypeProperties","child","staticProps","instanceProps","_classCallCheck","defaultAudioContext","SamplingMaster","audioContext","_audioContext","_samples","unmute","gain","createGain","connect","disconnect","destroy","_destroyed","_step","_iterator","sample","_step2","_iterator2","blobOrArrayBuffer","_this","_coerceToArrayBuffer","arrayBuffer","_decodeAudio","audioBuffer","Sample","ArrayBuffer","decodeAudioData","_startPlaying","_stoppedPlaying","samplingMaster","_master","_buffer","play","PlayInstance","buffer","createBufferSource","_source","_gain","currentTime","duration","onstop","DataStructure","validate","schemas","schema","validateObject","maybe","MaybeValidator","Buffer","subject","encoding","noZero","base64clean","byteLength","kMaxLength","buf","TYPED_ARRAY_SUPPORT","_augment","Uint8Array","_isBuffer","_set","isArrayish","isBuffer","readUInt8","hexWrite","string","offset","strLen","byte","utf8Write","charsWritten","blitBuffer","utf8ToBytes","asciiWrite","asciiToBytes","binaryWrite","base64Write","base64ToBytes","utf16leWrite","utf16leToBytes","base64Slice","base64","fromByteArray","utf8Slice","decodeUtf8Char","asciiSlice","binarySlice","hexSlice","toHex","utf16leSlice","bytes","checkOffset","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","stringtrim","INVALID_BASE64_RE","byteArray","encodeURIComponent","hi","lo","toByteArray","unitSize","decodeURIComponent","SlowBuffer","INSPECT_MAX_BYTES","poolSize","foo","subarray","compare","isEncoding","totalLength","loweredCase","equals","inspect","writeUInt8","swap","_arr","sliceLen","newBuf","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","target_start","toArrayBuffer","BP","_get","toLocaleString",39,"download","url","xh","XMLHttpRequest","open","responseType","status","response","onprogress","send",42,"Url","protocol","slashes","auth","host","hostname","hash","search","query","pathname","href","urlParse","parseQueryString","slashesDenoteHost","urlFormat","isString","urlResolve","relative","urlResolveObject","resolveObject","isNull","isNullOrUndefined","punycode","protocolPattern","portPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","javascript:","hostlessProtocol","slashedProtocol","http","https","ftp","gopher","file","http:","https:","ftp:","gopher:","file:","querystring","rest","lowerProto","hostEnd","hec","atSign","parseHost","ipv6Hostname","hostparts","newpart","validParts","notHost","bit","domainArray","newOut","encode","ae","esc","qm","rel","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","authInHost","hasTrailingSlash","up","isAbsolute",47,"webpackPolyfill","deprecate","children",56,"det","rec","confidence","lang",108,"lookup","decode","PLUS","SLASH","UPPER","LOWER","b64ToByteArray","b64","L","placeHolders","Arr","uint8ToBase64","uint8","num","tripletToBase64","temp","extraBytes","output",109,"isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt",110,111,"__WEBPACK_AMD_DEFINE_RESULT__","root","mapDomain","regexSeparators","labels","encoded","ucs2decode","ucs2encode","stringFromCharCode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","damp","baseMinusTMin","tMax","skew","input","basic","oldi","w","baseMinusT","inputLength","initialN","bias","initialBias","delimiter","maxInt","tMin","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","toUnicode","regexPunycode","toASCII","regexNonASCII","freeGlobal","overflow","not-basic","invalid-input","ucs2",112,"BMSChart","headers","BMSHeaders","objects","BMSObjects","timeSignatures","TimeSignatures","measureToBeat","measure","fraction",113,"_dataAll","getAll",114,"_objects","allSorted",115,"Speedcore","segments","_segments","Segment","segment","dx",116,"getBeats",117,"text","matched","when","else",128,"opts","seen","stylize","stylizeNoColor","depth","isBoolean","showHidden","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","styles","arrayToHash","recurseTimes","primitive","formatPrimitive","visibleKeys","isError","formatError","isRegExp","isDate","braces","toUTCString","formatArray","formatProperty","reduceToSingleString","simple","isNumber","numLinesEst","cur","ar","isSymbol","re","objectToString","pad","timestamp","time","getHours","getMinutes","getSeconds","getDate","months","getMonth","formatRegExp","deprecated","warned","throwDeprecation","traceDeprecation","noDeprecation","debugEnviron","debugs","debuglog","NODE_DEBUG","toUpperCase","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","boolean","null","date","regexp","origin",129,"_interopRequireWildcard","default","ProgressUtils","AudioLoader","assets","master","_assets","loadFrom","keysounds","loadProgress","decodeProgress","files","ondecode","_loadSample","_getFile","_decode",131,"getPayload","magic","metadataLength","_slicedToArray","addLazyProperty","throat","Progress","BemusePackageResources","lazy","_url","metadata","refs","Ref","_loadPayload","BemusePackageFileResource","ref","getBlob","_ref","payload","_resources",132,"eachLine","compile","handleChannelSentence","lineNumber","items","chart","warnings","headerSentences","channelSentences","malformedSentences",133,"Notes","notes","Note","_notes","BMSNoteBuilder","_chart","CHANNEL_MAPPING","IIDX_P1","column","fromBMSChart","builder","build","_activeLN","_channelMapping","_handle","_handleNormalNote","_handleLongNote","_normalizeChannel","beat","_getBeat","_getColumn","note","endBeat","keysound",134,"Column",135,136,"Timing","initialBPM","actions","bpm","seconds","precedence","stopBeats","_speedcore","beatToSeconds","secondsToBeat",138,"initializer",139,"Delayed","PromiseArgument","release",152,"main","song","subtitles","artist","genre","subartists","loader","GameLoader","bms","URLResource","SCENE_MANAGER","display","LoadingScene",193,"loadEngineModule","LoadingContext","use","readBMS","BMS","Reader","readAsync","_inherits","subClass","superClass","EventEmitter","Formatters","NORMAL","EXTRA","BYTES","_tasks","tasks","callee$2$0","context$3$0","graphics","_loadEngine","_loadSong","engine","_task","skin","Scintillator","cpack","pack","audio","bga","compileResult","audioLoader","Compiler","Keysounds","task","progressText",194,"getData","_ref2","width","view","View",196,"basename",197,"detach","element","parentNode","body","SceneManager","scene","exit","currentElement","className",198,"template","Ractive",199,"SongInfo",200,201,"utf8","mbcs","recognisers","UTF_16BE","UTF_16LE","sjis","euc_kr","detect","fByteStats","fC1Bytes","fRawInput","fRawLength","fInputBytes","fInputLen",202,"ISO_2022","Match","escN","quality","hits","misses","shifts","textLen","scanInput","checkEscapes","escapeSequences","seq","ISO_2022_JP","ISO_2022_KR","ISO_2022_CN",203,"binarySearch","searchValue","left","right","mid","IteratedChar","charValue","nextIndex","nextByte","byteValue","eucNextChar","firstByte","secondByte","thirdByte","singleByteCharCount","doubleByteCharCount","commonCharCount","badCharCount","totalCharCount","detectBlock","nextChar","cv","commonChars","maxVal","scaleFactor","language","big5","euc_jp","gb_18030","fourthByte","buildChar",204,"NGramParser","theNgramList","theByteMap","N_GRAM_MASK","byteIndex","ngram","ngramList","byteMap","ngramCount","hitCount","spaceChar","thisNgram","addByte","spaceCh","ignoreSpace","mb","rawPercent","NGramsPlusLang","la","ng","fLang","fNGrams","sbcs","ngrams","multiple","parser","bestConfidenceSoFar","ngl","ISO_8859_1","ISO_8859_2","ISO_8859_5","ISO_8859_6","ISO_8859_7","ISO_8859_8","ISO_8859_9","windows_1251","windows_1256","KOI8_R",205,"UTF_32","numValid","numInvalid","hasBOM","getChar","ch","UTF_32BE","UTF_32LE",206,"trailBytes",207,"baseCompareAscending","valIsReflexive","othIsReflexive","baseIndexOf","fromIndex","indexOfNaN","baseSortBy","comparer","baseToString","charAtCallback","charsLeftIndex","chars","charsRightIndex","compareAscending","criteria","compareMultipleAscending","objCriteria","othCriteria","deburrLetter","letter","deburredLetters","escapeHtmlChar","chr","htmlEscapes","escapeStringChar","stringEscapes","fromRight","isObjectLike","isSpace","charCode","replaceHolders","placeholder","resIndex","PLACEHOLDER","sortedUniq","iteratee","trimmedLeftIndex","trimmedRightIndex","unescapeHtmlChar","htmlUnescapes","runInContext","lodash","LazyWrapper","LodashWrapper","wrapperClone","chainAll","__wrapped__","__actions__","__chain__","__dir__","__dropCount__","__filtered__","__iteratees__","__takeCount__","POSITIVE_INFINITY","__views__","lazyClone","iteratees","views","arrayCopy","lazyReverse","lazyValue","baseWrapperValue","dir","isRight","getView","dropCount","takeCount","nativeMin","iterLength","outer","iterIndex","LAZY_MAP_FLAG","LAZY_FILTER_FLAG","MapCache","__data__","mapDelete","mapGet","mapHas","mapSet","SetCache","nativeCreate","cacheIndexOf","cachePush","arrayEach","arrayEachRight","arrayEvery","arrayFilter","arrayMap","arrayMax","NEGATIVE_INFINITY","arrayMin","arrayReduce","accumulator","initFromArray","arrayReduceRight","arraySome","assignDefaults","objectValue","sourceValue","assignOwnDefaults","baseAssign","customizer","baseCopy","baseAt","collection","isArr","isLength","propsLength","baseBindAll","methodNames","createWrapper","BIND_FLAG","baseCallback","argCount","isBindable","bindCallback","baseMatches","baseProperty","baseMatchesProperty","baseClone","isDeep","initCloneArray","objToString","isFunc","funcTag","objectTag","argsTag","cloneableTags","initCloneByTag","initCloneObject","baseForOwn","subValue","baseDelay","wait","FUNC_ERROR_TEXT","baseSlice","baseDifference","getIndexOf","isCommon","createCache","valuesLength","valuesIndex","baseEach","baseEachRight","baseForOwnRight","baseEvery","baseFill","baseFilter","baseFind","eachFunc","retKey","baseFlatten","isStrict","isArguments","valIndex","valLength","baseFor","keysFunc","baseForRight","baseForIn","baseFunctions","baseInvoke","baseIsEqual","isWhere","valType","othType","baseIsEqualDeep","equalFunc","objIsArr","othIsArr","objTag","arrayTag","othTag","isTypedArray","objIsObj","othIsObj","isSameTag","equalByTag","valWrapped","othWrapped","equalArrays","equalObjects","baseIsMatch","strictCompareFlags","noCustomizer","objValue","srcValue","baseMap","isStrictComparable","baseMerge","isSrcArr","baseMergeDeep","mergeFunc","isPlainObject","toPlainObject","basePullAt","indexes","previous","baseRandom","nativeRandom","baseReduce","initFromCollection","baseSome","baseUniq","isLarge","seenIndex","baseValues","binaryIndex","retHighest","low","high","HALF_MAX_ARRAY_LENGTH","binaryIndexBy","valIsNaN","valIsUndef","isReflexive","setLow","MAX_ARRAY_INDEX","bufferClone","bufferSlice","composeArgs","partials","holders","holdersLength","argsIndex","argsLength","nativeMax","leftIndex","leftLength","composeArgsRight","holdersIndex","rightIndex","rightLength","createAggregator","getCallback","createAssigner","assigner","isIterateeCall","createBindWrapper","createCtorWrapper","createCompounder","words","deburr","thisBinding","baseCreate","createExtremum","arrayFunc","isMin","noIteratee","toIterable","extremumBy","createHybridWrapper","bitmask","partialsRight","holdersRight","argPos","ary","isCurry","isCurryRight","argsHolders","newArgPos","newArity","newsHolders","newHoldersRight","newPartials","newPartialsRight","PARTIAL_FLAG","PARTIAL_RIGHT_FLAG","isCurryBound","BIND_KEY_FLAG","isBind","isBindKey","reorder","isAry","ARY_FLAG","CURRY_FLAG","CURRY_BOUND_FLAG","CURRY_RIGHT_FLAG","createPad","strLength","nativeIsFinite","padLength","createPartialWrapper","newData","mergeData","baseSetData","setData","arrLength","othLength","arrValue","othValue","othIndex","boolTag","dateTag","errorTag","numberTag","regexpTag","stringTag","objProps","objLength","othProps","hasCtor","objCtor","othCtor","exValue","transforms","arrayBufferTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","byteOffset","reFlags","support","funcNames","funcDecomp","fnToString","reFuncName","reThis","prereq","srcBitmask","newBitmask","arityFlags","REARG_FLAG","bindFlags","comboFlags","isRearg","isCombo","pickByArray","pickByCallback","oldArray","shimIsPlainObject","shimKeys","allowIndexes","nonEnumArgs","chunk","guard","compact","dropRight","dropRightWhile","flattenDeep","initial","caches","pull","pullAt","sortedIndex","sortedLastIndex","takeRight","takeRightWhile","isSorted","unzip","getLength","without","xor","zipObject","interceptor","thru","wrapperChain","wrapperCommit","wrapperPlant","wrapperReverse","wrapperToString","wrapperValue","every","findWhere","forEachRight","reduceRight","shuffle","rand","sortByAll","before","bindAll","bindKey","curryRight","debounce","timeoutId","maxTimeoutId","trailingCall","delayed","now","stamp","isCalled","lastCalled","maxDelayed","trailing","maxWait","debounced","leading","leadingCall","flow","funcs","flowRight","memoized","Cache","partial","partialRight","rearg","throttle","debounceOptions","cloneDeep","isElement","isEqual","isMatch","reNative","reHostCtor","typedArrayTags","toArray","properties","defaults","findKey","findLastKey","forIn","forInRight","forOwn","forOwnRight","multiValue","isProto","skipIndexes","mapValues","transform","floating","noMin","noMax","capitalize","reLatin1","reHasUnescapedHtml","reUnescapedHtml","escapeRegExp","reHasRegExpChars","reRegExpChars","padLeft","padRight","radix","nativeParseInt","otherOptions","settings","templateSettings","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reNoMatch","reDelimiters","reInterpolate","reEsTemplate","evaluate","sourceURL","templateCounter","escapeValue","interpolateValue","esTemplateValue","evaluateValue","reUnescapedString","variable","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","trimLeft","trimRight","DEFAULT_TRUNC_LENGTH","omission","DEFAULT_TRUNC_OMISSION","separator","newEnd","unescape","reHasEscapedHtml","reEscapedHtml","reWords","constant","matchesProperty","isObj","oldDash","property","propertyOf","MAX_ARRAY_LENGTH","uniqueId","idCounter","contextProps","arrayProto","objectProto","Float64Array","nativeIsArray","nativeKeys","nativeNow","nativeNumIsFinite","FLOAT64_BYTES_PER_ELEMENT","BYTES_PER_ELEMENT","metaMap","WinRTError","dom","createDocumentFragment","reEscape","reEvaluate","floatLength","HOT_SPAN","HOT_COUNT","indexBy","objProto","merge","camelCase","word","kebabCase","whitespace","reHexPrefix","snakeCase","startCase","backflow","collect","eachRight","extend","select","unique","include","inject","VERSION","isWhile","LAZY_WHILE_FLAG","filtered","countName","whileName","takeName","dropName","operationName","createCallback","lodashFunc","retUnwrapped","isHybrid","isLazy","onlyLazy","otherArgs","chainName","commit","plant","mapTag","setTag","weakMapTag","upper","lower","À","Á","Â","Ã","Ä","Å","à","á","â","ã","ä","å","Ç","ç","Ð","ð","È","É","Ê","Ë","è","é","ê","ë","Ì","Í","Î","Ï","ì","í","î","ï","Ñ","ñ","Ò","Ó","Ô","Õ","Ö","Ø","ò","ó","ô","õ","ö","ø","Ù","Ú","Û","Ü","ù","ú","û","ü","Ý","ý","ÿ","Æ","æ","Þ","þ","ß","&","<",">","\"","'","`","&amp;","&lt;","&gt;","&quot;","&#39;","&#96;","objectTypes","function","\\","\n","\r"," "," ","freeExports","freeModule",208,"chardet","charset","Blob",209,"difficulty","extractSubtitle",210,"convert","tb","gb","kb",244,246,254,"class",255,"defaultOptions","yield","preserveWhitespace","sanitize","stripComments","modifyArrays","isolated","twoway","noIntro","transitionsEnabled","noCssTransform","easing","linear","easeIn","easeOut","easeInOut","circular","thing","isNumeric","interpolators","cssLengthPattern","intermediate","svg","implementation","hasFeature","allowDuplicates","missingParser","mergeComparisonFail","noComponentEventArguments","noTemplateForPartial","noNestedPartials","evaluationError","badArguments","failedComputation","missingPlugin","badRadioInputBinding","noRegistryFunctionReturn","defaultElSpecified","noElementProxyEventWildcards","methodDeprecated","consolewarn","getMessage","passthru","warnAlways","logger","errorOnly","critical","Ractive$shared_hooks_Hook","Hook","deprecations","render","fire","ractive","removeFromArray","member","makeDispatcher","handlers","fulfil","_Promise","resolvePromise","rejectPromise","__export","FULFILLED","REJECTED","dispatchHandlers","makeResolver","fulfilledHandlers","rejectedHandlers","newState","promise2","processResolutionHandler","forward","p1result","processPromise","normaliseRef","getInnerContext","fragment","createComponentBinding","isSettable","viewmodel","keypath","computations","runloop","Binding","otherInstance","otherKeypath","this$0","lock","updating","unlock","isLocked","counterpart","newIndices","propagateChange","setValue","addViewmodel","scheduleTask","smartUpdate","refineValue","keypaths","register","rebind","newKeypath","unbind","unregister","component","parentInstance","parentKeypath","childKeypath","childInstance","bindings","parentToChildBinding","childToParentBinding","resolveRef","resolveAncestorReference","baseContext","contextKeys","ancestorErrorMessage","getOptions","evaluateWrapped","isParentLookup","parentValue","hasContextChain","parentKeys","childKeys","parentFragment","indexRefs","indexRefBindings","TransitionManager","detachNodes","tm","check","ready","outros","outroChildren","outrosComplete","decrementOutros","intros","totalChildren","decrementTotal","detachQueue","addChild","transition","isIntro","flushChanges","changeHash","batch","viewmodels","applyChanges","changeHook","attemptKeypathResolution","update","resolved","unresolved","returnPromise","fulfilPromise","previousBatch","transitionManager","changes","registerTransition","_manager","addView","addUnresolved","removeUnresolved","detachWhenReady","postRender","_batch","createBranch","numeric","viewmodel$get_magicAdaptor","createAccessors","originalWrapper","updateWrapper","oldGet","oldSet","_ractiveWrappers","magicAdaptor","MagicWrapper","parentWrapper","objKeypath","siblings","originalDescriptor","teardown","wrappers","mathml","xlink","xml","xmlns","ns","createElementNS","isClient","Ractive$shared_add","Ractive$add","normaliseKeypath","leadingDot","vendors","requestAnimationFrame","lastTime","currTime","timeToCall","performance","animations","rAF","tick","animation","running","abort","extractString","unit","selectorsPattern","commentsPattern","selectorUnitPattern","mediaQueryPattern","dataRvcGuidPattern","css","guid","transformed","addGuid","selector","selectorUnits","dataAttr","prepended","appended","modifiers","selectors","transformCss","_guid","getCss","cssConfig","wrapMethod","needsSuper","superMethod","force","hasSuper","_super","combine","getAddedKeys","dispatch","extendFn","fromFn","fromProperties","fillOnly","parentFn","childFn","dataConfig","types","TEXT","INTERPOLATOR","TRIPLE","SECTION","INVERTED","CLOSING","ELEMENT","PARTIAL","COMMENT","DELIMCHANGE","MUSTACHE","ATTRIBUTE","CLOSING_TAG","COMPONENT","NUMBER_LITERAL","STRING_LITERAL","ARRAY_LITERAL","OBJECT_LITERAL","BOOLEAN_LITERAL","KEY_VALUE_PAIR","REFINEMENT","MEMBER","PREFIX_OPERATOR","BRACKETED","CONDITIONAL","INFIX_OPERATOR","INVOCATION","SECTION_IF","SECTION_UNLESS","SECTION_EACH","SECTION_WITH","SECTION_IF_WITH","parse_Parser_expressions_shared_errors","expectedExpression","expectedParen","numberLiteral","numberPattern","matchPattern","booleanLiteral","makeQuotedStringMatcher","stringMiddlePattern","escapeSequencePattern","lineContinuationPattern","okQuote","literal","matchString","singleQuotedString","doubleQuotedString","stringLiteral","getSingleQuotedString","getDoubleQuotedString","patterns","getStringLiteral","getNumberLiteral","identifier","token","keyValuePair","getKey","allowWhitespace","readExpression","keyValuePairs","getKeyValuePair","getKeyValuePairs","objectLiteral","expressionList","getExpressionList","expression","expressions","expr","arrayLiteral","getBooleanLiteral","getObjectLiteral","getArrayLiteral","reference","dotRefinementPattern","arrayMemberPattern","getArrayRefinement","globals","keywords","startPos","ancestor","dot","combo","refinement","lastDotIndex","bracketedExpression","primary","getLiteral","getReference","getBracketedExpression","memberOrInvocation","getPrimary","getRefinement","_typeof","getMemberOrInvocation","getTypeof","makePrefixSequenceMatcher","symbol","fallthrough","matcher","prefixOperators","logicalOr","getLogicalOr","makeInfixSequenceMatcher","infixOperators","conditional","ifTrue","ifFalse","flattenExpression","quoteStringLiteral","extractRefs","stringifyAll","flattened","Parser","getConditional","ParseError","leadingWhitespace","lineStart","lineEnds","lineEnd","leftover","postProcess","converters","getLinePos","char","columnNum","lineNum","annotation","character","shortMessage","delimiterChange","delimiterChangePattern","whitespacePattern","opening","closing","delimiterTypes","delimiters","isTriple","mustacheTypes","#","^","/","!","handlebarsBlockCodes","if","if-with","with","unless","legacy","content","mustacheType","refineExpression","mustache","referenceExpression","getReferenceExpression","rx","members","legalReference","indexRefPattern","handlebarsBlockPattern","delimiterType","block","contextPartialExpression","mustacheContent","getMustache","inside","getMustacheOfType","expectedClose","elseChildren","currentChildren","delimiterChangeToken","exclude","sectionDepth","isSection","includeLinePositions","comment","OPEN_COMMENT","CLOSE_COMMENT","endIndex","voidElementNames","getLowestIndex","haystack","needles","lowest","decodeCharacterReferences","validateCode","controlCharacters","htmlEntities","entityPattern","quot","amp","apos","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","exist","nabla","isin","notin","ni","prod","minus","lowast","radic","infin","ang","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","rang","loz","spades","clubs","hearts","diams","entity","disallowed","barrier","tripleDelimiters","staticDelimiters","staticTripleDelimiters","inAttribute","closingTag","closingTagPattern","attribute","getAttribute","attr","attributeNamePattern","getAttributeValue","valueStart","startDepth","getQuotedAttributeValue","getUnquotedAttributeValue","getUnquotedAttributeValueToken","unquotedAttributeValueTextPattern","tokens","quoteMark","getQuotedStringToken","parseJSON","valueToken","JsonParser","specials","specialsPattern","placeholderPattern","placeholderAtStartPattern","onlyWhitespace","true","false","processDirective","ExpressionParser","methodCallPattern","colonIndex","directiveName","directiveArgs","getComment","getText","getClosingTag","getElement","lowerCaseName","addProxyEvent","directive","selfClosing","tagNamePattern","validTagNameFollower","reservedEventNames","directives","proxyEventPattern","sanitizeEventAttributes","onPattern","canContain","sanitizeElements","disallowedContents","intro-outro","intro","outro","decorator","li","dt","dd","rp","optgroup","option","thead","tbody","tfoot","tr","td","th","trimWhitespace","trailingWhitespace","stripStandalones","isComment","leadingLinebreak","trailingLinebreak","backOne","backTwo","lastSectionItem","cleanup","removeLeadingWhitespace","removeTrailingWhitespace","rewriteElse","previousItem","nextItem","preserveWhitespaceInsideFragment","removeLeadingWhitespaceInsideFragment","removeTrailingWhitespaceInsideFragment","unlessBlock","preserveWhitespaceElements","contiguousWhitespace","setDelimiters","StandardParser","script","elements","eventAttributes","startMatch","endMatch","inlinePartialStart","inlinePartialEnd","optionGroup","config","group","parseOptions","createHelper","helper","doParse","fromId","noThrow","isHashedId","getElementById","tagName","innerHTML","isParsed","getParseOptions","resetValue","_config","getDynamicTemplate","parseIfString","extendPartials","existingPartials","overwrite","templateConfig","Registry","useDefaults","recurseFind","configure","registry","changed","_fn","isOwner","findOwner","findConstructor","findInstance","registries","wrapPrototypeMethod","getSuperMethod","oldSuper","_method","correct","deprecateEventDefinitions","deprecateAdaptors","adaptors","wrapPrototype","customConfig","custom","isStandardDefaultKey","extendOtherMethods","blacklisted","_component","getConstructTarget","onconstruct","snap","interpol","Ractive$animate_Animation","Animation","startTime","interpolator","elapsed","timeNow","_animations","Ractive$animate","animate","noAnimation","makeValueCollector","currentValues","collectValue","dummy","dummyOptions","Ractive$detach","detachHook","detached","__ractive_instances__","Ractive$find","unprefixed","prefixed","makeFunction","cloneNode","querySelectorAll","Ractive$shared_makeQuery_test","noDirty","itemMatches","_isComponentQuery","_makeDirty","Ractive$shared_makeQuery_cancel","liveQueries","_root","Ractive$shared_makeQuery_sortByItemPosition","getParent","owner","getAncestry","ancestry","ancestryA","ancestryB","oldestA","oldestB","mutualAncestor","indexA","indexB","fragments","fragmentA","fragmentB","_ractive","proxy","Ractive$shared_makeQuery_sortByDocumentPosition","sortByItemPosition","otherNode","compareDocumentPosition","Ractive$shared_makeQuery_sort","sortByDocumentPosition","_dirty","Ractive$shared_makeQuery_dirty","_sort","Ractive$shared_makeQuery_remove","nodeOrComponent","Ractive$shared_makeQuery__makeQuery","dirty","live","isComponentQuery","_test","_remove","Ractive$findAll","makeQuery","_liveQueries","findAll","Ractive$findAllComponents","_liveComponentQueries","findAllComponents","Ractive$findComponent","findComponent","getPotentialWildcardMatches","getStarMap","starMap","mapper","ones","starMaps","wildcardKeypath","star","Ractive$shared_fireEvent","fireEventAs","eventNames","initialFire","subscribers","bubble","_subs","notifySubscribers","fullName","originalEvent","stopEvent","_noArg","original","preventDefault","eventName","Ractive$fire","fireEvent","Ractive$get","capture","querySelector","Ractive$insert","fireInsertHook","insertHook","anchor","rendered","insertBefore","Ractive$merge","currentArray","Ractive$observe_Observer","Observer","immediate","oldValue","getMatchingKeypaths","expand","matchingKeypaths","concatenate","Ractive$observe_getPattern","Ractive$observe_PatternObserver","getPattern","PatternObserver","wildcard","proxies","implicitChanges","getProxy","reallyUpdate","Ractive$observe_getObserverFacade","emptyObject","isPatternObserver","cancelled","patternObservers","Ractive$observe","getObserverFacade","observers","Ractive$shared_trim","Ractive$shared_notEmptyString","Ractive$off","notEmptyString","Ractive$on","listeners","listener","getNewIndices","getSpliceEquivalent","spliceArguments","removeStart","removeEnd","balance","Ractive$shared_makeArrayMethod","SLICE$0","Ractive$pop","makeArrayMethod","Ractive$push","global_css","styleElement","styleSheet","inDom","componentsInPage","getElementsByTagName","cssText","Component","Ractive$render","renderHook","completeHook","virtualdom_Fragment$bubble","dirtyValue","dirtyArgs","bound","virtualdom_Fragment$detach","docFrag","virtualdom_Fragment$find","queryResult","virtualdom_Fragment$findAll","virtualdom_Fragment$findAllComponents","virtualdom_Fragment$findComponent","virtualdom_Fragment$findNextNode","firstNode","findNextNode","virtualdom_Fragment$firstNode","virtualdom_Fragment$getNode","pElement","virtualdom_Fragment$getValue","processItems","placeholderId","getValue","asArgs","cachedResult","dirtyFlag","escapeHtml","lessThan","greaterThan","detachNode","Text","createTextNode","unrender","shouldDestroy","registered","startsWithKeypath","getNewKeypath","targetKeypath","oldKeypath","ReferenceResolver","forceResolution","indexRef","newIndex","SpecialResolver","IndexResolver","createReferenceResolver","getFunctionFromString","ExpressionResolver","getUniqueString","getKeypath","uniqueString","isValidDependency","wrapFunction","_noWrap","__ractive_nowrap","refResolvers","createEvaluator","computation","valueGetters","signature","deps","compute","MemberResolver","refResolver","ReferenceExpressionResolver","isDefined","baseResolver","initialise","resolveAndRebindChildren","wasResolved","twowayBinding","rebound","Mustache","Interpolator","virtualdom_items_Section$bubble","virtualdom_items_Section$detach","virtualdom_items_Section$find","virtualdom_items_Section$findAll","virtualdom_items_Section$findAllComponents","virtualdom_items_Section$findComponent","virtualdom_items_Section$findNextNode","virtualdom_items_Section$firstNode","virtualdom_items_Section$shuffle","Fragment","firstChange","newLength","reboundFragments","fragmentOptions","section","shuffling","unbound","subtype","oldIndex","by","fragmentsToUnrender","fragmentsToCreate","virtualdom_items_Section$render","virtualdom_items_Section$setValue","reevaluateSection","reevaluateConditionalSection","reevaluateContextSection","reevaluateConditionalContextSection","reevaluateListObjectSection","ordered","reevaluateListSection","fragmentsToRender","hasKey","removeSectionFragments","inverted","doRender","emptyArray","isRendered","virtualdom_items_Section$toString","virtualdom_items_Section$unbind","unbindFragment","virtualdom_items_Section$unrender","unrenderAndDestroy","virtualdom_items_Section$update","renderIndex","renderedFragments","getNode","childNodes","Section","virtualdom_items_Triple$detach","virtualdom_items_Triple$find","virtualdom_items_Triple$findAll","queryAllResult","numNodes","virtualdom_items_Triple$firstNode","insertHtml","elementCache","ieBug","ieBlacklist","TABLE","THEAD","TBODY","TR","SELECT","selectedOption","selectedIndex","namespaceURI","firstChild","selected","updateSelect","isSelected","parentElement","selectedOptions","virtualdom_items_Triple$render","virtualdom_items_Triple$setValue","virtualdom_items_Triple$toString","virtualdom_items_Triple$unrender","virtualdom_items_Triple$update","Triple","virtualdom_items_Element$bubble","virtualdom_items_Element$detach","virtualdom_items_Element$find","virtualdom_items_Element$findAll","virtualdom_items_Element$findAllComponents","virtualdom_items_Element$findComponent","virtualdom_items_Element$findNextNode","virtualdom_items_Element$firstNode","virtualdom_items_Element$getAttribute","enforceCase","svgCamelCaseElements","svgCamelCaseAttributes","createMap","elementName","lowerCaseElementName","virtualdom_items_Element_Attribute$bubble","booleanAttributes","determineNameAndNamespace","namespacePrefix","getInterpolator","determinePropertyName","propertyNames","accept-charset","accesskey","bgcolor","codebase","colspan","contenteditable","datetime","dirname","http-equiv","ismap","maxlength","novalidate","pubdate","readonly","rowspan","tabindex","usemap","pNode","useProperty","virtualdom_items_Element_Attribute$init","virtualdom_items_Element_Attribute$rebind","virtualdom_items_Element_Attribute$render","virtualdom_items_Element_Attribute$toString","virtualdom_items_Element_Attribute$unbind","virtualdom_items_Element_Attribute$update_updateSelectValue","optionValue","locked","arrayContains","virtualdom_items_Element_Attribute$update_updateMultipleSelectValue","virtualdom_items_Element_Attribute$update_updateRadioName","checked","virtualdom_items_Element_Attribute$update_updateRadioValue","wasChecked","handleChange","virtualdom_items_Element_Attribute$update_updateCheckboxName","valueAttribute","virtualdom_items_Element_Attribute$update_updateClassName","virtualdom_items_Element_Attribute$update_updateIdAttribute","virtualdom_items_Element_Attribute$update_updateIEStyleAttribute","virtualdom_items_Element_Attribute$update_updateContentEditableValue","virtualdom_items_Element_Attribute$update_updateValue","virtualdom_items_Element_Attribute$update_updateBoolean","virtualdom_items_Element_Attribute$update_updateEverythingElse","setAttributeNS","removeAttribute","virtualdom_items_Element_Attribute$update","updateSelectValue","updateMultipleSelectValue","updateRadioName","updateRadioValue","updateCheckboxName","updateClassName","updateIdAttribute","updateIEStyleAttribute","updateContentEditableValue","updateValue","updateBoolean","updateEverythingElse","updateMethod","Attribute","virtualdom_items_Element$init_createAttributes","ConditionalAttribute","parseAttributes","isSvg","notIn","needle","attrs","virtualdom_items_Element$init_createConditionalAttributes","sources","getInitialValue","_twowayBindings","SpecialisedBinding","handleDomEvent","ContentEditableBinding","attachEvent","removeEventListener","getSiblings","sets","RadioBinding","RadioNameBinding","radioName","CheckboxNameBinding","isChecked","noInitialValue","existingValue","bindingValue","checkboxName","CheckboxBinding","SelectBinding","optionWasSelected","forceUpdate","arrayContentsMatch","MultipleSelectBinding","valueFromModel","selectedValues","previousValue","updateModel","FileListBinding","GenericBinding","handleBlur","NumericBinding","virtualdom_items_Element$init_createTwowayBinding","bindName","bindChecked","virtualdom_items_Element_EventHandler$bubble","hasAction","getAction","hasListener","listen","virtualdom_items_Element_EventHandler$fire","virtualdom_items_Element_EventHandler$getAction","virtualdom_items_Element_EventHandler$init","fireMethodCall","eventObject","refinements","fireEventWithParams","params","fireEventWithDynamicParams","dynamicParams","getValueOptions","eventPattern","invalid","genericHandler","events","virtualdom_items_Element_EventHandler$listen","getCustomHandler","customHandlers","touchEvents","touchstart","touchmove","touchend","touchcancel","touchleave","definition","plugin","virtualdom_items_Element_EventHandler$rebind","virtualdom_items_Element_EventHandler$render","virtualdom_items_Element_EventHandler$resolve","virtualdom_items_Element_EventHandler$unbind","virtualdom_items_Element_EventHandler$unrender","EventHandler","virtualdom_items_Element$init_createEventHandlers","Decorator","decorators","actual","sync","valueContains","selectValue","selectElement","selectNode","isMultiple","shouldSelect","syncSelect","findParentSelect","virtualdom_items_Element$init","createAttributes","createConditionalAttributes","createTwowayBinding","createEventHandlers","bubbleSelect","initOption","conditionalAttributes","eventHandlers","t0","t1","t2","assignNewKeypath","existingKeypath","virtualdom_items_Element$rebind","img","loadHandler","height","virtualdom_items_Element_Transition$init","transitions","hyphenatedStr","prefixCache","testStyle","vendor","capped","virtualdom_items_Element_Transition$getStyle","getStyle","getComputedStyle","computedStyle","virtualdom_items_Element_Transition$setStyle","Ticker","eased","unprefix","unprefixPattern","hyphenate","vendorPattern","hyphenated","virtualdom_items_Element_Transition$animateStyle_createTransitions","createTransitions","TRANSITION","TRANSITIONEND","CSS_TRANSITIONS_ENABLED","TRANSITION_DURATION","TRANSITION_PROPERTY","TRANSITION_TIMING_FUNCTION","canUseCssTransitions","cannotUseCssTransitions","webkitTransition","changedProperties","hashPrefix","jsTransitionsComplete","cssTransitionsComplete","checkComplete","transitionEndHandler","originalValue","propertiesToTransitionInJs","virtualdom_items_Element_Transition$animateStyle_visibility","onChange","visibility","onHide","onShow","virtualdom_items_Element_Transition$animateStyle__animateStyle","animateStyle","setStyle","fillGaps","virtualdom_items_Element_Transition$processParams","virtualdom_items_Element_Transition$start","resetStyle","originalStyle","completed","noReset","Transition","processParams","virtualdom_items_Element$render","renderImage","getNamespace","processOption","updateLiveQueries","updateCss","updateScript","appearsToBeIELessEqual8","hasChildNodes","autofocus","focus","virtualdom_items_Element$toString","optionIsSelected","inputIsCheckedRadio","typeAttribute","nameAttribute","stringifyAttribute","virtualdom_items_Element_special_option_unbind","virtualdom_items_Element$unbind","unbindOption","virtualdom_items_Element$unrender","removeFromLiveQueries","Element","deIndent","reducer","lineIndent","firstLine","lastLine","minIndent","getPartialTemplate","getPartialFromRegistry","rname","applyIndent","indented","notFirstLine","Partial","fragmentToRender","fragmentToUnrender","isNamed","setTemplate","getComponent","components","virtualdom_items_Component$detach","virtualdom_items_Component$find","virtualdom_items_Component$findAll","virtualdom_items_Component$findAllComponents","virtualdom_items_Component$findComponent","virtualdom_items_Component$findNextNode","virtualdom_items_Component$firstNode","ComponentParameter","ReferenceExpressionParameter","toBind","createModel","parameter","complexParameters","defaultData","createInstance","contentDescriptor","createBindings","childValue","propagateEvents","propagateEvent","proxyEventName","eventsDescriptor","virtualdom_items_Component$init","yielders","virtualdom_items_Component$rebind","indexRefAlias","updated","virtualdom_items_Component$render","virtualdom_items_Component$toString","virtualdom_items_Component$unbind","removeFromLiveComponentQueries","teardownHook","virtualdom_items_Component$unrender","Comment","createComment","Yielder","componentInstance","surrogateParent","virtualdom_Fragment$init_createItem","virtualdom_Fragment$init","createItem","parentRefs","argsList","virtualdom_Fragment$rebind","virtualdom_Fragment$render","virtualdom_Fragment$toString","virtualdom_Fragment$unbind","unbindItem","virtualdom_Fragment$unrender","Ractive$reset","shouldRerender","resetHook","rerender","Ractive$resetTemplate","Ractive$reverse","Ractive$set","Ractive$shift","Ractive$sort","Ractive$splice","Ractive$subtract","Ractive$teardown","Ractive$toggle","messsage","Ractive$toHTML","Ractive$unrender","unrenderHook","Ractive$unshift","Ractive$update","updateHook","Ractive$updateModel","consolidateChangedValues","cascade","childDeps","newValue","checkboxGroups","depsMap","resetTemplate","toHTML","getGuid","getNextNumber","Ractive$shared_hooks_HookQueue","HookQueue","hook","inProcess","getChildQueue","hookQueue","childQueue","begin","viewmodel$get_arrayAdaptor_processWrapper","viewmodel$get_arrayAdaptor_patch","processWrapper","patchArrayMethods","unpatchArrayMethods","patchedArrayProto","mutatorMethods","setting","unpatch","viewmodel$get_arrayAdaptor","patch","arrayAdaptor","ArrayWrapper","errorMessage","viewmodel$get_magicArrayAdaptor","magicArrayAdaptor","MagicArrayWrapper","magicWrapper","arrayWrapper","viewmodel$adapt","prefixKeypath","getPrefixer","rootKeypath","rootDot","prefixers","relativeKeypath","adaptor","found","getUpstreamChanges","upstreamKeypath","upstreamChanges","viewmodel$applyChanges_getPotentialWildcardMatches","mask","viewmodel$applyChanges_notifyPatternObservers","notifyPatternObservers","onlyDirect","potentialWildcardMatches","updateMatchingPatternObservers","upstreamPattern","actualChildKeypath","lastKey","viewmodel$applyChanges","invalidate","notifyUpstreamDependants","groupName","dependants","findDependants","notifyBindings","useSet","notifyAllDependants","addKeypaths","addKeypath","noCascade","viewmodel$capture","captureGroups","viewmodel$clearCache","dontTeardownWrapper","cacheMap","clearCache","getComputationSignature","createFunctionFromString","functionBody","Computation","hardDeps","softDeps","depValues","_firstRun","bypass","newDeps","dependenciesChanged","dependencyValuesChanged","getting","updateDependencies","oldDeps","viewmodel$compute","viewmodel$get_FAILED_LOOKUP","FAILED_LOOKUP","viewmodel$get_UnresolvedImplicitDependency","UnresolvedImplicitDependency","unresolvedImplicitDependencies","viewmodel$get","retrieve","captureGroup","viewmodel$init","viewmodel$mark","implicit","viewmodel$merge_mapOldToNewIndex","newArray","usedIndices","firstUnusedIndex","viewmodel$merge","mapOldToNewIndex","getComparatorFunction","comparators","viewmodel$register","updateDependantsMap","dependant","depsByKeypath","viewmodel$release","viewmodel$set","resolveSet","wrapperSet","valueSet","silent","viewmodel$smartUpdate","canShuffle","implicitOption","noCascadeOption","oldLength","i$0","viewmodel$teardown","unresolvedImplicitDependency","viewmodel$unregister","adaptConfig","arrayIfString","Viewmodel","noMagic","Ractive_initialise","initialiseProperties","constructHook","configHook","initHook","unwrapExtended","addRegistry","Ractive_extend","unwrap","staticProperties","extendObj",276,363,"_events","_maxListeners","defaultMaxListeners","setMaxListeners","er","newListener","fired","listenerCount","emitter",364,"normalizeArray","allowAboveRoot","xs","splitPathRe","splitPath","filename","resolvedPath","resolvedAbsolute","normalize","trailingSlash","fromParts","toParts","samePartsLength","outputParts","extname",367,"superCtor","super_","TempCtor",368,369],"mappings":"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SA6BAC,GAAAzC,GAAAtH,GAAAnJ,IA+BAmT,GAAA1P,GAAA,SAAA/G,EAAA0W,GACA,GAAAlZ,GAAA,WACA,GACiBmZ,GAAAC,EADjBC,EAAA,YAKA,OAHAA,GAAA9b,UAAA2b,EAAA3b,UACA4b,EAAA,GAAAE,GACAD,EAAAF,EAAAlb,MAAAmb,EAAArc,WACAqF,OAAAiX,SAAAD,EAEA,OAAA3W,GAAA,EAAAqU,GAAAhQ,EAAArE,EAAAxC,QA0BAsZ,GAAA,SAAA5Z,GACA,OAAA5C,UAAA+C,OACA,KAAAoD,IAEA,OAAAiV,IAAAxY,EAAAG,OAAAH,IAsBA6Z,GAAAV,GAAA9V,EAAA+N,GAAAhL,GA4BA0T,GAAA,SAAAN,GACA,MAAAD,IAAAC,EAAArZ,OAAAqZ,IAGAzB,IACArP,KACAC,KACAC,KACAlJ,KACAgL,OACAC,OACAwL,WACAtR,SACA+F,OACAC,OACAuL,WACAvB,MACA/J,UACAC,YACAzM,SACAwG,QACAuR,SACAC,aACAtL,UACAC,QACAlN,OACA2Y,SACAC,UACAC,cACAzL,SACAmO,WACAzC,cACA1V,aACAiK,WACAzN,UACA+H,OACAoU,aACAP,cACAvC,YACA3L,gBACAzF,WACAqR,WACA3L,kBACA6L,SACA5L,UACAG,OACAC,cACAI,kBACAqL,UACAnL,QACAC,aACAC,SACAC,MACAiL,UACAhL,WACAiL,UACA9K,UACAC,iBACAC,QACAC,aACAC,YACAC,iBACAC,WACA/G,OACAgH,SACAC,gBACAC,SACAC,gBACAC,WACAC,kBACApH,YACAE,OACAuR,aACApK,eACAC,OACAC,WACAmK,MACAC,OACAlK,OACAC,SACAkK,QACAxR,WACAuH,UACAI,OACAC,WACA6J,QACA3J,UACAC,aACA2J,aACAE,gBACAG,oBACAE,UACAC,aACAjK,WACAG,MACAnI,cACAI,UACAC,QACAC,QACAgI,QACAC,QACAhI,SACAqI,YACAsJ,QACArJ,eACA/O,UACAiP,QACAwK,QACApB,SACAE,MACAC,OACApJ,OACAC,aACAE,aACAC,cACAC,UACAC,iBACA/S,SACA8b,WACAvW,OACA0N,SACAhJ,UACA5D,OACA6M,SACA8I,SACAC,UACA9I,YACA9I,OACA+I,UACA9I,MACA+I,OACA9I,SACA+I,MACAE,QACAhJ,OACAiJ,MACAE,MACAC,YACAC,SACAC,aACAG,QACAD,UACAG,UACAE,QACAC,WACAC,UACAC,QACAC,SACAC,WACAhK,YACAiK,WACAoI,WACAhT,OACA6K,UACAhK,UACAiK,UACAnH,SACAqH,YACAC,SACAG,UACAC,iBACAC,UACA6G,UACA9a,WACAyJ,WACA6K,SACA1U,SACA2U,QACAC,UACA1B,SACA6B,cACAC,kBACAC,aACAC,iBACAC,eACAC,YACAC,OACAC,QACAC,QACAC,aACAC,OACAC,SACAC,WACAC,WACA9L,aACA+L,WACA9L,QACAO,QACAE,WACAC,SACAqL,WACAqF,SACAC,aACAnF,QACAC,YACAC,UACAkF,WACAjF,UACA1L,YACA4L,SACAC,QACAE,SACAC,OACAE,UACAC,WAMA5Y,GAAAC,QAAA+b,KAOCha,KAAAV,OF+KK0c,GACA,SAAShe,GGxyMf,QAAAie,GAAAC,GACA,GAAAC,GAAA7c,IAKA,OAJA,kBAAA4c,SAAAlc,KAAAV,OAIA,GAAA8c,SAAA,SAAAC,EAAAnI,GASA,QAAAoI,GAAAC,GACA,GAAAZ,EACA,KACAA,EAAAO,EAAAM,KAAAD,GACO,MAAA1b,GACP,MAAAqT,GAAArT,GAEA2b,EAAAb,GASA,QAAAc,GAAAC,GACA,GAAAf,EACA,KACAA,EAAAO,WAAAQ,GACO,MAAA7b,GACP,MAAAqT,GAAArT,GAEA2b,EAAAb,GAYA,QAAAa,GAAAb,GACA,GAAAA,EAAAgB,KAAA,MAAAN,GAAAV,EAAA1W,MACA,IAAAA,GAAA2X,EAAA5c,KAAAmc,EAAAR,EAAA1W,MACA,OAAAA,IAAA4X,EAAA5X,KAAAC,KAAAoX,EAAAG,GACAA,EAAA,GAAAhX,WAAA,8GACA8C,OAAAoT,EAAA1W,OAAA,MAhDAqX,MA6DA,QAAAM,GAAA7Y,GACA,MAAAA,GACA8Y,EAAA9Y,KACA+Y,EAAA/Y,IAAAgZ,EAAAhZ,GAAAkY,EAAAjc,KAAAV,KAAAyE,GACA,kBAAAA,GAAAiZ,EAAAhd,KAAAV,KAAAyE,GACAlE,MAAA2E,QAAAT,GAAAkZ,EAAAjd,KAAAV,KAAAyE,GACAmZ,EAAAnZ,GAAAoZ,EAAAnd,KAAAV,KAAAyE,GACAA,EANAA,EAiBA,QAAAiZ,GAAA/a,GACA,GAAAka,GAAA7c,IACA,WAAA8c,SAAA,SAAAC,EAAAnI,GACAjS,EAAAjC,KAAAmc,EAAA,SAAAO,EAAAH,GACA,MAAAG,GAAAxI,EAAAwI,IACArd,UAAA+C,OAAA,IAAAma,EAAAxc,EAAAC,KAAAX,UAAA,QACAgd,GAAAE,QAcA,QAAAU,GAAAlZ,GACA,MAAAqY,SAAAxP,IAAA7I,EAAAyN,IAAAoL,EAAAtd,OAYA,QAAA6d,GAAApZ,GAcA,QAAAqZ,GAAAC,EAAArZ,GAEAqW,EAAArW,GAAAsG,OACAgT,EAAAxK,KAAAuK,EAAAnY,KAAA,SAAAqX,GACAlC,EAAArW,GAAAuY,KAdA,OAHAlC,GAAA,GAAAtW,GAAA4M,YACAE,EAAAnM,OAAAmM,KAAA9M,GACAuZ,KACAC,EAAA,EAAiBA,EAAA1M,EAAAzO,OAAiBmb,IAAA,CAClC,GAAAvZ,GAAA6M,EAAA0M,GACAF,EAAAT,EAAA5c,KAAAV,KAAAyE,EAAAC,GACAqZ,IAAAR,EAAAQ,GAAAD,EAAAC,EAAArZ,GACAqW,EAAArW,GAAAD,EAAAC,GAEA,MAAAoY,SAAAxP,IAAA0Q,GAAApY,KAAA,WACA,MAAAmV,KAoBA,QAAAwC,GAAA9Y,GACA,wBAAAA,GAAAmB,KAWA,QAAA6X,GAAAhZ,GACA,wBAAAA,GAAAyY,MAAA,kBAAAzY,YAUA,QAAA+Y,GAAA/Y,GACA,GAAA4M,GAAA5M,EAAA4M,YACA6M,EAAA7M,EAAA7Q,UACAqG,EAAAwK,EAAA8M,aAAA9M,EAAAxK,KACAuX,EAAA,qBAAAvX,EACAwX,EAAA,kBAAAH,GAAAhB,MACA,kBAAAgB,WACA,OAAAE,IAAAC,EAWA,QAAAT,GAAAzY,GACA,MAAAC,SAAAD,EAAAkM,YAnOA,GAAA5Q,GAAAF,MAAAC,UAAAC,KAMA/B,GAAAC,QAAAge,EAAA,WAAAA,OAcAA,EAAA3F,KAAA,SAAArU,GACA,kBACA,MAAAga,GAAAjc,KAAAV,KAAA2C,EAAA1B,MAAAjB,KAAAD,eHqiNMue,GACA,SAAS5f,GI9/Mf,QAAA6f,MAjEA,GAAAC,GAAA9f,EAAAC,UAEA6f,GAAAC,SAAA,WACA,GAAAC,GAAA,mBAAAzf,SACAA,OAAA0f,aACAC,EAAA,mBAAA3f,SACAA,OAAA4f,iBACAC,EAAA,mBAAA7f,SACAA,OAAA8f,aAAA9f,OAAA+f,gBAGA,IAAAN,EACA,gBAAAzb,GAA6B,MAAAhE,QAAA0f,aAAA1b,GAG7B,IAAAgc,KAEA,IAAAL,EAAA,CACA,GAAAM,GAAApgB,SAAAqgB,cAAA,OACAC,EAAA,GAAAP,kBAAA,WACA,GAAAQ,GAAAJ,EAAAxe,OACAwe,GAAAnc,OAAA,EACAuc,EAAAvP,QAAA,SAAAnN,GACAA,OAMA,OAFAyc,GAAAE,QAAAJ,GAAqCK,YAAA,IAErC,SAAA5c,GACAsc,EAAAnc,QACAoc,EAAAM,aAAA,YAEAP,EAAAzL,KAAA7Q,IAIA,MAAAmc,IACA7f,OAAA+f,iBAAA,mBAAAS,GACA,GAAA5H,GAAA4H,EAAA5H,MACA,KAAAA,IAAA5Y,QAAA,OAAA4Y,IAAA,iBAAA4H,EAAAC,OACAD,EAAAE,kBACAV,EAAAnc,OAAA,IACA,GAAAH,GAAAsc,EAAAW,OACAjd,QAGS,GAET,SAAAA,GACAsc,EAAAzL,KAAA7Q,GACA1D,OAAA8f,YAAA,sBAIA,SAAApc,GACAkd,WAAAld,EAAA,OAIA6b,EAAAsB,MAAA,UACAtB,EAAAuB,SAAA,EACAvB,EAAAwB,OACAxB,EAAAyB,QAIAzB,EAAA0B,GAAA3B,EACAC,EAAA2B,YAAA5B,EACAC,EAAAvU,KAAAsU,EACAC,EAAA4B,IAAA7B,EACAC,EAAA6B,eAAA9B,EACAC,EAAA8B,mBAAA/B,EACAC,EAAA+B,KAAAhC,EAEAC,EAAAgC,QAAA,WACA,SAAApY,OAAA,qCAIAoW,EAAAiC,IAAA,WAA2B,WAC3BjC,EAAAkC,MAAA,WACA,SAAAtY,OAAA,oCJykNMuY,GACA,SAASjiB,EAAQC,GAEtB,YK/pNM,SAASiiB,GAAMC,EAAOC,GAC3B,IAAKA,EAAU,MAAO,aACtB,IAAIC,GAAS,CAEb,OADAD,GAASE,OAAO,EAAGH,GACZ,SAACI,GLsqNL,MKtqNeH,GAASE,SAASD,EAAQF,EAAOI,IAG9C,QAASC,GAAYJ,EAAU7d,GACpC,GAAImW,GAAU,EACVyH,EAAQ,CACZ,OAAO,YAEL,MADAC,GAASE,OAAO5H,IAAWyH,GACpB/D,QAAQC,QAAQ9Z,EAAEhC,MAAMjB,KAAMD,YAClCmW,IAAI,WLuqNJ,MKvqNU4K,GAASE,SAAS5H,EAASyH,MAIrC,QAASjT,GAAK9I,EAAMyC,GACzB,MAAOzC,GAAKqc,MAAM,WLyqNf,MKzqNqB5Z,GAAGyZ,OAAOlc,EAAKsU,QAAStU,EAAK+b,MAAO/b,EAAKmc,SL+oNlEtiB,EKjqNeiiB,QLkqNfjiB,EK3pNeuiB,cL4pNfviB,EKlpNeiP,OL6qNfxI,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ0b,GACA,SAAS3iB,EAAQC,GAEtB,YMrsNM,SAAS2iB,GAASC,GACvB,OACEC,GAAE,SAACzW,GACD,MAAO,IAAI+R,SAAQ,SAASC,EAASnI,GACnC,GAAI6M,GAAS,GAAIC,WAOjB,QANAD,EAAOE,OAAS,WACd5E,EAAQ0E,EAAOje,SAEjBie,EAAOG,QAAU,WACfhN,EAAO,GAAIxM,OAAM,8BAEX2C,GACR,IAAK,cACH0W,EAAOI,kBAAkBN,EACzB,MACF,KAAK,OACHE,EAAOK,WAAWP,QNurN3B5iB,EMvsNe2iB,WNwsNf3iB,EAAQ,WM1sNM2iB,ENkuNdlc,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJoc,GACA,SAASrjB,EAAQC,EAASC,GO1uNhC,GAAAK,GAAAL,EAAA,IAEAojB,EAAA/iB,EAAAgjB,cAAAhjB,EAAAijB,kBACAF,KAAAtjB,EAAAC,QAAA,GAAAqjB,KPivNMG,GACA,SAASzjB,EAAQC,EAASC,IQrvNhC,SAAAkZ,GAAA,YAEA,IAAAA,EAAAsK,eACA,SAAAha,OAAA,iDAEA0P,GAAAsK,gBAAA,EAEAxjB,EAAA,IACAA,EAAA,MRyvN8B8B,KAAK/B,EAAU,WAAa,MAAOqB,WAI3DqiB,GACA,SAAS3jB,IShwNf,SAAAoZ,EAAAwK,EAAAtX,GACA,YAwEA,SAAA4S,GAAA2E,GACA,cAAAA,IAAA,gBAAAA,IAAA,kBAAAA,IAEA,QAAAC,GAAAD,GACA,wBAAAA,GAQA,QAAAE,GAAAF,EAAAG,EAAAC,GACAJ,IAAAnS,GAAAmS,EAAAI,EAAAJ,IAAAK,IAAAC,KAAAC,GAAAP,EAAAM,GAAAH,GAEA,QAAAK,GAAAR,GACA,MAAAld,IAAA3E,KAAA6hB,GAAA9hB,MAAA,MAEA,QAAAuiB,GAAAT,GACA,GAAAU,GAAA1X,CACA,OAAAgX,IAAAvX,EAAAuX,IAAAvX,EAAA,mBACA,iBAAAO,GAAA0X,EAAA7d,GAAAmd,IAAAM,KAAAtX,EAAAwX,EAAAE,GAQA,QAAAC,KAOA,IANA,GAAAvgB,GAAAwgB,EAAAnjB,MACA8C,EAAA/C,UAAA+C,OACAhD,EAAAS,GAAAuC,GACAmb,EAAA,EACAmF,EAAA1P,GAAA0P,EACAC,GAAA,EACAvgB,EAAAmb,IAAAne,EAAAme,GAAAle,UAAAke,QAAAmF,IAAAC,GAAA,EACA,mBACA,GAEAC,GAFAC,EAAAvjB,KACAwjB,EAAAzjB,UAAA+C,OACAmb,EAAA,EAAAlc,EAAA,CACA,KAAAshB,IAAAG,EAAA,MAAAC,GAAA9gB,EAAA7C,EAAAyjB,EAEA,IADAD,EAAAxjB,EAAAW,QACA4iB,EAAA,KAAmBvgB,EAAAmb,EAAWA,IAAAqF,EAAArF,KAAAmF,IAAAE,EAAArF,GAAAle,UAAAgC,KAC9B,MAAAyhB,EAAAzhB,GAAAuhB,EAAA9P,KAAAzT,UAAAgC,KACA,OAAA0hB,GAAA9gB,EAAA2gB,EAAAC,IAIA,QAAA1G,GAAAla,EAAA4gB,EAAAzgB,GAEA,GADAqgB,EAAAxgB,IACAG,GAAAygB,IAAAvY,EAAA,MAAArI,EACA,QAAAG,GACA,uBAAAN,GACA,MAAAG,GAAAjC,KAAA6iB,EAAA/gB,GAEA,wBAAAA,EAAAC,GACA,MAAAE,GAAAjC,KAAA6iB,EAAA/gB,EAAAC,GAEA,wBAAAD,EAAAC,EAAArC,GACA,MAAAuC,GAAAjC,KAAA6iB,EAAA/gB,EAAAC,EAAArC,IAEG,kBACH,MAAAuC,GAAA1B,MAAAsiB,EAAAxjB,YAKA,QAAA0jB,GAAA9gB,EAAA7C,EAAAyjB,GACA,GAAAG,GAAAH,IAAAvY,CACA,UAAAlL,EAAAgD,QACA,aAAA4gB,GAAA/gB,IACAA,EAAAjC,KAAA6iB,EACA,cAAAG,GAAA/gB,EAAA7C,EAAA,IACA6C,EAAAjC,KAAA6iB,EAAAzjB,EAAA,GACA,cAAA4jB,GAAA/gB,EAAA7C,EAAA,GAAAA,EAAA,IACA6C,EAAAjC,KAAA6iB,EAAAzjB,EAAA,GAAAA,EAAA,GACA,cAAA4jB,GAAA/gB,EAAA7C,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA6C,EAAAjC,KAAA6iB,EAAAzjB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA,cAAA4jB,GAAA/gB,EAAA7C,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA6C,EAAAjC,KAAA6iB,EAAAzjB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA,cAAA4jB,GAAA/gB,EAAA7C,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA6C,EAAAjC,KAAA6iB,EAAAzjB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACG,MAAA6C,GAAA1B,MAAAsiB,EAAAzjB,GAEH,QAAA2c,GAAA7L,EAAA+S,GACA,GAAAzF,GAAAiF,EAAApjB,UAAA+C,OAAA,EAAA8N,EAAA7Q,UAAA,IAAA6iB,IACAgB,EAAAC,GAAAjG,EAAAM,KAAA4F,IACAtgB,EAAAvC,GAAAP,KAAAkQ,EAAAgT,EAAAD,EACA,OAAA/F,GAAApa,KAAAogB,EAkBA,QAAAG,GAAAxB,GACA,MAAAyB,IAAAC,EAAA1B,IAEA,QAAA2B,GAAA3B,GACA,MAAAA,GAEA,QAAA4B,KACA,MAAAnkB,MAEA,QAAAiQ,GAAAkK,EAAAzV,GACA,MAAA0L,IAAA+J,EAAAzV,GAAAyV,EAAAzV,GAAA,OAEA,QAAA0f,GAAA7B,GAEA,MADA8B,GAAA9B,GACA+B,GAAAC,GAAAhC,GAAAjiB,OAAAgkB,GAAA/B,IAAAgC,GAAAhC,GAiBA,QAAAiC,GAAArK,EAAApT,GAMA,IALA,GAIArC,GAJAue,EAAAc,EAAA5J,GACA5I,EAAAkT,GAAAxB,GACAngB,EAAAyO,EAAAzO,OACAnC,EAAA,EAEAmC,EAAAnC,GAAA,GAAAsiB,EAAAve,EAAA6M,EAAA5Q,QAAAoG,EAAA,MAAArC,GAKA,QAAAggB,GAAAnC,GACA,MAAAtZ,IAAAsZ,GAAA5O,MAAA,KAiBA,QAAAgR,GAAA5Z,GACA,GAAA6Z,GAAA,GAAA7Z,EACA8Z,EAAA,GAAA9Z,EACA+Z,EAAA,GAAA/Z,EACAga,EAAA,GAAAha,EACAia,EAAA,GAAAja,EACAka,EAAA,GAAAla,GAAAia,CACA,iBAAAE,GASA,IARA,GAOA/f,GAAA8X,EAPAgG,EAAA7d,GAAA6e,EAAAjkB,OACAujB,EAAAxjB,UAAA,GACAolB,EAAAnB,GAAAf,GACAhgB,EAAA4Z,EAAAqI,EAAA3B,EAAA,GACAzgB,EAAAsiB,EAAAD,EAAAriB,QACAnC,EAAA,EACA6C,EAAAohB,EAAArkB,GAAAuC,GAAA+hB,KAAA7Z,EAESlI,EAAAnC,EAAeA,IAAA,IAAAskB,GAAAtkB,IAAAwkB,MACxBhgB,EAAAggB,EAAAxkB,GACAsc,EAAAha,EAAAkC,EAAAxE,EAAAsiB,GACAlY,GACA,GAAA6Z,EAAAphB,EAAA7C,GAAAsc,MACA,IAAAA,EAAA,OAAAlS,GACA,eACA,cAAA5F,EACA,cAAAxE,EACA,QAAA6C,EAAAgQ,KAAArO,OACS,IAAA4f,EAAA,QAGT,OAAAC,GAAA,GAAAF,GAAAC,IAAAvhB,GAGA,QAAA6hB,GAAAC,GACA,gBAAAve,GACA,GAAAkc,GAAAc,EAAA/jB,MACA8C,EAAAsiB,EAAAnC,EAAAngB,QACAnC,EAAA4kB,EAAAxlB,UAAA,GAAA+C,EACA,IAAAwiB,GAAAve,MACA,KAAWjE,EAAAnC,EAAeA,IAAA,GAAA6kB,EAAAvC,EAAAtiB,IAAA,MAAA2kB,IAAA3kB,MACrB,MAAWmC,EAAAnC,EAAeA,IAAA,IAAA2kB,GAAA3kB,IAAAsiB,KAC/BA,EAAAtiB,KAAAoG,EAAA,MAAAue,IAAA3kB,CACK,QAAA2kB,GAAA,IAGL,QAAAG,GAAAC,EAAAC,GAEA,wBAAAD,KAAAC,EAgBA,QAAAH,GAAAI,GACA,MAAAA,MAGA,QAAAC,GAAAtD,GACA,MAAAuD,OAAAvD,GAAA,EAAAwD,GAAAxD,GAGA,QAAA6C,GAAA7C,GACA,MAAAA,GAAA,EAAAzc,GAAA+f,EAAAtD,GAAAyD,IAAA,EAEA,QAAAT,GAAA5kB,EAAAmC,GACA,GAAAnC,GAAAklB,EAAAllB,EACA,UAAAA,EAAAqE,GAAArE,EAAAmC,EAAA,GAAAgD,GAAAnF,EAAAmC,GAMA,QAAAmjB,GAAAC,EAAArlB,EAAAslB,GACA,GAAAC,GAAAxI,EAAA/c,GAAA,SAAAqiB,GACA,MAAAriB,GAAAqiB,IACGriB,CACH,iBAAA0hB,GACA,MAAAtZ,IAAAkd,EAAA5D,EAAAviB,MAAAa,QAAAqlB,EAAAE,IAGA,QAAAC,GAAAhhB,GACA,gBAAAihB,GACA,GAGA9jB,GAAAC,EAHA8jB,EAAAtd,GAAAgb,EAAAjkB,OACAie,EAAA4H,EAAAS,GACAE,EAAAD,EAAAzjB,MAEA,UAAAmb,MAAAuI,EAAAnhB,EAAA,GAAA2F,GACAxI,EAAA+jB,EAAAhN,WAAA0E,GACA,MAAAzb,KAAA,OAAAyb,EAAA,IAAAuI,IAAA/jB,EAAA8jB,EAAAhN,WAAA0E,EAAA,WAAAxb,EAAA,MACA4C,EAAAkhB,EAAAjN,OAAA2E,GAAAzb,EACA6C,EAAAkhB,EAAA9lB,MAAAwd,IAAA,IAAAzb,EAAA,YAAAC,EAAA,eAMA,QAAAgkB,GAAAlW,EAAAmW,EAAAC,GACA,IAAApW,EAAA,KAAApK,IAAAwgB,EAAAD,EAAAC,EAAAD,GAEA,QAAAzC,GAAA1B,GACA,GAAAA,GAAAvX,EAAA,KAAA7E,IAAA,uCACA,OAAAoc,GAEA,QAAAY,GAAAZ,GAEA,MADAkE,GAAAjE,EAAAD,KAAA,uBACAA,EAEA,QAAA8B,GAAA9B,GAEA,MADAkE,GAAA7I,EAAA2E,KAAA,sBACAA,EAEA,QAAAqE,GAAArE,EAAAsE,EAAAhgB,GACA4f,EAAAlE,YAAAsE,GAAAhgB,EAAA,6BAIA,QAAAigB,GAAAC,EAAAphB,GACA,OACAqhB,aAAA,EAAAD,GACAE,eAAA,EAAAF,GACAG,WAAA,EAAAH,GACAphB,SAGA,QAAAwhB,GAAAhN,EAAAzV,EAAAiB,GAEA,MADAwU,GAAAzV,GAAAiB,EACAwU,EAEA,QAAAiN,GAAAL,GACA,MAAAM,IAAA,SAAAlN,EAAAzV,EAAAiB,GACA,MAAAyb,IAAAjH,EAAAzV,EAAAoiB,EAAAC,EAAAphB,KACGwhB,EAEH,QAAAG,GAAA5iB,GACA,MAAA6iB,IAAA,IAAA7iB,EAAA,QAAA8iB,GAAAC,MAAAC,IAAA,IAEA,QAAAC,GAAA9gB,EAAA+gB,GACA,MAAAC,QAAAhhB,KAAA+gB,EAAAC,GAAAC,IAAAP,GAAAQ,GAAAlhB,GAYA,QAAAmhB,GAAApX,EAAAqX,GACA,OAAAvjB,KAAAujB,GAAAnF,GAAAlS,EAAAlM,EAAAujB,EAAAvjB,GACA,OAAAkM,GAMA,QAAAsX,GAAAC,IACA7F,IAAA8F,GAAAD,KAAA/G,GAAA+G,EAAAE,IACApB,cAAA,EACAhX,IAAAkU,IAkBA,QAAAmE,GAAArF,EAAAtd,GACAmd,GAAAG,EAAAsF,GAAA5iB,GAEA6iB,IAAA1F,GAAAG,EAAAwF,GAAA9iB,GAEA,QAAA+iB,GAAA7B,EAAA8B,EAAAzL,EAAAgB,GACA2I,EAAAjE,IAAAiB,GAAA3F,GAAA0K,IAA+D1L,KAAA4J,EAAA,EAAA5J,KAC/DuF,EAAAoE,EAAA8B,EAAA,aAEA,QAAAE,GAAAhC,EAAA8B,EAAAhjB,EAAAmjB,GACA,GAAA5K,GAAA2I,EAAAjE,IACAmG,EAAA9Y,EAAAiO,EAAAqK,KAAAtY,EAAAiO,EAAAuK,KAAAK,GAAA7Y,EAAAiO,EAAA4K,IAAAnjB,CACA,IAAA2c,IAEAgG,EAAApK,EAAA6K,GACAA,IAAApjB,GAAA,CACA,GAAAqjB,GAAAC,GAAAF,EAAAroB,KAAA,GAAAmmB,IAEApE,GAAAuG,EAAAL,EAAA,gBAEAvY,GAAA8N,EAAAuK,KAAAH,EAAAU,EAAA7E,GAOA,MAHA+E,IAAAP,GAAAI,EAEAG,GAAAP,EAAA,aAAAxE,EACA4E,EAEA,QAAAI,GAAAC,EAAAT,EAAA9B,EAAA3J,EAAA4L,EAAAO,GACA,QAAAC,GAAAC,GACA,kBACA,UAAA1C,GAAA7mB,KAAAupB,IAGAb,EAAA7B,EAAA8B,EAAAzL,EACA,IAAAsM,GAAAF,EAAAG,GAAAC,IACA7S,EAAAyS,EAAAI,GACAZ,IAAAY,GAAA7S,EAAAgS,EAAAO,EAAAT,EAAA9R,EAAA,UACA2S,EAAAX,EAAAO,EAAAT,EAAAa,EAAA,WACAV,GACAa,EAAAC,GAAAC,GAAAC,GAAAnB,GACAa,UACAjY,KAAA8X,EAAAxS,EAAAyS,EAAAG,IACA5S,WAIA,QAAAkT,GAAA1M,EAAA1X,GACA,OAAUA,QAAA0X,UAEV,QAAA2M,GAAAzH,GACA,GAAAU,GAAA7d,GAAAmd,GACAsF,EAAA/P,EAAAyP,IACA0C,GAAApC,KAAAqC,KAAAzB,KAAAxF,EACA,OAAAgH,IAAA1B,KAAAtF,IAAA7S,GAAA8Y,GAAAlG,EAAAC,IAEA,QAAAkH,GAAA5H,GACA,GAAAsF,GAAA/P,EAAAyP,IACA6C,EAAA7H,EAAAsF,KAAAqC,KAAAzB,IACA4B,EAAAD,GAAA7H,EAAAgG,KAAAW,GAAAlG,EAAAT,GACA,OAAA8B,GAAAgG,EAAA3pB,KAAA6hB,IAEA,QAAA+H,GAAA3nB,EAAAgD,EAAA6jB,GACA,MAAAA,GAAA/F,EAAA9gB,EAAAgD,GAAAhD,EAAAgD,GAEA,QAAA4kB,GAAAC,EAAAhB,EAAA7mB,EAAA4gB,GAIA,IAHA,GAEAkH,GAFAC,EAAAP,EAAAK,GACAvnB,EAAA4Z,EAAAla,EAAA4gB,EAAAiG,EAAA,OAEAiB,EAAAC,EAAAxN,QAAAG,MAAA,GAAAiN,EAAArnB,EAAAwnB,EAAA9kB,MAAA6jB,MAAA,SAiBA,QAAAG,GAAA5e,EAAAlE,EAAAgR,GACA,GAAAnT,GAAAimB,EAAA/hB,EAAAgiB,EACAC,EAAA9f,EAAA+f,GACAla,EAAAia,EAAA/S,EAAA/M,EAAAggB,GACAjT,EAAAjR,IAAAiR,EAAAjR,IAAAid,IAAAlB,IACAjkB,EAAAksB,EAAAG,MAAAnkB,KAAAmkB,GAAAnkB,MACAgkB,KAAAhT,EAAAhR,EACA,KAAAnC,IAAAmT,GAEA8S,IAAA5f,EAAA8e,KAAAjZ,GAAAlM,IAAAkM,MACA4R,EAAA5R,EAAAlM,KAAA0jB,GAAAxX,EAAAlM,KAEAkE,GAAA+hB,EAAA/Z,EAAAiH,GAAAnT,GAEA4d,IAAAuI,GAAArI,EAAA5R,EAAAlM,IAEAqG,EAAAkgB,IAAAN,EAAAC,EAAA/N,EAAAjU,EAAAkP,GAEA/M,EAAAmgB,KAAA5I,GAAA1R,EAAAlM,IAAAkE,GACAgiB,EAAA,SAAAO,GACA,MAAAnrB,gBAAA4I,GAAA,GAAAA,GAAAuiB,GAAAviB,EAAAuiB,IAEAP,EAAAhI,IAAAha,EAAAga,KACKgI,EAAA7f,EAAA6e,IAAApH,EAAA5Z,GAAAiU,EAAAnc,GAAAkI,KATLgiB,EAAA/S,EAAAnT,GAWA4d,GAAA1R,IAAA+Z,IACAE,GAAA9f,EAAAqgB,GAAAxa,EAAAlM,GAAAkE,QACAgI,GAAAlM,IAAAoe,GAAAlS,EAAAlM,EAAAkE,IAGAjK,EAAA+F,IAAAkE,GAAAka,GAAAnkB,EAAA+F,EAAAkmB,GAxhBA,GA4FAS,GA5FAC,EAAA,SACAC,EAAA,WACAC,GAAA,QACAC,GAAA,SACAC,GAAA,SACAC,GAAA,SACAC,GAAA,OACAC,GAAA,MACAC,GAAA,MACAC,GAAA,UACAC,GAAA,UACAzE,GAAA,SACA0E,GAAA,UACAC,GAAA,OACAC,GAAA,YACAvJ,GAAA,YACAwJ,GAAA,cACA1E,GAAA,WACA2E,GAAA3E,GAAA,MAEA4E,GAAA,iBACAC,GAAA,UACArC,GAAA,WACAzB,GAAA,KAAAyB,GACAsC,GAAA,UACAC,GAAA,gBAEAzrB,GAAA8W,EAAAyT,GACAnmB,GAAA0S,EAAAwT,GACA/qB,GAAAuX,EAAA0T,IACAviB,GAAA6O,EAAA2T,IACAlmB,GAAAuS,EAAA4T,IACA/rB,GAAAmY,EAAA6T,IAEAe,IADA5U,EAAA8T,IACA9T,EAAA+T,KACAc,GAAA7U,EAAAgU,IACAc,GAAA9U,EAAAiU,IACAc,GAAA/U,EAAAkU,IACAnE,GAAA/P,EAAAyP,IACAxiB,GAAA+S,EAAAoU,IACA/lB,GAAA2R,EAAA3R,UACA2mB,GAAAhV,EAAAgV,WACAjN,GAAA/H,EAAA+H,WACAlB,GAAA7G,EAAA6G,aACAoO,GAAAjV,EAAAiV,eACArtB,GAAAoY,EAAApY,SACAstB,GAAAlV,EAAAkV,SACAxO,GAAA1G,EAAA0U,IACA/N,GAAAD,OAAAC,SACA3f,GAAAgZ,EAAAhZ,SACAmuB,GAAAnuB,OAAAC,gBAEAmuB,IADApV,EAAAxY,UACAwY,EAAAoV,QACAC,GAAA5sB,GAAAqiB,IACAkB,GAAA1e,GAAAwd,IACAwK,GAAApsB,GAAA4hB,IACAnQ,GAAA,IACAsV,GAAA,IAeAK,GAAAvL,EAAA,IAAA3P,KAAA,2BAAkD,GAIlD7H,GAAAye,GAAA4D,IAcAhnB,GAAA0sB,GAAA1sB,KACAO,GAAAmsB,GAAAnsB,MAmEA4iB,GAAAze,GAAAye,OACAoF,GAAA7jB,GAAA6jB,eACAoE,GAAAjoB,GAAAioB,eACAjM,GAAAhc,GAAAgc,eAEAkM,IADAloB,GAAAmoB,iBACAnoB,GAAAooB,0BACA/I,GAAArf,GAAAmM,KACAgT,GAAAnf,GAAAqoB,oBACAnJ,GAAAlf,GAAAsoB,sBACAC,GAAAvoB,GAAAuoB,SACAvd,GAAAyM,EAAAnc,GAAAojB,GAAAwI,IAAA,GAEAtI,GAAA5e,GAmBAwoB,GAAAxoB,GAAAwoB,QAAA,SAAAhd,GAIA,IAHA,GAAArF,GAAAnG,GAAA6e,EAAArT,IACA4V,EAAAzmB,UAAA+C,OACAmb,EAAA,EACAuI,EAAAvI,GAMA,IALA,GAIAvZ,GAJAmpB,EAAA7J,GAAAjkB,UAAAke,MACA1M,EAAAkT,GAAAoJ,GACA/qB,EAAAyO,EAAAzO,OACAf,EAAA,EAEAe,EAAAf,GAAAwJ,EAAA7G,EAAA6M,EAAAxP,MAAA8rB,EAAAnpB,EAEA;MAAA6G,IAgBAiI,GAAA2Z,GAAA3Z,KAKA1D,IAJAqd,GAAAW,QACAX,GAAA1sB,MACA0sB,GAAArsB,OACAqsB,GAAAxc,QACAwc,GAAAZ,KA4DAvG,GAAA,iBACA+H,GAAAhpB,GAAAgpB,IACAC,GAAAjpB,GAAAipB,IACArZ,GAAA5P,GAAA4P,KACAD,GAAA3P,GAAA2P,MACA1P,GAAAD,GAAAC,IACAc,GAAAf,GAAAe,IACA2hB,GAAA1iB,GAAA0iB,OACA1B,GAAAhhB,GAAAghB,OAAA,SAAAxD,GACA,OAAAA,EAAA,EAAA7N,GAAAC,IAAA4N,IA0FA8E,KAAA,WACA,IACA,MAAoE,IAApEjG,MAAgC,KAAQnR,IAAA,WAAgB,YAAYzN,EAC7D,MAAAjB,QAEPimB,GAAA,EACA1E,GAAAsE,EAAA,GACApV,GAAA6V,GAAAV,EAAArE,GACAgF,GAAAD,IAAAP,EAMA2G,GAAAtG,EAAA,eACAuG,GAAAf,GAAAc,QACA5F,GAAAV,EAAA,WASAY,GAAAZ,EAAAuC,IACArH,GAAA8E,EAAA0E,IACA7D,GAAAC,KAAA0E,IACAgB,GAAArG,GAAA,QACA2B,GAAA,EACAC,GAAA,EACAR,MACAN,MACAwF,GAAA7F,KAAA4E,IAEArD,GAAA,QAAAqD,OAAA,WAAA5b,OAEA+W,GAAAM,GAAAzE,EA2EA,IAIAkK,IAJAC,GAAAvL,EAAAvE,KAAAgO,GACAxB,MACAtX,GAAA4O,EAAAxK,EAAAkT,GACAuD,GAAAzW,EAAAkT,KAGAnB,GAAA,EACAiB,GAAA,EACAC,GAAA,EACAnB,GAAA,EACAqB,GAAA,GACAC,GAAA,GACAE,GAAA,EAmCA,oBAAA1sB,MAAAC,QAAAD,EAAAC,QAAAqsB,GAEAxI,EAAA0K,QAAAsB,IAAAtB,GAAA,WAA2D,MAAAlC,MAE3DqD,IAAA,GACAA,IAAA/L,KACA0I,GAAAyD,WAAA,WAEA,MADA3W,GAAAkT,KAAAuD,GACAvD,IAEAlT,EAAAkT,UAQA,SAAA0D,EAAAC,EAAAC,EAAAhH,GAEAQ,GAAAP,MACAA,GAAA,SAAAgH,GACApI,IAAAzmB,eAAA6nB,KAAAN,GAAA,aAAA6E,GACA,IAAA1J,GAAA4E,EAAAuH,GACAC,EAAA9c,GAAA6R,GAAAgE,GAAAjF,KAAA8L,EAAAhM,EAQA,OAPAkM,GAAAlM,GAAAoM,EACAzH,IAAAO,GAAAxG,GAAA0C,GAAApB,GACAuE,cAAA,EACAjV,IAAA,SAAArM,GACAmd,GAAA9iB,KAAA0iB,EAAA/c,MAGAmpB,GAEAhM,GAAA+E,GAAAjF,IAAA8E,GAAA,WACA,MAAA1nB,MAAA0uB,MAGA/E,EAAAmB,GAAAI,IAA0BrD,WAE1B,IAAAkH,IAEAC,MAAA,SAAAtqB,GACA,MAAA0L,IAAAue,EAAAjqB,GAAA,IACAiqB,EAAAjqB,GACAiqB,EAAAjqB,GAAAmjB,GAAAnjB,IAGAgmB,SAAAnC,GAEA0G,OAAA/L,EAAAxiB,KAAA8jB,EAAAmK,GAEAO,QAAA7G,GAEA8G,YAAAtM,GAAA8E,EAAA0E,IAAA,GAEA+C,YAAAnB,GACAoB,KAAAvH,GACA9V,OACAsd,UAAA,WAA0B1H,GAAA,GAC1B2H,UAAA,WAA0B3H,GAAA,GAS1B9X,IAAApP,KAAAgkB,EAAA,yEACA,SAAAnC,GACAwM,EAAAxM,GAAAoF,EAAApF,KAGAoH,EAAAoB,GAAAxD,GAAAwH,GAEAtM,EAAAoF,GAAAN,IAEAoC,EAAAoB,GAAAlB,IAAAzB,GAAAP,IAAAyD,GAEAmC,oBAAA,SAAAlL,GAEA,IADA,GAAA7d,GAAAiC,EAAA4d,GAAAR,EAAAxB,IAAA/e,KAAAya,EAAA,EACAtX,EAAA7D,OAAAmb,GAAA7N,GAAAwe,EAAAlqB,EAAAiC,EAAAsX,OAAAza,EAAAgQ,KAAA9O,EACA,OAAAlB,IAGAkqB,sBAAA,SAAAnL,GAEA,IADA,GAAA7d,GAAAiC,EAAA4d,GAAAR,EAAAxB,IAAA/e,KAAAya,EAAA,EACAtX,EAAA7D,OAAAmb,GAAA7N,GAAAwe,EAAAlqB,EAAAiC,EAAAsX,OAAAza,EAAAgQ,KAAAob,EAAAlqB,GACA,OAAAlB,OAGCskB,GAAA,cAA0B,IAM3B,SAAA0H,GACA,GAAAC,IAEA7B,UAEAzc,GAAA,SAAAxN,EAAA+rB,GACA,MAAA/rB,KAAA+rB,EAAA,IAAA/rB,GAAA,EAAAA,IAAA,EAAA+rB,EAAA/rB,MAAA+rB,MAKA,cAAA5L,KAAA,SAAA6L,EAAA3d,GACA,IACAA,EAAA6K,EAAAnc,GAAA4sB,GAAAxJ,GAAA,aAAA9R,IAAA,GACAA,KAAYmb,IACP,MAAA5rB,GAAUouB,GAAA,EACfF,EAAApC,sBAAA,SAAApK,EAAA/E,GAKA,MAJAmG,GAAApB,GACAwD,EAAA,OAAAvI,GAAAN,EAAAM,KAAA,6BACAyR,EAAA1M,EAAA2M,UAAA1R,EACAlM,EAAAiR,EAAA/E,GACA+E,MAGA0G,EAAAoB,GAAAO,EAAAmE,GAEAnN,IAEAkN,EAAA3M,IAAAkF,GACAhF,EAAAyM,IAAAzH,IAAAjF,GAAAgB,GAAA4D,GAAA,WACA,iBAAA1E,EAAAhjB,MAAA,OAKAyiB,EAAA1d,GAAAmnB,IAAA,GAEAzJ,EAAA3K,EAAA7V,KAAA,iBAOA,WAEA,QAAA4tB,GAAAnrB,EAAAorB,GACA,GAAAntB,GAAAyC,GAAAV,GACAkmB,EAAAI,GAAAM,GAAA5mB,GACAzB,EAAA,EACA8sB,IACA,KAAAnF,GAAAxC,GAAAwC,GAAA,CACAmF,EAAArrB,GAAA,GAAAorB,EAAA,SAAAvN,GACA,MAAA3E,GAAA2E,GAAA5f,EAAA4f,MACO,GAAAuN,EAAA,SAAAvN,GACP,MAAA3E,GAAA2E,GAAA5f,EAAA4f,IAAA,GACO,GAAAuN,EAAA,SAAAvN,GACP,MAAA3E,GAAA2E,GAAA5f,EAAA4f,IAAA,GACO,GAAAuN,EAAA,SAAAvN,EAAA7d,GACP,MAAA/B,GAAAohB,EAAAxB,GAAA7d,IACO,SAAA6d,GACP,MAAA5f,GAAAohB,EAAAxB,IAEA,KAAW5f,EAAAolB,IACX,MAAAxmB,GAAe0B,EAAA,EACf0mB,EAAAoB,GAAAlB,GAAA5mB,EAAAqoB,EAAAyE,IAGAF,EAAA,YACAA,EAAA,UACAA,EAAA,uBACAA,EAAA,cACAA,EAAA,cACAA,EAAA,kBACAA,EAAA,8BACAA,EAAA,kBACAA,EAAA,QACAA,EAAA,2BAOA,SAAAlH,GAEAA,IAAAyE,KAAAhM,GAAAgM,GAAAzE,GACA1B,cAAA,EACAhX,IAAA,WACA,GAAAxQ,GAAAwJ,GAAAjJ,MAAAP,MAAA,yBACAoH,EAAApH,IAAA,KAEA,OADA2Q,IAAApQ,KAAA2oB,IAAAvH,GAAAphB,KAAA2oB,EAAA7B,EAAA,EAAAjgB,IACAA,GAEAmL,IAAA,SAAArM,GACAyK,GAAApQ,KAAA2oB,IAAAvH,GAAAphB,KAAA2oB,EAAA7B,EAAA,EAAAnhB,QAGC,QAMDJ,GAAA,QAAAA,GAAA,iBAAAyqB,EAAAC,GACA,QAAAC,GAAA3N,GAEA,GADA3E,EAAA2E,OAAA4N,EAAA5N,IACA,gBAAAA,MAAAzf,OAAA,OAAAyf,EAAAhJ,WAAA,IACA,GAAA5L,IAAA,CACA,QAAA4U,EAAAhJ,WAAA,IACA,gBAAA5L,GAAA,CACA,wBAAAjO,IAAA6iB,EAAA9hB,MAAA,GAAAkN,EAAA,MAEK,OAAA4U,EAEL,QAAA4N,GAAA5N,GACA,GAAA5f,GAAAwC,CACA,IAAAqd,EAAA7f,EAAA4f,EAAA6N,WAAAxS,EAAAzY,EAAAxC,EAAAjC,KAAA6hB,IAAA,MAAApd,EACA,IAAAqd,EAAA7f,EAAA4f,EAAAmF,OAAA9J,EAAAzY,EAAAxC,EAAAjC,KAAA6hB,IAAA,MAAApd,EACA,MAAAgB,IAAA,kCAEAZ,GAAA,QAAAA,GAAAgd,GACA,MAAAviB,gBAAAuF,GAAA,GAAAyqB,GAAAE,EAAA3N,IAAA2N,EAAA3N,IAEAzS,GAAApP,KAAA2mB,GAAA9C,GAAAyL,GACAtL,EAAA,wEAAAhgB,GACAA,IAAAa,KAAA6b,GAAA7b,GAAAb,EAAA4oB,GAAA0C,EAAAtrB,MAEAa,GAAAqd,IAAAqN,EACAA,EAAA7D,IAAA7mB,GACAud,GAAAhL,EAAA4T,GAAAnmB,KACCA,MAAAqd,MAMD,SAAApd,GACAmkB,EAAAoB,GAAAW,IAEA2E,QAAAtC,GAAA,OAEAf,SAAA,SAAAzK,GACA,sBAAAA,IAAAyK,GAAAzK,IAGA/c,YAEAsgB,MAAAN,EAEA8K,cAAA,SAAA1K,GACA,MAAApgB,GAAAogB,IAAAoI,GAAApI,IAAAI,IAGAA,oBAEAuK,kBAAAvK,GAEAwK,sBAEA9wB,eAGC6F,GAAAC,WAAA,SAAA+c,GACD,OAAA3E,EAAA2E,IAAAyK,GAAAzK,IAAA7N,GAAA6N,UAQA,WAWA,QAAAkO,GAAA9sB,GACA,MAAAqpB,IAAArpB,OAAA,GAAAA,EAAA,EAAAA,GAAA8sB,GAAA9sB,GAAA5C,EAAA4C,EAAA+sB,EAAA/sB,IAAA,IAAAA,EAGA,QAAAgtB,GAAAhtB,GACA,WAAAA,WAAA,WAAAA,QAAA,EAAAinB,EAAAjnB,GAAA,EAdA,GAAAitB,GAAA7rB,GAAA6rB,EACAhG,EAAA7lB,GAAA6lB,IACA7pB,EAAAgE,GAAAhE,IACA2vB,EAAA3rB,GAAA2rB,KACAG,EAAA9rB,GAAA8rB,MAAA,SAAAltB,GACA,WAAAA,cAAA,EAAAA,EAAA,KAYAgmB,GAAAoB,GAAAmB,IAEA4E,MAAA,SAAAntB,GACA,OAAAA,MAAA,EAAAmO,IAAAkb,GAAArpB,GAAA5C,EAAA4C,EAAAitB,EAAAF,EAAA/sB,EAAA,GAAA+sB,EAAA/sB,EAAA,GAAAitB,GAAA,EAAAjtB,GAGA8sB,QAEAM,MAAA,SAAAptB,GACA,WAAAA,QAAA5C,GAAA,EAAA4C,IAAA,EAAAA,IAAA,GAGAqtB,KAAA,SAAArtB,GACA,MAAAktB,GAAAltB,MAAAoqB,GAAAC,GAAArqB,GAAA,MAGAstB,MAAA,SAAAttB,GACA,OAAAA,KAAA,MAAAA,EAAA+jB,IAAA,GAAA5kB,OAAA,IAGAouB,KAAA,SAAAvtB,GACA,OAAAinB,EAAAjnB,MAAAinB,GAAAjnB,IAAA,GAGAgtB,QAGAQ,OAAA,SAAAxtB,GACA,UAAAytB,eAAAztB,IAAA,IAGA0tB,MAAA,WAOA,IANA,GAKAxnB,GALAiM,EAAA,EACAxS,EAAAvD,UAAA+C,OACAS,EAAAD,EACAxD,EAAAS,GAAA+C,GACAguB,GAAA7e,GAEAnP,KAAA,CAEA,GADAuG,EAAA/J,EAAAwD,IAAAvD,UAAAuD,GACAuG,GAAA4I,IAAA5I,IAAA4I,GAAA,MAAAA,GACA5I,GAAAynB,MAAAznB,GAGA,IADAynB,EAAAznB,GAAA,EACAtG,KAAAuS,GAAAiY,GAAAjuB,EAAAyD,GAAA+tB,EAAA,EACA,OAAAA,GAAAZ,EAAA5a,IAGAyb,KAAA,SAAA5tB,EAAA+rB,GACA,GAAA8B,GAAA,MACAC,GAAA9tB,EACA+tB,GAAAhC,EACAiC,EAAAH,EAAAC,EACAG,EAAAJ,EAAAE,CACA,UAAAC,EAAAC,IAAAJ,EAAAC,IAAA,IAAAG,EAAAD,GAAAH,EAAAE,IAAA,cAGAG,MAAA,SAAAluB,GACA,OAAAA,MAAA,YAAAA,QAAA,EAAA5C,EAAA,EAAA4C,IAGAmuB,MAAA,SAAAnuB,GACA,MAAA5C,GAAA4C,GAAAoB,GAAAgtB,MAGAC,KAAA,SAAAruB,GACA,MAAA5C,GAAA4C,GAAAoB,GAAAktB,KAGApB,OAEAqB,KAAA,SAAAvuB,GACA,MAAAqqB,IAAArqB,MAAA,GAAAgtB,EAAAhtB,GAAAgtB,GAAAhtB,IAAA,GAAAinB,EAAAjnB,EAAA,GAAAinB,GAAAjnB,EAAA,KAAAitB,EAAA,IAGAuB,KAAA,SAAAxuB,GACA,GAAAnB,GAAAmuB,EAAAhtB,MACAlB,EAAAkuB,GAAAhtB,EACA,OAAAnB,IAAAiQ,GAAA,EAAAhQ,GAAAgQ,GAAA,IAAAjQ,EAAAC,IAAAmoB,EAAAjnB,GAAAinB,GAAAjnB,KAGAoiB,eAQA,SAAAqM,GACA,QAAAC,GAAA9P,GACA,GAAAQ,EAAAR,IAAAoJ,GAAA,KAAAxlB,MAGAwjB,EAAAoB,GAAAU,IAEA6G,cAAA,WAKA,IAJA,GAGAC,GAHAtV,KACArZ,EAAA7D,UAAA+C,OACAmb,EAAA,EAEAra,EAAAqa,GAAA,CAEA,GADAsU,GAAAxyB,UAAAke,KACAsH,EAAAgN,EAAA,WAAAA,EAAA,KAAAzF,IAAAyF,EAAA,6BACAtV,GAAAzJ,KAAA,MAAA+e,EACAH,EAAAG,GACAH,IAAAG,GAAA,kBAAAA,EAAA,aAEO,MAAAtV,GAAA3L,KAAA,KAGPkhB,IAAA,SAAAC,GAMA,IALA,GAAAD,GAAAzO,EAAA0O,EAAAD,KACA5uB,EAAAwhB,EAAAoN,EAAA1vB,QACA4vB,EAAA3yB,UAAA+C,OACAma,KACAgB,EAAA,EACAra,EAAAqa,GACAhB,EAAAzJ,KAAAvK,GAAAupB,EAAAvU,OACAyU,EAAAzU,GAAAhB,EAAAzJ,KAAAvK,GAAAlJ,UAAAke,IACO,OAAAhB,GAAA3L,KAAA,OAIPqY,EAAAC,GAAA6B,IAEAkH,YAAAtM,GAAA,GAEAuM,SAAA,SAAAC,GACAR,EAAAQ,EACA,IAAAtP,GAAAta,GAAAgb,EAAAjkB,OACA8yB,EAAA/yB,UAAA,GACA6D,EAAAwhB,EAAA7B,EAAAzgB,QACAiwB,EAAAD,IAAA9nB,EAAApH,EAAAkC,GAAAsf,EAAA0N,GAAAlvB,EAEA,OADAivB,IAAA,GACAtP,EAAA9iB,MAAAsyB,EAAAF,EAAA/vB,OAAAiwB,KAAAF,GAGAG,SAAA,SAAAH,GAEA,MADAR,GAAAQ,MACA5pB,GAAAgb,EAAAjkB,OAAA2Q,QAAAkiB,EAAA9yB,UAAA,KAGA4b,OAAA,SAAA3G,GACA,GAAApK,GAAA3B,GAAAgb,EAAAjkB,OACAid,EAAA,GACAxX,EAAAogB,EAAA7Q,EACA,MAAAvP,MAAAgN,GAAA,KAAAqa,IAAA,0BACA,MAAWrnB,EAAA,GAAMA,KAAA,KAAAmF,MAAA,EAAAnF,IAAAwX,GAAArS,EACjB,OAAAqS,IAGAgW,WAAA,SAAAJ,GACAR,EAAAQ,EACA,IAAAtP,GAAAta,GAAAgb,EAAAjkB,OACAW,EAAAykB,EAAAtf,GAAA/F,UAAA,GAAAwjB,EAAAzgB,QAEA,OADA+vB,IAAA,GACAtP,EAAA9iB,MAAAE,IAAAkyB,EAAA/vB,UAAA+vB,MAGC5pB,GAAAmpB,eAMD,WACAzI,EAAAoB,GAAAS,IAEA1mB,KAAA,SAAAouB,GACA,GAKApwB,GAAAU,EAAAulB,EAAA0B,EALAxH,EAAA7d,GAAA6e,EAAAiP,IACAC,EAAApzB,UAAA,GACAqzB,EAAAD,IAAAnoB,EACA/H,EAAAmwB,EAAAvW,EAAAsW,EAAApzB,UAAA,MAAAiL,EACArK,EAAA,CAEA,IAAAqpB,EAAA/G,GAAA,IAAA8F,EAAAoB,EAAAlH,GAAAzf,EAAA,IAAAiiB,EAAAzlB,KAAAO,OAAsFkqB,EAAA1B,EAAA7L,QAAAG,KAA4B1c,IAClH6C,EAAA7C,GAAAyyB,EAAAnwB,EAAAwnB,EAAA9kB,MAAAhF,GAAA8pB,EAAA9kB,UACO,KAAAnC,EAAA,IAAAiiB,EAAAzlB,KAAAO,KAAAuC,EAAAsiB,EAAAnC,EAAAngB,SAA2EA,EAAAnC,EAAgBA,IAClG6C,EAAA7C,GAAAyyB,EAAAnwB,EAAAggB,EAAAtiB,MAAAsiB,EAAAtiB,EAGA,OADA6C,GAAAV,OAAAnC,EACA6C,GAGAuP,GAAA,WAIA,IAHA,GAAApS,GAAA,EACAmC,EAAA/C,UAAA+C,OACAU,EAAA,IAAAiiB,EAAAzlB,KAAAO,KAAAuC,GACAA,EAAAnC,GAAA6C,EAAA7C,GAAAZ,UAAAY,IAEA,OADA6C,GAAAV,SACAU,KAIAmmB,EAAAC,GAAA4B,IAEA6H,WAAA,SAAAziB,EAAAmE,GACA,GAAAkO,GAAA7d,GAAA6e,EAAAjkB,OACA4D,EAAAwhB,EAAAnC,EAAAngB,QACAyE,EAAAge,EAAA3U,EAAAhN,GACAkB,EAAAygB,EAAAxQ,EAAAnR,GACAmvB,EAAAhzB,UAAA,GACAuzB,EAAAP,IAAA/nB,EAAApH,EAAA2hB,EAAAwN,EAAAnvB,GACAoR,EAAAlP,GAAAwtB,EAAAxuB,EAAAlB,EAAA2D,GACAmJ,EAAA,CAMA,KALAnJ,EAAAzC,KAAAkQ,EAAAzN,IACAmJ,EAAA,GACA5L,IAAAkQ,EAAA,EACAzN,IAAAyN,EAAA,GAEAA,IAAA,GACAlQ,IAAAme,KAAA1b,GAAA0b,EAAAne,SACAme,GAAA1b,GACAA,GAAAmJ,EACA5L,GAAA4L,CACO,OAAAuS,IAGPsQ,KAAA,SAAA5tB,GAMA,IALA,GAAAsd,GAAA7d,GAAA6e,EAAAjkB,OACA8C,EAAAsiB,EAAAnC,EAAAngB,QACAnC,EAAA4kB,EAAAxlB,UAAA,GAAA+C,GACAiwB,EAAAhzB,UAAA,GACAyzB,EAAAT,IAAA/nB,EAAAlI,EAAAyiB,EAAAwN,EAAAjwB,GACA0wB,EAAA7yB,GAAAsiB,EAAAtiB,KAAAgF,CACA,OAAAsd,IAGA5T,KAAAsV,EAAA,GAEArV,UAAAqV,EAAA,KAGArC,IAEAxS,GAAApP,KAAAgkB,EAAA,+DAAAnC,GACA2L,GAAA3L,IAAA,IAEA0L,KAAAd,KAAArK,GAAAqK,GAAAc,GAAAC,KAGAhG,EAAA3nB,QAOA,SAAAkzB,GAKAtK,EAAA5oB,GAAAirB,GAAA,SAAAkI,EAAAnK,GACAvX,GAAAhS,KAAAmuB,IAAqB4B,EAAAhM,EAAA2P,GAAAzV,EAAA,EAAA0V,EAAApK,KAElB,WACH,GAAAR,GAAA/oB,KAAAmuB,IACAlL,EAAA8F,EAAAgH,EACAxG,EAAAR,EAAA4K,EACAhzB,EAAAooB,EAAA9K,GACA,QAAAgF,GAAAtiB,GAAAsiB,EAAAngB,QACAimB,EAAAgH,EAAA/kB,EACA+e,EAAA,IAEAR,GAAAE,GAAAM,EAAA,EAAAppB,GACA4oB,GAAAG,GAAAK,EAAA,EAAA9G,EAAAtiB,IACAopB,EAAA,GAAAppB,EAAAsiB,EAAAtiB,MACG+oB,IAGHR,GAAAiD,IAAAjD,GAAAsC,IAGArC,EAAAlgB,GAAAwiB,GAAA,SAAAiI,GACA1hB,GAAAhS,KAAAmuB,IAAqB4B,EAAA9mB,GAAAyqB,GAAAzV,EAAA,KAElB,WACH,GAGA2V,GAHA7K,EAAA/oB,KAAAmuB,IACAlL,EAAA8F,EAAAgH,EACApvB,EAAAooB,EAAA9K,CAEA,OAAAtd,IAAAsiB,EAAAngB,OAAAinB,EAAA,IACA6J,EAAAH,EAAA/yB,KAAAuiB,EAAAtiB,GACAooB,EAAA9K,GAAA2V,EAAA9wB,OACAinB,EAAA,EAAA6J,OAECvN,GAAA,KAMD,SAAAwN,EAAAC,GACA,QAAAC,GAAApxB,GACA,kBAEA,MADA8jB,GAAA1D,EAAA/iB,QAAA2rB,IACAhpB,EAAA3C,OAKAqnB,KAAA,WAAyB,IAAI,cAAA1nB,GAAA,UAAmC,MAAA4B,UAChE5B,GAAA,SAAAq0B,EAAAC,GACA,UAAAH,GAAA/Q,EAAAiR,IAAArI,IAAAsI,IAAAjpB,EACAgpB,EAAAnc,OAAAmc,EAAAC,IAEAnkB,GAAApP,KAAA6jB,GAAAuP,GAAA,SAAApvB,GACAA,IAAA/E,KAAAyhB,GAAAzhB,GAAA+E,GACAuiB,cAAA,EACAhX,IAAA,WAAwB,MAAA6jB,GAAApvB,IACxBsN,IAAA,SAAAuQ,GAA0BuR,EAAApvB,GAAA6d,OAG1BsR,EAAAzH,IAAAzsB,GACAA,GAAAijB,IAAAiR,EACA/Q,GAAAhL,EAAA6T,GAAAhsB,KAIA,UAAAs0B,OAAA7S,GAAAyS,EAAA,SACA5M,cAAA,EACAhX,IAAA8jB,EAAA9N,EAAA,0BAKAnW,GAAApP,KAAAgkB,EAAA,2BAAAhgB,GACAA,IAAA,KAAA0c,GAAAyS,EAAAnvB,EAAA2iB,IACAJ,cAAA,EACAhX,IAAA8jB,EAAA,WACA,YAEKjN,EAAA,SAGLoB,EAAAvoB,KACCA,GAAAijB,IAAAjjB,IAQD6iB,EAAA7D,KAAA6D,EAAAuK,KAAA,SAAAmH,GAmBA,QAAAC,GAAAC,GACA,GAAAhkB,GAAA6O,EAAAmV,GAAA,CACA,GAAAzxB,GAAAsc,EAAAmV,SACAnV,GAAAmV,GACAzxB,KAGA,QAAA0xB,GAAAC,GACAH,EAAAG,EAAA5U,MA1BA,GAKA5B,GAAAyW,EAAAC,EALAzV,EAAAjH,EAAAiH,YACAC,EAAAlH,EAAAkH,iBACAyV,EAAA3c,EAAA2c,eACAC,EAAA,EACAzV,IAEAN,IAAA,SAAAhc,GAEA,IADA,GAAA7C,MAAAme,EAAA,EACAle,UAAA+C,OAAAmb,GAAAne,EAAA0T,KAAAzT,UAAAke,KAKA,OAJAgB,KAAAyV,GAAA,WACAjR,EAAAjB,EAAA7f,KAAA3B,GAAA2B,GAAA7C,IAEAge,EAAA4W,GACAA,GAEA3H,GAAA,SAAAqH,SACAnV,GAAAmV,IAaA9F,GACAxQ,EAAA,SAAAsW,GACA3V,GAAAyE,EAAAxiB,KAAAyzB,EAAAC,KAIGpV,GAAAwD,EAAAzD,KAAAjH,EAAA6c,eACH7W,EAAA,SAAAsW,GACArV,EAAAqV,EAAA,MAEApV,EAAA,UAAAqV,GAAA,IAEG7R,EAAAiS,IACHF,EAAA,GAAAE,GACAD,EAAAD,EAAAK,MACAL,EAAAM,MAAAC,UAAAT,EACAvW,EAAAjB,EAAA2X,EAAAzV,YAAAyV,EAAA,IAGA1W,EADGhf,IAAAo1B,IAAAp1B,IAAA2tB,IAAA,UACH,SAAA2H,GACAnH,GAAA8H,YAAAj2B,GAAA2tB,IAAA,WAAAyH,GAAA,WACAjH,GAAA+H,YAAAh1B,MACAm0B,EAAAC,KAKA,SAAAA,GACAvU,GAAAsU,EAAA,EAAAC,KAGC,sBACDzK,EAAAmB,GAAAG,IACAtM,gBACAoO,qBASA,SAAAjQ,EAAA5P,GACAsV,EAAA1F,IAAA0F,EAAA1F,EAAAC,UACAD,EAAAC,QAAA7P,EAAA,GAAA4P,GAAA,gBAAoD5P,GACpD,SAAA+nB,EAAAC,GACA,QAAAC,GAAApF,GACA,GAAAnqB,EAEA,OADAgY,GAAAmS,KAAAnqB,EAAAmqB,EAAAnqB,MACA4c,EAAA5c,MAAA,EAEA,QAAAwvB,GAAAC,GACA,GAAAhc,GAAAgc,EAAAhc,KACAA,GAAAvW,QAAAmyB,EAAA,WAIA,IAHA,GAAAK,GAAAD,EAAAC,IACAC,EAAA,GAAAF,EAAAG,MACAvX,EAAA,EACA5E,EAAAvW,OAAAmb,IAAA,SAAAwX,GACA,GACApZ,GAAAzW,EADA8vB,EAAAH,EAAAE,EAAAF,GAAAE,EAAAE,IAEA,KACAD,GACArZ,EAAAqZ,KAAA,EAAAJ,EAAAI,EAAAJ,GACAjZ,IAAAoZ,EAAAG,EACAH,EAAAI,IAAA1vB,GAAA8lB,GAAA,kBACermB,EAAAuvB,EAAA9Y,IACfzW,EAAAlF,KAAA2b,EAAAoZ,EAAAxY,IAAAwY,EAAAI,KACeJ,EAAAxY,IAAAZ,IACFoZ,EAAAI,IAAAP,GACF,MAAAlY,GACXqY,EAAAI,IAAAzY,KAES/D,EAAA4E,KACT5E,GAAAvW,OAAA,IAGA,QAAAia,GAAAuY,GACA,GACA1vB,GAAAqR,EADAoe,EAAAr1B,IAEA,KAAAq1B,EAAAhY,KAAA,CACAgY,EAAAhY,MAAA,EACAgY,UACA,MACAzvB,EAAAuvB,EAAAG,KACAre,GAAqBoe,MAAAhY,MAAA,GACrBzX,EAAAlF,KAAA40B,EAAAzY,EAAAE,EAAA9F,EAAA,GAAA4F,EAAAjI,EAAAqC,EAAA,MAEAoe,EAAAC,MACAD,EAAAG,MAAA,EACAJ,EAAAC,IAEO,MAAAjY,GACPxI,EAAAlU,KAAAuW,IAAgCoe,MAAAhY,MAAA,GAAsBD,KAGtD,QAAAxI,GAAA0gB,GACA,GAAAD,GAAAr1B,IACAq1B,GAAAhY,OACAgY,EAAAhY,MAAA,EACAgY,WACAA,EAAAC,MACAD,EAAAG,MAAA,EACAJ,EAAAC,IAEA,QAAAS,GAAA3N,GACA,GAAA0F,GAAAxJ,EAAA8D,GAAAE,GACA,OAAAwF,IAAA7iB,EAAA6iB,EAAA1F,EAGArL,EAAA,SAAAiZ,GACA5S,EAAA4S,GACAnP,EAAA5mB,KAAA8c,EAAAmP,GACA,IAAAoJ,IAAiBhc,SAAAmc,MAAA,EAAAnY,MAAA,EAAAiY,IAAAtqB,EACjB8X,IAAA9iB,KAAAk1B,EAAAG,EACA,KACAU,EAAAlZ,EAAAE,EAAAsY,EAAA,GAAAxY,EAAAjI,EAAAygB,EAAA,IACO,MAAAjY,GACPxI,EAAAlU,KAAA20B,EAAAjY,KAGA4K,EAAAlL,EAAA8F,KAEAhd,KAAA,SAAAoX,EAAAG,GACA,GAAA0Q,GAAAxJ,IAAArkB,MAAAosB,KAAA/D,IACAoN,GACAF,GAAA/S,EAAAxF,MAAA,EACA2Y,KAAAnT,EAAArF,MAAA,GACSyY,EAAAH,EAAAG,EAAA,IAAA/H,GAAA7iB,EAAA6iB,EAAA/Q,GAAA,SAAAC,EAAAnI,GACT6gB,EAAAxY,IAAAkG,EAAApG,GACA0Y,EAAAI,IAAA1S,EAAAvO,KACSygB,EAAAr1B,KAAAk1B,EAGT,OAFAG,GAAAhc,MAAA7F,KAAAiiB,GACAJ,EAAAG,OAAAJ,EAAAC,GACAO,GAGAI,QAAA,SAAA7Y,GACA,MAAAnd,MAAA4F,KAAAoF,EAAAmS,MAGA6K,EAAAlL,GAEAxP,IAAA,SAAAkd,GACA,GAAA1N,GAAAgZ,EAAA91B,MACA6W,IACA,WAAAiG,GAAA,SAAAC,EAAAnI,GACA2V,EAAAC,GAAA,EAAAhX,GAAAqD,EACA,IAAAof,GAAApf,EAAA/T,OACAiY,EAAAxa,GAAA01B,EACAA,GAAAnmB,GAAApP,KAAAmW,EAAA,SAAAkH,EAAApd,GACAmc,EAAAC,QAAAgB,GAAAnY,KAAA,SAAAD,GACAoV,EAAApa,GAAAgF,IACAswB,GAAAlZ,EAAAhC,IACanG,KAEbmI,EAAAhC,MAIAmb,KAAA,SAAA1L,GACA,GAAA1N,GAAAgZ,EAAA91B,KACA,WAAA8c,GAAA,SAAAC,EAAAnI,GACA2V,EAAAC,GAAA,WAAAzM,GACAjB,EAAAC,QAAAgB,GAAAnY,KAAAmX,EAAAnI,QAKAA,OAAA,SAAAnT,GACA,WAAAq0B,EAAA91B,OAAA,SAAA+c,EAAAnI,GACAA,EAAAnT,MAIAsb,QAAA,SAAApZ,GACA,MAAAia,GAAAja,IAAAuxB,IAAAvxB,IAAAslB,GAAAtlB,KAAA3D,KAAA4iB,IACAjf,EAAA,IAAAmyB,EAAA91B,OAAA,SAAA+c,GACAA,EAAApZ,SAIG8a,IAAAE,GAAAmJ,GAAA,QACHrF,EAAA3F,EAAAmP,IACA/D,EAAApL,GACA6M,EAAAmB,GAAAjB,IAAAzB,GAAAtL,IAAiDA,aAChDhF,EAAAmU,MAOD,WAWA,QAAAkK,GAAAhO,EAAAQ,EAAAyN,EAAAC,EAAAzR,EAAA0R,GAIA,QAAAC,GAAAhT,EAAAiH,GAEA,MADAA,IAAAxf,GAAAuf,EAAAC,EAAA5F,EAAArB,EAAAiT,GAAAjT,GACAA,EAEA,QAAAkT,GAAA/xB,EAAA2U,GACA,GAAApI,GAAAiN,EAAAxZ,EACA4d,KAAApE,EAAAxZ,GAAA,SAAAlC,EAAAC,GACA,GAAAe,GAAAyN,EAAAvQ,KAAAV,KAAA,IAAAwC,EAAA,EAAAA,EAAAC,EACA,OAAA4W,GAAArZ,KAAAwD,IAXA,GAAAgzB,GAAA5R,EAAA,YACA1G,EAAAiK,KAAAvF,IACAK,IAYA,IAAAmF,GAAAD,KAAAmO,IAAAxM,IAAA1Z,GAAA8N,EAAAqO,KAAAnc,GAAA8N,EAAA,YAqBK,CACL,GAGAwY,GAHAC,EAAAxO,EACA/L,EAAA,GAAA+L,GACA9O,EAAA+C,EAAAoa,GAAAF,MAA0C,IAG1ClI,KAAAjG,EAAArlB,SACAqlB,EAAA,SAAAqC,GAEA,MADA5D,GAAA5mB,KAAAmoB,EAAAQ,GACA4N,EAAA,GAAAI,GAAAnM,IAEArC,EAAAvF,IAAA1E,EACAoE,IAAApE,EAAAkO,IAAAjE,IAEAmO,GAAAla,EAAAmQ,IAAA,SAAApnB,EAAAT,GACAgyB,EAAA,EAAAhyB,KAAA+N,KAGAikB,IACAD,EAAA,UACAA,EAAA,OACA7R,GAAA6R,EAAA,SAGAC,GAAArd,IAAA+C,IAAAqa,EAAAD,GAAA,OA3CArO,GAAAmO,EACA,SAAA9L,GACA5D,EAAA5mB,KAAAmoB,EAAAQ,GACA3W,GAAAhS,KAAA42B,EAAAtP,KACAiP,EAAAv2B,KAAAwqB,IAEA,SAAAA,GACA,GAAAjH,GAAAvjB,IACA4mB,GAAArD,EAAA4E,EAAAQ,GACA3W,GAAAuR,EAAAsT,EAAAhT,GAAA,OACA7R,GAAAuR,EAAAuT,EAAA,GACA9kB,GAAAuR,EAAAwT,EAAA/rB,GACAgH,GAAAuR,EAAAyT,EAAAhsB,GACAurB,EAAAhT,EAAAiH,IAEAxC,IAAAG,EAAAvF,IAAAwT,GAAAC,GACAC,GAAAlV,GAAA+G,EAAAvF,IAAA,QAAsD3S,IAAA,WACtD,MAAAgU,GAAAjkB,KAAA82B,MAwDA,OA5BArU,GAAA0F,EAAAQ,GACAT,EAAAC,GAEAlF,EAAA0F,GAAAR,EACAwB,EAAAmB,GAAAI,GAAArB,IAAAzB,GAAAD,GAAAlF,GAIAqT,GAAAnN,EAAAhB,EAAAQ,EAAA,SAAA+K,EAAAnK,GACAvX,GAAAhS,KAAAmuB,IAAuB4B,EAAA2D,EAAAC,EAAApK,KAClB,WAKL,IAJA,GAAAR,GAAA/oB,KAAAmuB,IACA5E,EAAAR,EAAA4K,EACAsD,EAAAlO,EAAAvC,EAEAyQ,KAAAx1B,GAAAw1B,IAAA7sB,CAEA,OAAA2e,GAAAgH,IAAAhH,EAAAvC,EAAAyQ,MAAAxxB,EAAAsjB,EAAAgH,EAAAiH,IAMAzN,GAAAE,GAAAM,EAAA,EAAAkN,EAAAtD,GACApK,GAAAG,GAAAK,EAAA,EAAAkN,EAAAj1B,GACA+nB,EAAA,GAAAkN,EAAAtD,EAAAsD,EAAAj1B,KANA+mB,EAAAgH,EAAA/kB,EACA+e,EAAA,KAMKnF,EAAA6E,GAAAC,OAAA9E,GAELuD,EAGA,QAAA+O,GAAA3U,EAAAsB,GAEA,IAAAjG,EAAA2E,GAAA,uBAAAA,GAAA,SAAAA,CAEA,IAAAoL,GAAApL,GAAA,SACA,KAAAnS,GAAAmS,EAAAqU,GAAA,CAEA,IAAA/S,EAAA,SAEAf,IAAAP,EAAAqU,IAAAtP,GAEK,UAAA/E,EAAAqU,GAEL,QAAAO,GAAA5T,EAAA7e,GAEA,GAAAuyB,GAAAt2B,EAAAu2B,EAAAxyB,EACA,SAAA/D,EAAA,MAAA4iB,GAAAsT,GAAAl2B,EAEA,KAAAs2B,EAAA1T,EAAAyT,GAA4BC,EAAOA,IAAAxxB,EACnC,GAAAwxB,EAAAtD,GAAAjvB,EAAA,MAAAuyB,GAGA,QAAA5B,GAAA9R,EAAA7e,EAAAiB,GACA,GACAyxB,GAAAz2B,EADAs2B,EAAAE,EAAA5T,EAAA7e,EAmBK,OAhBLuyB,KAAAj1B,EAAA2D,GAGA4d,EAAAwT,GAAAE,GACAhZ,EAAAtd,EAAAu2B,EAAAxyB,GAAA,GACAivB,EAAAjvB,EACA1C,EAAA2D,EACAyE,EAAAgtB,EAAA7T,EAAAwT,GACAtxB,EAAAuF,EACAvJ,GAAA,GAEA8hB,EAAAyT,KAAAzT,EAAAyT,GAAAC,GACAG,MAAA3xB,EAAAwxB,GACA1T,EAAAuT,KAEA,KAAAn2B,IAAA4iB,EAAAsT,GAAAl2B,GAAAs2B,IACK1T,EAuEL,QAAA8T,GAAA9T,EAAA7e,EAAAiB,GAKK,MAJLgoB,IAAAtJ,EAAA3f,IAAA4yB,EAAA/T,GAAAvR,IAAAtN,EAAAiB,IAEAyK,GAAA1L,EAAA6yB,IAAAzU,GAAApe,EAAA6yB,MACA7yB,EAAA6yB,GAAAhU,EAAAqT,IAAAjxB,GACK4d,EAEL,QAAA+T,GAAA/T,GACA,MAAAA,GAAAiU,IAAA1U,GAAAS,EAAAiU,EAAA,GAAA9K,KAAA8K,GAhOA,GAAAZ,GAAA9O,GAAA,OACA+O,EAAA/O,GAAA,MACAyP,EAAAzP,GAAA,QACA0P,EAAA1P,GAAA,QACAiP,EAAAjP,GAAA,QACAkP,EAAAlP,GAAA,SACAgP,EAAAzP,GAAAS,GAAA,eACAR,EAAA,EACAkI,KA4IAiI,GAGAC,MAAA,WACA,OAAAnU,GAAAvjB,KAAA0f,EAAA6D,EAAAsT,GAAAI,EAAA1T,EAAAyT,GAAgEC,EAAOA,IAAAxxB,EACvEwxB,EAAAx1B,GAAA,EACAw1B,EAAA7sB,IAAA6sB,EAAA7sB,EAAA6sB,EAAA7sB,EAAA3E,EAAAuF,SACA0U,GAAAuX,EAAAhZ,EAEAsF,GAAAyT,GAAAzT,EAAAwT,GAAA/rB,EACAuY,EAAAuT,GAAA,GAIAa,SAAA,SAAAjzB,GACA,GAAA6e,GAAAvjB,KACAi3B,EAAAE,EAAA5T,EAAA7e,EACA,IAAAuyB,EAAA,CACA,GAAA/Z,GAAA+Z,EAAAxxB,EACA2xB,EAAAH,EAAA7sB,QACAmZ,GAAAsT,GAAAI,EAAAhZ,GACAgZ,EAAAx1B,GAAA,EACA21B,MAAA3xB,EAAAyX,GACAA,MAAA9S,EAAAgtB,GACA7T,EAAAyT,IAAAC,IAAA1T,EAAAyT,GAAA9Z,GACAqG,EAAAwT,IAAAE,IAAA1T,EAAAwT,GAAAK,GACA7T,EAAAuT,KACO,QAAAG,GAIPnnB,QAAA,SAAAoV,GAGA,IAFA,GACA+R,GADAh0B,EAAA4Z,EAAAqI,EAAAnlB,UAAA,MAEAk3B,MAAAxxB,EAAAzF,KAAAg3B,IAGA,IAFA/zB,EAAAg0B,EAAAj1B,EAAAi1B,EAAAtD,EAAA3zB,MAEAi3B,KAAAx1B,GAAAw1B,IAAA7sB,GAKAgG,IAAA,SAAA1L,GACA,QAAAyyB,EAAAn3B,KAAA0E,IAKAgoB,IAAAyJ,EAAAzJ,GAAAb,IAEA5b,IAAA,SAAAvL,GACA,GAAAuyB,GAAAE,EAAAn3B,KAAA0E,EACA,OAAAuyB,MAAAj1B,GAGAgQ,IAAA,SAAAtN,EAAAiB,GACA,MAAA0vB,GAAAr1B,KAAA,IAAA0E,EAAA,EAAAA,EAAAiB,KAEG8xB,GAAA,GAGH9K,GAAAwJ,EAAAxJ,GAAAb,IAEAze,IAAA,SAAA1H,GACA,MAAA0vB,GAAAr1B,KAAA2F,EAAA,IAAAA,EAAA,EAAAA,OAEG8xB,EAaH,IAAAG,IAGAD,SAAA,SAAAjzB,GACA,MAAAkZ,GAAAlZ,GACAipB,GAAAjpB,GAAA4yB,EAAAt3B,MAAA,UAAA0E,GACA0L,GAAA1L,EAAA6yB,IAAAnnB,GAAA1L,EAAA6yB,GAAAv3B,KAAA42B,WAAAlyB,GAAA6yB,GAAAv3B,KAAA42B,KAFA,GAMAxmB,IAAA,SAAA1L,GACA,MAAAkZ,GAAAlZ,GACAipB,GAAAjpB,GAAA4yB,EAAAt3B,MAAAoQ,IAAA1L,GACA0L,GAAA1L,EAAA6yB,IAAAnnB,GAAA1L,EAAA6yB,GAAAv3B,KAAA42B,KAFA,GAOAhK,IAAAuJ,EAAAvJ,GAAAb,IAEA9b,IAAA,SAAAvL,GACA,GAAAkZ,EAAAlZ,GAAA,CACA,GAAAipB,GAAAjpB,GAAA,MAAA4yB,GAAAt3B,MAAAiQ,IAAAvL,EACA,IAAA0L,GAAA1L,EAAA6yB,GAAA,MAAA7yB,GAAA6yB,GAAAv3B,KAAA42B,MAIA5kB,IAAA,SAAAtN,EAAAiB,GACA,MAAA0xB,GAAAr3B,KAAA0E,EAAAiB,KAEGiyB,GAAA,MAGHtV,GAAA,OAAAsK,KAAA5a,IAAA5M,GAAAyyB,OAAArI,GAAA,GAAAvf,IAAAuf,IACA1f,GAAApP,KAAAgkB,EAAA,+BAAAhgB,GACA,GAAAuM,GAAA2b,GAAAhK,IAAAle,EACAkoB,IAAAhK,IAAAle,GAAA,SAAAlC,EAAAC,GAEA,GAAAmb,EAAApb,IAAAmrB,GAAAnrB,GAAA,CACA,GAAAgB,GAAA8zB,EAAAt3B,MAAA0E,GAAAlC,EAAAC,EACA,cAAAiC,EAAA1E,KAAAwD,EAES,MAAAyN,GAAAvQ,KAAAV,KAAAwC,EAAAC,MAMToqB,GAAAsJ,EAAAtJ,GAAAb,IAEA3e,IAAA,SAAA1H,GACA,MAAA0xB,GAAAr3B,KAAA2F,GAAA,KAEGiyB,GAAA,UAOH,WACA,QAAAE,GAAApE,GACA,GAAAhvB,GAAA6M,IACA,KAAA7M,IAAAgvB,GAAAniB,EAAAiC,KAAA9O,EACAsN,IAAAhS,KAAAmuB,IAAqB4B,EAAA2D,EAAAlxB,EAAA+O,EAAA0M,EAAA,IAYrB,QAAAjH,GAAArU,GACA,gBAAA4f,GACA8B,EAAA9B,EACA,KACA,MAAA5f,GAAA1B,MAAA+J,EAAAjL,YAAA,EACO,MAAAwB,GACP,WAKA,QAAAw2B,GAAAnnB,EAAAonB,GACA,GACA9Z,GADA+Z,EAAAl4B,UAAA+C,OAAA,EAAA8N,EAAA7Q,UAAA,GACAm4B,EAAA5K,GAAAjJ,EAAAzT,GAAAonB,EACA,OAAAE,GAAA9nB,GAAA8nB,EAAA,SACAA,EAAAvyB,MACAuyB,EAAAjoB,MAAAjF,EACAA,EACAktB,EAAAjoB,IAAAvP,KAAAu3B,GACAra,EAAAM,EAAA+K,GAAArY,IACAmnB,EAAA7Z,EAAA8Z,EAAAC,GACAjtB,EAEA,QAAAmtB,GAAAvnB,EAAAonB,EAAAI,GACA,GAEAC,GAAAna,EAFA+Z,EAAAl4B,UAAA+C,OAAA,EAAA8N,EAAA7Q,UAAA,GACAu4B,EAAAhL,GAAAjJ,EAAAzT,GAAAonB,EAEA,KAAAM,EAAA,CACA,GAAA1a,EAAAM,EAAA+K,GAAArY,IACA,MAAAunB,GAAAja,EAAA8Z,EAAAI,EAAAH,EAEAK,GAAAxR,EAAA,GAEA,MAAA1W,IAAAkoB,EAAA,SACAA,EAAApR,YAAA,GAAAtJ,EAAAqa,IACAI,EAAA/K,GAAA2K,EAAAD,IAAAlR,EAAA,GACAuR,EAAA1yB,MAAAyyB,EACAhX,GAAA6W,EAAAD,EAAAK,IAAA,IAHA,EAKAC,EAAAtmB,MAAAhH,GACA,GACAstB,EAAAtmB,IAAAtR,KAAAu3B,EAAAG,IAAA,GAnDA1P,EAAAoP,EAAAxM,EAAA,WACA,GAEA5mB,GAFAqkB,EAAA/oB,KAAAmuB,IACA5c,EAAAwX,EAAAvmB,CAEA,GACA,IAAAumB,EAAA9K,GAAA1M,EAAAzO,OAAA,MAAAinB,GAAA,YACKrlB,EAAA6M,EAAAwX,EAAA9K,OAAA8K,GAAAgH,GACL,OAAAhG,GAAA,EAAArlB,IA8CA,IAAA6zB,GAAAnzB,GAAAmzB,cAAArU,EAEAsU,GAEAv3B,MAAA4b,EAAAnc,GAAAO,GAAA,GAEAwb,YAEA2E,eAAApK,EAAAoK,IAEAqX,eAAA,SAAA7nB,EAAAonB,GACA,GAAAE,GAAA5K,GAAAjJ,EAAAzT,GAAAonB,EACA,OAAAE,OAAAjR,cAAA,QAAArW,GAAAonB,IAGAU,UAAA,SAAA9nB,GACA,UAAAknB,GAAAzT,EAAAzT,KAGAX,IAAA8nB,EAEAvK,yBAAA,SAAA5c,EAAAonB,GACA,MAAA1K,IAAAjJ,EAAAzT,GAAAonB,IAGA/O,eAAA,SAAArY,GACA,MAAAqY,IAAA5E,EAAAzT,KAGAR,IAAA,SAAAQ,EAAAonB,GACA,MAAAA,KAAApnB,IAGA2nB,aAAA,SAAA3nB,GACA,QAAA2nB,EAAAlU,EAAAzT,KAGAwT,UAEAuU,kBAAA3hB,EAAA5R,GAAAuzB,mBAAAzU,GAEAlS,IAAAmmB,EAGA9K,MAAAmL,EAAAnL,eAAA,SAAAzc,EAAAsN,GACA,MAAAmP,IAAAhJ,EAAAzT,GAAAsN,IAAA,IAGAyL,EAAAmB,IAAmB8N,aACnBjP,EAAAoB,GAAA,UAAAyN,OAOA,WAUA,QAAAK,GAAAC,GACA,gBAAA3e,GACA,GAKAzV,GALAue,EAAAc,EAAA5J,GACA5I,EAAAkT,GAAAtK,GACArX,EAAAyO,EAAAzO,OACAmb,EAAA,EACAza,EAAAjD,GAAAuC,EAEA,IAAAg2B,EAAA,KAAAh2B,EAAAmb,GAAAza,EAAAya,IAAAvZ,EAAA6M,EAAA0M,KAAAgF,EAAAve,QACA,MAAA5B,EAAAmb,GAAAza,EAAAya,GAAAgF,EAAA1R,EAAA0M,KACA,OAAAza,IAnBAmmB,EAAAC,GAAA4B,IAEAwH,SAAA3N,GAAA,KAEAsE,EAAAC,GAAA6B,IAEAgI,GAAApN,GAAA,KAgBAsD,EAAAoB,GAAAO,GAEAzU,OAAAgiB,GAAA,GACArP,QAAAqP,GAAA,KAEAlP,EAAAoB,GAAAY,IAEAoN,OAAA9S,EAAA,2BAAuC,iBASvC,SAAA+S,GAaA,QAAAC,GAAApS,GACA,GAAAA,EAAA,CACA,GAAAqS,GAAArS,EAAAjE,GACAE,IAAAoW,EAAA7N,EAAA6N,EAAAjpB,KACA6S,GAAAoW,EAAAC,EAAAD,EAAAlnB,KACA8Q,GAAAoW,EAAAE,EAAAF,EAAA,YAjBA7N,EAAA1D,EAAAqR,EAAA,SACA,IAAAG,GAAAxR,EAAAqR,EAAAlN,IAAA,GACAsN,EAAAzR,EAAAqR,EAAA,YAEArP,GAAAoB,GAAAxD,IACA8R,aAAAhO,EACAiO,aAAAH,EACAI,gBAAAH,IAGAtW,GAAAsK,GAAA/B,EAAAlH,GAUA8U,EAAAvM,IACAuM,EAAArM,KACC,cAOD,SAAA4M,GACA,QAAAC,GAAAloB,EAAAzO,GACAgN,GAAApP,KAAAgkB,EAAAnT,GAAA,SAAA7M,GACAA,IAAAyoB,MAAAqM,EAAA90B,GAAAmY,EAAAnc,GAAAysB,GAAAzoB,GAAA5B,MAGA22B,EAAA,2CACAA,EAAA,mEACAA,EAAA,kGAEA9P,EAAAoB,GAAAS,GAAAgO,SAOA,SAAAE,IACApX,IAAAoX,GAAAnR,KAAAmR,GAAA9W,KACAE,GAAA4W,EAAA9W,IAAA2F,GAAAW,GAAAsC,KAEAtC,GAAAwQ,SAAAxQ,GAAAsC,KACC1T,EAAA4hB,WACA,mBAAAvU,YAAApgB,YAAAogB,KAAAnkB,SAAA,sBT4wNK24B,GACA,SAASj7B,EAAQC,IUhoRvB,SAAAmZ,IAUA,SAAAA,GACA,YAwBA,SAAAd,GAAA4iB,EAAAC,EAAA1U,EAAA2U,GACA,UAAAC,GAAAH,EAAAC,EAAA1U,GAAA,KAAA2U,OAcA,QAAAE,GAAAr3B,EAAA8B,EAAAoF,GACA,IACA,OAAckB,KAAA,SAAAlB,IAAAlH,EAAAjC,KAAA+D,EAAAoF,IACT,MAAAuT,GACL,OAAcrS,KAAA,QAAAlB,IAAAuT,IAiBd,QAAA6c,MACA,QAAAC,MAgDA,QAAAH,GAAAH,EAAAC,EAAA1U,EAAA2U,GAKA,QAAArW,GAAAxS,EAAApH,GACA,GAAA2rB,IAAA2E,EACA,SAAA/xB,OAAA,+BAGA,IAAAotB,IAAA4E,EAGA,MAAAC,IAGA,SACA,GAAAC,GAAAh0B,EAAAg0B,QACA,IAAAA,EAAA,CACA,GAAAC,GAAAP,EACAM,EAAA5P,SAAAzZ,GACAqpB,EAAA5P,SACA7gB,EAGA,cAAA0wB,EAAAxvB,KAAA,CACAzE,EAAAg0B,SAAA,KAIArpB,EAAA,QACApH,EAAA0wB,EAAA1wB,GAEA,UAMAoH,EAAA,OACApH,EAAAmB,CAEA,IAAAwvB,GAAAD,EAAA1wB,GACA,KAAA2wB,EAAAnd,KAKA,MADAmY,GAAAiF,EACAD,CAJAl0B,GAAAg0B,EAAAI,YAAAF,EAAA70B,MACAW,EAAA4W,KAAAod,EAAAK,QAMAr0B,EAAAg0B,SAAA,KAGA,YAAArpB,EAAA,CACA,GAAAukB,IAAAoF,GACA,mBAAA/wB,GAEA,SAAA1D,WACA,mBAAAlE,KAAAC,UAAA2H,GAAA,wBAIA2rB,KAAAiF,EACAn0B,EAAAu0B,KAAAhxB,QAEAvD,GAAAu0B,SAGS,cAAA5pB,EAAA,CACT,GAAAukB,IAAAoF,EAEA,KADApF,GAAA4E,EACAvwB,CAGAvD,GAAAw0B,kBAAAjxB,KAGAoH,EAAA,OACApH,EAAAmB,OAGS,WAAAiG,GACT3K,EAAAy0B,OAAA,SAAAlxB,EAGA2rB,GAAA2E,CAEA,IAAAI,GAAAP,EAAAJ,EAAAzU,EAAA7e,EACA,eAAAi0B,EAAAxvB,KAAA,CAGAyqB,EAAAlvB,EAAA+W,KACA+c,EACAK,CAEA,IAAAD,IACA70B,MAAA40B,EAAA1wB,IACAwT,KAAA/W,EAAA+W,KAGA,IAAAkd,EAAA1wB,MAAAmxB,EAOA,MAAAR,EANAl0B,GAAAg0B,UAAA,SAAArpB,IAGApH,EAAAmB,OAMS,UAAAuvB,EAAAxvB,OACTyqB,EAAA4E,EAEA,SAAAnpB,EACA3K,EAAAw0B,kBAAAP,EAAA1wB,KAEAA,EAAA0wB,EAAA1wB,MApHA,GAAAoxB,GAAApB,EAAAz0B,OAAAye,OAAAgW,EAAAr5B,WAAAR,KACAsG,EAAA,GAAA0b,GAAA8X,GACAtE,EAAAoF,CA4HA,OAJAK,GAAA/d,KAAAuG,EAAA7V,KAAAqtB,EAAA,QACAA,EAAA,SAAAxX,EAAA7V,KAAAqtB,EAAA,SACAA,EAAA,UAAAxX,EAAA7V,KAAAqtB,EAAA,UAEAA,EAWA,QAAAC,GAAAC,GACA,GAAAlE,IAAiBmE,OAAAD,EAAA,GAEjB,KAAAA,KACAlE,EAAAoE,SAAAF,EAAA,IAGA,IAAAA,KACAlE,EAAAqE,WAAAH,EAAA,GACAlE,EAAAsE,SAAAJ,EAAA,IAGAn7B,KAAAw7B,WAAAhoB,KAAAyjB,GAGA,QAAAwE,GAAAxE,GACA,GAAAsD,GAAAtD,EAAAyE,cACAnB,GAAAxvB,KAAA,eACAwvB,GAAA1wB,IACAotB,EAAAyE,WAAAnB,EAGA,QAAAvY,GAAA8X,GAIA95B,KAAAw7B,aAAwBJ,OAAA,SACxBtB,EAAAhqB,QAAAorB,EAAAl7B,MACAA,KAAA27B,QA8BA,QAAA9kB,GAAA2T,GACA,GAAAA,EAAA,CACA,GAAAoR,GAAApR,EAAAqR,EACA,IAAAD,EACA,MAAAA,GAAAl7B,KAAA8pB,EAGA,sBAAAA,GAAAtN,KACA,MAAAsN,EAGA,KAAA1E,MAAA0E,EAAA1nB,QAAA,CACA,GAAAmb,GAAA,GAAAf,EAAA,QAAAA,KACA,OAAAe,EAAAuM,EAAA1nB,QACA,GAAAg5B,EAAAp7B,KAAA8pB,EAAAvM,GAGA,MAFAf,GAAAvX,MAAA6kB,EAAAvM,GACAf,EAAAG,MAAA,EACAH,CAOA,OAHAA,GAAAvX,MAAAqF,EACAkS,EAAAG,MAAA,EAEAH,EAGA,OAAAA,WAKA,OAAYA,KAAAmd,GAIZ,QAAAA,KACA,OAAY10B,MAAAqF,EAAAqS,MAAA,GApVZ,GACArS,GADA8wB,EAAA12B,OAAA5E,UAAA2I,eAEA0yB,EACA,kBAAAhU,gBAAA6C,UAAA,aAEAqR,EAAA,gBAAAr9B,GACAs9B,EAAAlkB,EAAAmkB,kBACA,IAAAD,EAQA,YAPAD,IAGAr9B,EAAAC,QAAAq9B,GASAA,GAAAlkB,EAAAmkB,mBAAAF,EAAAr9B,EAAAC,WAKAq9B,EAAAhlB,MAoBA,IAAA4jB,GAAA,iBACAH,EAAA,iBACAN,EAAA,YACAC,EAAA,YAIAY,KASAkB,EAAAhC,EAAA15B,UAAAu5B,EAAAv5B,SACAy5B,GAAAz5B,UAAA07B,EAAA7qB,YAAA6oB,EACAA,EAAA7oB,YAAA4oB,EACAA,EAAA9b,YAAA,oBAEA6d,EAAAxe,oBAAA,SAAA2e,GACA,GAAAC,GAAA,kBAAAD,MAAA9qB,WACA,OAAA+qB,GACAA,IAAAnC,GAGA,uBAAAmC,EAAAje,aAAAie,EAAAv1B,OACA,GAGAm1B,EAAAK,KAAA,SAAAF,GAGA,MAFAA,GAAAvM,UAAAsK,EACAiC,EAAA37B,UAAA4E,OAAAye,OAAAqY,GACAC,GAGAH,EAAAM,MAAA,SAAA1C,EAAAC,EAAA1U,EAAA2U,GACA,UAAAhd,SAAA,SAAAC,EAAAnI,GAKA,QAAA6V,GAAA5gB,GACA,GAAA0wB,GAAAP,EAAAh6B,KAAA,KAAA6J,EACA,cAAA0wB,EAAAxvB,KAEA,WADA6J,GAAA2lB,EAAA1wB,IAIA,IAAA2wB,GAAAD,EAAA1wB,GACA2wB,GAAAnd,KACAN,EAAAyd,EAAA70B,OAEAmX,QAAAC,QAAAyd,EAAA70B,OAAAC,KAAA22B,EAAAC,GAfA,GAAAvB,GAAAjkB,EAAA4iB,EAAAC,EAAA1U,EAAA2U,GACAyC,EAAA9R,EAAA7c,KAAAqtB,EAAA/d,MACAsf,EAAA/R,EAAA7c,KAAAqtB,EAAA,SAiBAsB,QAsIAL,EAAAL,GAAA,WACA,MAAA77B,OAGAk8B,EAAA72B,SAAA,WACA,4BAkCA22B,EAAAzqB,KAAA,SAAA4I,GACA,GAAA5I,KACA,QAAA7M,KAAAyV,GACA5I,EAAAiC,KAAA9O,EAMA,OAJA6M,GAAAjH,UAIA,QAAA4S,KACA,KAAA3L,EAAAzO,QAAA,CACA,GAAA4B,GAAA6M,EAAA8G,KACA,IAAA3T,IAAAyV,GAGA,MAFA+C,GAAAvX,MAAAjB,EACAwY,EAAAG,MAAA,EACAH,EAQA,MADAA,GAAAG,MAAA,EACAH,IAsCA8e,EAAAnlB,SAMAmL,EAAAxhB,WACA6Q,YAAA2Q,EAEA2Z,MAAA,WACA37B,KAAAo3B,KAAA,EACAp3B,KAAAkd,KAAA,EACAld,KAAA66B,KAAA7vB,EACAhL,KAAAqd,MAAA,EACArd,KAAAs6B,SAAA,KAEAt6B,KAAAw7B,WAAA1rB,QAAA2rB,EAIA,QAAAgB,GAAAC,EAAA,EACAZ,EAAAp7B,KAAAV,KAAAy8B,EAAA,IAAAC,IAAA,GAAAA,IACAA,EACA18B,KAAAy8B,GAAA,MAIAE,KAAA,WACA38B,KAAAqd,MAAA,CAEA,IAAAuf,GAAA58B,KAAAw7B,WAAA,GACAqB,EAAAD,EAAAlB,UACA,cAAAmB,EAAA9xB,KACA,KAAA8xB,GAAAhzB,GAGA,OAAA7J,MAAA88B,MAGAhC,kBAAA,SAAA17B,GAMA,QAAA29B,GAAAC,EAAAC,GAIA,MAHA1C,GAAAxvB,KAAA,QACAwvB,EAAA1wB,IAAAzK,EACAkH,EAAA4W,KAAA8f,IACAC,EATA,GAAAj9B,KAAAqd,KACA,KAAAje,EAWA,QARAkH,GAAAtG,KAQAie,EAAAje,KAAAw7B,WAAA14B,OAAA,EAA8Cmb,GAAA,IAAQA,EAAA,CACtD,GAAAgZ,GAAAj3B,KAAAw7B,WAAAvd,GACAsc,EAAAtD,EAAAyE,UAEA,aAAAzE,EAAAmE,OAIA,MAAA2B,GAAA,MAGA,IAAA9F,EAAAmE,QAAAp7B,KAAAo3B,KAAA,CACA,GAAA8F,GAAApB,EAAAp7B,KAAAu2B,EAAA,YACAkG,EAAArB,EAAAp7B,KAAAu2B,EAAA,aAEA,IAAAiG,GAAAC,EAAA,CACA,GAAAn9B,KAAAo3B,KAAAH,EAAAoE,SACA,MAAA0B,GAAA9F,EAAAoE,UAAA,EACa,IAAAr7B,KAAAo3B,KAAAH,EAAAqE,WACb,MAAAyB,GAAA9F,EAAAqE,gBAGW,IAAA4B,GACX,GAAAl9B,KAAAo3B,KAAAH,EAAAoE,SACA,MAAA0B,GAAA9F,EAAAoE,UAAA,OAGW,KAAA8B,EAMX,SAAA/0B,OAAA,yCALA,IAAApI,KAAAo3B,KAAAH,EAAAqE,WACA,MAAAyB,GAAA9F,EAAAqE,gBAUA8B,kBAAA,SAAA9B,GACA,OAAArd,GAAAje,KAAAw7B,WAAA14B,OAAA,EAA8Cmb,GAAA,IAAQA,EAAA,CACtD,GAAAgZ,GAAAj3B,KAAAw7B,WAAAvd,EACA,IAAAgZ,EAAAmE,QAAAp7B,KAAAo3B,MACA0E,EAAAp7B,KAAAu2B,EAAA,gBACAA,EAAAqE,gBACAt7B,KAAAo3B,KAAAH,EAAAqE,YACA,MAAArE,KAKA8D,OAAA,SAAAhwB,EAAAlB,GACA,GAAAotB,GAAAj3B,KAAAo9B,oBACA7C,EAAAtD,IAAAyE,aAWA,OATAnB,GAAAxvB,OACAwvB,EAAA1wB,MAEAotB,EACAj3B,KAAAkd,KAAA+Z,EAAAqE,WAEAt7B,KAAAq9B,SAAA9C,GAGAS,GAGAqC,SAAA,SAAA9C,EAAAgB,GACA,aAAAhB,EAAAxvB,KACA,KAAAwvB,GAAA1wB,GAaA,OAVA,UAAA0wB,EAAAxvB,MACA,aAAAwvB,EAAAxvB,KACA/K,KAAAkd,KAAAqd,EAAA1wB,IACO,WAAA0wB,EAAAxvB,MACP/K,KAAA88B,KAAAvC,EAAA1wB,IACA7J,KAAAkd,KAAA,OACO,WAAAqd,EAAAxvB,MAAAwwB,IACPv7B,KAAAkd,KAAAqe,GAGAP,GAGAsC,OAAA,SAAAhC,GACA,GAAArE,GAAAj3B,KAAAo9B,kBAAA9B,EACA,OAAAt7B,MAAAq9B,SAAApG,EAAAyE,WAAAzE,EAAAsE,WAGAvF,QAAA,SAAAoF,GACA,OAAAnd,GAAAje,KAAAw7B,WAAA14B,OAAA,EAA8Cmb,GAAA,IAAQA,EAAA,CACtD,GAAAgZ,GAAAj3B,KAAAw7B,WAAAvd,EACA,IAAAgZ,EAAAmE,WAAA,CACA,GAAAb,GAAAtD,EAAAyE,UACA,cAAAnB,EAAAxvB,KAAA,CACA,GAAAwyB,GAAAhD,EAAA1wB,GACA4xB,GAAAxE,GAEA,MAAAsG,IAMA,SAAAn1B,OAAA,0BAGAo1B,cAAA,SAAAhT,EAAAkQ,EAAAC,GAOA,MANA36B,MAAAs6B,UACA5P,SAAA7T,EAAA2T,GACAkQ,aACAC,WAGAK,KAOA,gBAAAljB,KACA,gBAAA7Y,eAAAe,QVqoR8BU,KAAK/B,EAAU,WAAa,MAAOqB,WAI3Dy9B,GACA,SAAS/+B,EAAQC,EAASC,GWvpShCF,EAAAC,QAAAC,EAAA,KX8pSM8+B,GACA,SAASh/B,EAAQC,EAASC,IAEH,SAASkZ,GAAS,YAE9C,IAAI6lB,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnFo5B,EAAqB,SAAUC,GAAO,GAAIv9B,MAAM2E,QAAQ44B,GAAM,CAAE,IAAK,GAAI7f,GAAI,EAAG8f,EAAOx9B,MAAMu9B,EAAIh7B,QAASmb,EAAI6f,EAAIh7B,OAAQmb,IAAK8f,EAAK9f,GAAK6f,EAAI7f,EAAI,OAAO8f,GAAe,MAAOx9B,OAAMuE,KAAKg5B,GAE7Ll/B,GYtqSM,GZwqSN,IYvqSM0C,GAAKq8B,EAAA/+B,EAAS,IACdo/B,EAAQL,EAAA/+B,EAAM,IAErBkZ,GAAOmmB,MAAQ38B,EACfwW,EAAOgF,QAAUkhB,EAEjBlhB,QAAQtc,UAAUO,IAAM,WZyqSrB,IAAK,GAAIm9B,GAAOn+B,UAAU+C,OYzqSOhD,EAAIS,MAAA29B,GAAAC,EAAA,EAAAD,EAAAC,MAAJr+B,EAAIq+B,GAAAp+B,UAAAo+B,EACtC,OAAOn+B,MAAKkW,IAAI,SAAAvQ,GZ6qSb,MY7qSsBzG,SAAQ6B,IAAGE,MAAX/B,QAAO2+B,EAAQ/9B,EAAKQ,QAAQqF,WZgrSzBjF,KAAK/B,EAAU,WAAa,MAAOqB,WAI3Do+B,GACA,SAAS1/B,EAAQC,EAASC,Ia9rShC,SAAA4f,EAAA1G;;;;;;;;;;;;;;;;;;;;;;;;CA4BA,SAAAvW,GAAa7C,EAAAC,QAAA4C,KAA2Q,WAAY,GAAA2rB,GAAAxuB,EAAAC,CAA0B,gBAAA4C,GAAA88B,EAAA54B,EAAAhE,GAA0B,QAAA8kB,GAAAwJ,EAAAuO,GAAgB,IAAA74B,EAAAsqB,GAAA,CAAU,IAAAsO,EAAAtO,GAAA,CAAU,GAAAvtB,GAAA,kBAAA+7B,iBAA0C,KAAAD,GAAA97B,EAAA,MAAAA,GAAAutB,GAAA,EAAwB,IAAA9R,EAAA,MAAAA,GAAA8R,GAAA,EAAoB,IAAA9sB,GAAA,GAAAmF,OAAA,uBAAA2nB,EAAA,IAA8C,MAAA9sB,GAAAsvB,KAAA,mBAAAtvB,EAAkC,GAAAujB,GAAA/gB,EAAAsqB,IAAYpxB,WAAY0/B,GAAAtO,GAAA,GAAArvB,KAAA8lB,EAAA7nB,QAAA,SAAA4C,GAAmC,GAAAkE,GAAA44B,EAAAtO,GAAA,GAAAxuB,EAAiB,OAAAglB,GAAA9gB,IAAAlE,IAAgBilB,IAAA7nB,QAAA4C,EAAA88B,EAAA54B,EAAAhE,GAAsB,MAAAgE,GAAAsqB,GAAApxB,QAA8D,OAA1Csf,GAAA,kBAAAsgB,kBAA0CxO,EAAA,EAAYA,EAAAtuB,EAAAqB,OAAWitB,IAAAxJ,EAAA9kB,EAAAsuB,GAAY,OAAAxJ,KAAYiY,GAAA,SAAAD,EAAA7/B,GACjwB,YACAA,GAAAC,QAAA,SAAAme,GAEA,QAAAtP,GAAAwQ,GACA,GAAA3B,GAAA,GAAAoiB,GAAAzgB,GACAD,EAAA1B,EAAA0B,SAIA,OAHA1B,GAAAqiB,WAAA,GACAriB,EAAAsiB,YACAtiB,EAAA7B,OACAuD,EAPA,GAAA0gB,GAAA3hB,EAAA8hB,iBAUA9hB,GAAAtP,IAAA,SAAAwQ,GACA,MAAAxQ,GAAAwQ,IAGAlB,EAAAtc,UAAAgN,IAAA,WACA,MAAAA,GAAAxN,aAKI6+B,GAAA,SAAAN,EAAA7/B,GACJ,YAOA,SAAAogC,KACA9+B,KAAA++B,aAAA,EACA/+B,KAAAg/B,WAAA,GAAAC,GAAA,IACAj/B,KAAAk/B,aAAA,GAAAD,GAAA,GACA,IAAA9Z,GAAAnlB,IACAA,MAAAm/B,YAAA,WACAha,EAAAia,gBAEAp/B,KAAAq/B,UACAC,EAAAnZ,SAAAmZ,EAAAt/B,KAAAm/B,aAAAG,EAfA,GAAAC,EACA,KAAK,SAAAn3B,OAAoB,MAAA7G,GAAYg+B,EAAAh+B,EACrC,GAAA+9B,GAAAf,EAAA,iBACAU,EAAAV,EAAA,cACAiB,EAAA,mBAAAhhB,KAAAxT,MAcA8zB,GAAAt+B,UAAAi/B,gBAAA,WACA,MAAAz/B,MAAAk/B,aAAAp8B,SAAA,GAGAg8B,EAAAt+B,UAAAk/B,YAAA,SAAA/8B,GAMA,MALAqI,UAAAw0B,GACA,MAAAA,EAAAG,QACAh9B,EAAAg9B,SACAh9B,EAAA68B,EAAAG,OAAA/xB,KAAAjL,IAEAA,GAGAm8B,EAAAt+B,UAAAo/B,WAAA,SAAAj9B,EAAAkH,GAMA,GALA,IAAA9J,UAAA+C,SACA+G,EAAAlH,EACAA,EAAA,WAA0B,KAAAkH,KAE1BlH,EAAA3C,KAAA0/B,YAAA/8B,GACA,mBAAAkd,YACAA,WAAA,WACAld,EAAAkH,IACS,OACJ,KACL7J,KAAAq/B,UAAA,WACA18B,EAAAkH,KAEK,MAAAtI,GACL,SAAA6G,OAAA,oEAIA02B,EAAAt+B,UAAAq/B,YAAA,SAAAl9B,EAAAs1B,EAAApuB,GACAlH,EAAA3C,KAAA0/B,YAAA/8B,GACA3C,KAAAg/B,WAAAxrB,KAAA7Q,EAAAs1B,EAAApuB,GACA7J,KAAA8/B,cAGAhB,EAAAt+B,UAAAu/B,YAAA,SAAAp9B,EAAAs1B,EAAApuB,GACAlH,EAAA3C,KAAA0/B,YAAA/8B,GACA3C,KAAAk/B,aAAApR,QAAAnrB,EAAAs1B,EAAApuB,GACA7J,KAAA8/B,cAGAhB,EAAAt+B,UAAAijB,OAAA,SAAA9gB,EAAAs1B,EAAApuB,GACAlH,EAAA3C,KAAA0/B,YAAA/8B,GACA3C,KAAAk/B,aAAA1rB,KAAA7Q,EAAAs1B,EAAApuB,GACA7J,KAAA8/B,cAGAhB,EAAAt+B,UAAAw/B,eAAA,SAAAjiB,GACA/d,KAAAk/B,aAAAe,SAAAliB,GACA/d,KAAA8/B,cAGAhB,EAAAt+B,UAAA0/B,YAAA,SAAAjhB,GACA,KAAAA,EAAAnc,SAAA,IACA,GAAAH,GAAAsc,EAAAW,OACA,sBAAAjd,GAAA,CAIA,GAAAs1B,GAAAhZ,EAAAW,QACA/V,EAAAoV,EAAAW,OACAjd,GAAAjC,KAAAu3B,EAAApuB,OALAlH,GAAAw9B,oBASArB,EAAAt+B,UAAA4+B,aAAA,WACAp/B,KAAAkgC,YAAAlgC,KAAAk/B,cACAl/B,KAAAogC,SACApgC,KAAAkgC,YAAAlgC,KAAAg/B,aAGAF,EAAAt+B,UAAAs/B,WAAA,WACA9/B,KAAA++B,cACA/+B,KAAA++B,aAAA,EACA/+B,KAAAq/B,UAAAr/B,KAAAm/B,eAIAL,EAAAt+B,UAAA4/B,OAAA,WACApgC,KAAA++B,aAAA,GAGArgC,EAAAC,QAAA,GAAAmgC,GACApgC,EAAAC,QAAA4gC,mBAEGc,aAAA,GAAAC,gBAAA,KAAmCC,GAAA,SAAAhC,EAAA7/B,GACtC,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,EAAAC,GACA,GAAAC,GAAA,SAAAtd,EAAA7hB,GACAvB,KAAA2gC,QAAAp/B,IAGAq/B,EAAA,SAAAr/B,EAAA+E,GACAA,EAAAu6B,wBAAA,EACAv6B,EAAAw6B,eAAAC,MAAAL,IAAA,KAAA1gC,KAAAuB,IAGAy/B,EAAA,SAAAC,EAAA36B,GACAtG,KAAAkhC,YAAAD,GACAjhC,KAAAmhC,cACAnhC,KAAAohC,iBAAA96B,EAAAsK,SAIAywB,EAAA,SAAA9/B,EAAA+E,GACAA,EAAAu6B,wBAAA7gC,KAAA2gC,QAAAp/B,GAGAub,GAAAtc,UAAAoN,KAAA,SAAAqzB,GACA,GAAAK,GAAAb,EAAAQ,GACA5kB,EAAA,GAAAS,GAAA0jB,EACAnkB,GAAAklB,eAAAvhC,KAAA,EACA,IAAA4Q,GAAA5Q,KAAAwhC,SACA,IAAAF,YAAAxkB,GAAA,CACA,GAAAxW,IACAu6B,wBAAA,EACA9iB,QAAA1B,EACAzL,SACAkwB,eAAAQ,EAEA1wB,GAAAmwB,MAAAP,EAAAI,EAAAvkB,EAAAolB,UAAAplB,EAAA/V,GACAg7B,EAAAP,MACAC,EAAAK,EAAAhlB,EAAAolB,UAAAplB,EAAA/V,OAEA+V,GAAA6kB,YAAAD,GACA5kB,EAAA+kB,iBAAAxwB,EAEA,OAAAyL,IAGAS,EAAAtc,UAAA0gC,YAAA,SAAAz8B,GACAuG,SAAAvG,GACAzE,KAAA0hC,UAAA,OAAA1hC,KAAA0hC,UACA1hC,KAAA2hC,SAAAl9B,GAEAzE,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,WAIA5kB,EAAAtc,UAAAohC,SAAA,WACA,wBAAA5hC,KAAA0hC,YAGA5kB,EAAAlP,KAAA,SAAAqzB,EAAAt7B,GACA,GAAA27B,GAAAb,EAAAQ,GACA5kB,EAAA,GAAAS,GAAA0jB,EAWA,OATAc,aAAAxkB,GACAwkB,EAAAP,MAAA,SAAAE,GACA5kB,EAAA6kB,YAAAD,GACA5kB,EAAA+kB,iBAAAz7B,IACS0W,EAAAskB,QAAAtkB,EAAAolB,UAAAplB,EAAA,OAETA,EAAA6kB,YAAAD,GACA5kB,EAAA+kB,iBAAAz7B,IAEA0W,SAIIwlB,GAAA,SAAAtD,EAAA7/B,GACJ,YAGA,SAAA+vB,KACA,IAAS3R,UAAAglB,IAAAhlB,QAAAyR,GACT,MAAAhtB,IACA,MAAAugC,GALA,GAAAvT,EACA,oBAAAzR,WAAAyR,EAAAzR,QAMA,IAAAglB,GAAAvD,EAAA,iBACAuD,GAAArT,aACA/vB,EAAAC,QAAAmjC,IAEGC,eAAA,KAAkBtjC,GAAA,SAAA8/B,EAAA7/B,GACrB,YACA,IAAAsjC,GAAA58B,OAAAye,MACA,IAAAme,EAAA,CACA,GAAAC,GAAAD,EAAA,MACAE,EAAAF,EAAA,KACAC,GAAA,SAAAC,EAAA,WAGAxjC,EAAAC,QAAA,SAAAme,GA4DA,QAAAqlB,GAAA19B,EAAAkI,GACA,GAAAhK,EAEA,IADA,MAAA8B,IAAA9B,EAAA8B,EAAAkI,IACA,kBAAAhK,GAAA,CACA,GAAAy/B,GAAA,UAAAC,EAAAC,YAAA79B,GAAA,mBACA49B,EAAAh9B,SAAAsH,GAAA,GACA,UAAAmQ,GAAA3W,UAAAi8B,GAEA,MAAAz/B,GAGA,QAAA4/B,GAAA99B,GACA,GAAAkI,GAAA3M,KAAAqY,MACA1V,EAAAw/B,EAAA19B,EAAAkI,EACA,OAAAhK,GAAA1B,MAAAwD,EAAAzE,MAiBA,QAAAwiC,GAAA/9B,GACA,MAAAA,GAAAzE,MAEA,QAAAyiC,GAAAh+B,GACA,GAAA9D,IAAAX,IAEA,OADA,GAAAW,MAAAoE,KAAAC,IAAA,EAAArE,EAAA8D,EAAA3B,SACA2B,EAAA9D,GAhGA,IAKA+hC,GALAL,EAAA9D,EAAA,aACAoE,EAAAN,EAAAM,WACAN,GAAAO,aAyEA9lB,EAAAtc,UAAAE,KAAA,SAAAiM,GACiE,OAAjEk2B,GAAA9iC,UAAA+C,OAAiChD,EAAA,GAAAS,OAAAsiC,EAAA,GAAgCC,EAAA,EAAiBD,EAAAC,IAAaA,EAAShjC,EAAAgjC,EAAA,GAAA/iC,UAAA+iC,EAWxG,OADAhjC,GAAA0T,KAAA7G,GACA3M,KAAA+gC,MAAAwB,EAAAv3B,cAAAlL,EAAAkL,SAWA8R,EAAAtc,UAAAyP,IAAA,SAAA8yB,GACA,GACAC,GADAC,EAAA,gBAAAF,EAEA,IAAAE,EAQAD,EAAAP,MAPA,IAAAE,EAAA,CACA,GAAAO,GAAAR,EAAAK,EACAC,GAAA,OAAAE,IAAAV,MAEAQ,GAAAR,CAKA,OAAAxiC,MAAA+gC,MAAAiC,EAAAh4B,cAAA+3B,EAAA/3B,YAIGm4B,YAAA,KAAeC,GAAA,SAAA7E,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,GACA,GAAAumB,GAAA9E,EAAA,eACAjC,EAAAiC,EAAA,cACA+E,EAAAD,EAAAC,iBAEAxmB,GAAAtc,UAAA+iC,QAAA,SAAAC,GACA,IAAAxjC,KAAAyjC,gBAAA,MAAAzjC,KAGA,KAFA,GAAA0jC,GACAC,EAAA3jC,KACAgL,UAAA04B,EAAAC,EAAAC,sBACAF,EAAAD,iBACAE,EAAAD,CAEA1jC,MAAA6jC,oBACAF,EAAAnC,UAAAsC,gBAAAN,GAAA,OAGA1mB,EAAAtc,UAAAujC,OAAA,SAAAP,GACA,MAAAxjC,MAAAyjC,iBACAz4B,SAAAw4B,MAAA,GAAAF,IACAhH,EAAAuD,YAAA7/B,KAAAujC,QAAAvjC,KAAAwjC,GACAxjC,MAHAA,MAMA8c,EAAAtc,UAAAwjC,YAAA,WACA,MAAAhkC,MAAAikC,eAAAjkC,MACAA,KAAAkkC,kBACAlkC,KAAA4jC,oBAAA54B,OACAhL,OAGA8c,EAAAtc,UAAA2jC,cAAA,WACA,GAAA9nB,GAAArc,KAAA4F,MAEA,OADAyW,GAAAwnB,oBACAxnB,GAGAS,EAAAtc,UAAA4jC,KAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAloB,GAAArc,KAAA+gC,MAAAsD,EAAAC,EAAAC,EACAv5B,cAIA,OAFAqR,GAAA6nB,kBACA7nB,EAAAunB,oBAAA54B,OACAqR,MAIGmoB,aAAA,EAAAC,cAAA,KAAgCC,GAAA,SAAAnG,EAAA7/B,GACnC,YACAA,GAAAC,QAAA,WAUA,QAAAgmC,GAAAjB,GACA1jC,KAAA4kC,QAAAlB,CACA,IAAA5gC,GAAA9C,KAAAwjB,QAAA,GAAAxY,SAAA04B,EAAA,EAAAA,EAAAlgB,QACAqhB,GAAA7kC,KAAA2kC,GACA7hC,EAAA,IAAA9C,KAAA8kC,UA8EA,QAAAC,GAAA3C,EAAA4C,GACA,OAAA/mB,GAAA,EAAmBA,EAAA+mB,EAAAliC,OAAA,IAAuBmb,EAC1C+mB,EAAA/mB,GAAAzK,KAAA,wBACAwxB,EAAA/mB,GAAA+mB,EAAA/mB,GAAA3M,KAAA,KAKA,OAHA2M,GAAA+mB,EAAAliC,SACAkiC,EAAA/mB,GAAA+mB,EAAA/mB,GAAA3M,KAAA,OAEA8wB,EAAA,KAAA4C,EAAA1zB,KAAA,MAGA,QAAA2zB,GAAAD,GACA,OAAA/mB,GAAA,EAAmBA,EAAA+mB,EAAAliC,SAAmBmb,GACtC,IAAA+mB,EAAA/mB,GAAAnb,QACAmb,EAAA,EAAA+mB,EAAAliC,QAAAkiC,EAAA/mB,GAAA,KAAA+mB,EAAA/mB,EAAA,SACA+mB,EAAAlkC,OAAAmd,EAAA,GACAA,KAKA,QAAAinB,GAAAF,GAEA,OADA5rB,GAAA4rB,EAAA,GACA/mB,EAAA,EAAmBA,EAAA+mB,EAAAliC,SAAmBmb,EAAA,CAMtC,OALAmZ,GAAA4N,EAAA/mB,GACAknB,EAAA/rB,EAAAtW,OAAA,EACAsiC,EAAAhsB,EAAA+rB,GACAE,EAAA,GAEAtjC,EAAAq1B,EAAAt0B,OAAA,EAAqCf,GAAA,IAAQA,EAC7C,GAAAq1B,EAAAr1B,KAAAqjC,EAAA,CACAC,EAAAtjC,CACA,OAIA,OAAAA,GAAAsjC,EAAyCtjC,GAAA,IAAQA,EAAA,CACjD,GAAAujC,GAAAlO,EAAAr1B,EACA,IAAAqX,EAAA+rB,KAAAG,EAIA,KAHAlsB,GAAAf,MACA8sB,IAKA/rB,EAAAge,GAIA,QAAAmO,GAAAC,GAEA,OADAnpB,MACA4B,EAAA,EAAmBA,EAAAunB,EAAA1iC,SAAkBmb,EAAA,CACrC,GAAAqnB,GAAAE,EAAAvnB,GACAwnB,EAAAC,EAAAx4B,KAAAo4B,IACA,yBAAAA,EACAK,EAAAF,GAAAG,EAAAN,EACAG,KAAAE,IACAE,GAAA,MAAAP,EAAAhsB,OAAA,KACAgsB,EAAA,OAAAA,GAEAjpB,EAAA7I,KAAA8xB,IAGA,MAAAjpB,GAGA,QAAAypB,GAAAC,GAEA,OADAP,GAAAO,EAAAP,MAAA3kC,QAAA,YAAA8S,MAAA,MACAsK,EAAA,EAAmBA,EAAAunB,EAAA1iC,SAAkBmb,EAAA,CACrC,GAAAqnB,GAAAE,EAAAvnB,EACA,6BAAAqnB,GAAAI,EAAAx4B,KAAAo4B,GACA,MAMA,MAHArnB,GAAA,IACAunB,IAAA/kC,MAAAwd,IAEAunB,EAmFA,QAAAQ,GAAAvhC,GACA,GAAAmG,EACA,sBAAAnG,GACAmG,EAAA,cACAnG,EAAAoC,MAAA,aACA,QACK,CACL+D,EAAAnG,EAAAY,UACA,IAAA4gC,GAAA,2BACA,IAAAA,EAAA/4B,KAAAtC,GACA,IACA,GAAAs7B,GAAAjkC,KAAAC,UAAAuC,EACAmG,GAAAs7B,EAEA,MAAA3kC,IAIA,IAAAqJ,EAAA9H,SACA8H,EAAA,iBAGA,WAAAu7B,EAAAv7B,GAAA,qBAGA,QAAAu7B,GAAAv7B,GACA,GAAAw7B,GAAA,EACA,OAAAx7B,GAAA9H,OAAAsjC,EACAx7B,EAEAA,EAAAy7B,OAAA,EAAAD,EAAA,SAKA,QAAAE,GAAAhB,GACA,GAAAiB,GAAAjB,EAAA7lC,MAAA+mC,EACA,OAAAD,IAEAE,SAAAF,EAAA,GACAjB,KAAA5lC,SAAA6mC,EAAA,QAHA,OAhSA,GAOAG,GAPApK,EAAAiC,EAAA,cACA8D,EAAA9D,EAAA,aACAoI,EACA,8DACAjB,EAAA,KACAkB,EAAA,KACAf,GAAA,CASAxD,GAAAwE,SAAAlC,EAAAv8B,OAEAu8B,EAAAnkC,UAAAskC,QAAA,WACA,GAAAhiC,GAAA9C,KAAAwjB,OACA,QAAA1gB,GAAA,CAIA,OAHAgkC,MACAC,KAEA9oB,EAAA,EAAA+oB,EAAAhnC,KAAgCgL,SAAAg8B,IAAoB/oB,EACpD6oB,EAAAtzB,KAAAwzB,GACAA,IAAApC,OAEA9hC,GAAA9C,KAAAwjB,QAAAvF,CACA,QAAAA,GAAAnb,EAAA,EAA4Bmb,GAAA,IAAQA,EAAA,CACpC,GAAAunB,GAAAsB,EAAA7oB,GAAAunB,KACAx6B,UAAA+7B,EAAAvB,KACAuB,EAAAvB,GAAAvnB,GAGA,OAAAA,GAAA,EAAmBnb,EAAAmb,IAAYA,EAAA,CAC/B,GAAAgpB,GAAAH,EAAA7oB,GAAAunB,MACA7kC,EAAAomC,EAAAE,EACA,IAAAj8B,SAAArK,OAAAsd,EAAA,CACAtd,EAAA,IACAmmC,EAAAnmC,EAAA,GAAAikC,QAAA55B,OACA87B,EAAAnmC,EAAA,GAAA6iB,QAAA,GAEAsjB,EAAA7oB,GAAA2mB,QAAA55B,OACA87B,EAAA7oB,GAAAuF,QAAA,CACA,IAAA0jB,GAAAjpB,EAAA,EAAA6oB,EAAA7oB,EAAA,GAAAje,IAEA8C,GAAA,EAAAnC,GACAumC,EAAAtC,QAAAkC,EAAAnmC,EAAA,GACAumC,EAAAtC,QAAAE,UACAoC,EAAA1jB,QACA0jB,EAAAtC,QAAAphB,QAAA,IAEA0jB,EAAAtC,QAAA55B,OACAk8B,EAAA1jB,QAAA,EAGA,QADA2jB,GAAAD,EAAA1jB,QAAA,EACAzhB,EAAAkc,EAAA,EAA+Blc,GAAA,IAAQA,EACvC+kC,EAAA/kC,GAAAyhB,QAAA2jB,EACAA,GAEA,YAKAxC,EAAAnkC,UAAAkjC,OAAA,WACA,MAAA1jC,MAAA4kC,SAGAD,EAAAnkC,UAAA4mC,UAAA,WACA,MAAAp8B,UAAAhL,KAAA4kC,SAGAD,EAAAnkC,UAAA6mC,iBAAA,SAAAtB,GACA,IAAAA,EAAAuB,iBAAA,CACAtnC,KAAA8kC,SAMA,KALA,GAAAyC,GAAA5C,EAAA6C,qBAAAzB,GACA3D,EAAAmF,EAAAnF,QACA4C,GAAAuC,EAAA/B,OAEAiC,EAAAznC,KACAgL,SAAAy8B,GACAzC,EAAAxxB,KAAA+xB,EAAAkC,EAAAjC,MAAA7xB,MAAA,QACA8zB,IAAA7C,OAEAM,GAAAF,GACAC,EAAAD,GACAe,EAAAP,MAAAT,EAAA3C,EAAA4C,GACA3C,EAAAqF,kBAAA3B,EAAA,yBAmFApB,EAAA6C,qBAAA,SAAAzB,GACA,GAAAP,GAAAO,EAAAP,MACApD,EAAA2D,EAAA1gC,UAGA,OAFAmgC,GAAA,gBAAAA,MAAA1iC,OAAA,EACAgjC,EAAAC,IAAA,yBAEA3D,UACAoD,MAAAD,EAAAC,KAIAb,EAAAgD,kBAAA,SAAA5B,EAAAjmB,GACA,sBAAA5gB,SAAA,CACA,GAAAkjC,EACA,oBAAA2D,IAAA,kBAAAA,GAAA,CACA,GAAAP,GAAAO,EAAAP,KACApD,GAAAtiB,EAAA8mB,EAAApB,EAAAO,OAEA3D,GAAAtiB,EAAA7W,OAAA88B,EAEA,mBAAAW,GACAA,EAAAtE,IACS,kBAAAljC,SAAA6B,KACT,gBAAA7B,SAAA6B,MACA7B,QAAA6B,IAAAqhC,KAKAuC,EAAAiD,mBAAA,SAAApE,GACAmB,EAAAgD,kBAAAnE,EAAA,uCAGAmB,EAAAkD,YAAA,WACA,wBAAAhD,IAGAF,EAAAmD,mBACA,SAAAjhC,EAAAkhC,EAAAvE,EAAAzlB,GACA,GAAAiqB,IAAA,CACA,KACA,kBAAAD,KACAC,GAAA,EACA,qBAAAnhC,EACAkhC,EAAAhqB,GAEAgqB,EAAAvE,EAAAzlB,IAGK,MAAAxc,GACL+6B,EAAAsD,WAAAr+B,GAGA,GAAA0mC,IAAA,CACA,KACAA,EAAAC,EAAArhC,EAAA28B,EAAAzlB,GACK,MAAAxc,GACL0mC,GAAA,EACA3L,EAAAsD,WAAAr+B,GAGA,GAAA4mC,IAAA,CACA,IAAAC,EACA,IACAD,EAAAC,EAAAvhC,EAAArH,eACAgkC,SACAzlB,YAES,MAAAxc,GACT4mC,GAAA,EACA7L,EAAAsD,WAAAr+B,GAIA0mC,GAAAD,GAAAG,GACA,uBAAAthC,GACA89B,EAAAgD,kBAAAnE,EAAA,wBAqCA,IAAAoC,GAAA,WAA+B,UAC/BY,EAAA,uCAUA7B,GAAA0D,UAAA,SAAA9I,EAAA+I,GACA,GAAA3D,EAAAkD,cAAA,CAOA,OAFAU,GACAC,EALAC,EAAAlJ,EAAAiG,MAAA7xB,MAAA,MACA+0B,EAAAJ,EAAA9C,MAAA7xB,MAAA,MACAg1B,EAAA,GACAC,EAAA,GAGA3qB,EAAA,EAAmBA,EAAAwqB,EAAA3lC,SAA4Bmb,EAAA,CAC/C,GAAAza,GAAA8iC,EAAAmC,EAAAxqB,GACA,IAAAza,EAAA,CACA+kC,EAAA/kC,EAAAijC,SACAkC,EAAAnlC,EAAA8hC,IACA,QAGA,OAAArnB,GAAA,EAAmBA,EAAAyqB,EAAA5lC,SAA2Bmb,EAAA,CAC9C,GAAAza,GAAA8iC,EAAAoC,EAAAzqB,GACA,IAAAza,EAAA,CACAglC,EAAAhlC,EAAAijC,SACAmC,EAAAplC,EAAA8hC,IACA,QAGA,EAAAqD,GAAA,EAAAC,IAAAL,IAAAC,GACAD,IAAAC,GAAAG,GAAAC,IAIAhD,EAAA,SAAAN,GACA,GAAAqB,EAAAz5B,KAAAo4B,GAAA,QACA,IAAA9K,GAAA8L,EAAAhB,EACA,OAAA9K,IACAA,EAAAiM,WAAA8B,GACAI,GAAAnO,EAAA8K,MAAA9K,EAAA8K,MAAAsD,GACA,GAGA,KAIA,IAwEAR,GAxEAvD,EAAA,WACA,GAAAgE,GAAA,YACAC,EAAA,SAAAtD,EAAAO,GACA,sBAAAP,KAEAx6B,SAAA+6B,EAAAl/B,MACAmE,SAAA+6B,EAAA3D,QACA2D,EAAA1gC,WAEA2gC,EAAAD,GAGA,oBAAA39B,OAAA2gC,iBACA,kBAAA3gC,OAAAy8B,kBAAA,CACAz8B,MAAA2gC,gBAAA3gC,MAAA2gC,gBAAA,EACArD,EAAAmD,EACAjC,EAAAkC,CACA,IAAAjE,GAAAz8B,MAAAy8B,iBAKA,OAHAe,GAAA,SAAAN,GACA,MAAAqB,GAAAz5B,KAAAo4B,IAEA,SAAArN,EAAA+Q,GACA5gC,MAAA2gC,gBAAA3gC,MAAA2gC,gBAAA,EACAlE,EAAA5M,EAAA+Q,GACA5gC,MAAA2gC,gBAAA3gC,MAAA2gC,gBAAA,GAGA,GAAA3rB,GAAA,GAAAhV,MAEA,oBAAAgV,GAAAooB,OACApoB,EAAAooB,MAAA7xB,MAAA,SAAAhD,QAAA,sBAIA,MAHA+0B,GAAA,IACAkB,EAAAkC,EACAjD,GAAA,EACA,SAAA9V,GACAA,EAAAyV,OAAA,GAAAp9B,QAAAo9B,MAIA,IAAAyD,EACA,KAAS,SAAA7gC,OACT,MAAA7G,GACA0nC,EAAA,SAAA1nC,GAEA,eAAA6b,KAAA6rB,GAWArC,EAAA,SAAApB,EAAAO,GACA,sBAAAP,KAEA,gBAAAO,IACA,kBAAAA,IACA/6B,SAAA+6B,EAAAl/B,MACAmE,SAAA+6B,EAAA3D,QAGA4D,EAAAD,GAFAA,EAAA1gC,YAKA,OAtBAqgC,EAAAmD,EACAjC,EAAAkC,EACA,SAAA/Y,GACA3nB,MAAA2gC,gBAAA3gC,MAAA2gC,gBAAA,CACA,KAAiB,SAAA3gC,OACjB,MAAA7G,GAAsBwuB,EAAAyV,MAAAjkC,EAAAikC,MACtBp9B,MAAA2gC,gBAAA3gC,MAAA2gC,gBAAA,SAqBAb,EAAA,WACA,GAAA7F,EAAA6G,OACA,gBAAAriC,EAAA28B,EAAAzlB,GACA,2BAAAlX,EACA2X,EAAA+B,KAAA1Z,EAAAkX,GAEAS,EAAA+B,KAAA1Z,EAAA28B,EAAAzlB,GAIA,IAAAorB,IAAA,EACAC,GAAA,CACA,KACA,GAAA3pB,GAAA,GAAA0F,MAAAkkB,YAAA,OACAF,GAAA1pB,YAAA4pB,aACS,MAAA9nC,IACT,IAAA4nC,EACA,IACA,GAAA7U,GAAAx1B,SAAAwqC,YAAA,cACAhV,GAAAiV,gBAAA,4BACApkB,KAAAqkB,cAAAlV,GACa,MAAA/yB,GACb6nC,GAAA,EAGAA,IACAhB,EAAA,SAAAr9B,EAAA0+B,GACA,GAAAnV,EAYA,OAXA6U,GACA7U,EAAA,GAAAnP,MAAAkkB,YAAAt+B,GACA0+B,SACAC,SAAA,EACAC,YAAA,IAEiBxkB,KAAAqkB,gBACjBlV,EAAAx1B,SAAAwqC,YAAA,eACAhV,EAAAiV,gBAAAx+B,GAAA,KAAA0+B,IAGAnV,GAAAnP,KAAAqkB,cAAAlV,IAAA,GAIA,IAAAsV,KAMA,OALAA,GAAA,0CACApqC,cACAoqC,EAAA,sCACApqC,cAEA,SAAAqH,EAAA28B,EAAAzlB,GACA,GAAApR,GAAAi9B,EAAA/iC,GACAoK,EAAAkU,KAAAxY,EACA,OAAAsE,IACA,qBAAApK,EACAoK,EAAAvQ,KAAAykB,KAAApH,GAEA9M,EAAAvQ,KAAAykB,KAAAqe,EAAAzlB,IAEA,IANA,KA0BA,OAfA,mBAAA7e,UAAA,mBAAAA,SAAAwnC,OACAA,EAAA,SAAAtE,GACAljC,QAAAwnC,KAAAtE,IAEAC,EAAA6G,QAAA1qB,EAAAqrB,OAAAC,MACApD,EAAA,SAAAtE,GACA5jB,EAAAqrB,OAAAE,MAAA,QAAA3H,EAAA,YAEKC,EAAA6G,QAAA,oBAAA9gC,QAAA,QACLs+B,EAAA,SAAAtE,GACAljC,QAAAwnC,KAAA,KAAAtE,EAAA,iBAKAuC,KAGGH,aAAA,EAAArB,YAAA,KAA8B6G,GAAA,SAAAzL,EAAA7/B,GACjC,YACAA,GAAAC,QAAA,SAAAsrC,GAQA,QAAAC,GAAAC,EAAAC,EAAArsB,GACA/d,KAAAqqC,WAAAF,EACAnqC,KAAAsqC,UAAAF,EACApqC,KAAAuqC,SAAAxsB,EAGA,QAAAysB,GAAA3xB,EAAAtX,GACA,GAAAkpC,MACAC,EAAA1Q,EAAAnhB,GAAAnY,KAAA+pC,EAAAlpC,EAEA,IAAAmpC,IAAAC,EAAA,MAAAD,EAEA,IAAAE,GAAAr5B,EAAAk5B,EACA,OAAAG,GAAA9nC,QACA6nC,EAAAppC,EAAA,GAAA4E,GAAA,4GACAwkC,GAEAD,EAxBA,GAAArI,GAAA9D,EAAA,aACA8E,EAAA9E,EAAA,eACAvE,EAAAqI,EAAArI,SACA2Q,EAAAtI,EAAAsI,SACAp5B,EAAAgtB,EAAA,YAAAhtB,KACApL,EAAAk9B,EAAAl9B,SAyDA,OAnCA+jC,GAAA1pC,UAAAqqC,SAAA,SAAAtpC,GAIA,OAHAm0B,GAAA11B,KAAAsqC,UACAvsB,EAAA/d,KAAAuqC,SACAO,EAAA/sB,EAAA4jB,SACA1jB,EAAA,EAAAra,EAAA5D,KAAAqqC,WAAAvnC,OAAiDc,EAAAqa,IAASA,EAAA,CAC1D,GAAApZ,GAAA7E,KAAAqqC,WAAApsB,GACA8sB,EAAAlmC,IAAAuD,OACA,MAAAvD,KAAArE,oBAAA4H,MAEA,IAAA2iC,GAAAxpC,YAAAsD,GAAA,CACA,GAAAwX,GAAA2d,EAAAtE,GAAAh1B,KAAAoqC,EAAAvpC,EACA,OAAA8a,KAAAsuB,GACAV,EAAA1oC,EAAA8a,EAAA9a,EACA0oC,GAEA5tB,EACS,qBAAAxX,KAAAkmC,EAAA,CACT,GAAAC,GAAAR,EAAA3lC,EAAAtD,EACA,IAAAypC,IAAAL,EAAA,CACAppC,EAAAopC,EAAAppC,CACA,OACa,GAAAypC,EAAA,CACb,GAAA3uB,GAAA2d,EAAAtE,GAAAh1B,KAAAoqC,EAAAvpC,EACA,OAAA8a,KAAAsuB,GACAV,EAAA1oC,EAAA8a,EAAA9a,EACA0oC,GAEA5tB,IAKA,MADA4tB,GAAA1oC,IACA0oC,GAGAC,KAGGzF,cAAA,GAAAwG,WAAA,GAAA9H,YAAA,KAA8C+H,GAAA,SAAA3M,EAAA7/B,GACjD,YACAA,GAAAC,QAAA,SAAAme,EAAA6nB,EAAAwG,GAEA,QAAAnpB,KACAhiB,KAAAorC,OAAA,GAAAzG,GAAA0G,KAgBA,QAAAC,KACA,MAAAH,KAAA,GAAAnpB,GAAA,OAGA,QAAAqpB,KACA,GAAAzC,GAAA2C,EAAAzoC,OAAA,CACA,OAAA8lC,IAAA,EACA2C,EAAA3C,GAEA59B,OA3BA,GAAAugC,KAkCA,OA9BAvpB,GAAAxhB,UAAAgrC,aAAA,WACAL,KACAngC,SAAAhL,KAAAorC,QACAG,EAAA/3B,KAAAxT,KAAAorC,SAIAppB,EAAAxhB,UAAAirC,YAAA,WACAN,KACAngC,SAAAhL,KAAAorC,QACAG,EAAAlzB,OAgBAyE,EAAAtc,UAAAkrC,aAAAL,EACAvuB,EAAAtc,UAAAgrC,aAAAxpB,EAAAxhB,UAAAgrC,aACA1uB,EAAAtc,UAAAirC,YAAAzpB,EAAAxhB,UAAAirC,YAEAH,QAGIlpC,IAAA,SAAAm8B,EAAA7/B,GACJ,YACAA,GAAAC,QAAA,SAAAme,EAAA6nB,GACA,GAIAgH,GACAC,EALAtP,EAAAiC,EAAA,cACAsN,EAAAtN,EAAA,eAAAsN,QACAxJ,EAAA9D,EAAA,aACAuN,EAAAzJ,EAAAyJ,eAGAC,GAAA,GAAA1J,EAAA6G,WACA1qB,EAAAwB,IAAA,gBACA,gBAAAxB,EAAAwB,IAAA,SA6HA,OA3HAlD,GAAAtc,UAAAwrC,gCAAA,WACAhsC,KAAAisC,2BACA3P,EAAAuD,YAAA7/B,KAAAksC,0BAAAlsC,KAAAgL,SAGA8R,EAAAtc,UAAA2rC,mCAAA,WACAxH,EAAAmD,mBAAA,mBACA6D,EAAA3gC,OAAAhL,OAGA8c,EAAAtc,UAAA0rC,0BAAA,WACA,GAAAlsC,KAAAosC,wBAAA,CACA,GAAA5I,GAAAxjC,KAAAqsC,yBAAArsC,KAAAssC,aACAtsC,MAAAusC,mCACA5H,EAAAmD,mBAAA,qBACA8D,EAAApI,EAAAxjC,QAIA8c,EAAAtc,UAAA+rC,iCAAA,WACAvsC,KAAA0hC,UAAA,OAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAgsC,mCAAA,WACAxsC,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAisC,8BAAA,WACA,cAAAzsC,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAAyrC,yBAAA,WACAjsC,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAksC,2BAAA,WACA1sC,KAAA0hC,UAAA,SAAA1hC,KAAA0hC,UACA1hC,KAAAysC,kCACAzsC,KAAAwsC,qCACAxsC,KAAAmsC,uCAIArvB,EAAAtc,UAAA4rC,sBAAA,WACA,eAAApsC,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAAmsC,sBAAA,SAAAC,GACA5sC,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,UACA1hC,KAAA6sC,qBAAAD,GAGA9vB,EAAAtc,UAAAssC,sBAAA,WACA,eAAA9sC,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAA6rC,sBAAA,WACA,MAAArsC,MAAA8sC,wBACA9sC,KAAA6sC,qBACA7hC,QAGA8R,EAAAtc,UAAAusC,mBAAA,WAIA,MAHAhB,KACA/rC,KAAAorC,OAAA,GAAAzG,GAAA3kC,KAAA0rC,iBAEA1rC,MAGA8c,EAAAtc,UAAAwsC,kBAAA,SAAAjH,EAAAkH,GACA,GAAAlB,GAAAD,EAAA/F,GAAA,CACA,GAAA0B,GAAAznC,KAAAorC,MAIA,IAHApgC,SAAAy8B,GACAwF,IAAAxF,IAAA7C,SAEA55B,SAAAy8B,EACAA,EAAAJ,iBAAAtB,OACS,KAAAA,EAAAuB,iBAAA,CACT,GAAAC,GAAA5C,EAAA6C,qBAAAzB,EACAA,GAAAP,MAAA+B,EAAAnF,QAAA,KAAAmF,EAAA/B,MAAAl0B,KAAA,MACA+wB,EAAAqF,kBAAA3B,EAAA,0BAKAjpB,EAAAtc,UAAA0sC,MAAA,SAAA9K,GACA,GAAA+K,GAAA,GAAAtB,GAAAzJ,GACAvlB,EAAA7c,KAAA0rC,cACA,IAAA7uB,EACAA,EAAAwqB,iBAAA8F,OACK,CACL,GAAA5F,GAAA5C,EAAA6C,qBAAA2F,EACAA,GAAA3H,MAAA+B,EAAAnF,QAAA,KAAAmF,EAAA/B,MAAAl0B,KAAA,MAEAqzB,EAAAgD,kBAAAwF,EAAA,KAGArwB,EAAAswB,6BAAA,SAAAzqC,GACAipC,EAAA,kBAAAjpC,KAAAqI,QAGA8R,EAAAuwB,4BAAA,SAAA1qC,GACAgpC,EAAA,kBAAAhpC,KAAAqI,QAGA8R,EAAAwwB,gBAAA,WACA,GAAAhR,EAAAmD,mBACAsM,KAAA,EAEA,SAAA3jC,OAAA,qGAEA2jC,GAAApH,EAAAkD,eAGA/qB,EAAAywB,mBAAA,WACA,MAAAxB,IAAApH,EAAAkD,eAGAlD,EAAAkD,gBACA/qB,EAAAwwB,gBAAA,aACAvB,GAAA,GAGA,WACA,MAAAA,OAIGvH,aAAA,EAAAC,cAAA,GAAAtB,YAAA,KAA+CzmB,IAAA,SAAA6hB,EAAA7/B,GAClD,YACA,IAAA2jC,GAAA9D,EAAA,aACAiP,EAAAnL,EAAAmL,YACAC,EAAApL,EAAAoL,sBAEA/uC,GAAAC,QAAA,SAAAme,GACA,GAAA4wB,GAAA,WACA,MAAA1tC,OAEA2tC,EAAA,WACA,KAAA3tC,OAGAiX,EAAA,SAAAtR,EAAAioC,GACA,WAAAA,EACA,WACA,KAAAjoC,IAEK,IAAAioC,EACL,WACA,MAAAjoC,IAFK,OAQLmX,GAAAtc,UAAA,UACAsc,EAAAtc,UAAAqtC,WAAA,SAAAloC,GACA,MAAA8nC,IAAAD,EAAA7nC,GACA3F,KAAA+gC,MACA9pB,EAAAtR,EAAA,GACAqF,OACAA,OACAA,OACAA,QAGAhL,KAAA+gC,MAAA2M,EAAA1iC,cAAArF,EAAAqF,SAGA8R,EAAAtc,UAAA,SACAsc,EAAAtc,UAAAstC,UAAA,SAAAtK,GACA,MAAAiK,IAAAD,EAAAhK,GACAxjC,KAAA+gC,MACA9pB,EAAAusB,EAAA,GACAx4B,OACAA,OACAA,OACAA,QAGAhL,KAAA+gC,MAAA4M,EAAA3iC,cAAAw4B,EAAAx4B,YAIGm4B,YAAA,KAAe4K,IAAA,SAAAxP,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,GACA,GAAAwN,GAAAlxB,EAAAmxB,MAEAnxB,GAAAtc,UAAA0tC,KAAA,SAAAvrC,GACA,MAAAqrC,GAAAhuC,KAAA2C,EAAA,KAAA69B,IAGA1jB,EAAAoxB,KAAA,SAAAlwB,EAAArb,GACA,MAAAqrC,GAAAhwB,EAAArb,EAAA,KAAA69B,UAIIliB,IAAA,SAAAigB,EAAA7/B,GACJ,YAOA,SAAAyvC,GAAAC,EAAAC,GACA,QAAAC,GAAAlM,GACA,MAAApiC,gBAAAsuC,IACA5G,EAAA1nC,KAAA,UACA,gBAAAoiC,KAAAiM,GACA3G,EAAA1nC,KAAA,OAAAouC,QACAhmC,MAAAy8B,kBACAz8B,MAAAy8B,kBAAA7kC,UAAAqR,aAEAjJ,MAAA1H,KAAAV,QAPA,GAAAsuC,GAAAlM,GAWA,MADAyE,GAAAyH,EAAAlmC,OACAkmC,EAmDA,QAAAC,GAAAnM,GACA,MAAApiC,gBAAAuuC,IAEA7G,EAAA1nC,KAAA,2BACA0nC,EAAA1nC,KAAA,UAAAoiC,GACApiC,KAAAwuC,MAAApM,EACApiC,KAAA,sBAEAoiC,YAAAh6B,QACAs/B,EAAA1nC,KAAA,UAAAoiC,WACAsF,EAAA1nC,KAAA,QAAAoiC,EAAAoD,QACKp9B,MAAAy8B,mBACLz8B,MAAAy8B,kBAAA7kC,UAAAqR,eAVA,GAAAk9B,GAAAnM,GAxEA,GAsBAqM,GAAAC,EAtBAC,EAAApQ,EAAA,YACAqQ,EAAAD,EAAA9W,OACAwK,EAAA9D,EAAA,aACAsI,EAAAxE,EAAAwE,SACAa,EAAArF,EAAAqF,kBAmBAmE,EAAAsC,EAAA,qBACA7K,EAAA6K,EAAA,0CACAU,EAAAV,EAAA,gCACAW,EAAAX,EAAA,mCACA,KACAM,EAAAtoC,UACAuoC,EAAA5hB,WACC,MAAAvrB,GACDktC,EAAAN,EAAA,0BACAO,EAAAP,EAAA,4BAMA,OAHA/X,GAAA,sHACAziB,MAAA,KAEAsK,EAAA,EAAeA,EAAAmY,EAAAtzB,SAAoBmb,EACnC,kBAAA1d,OAAAC,UAAA41B,EAAAnY,MACA6wB,EAAAtuC,UAAA41B,EAAAnY,IAAA1d,MAAAC,UAAA41B,EAAAnY,IAIA0wB,GAAAvtB,eAAA0tB,EAAAtuC,UAAA,UACAmF,MAAA,EACAshB,cAAA,EACAC,UAAA,EACAF,YAAA,IAEA8nB,EAAAtuC,UAAA,gBACA,IAAAuuC,GAAA,CACAD,GAAAtuC,UAAA6E,SAAA,WACA,GAAA2pC,GAAAzuC,MAAA,EAAAwuC,EAAA,GAAAz9B,KAAA,KACA+K,EAAA,KAAA2yB,EAAA,sBACAD,KACAC,EAAAzuC,MAAA,EAAAwuC,EAAA,GAAAz9B,KAAA,IACA,QAAA2M,GAAA,EAAmBA,EAAAje,KAAA8C,SAAiBmb,EAAA,CAGpC,OAFArT,GAAA5K,KAAAie,KAAAje,KAAA,4BAAAA,KAAAie,GAAA,GACAgxB,EAAArkC,EAAA+I,MAAA,MACA5R,EAAA,EAAuBA,EAAAktC,EAAAnsC,SAAkBf,EACzCktC,EAAAltC,GAAAitC,EAAAC,EAAAltC,EAEA6I,GAAAqkC,EAAA39B,KAAA,MACA+K,GAAAzR,EAAA,KAGA,MADAmkC,KACA1yB,GAmBAwqB,EAAA0H,EAAAnmC,MAEA,IAAA8mC,GAAA9mC,MAAA,sBACA8mC,KACAA,EAAAN,GACAtL,oBACAuL,eACAN,mBACAY,eAAAZ,EACAO,mBAEApH,EAAAt/B,MAAA,yBAAA8mC,IAGAxwC,EAAAC,SACAyJ,YACAjC,UAAAsoC,EACA3hB,WAAA4hB,EACApL,kBAAA4L,EAAA5L,kBACAiL,iBAAAW,EAAAX,iBACAM,aAAAK,EAAAL,aACAC,eAAAI,EAAAJ,eACAjD,aAGGZ,WAAA,GAAA9H,YAAA,KAA6BxiB,IAAA,SAAA4d,EAAA7/B,GAChC,GAAA0wC,GAAA,WACA,YACA,OAAApkC,UAAAhL,OAGA,IAAAovC,EACA1wC,EAAAC,SACAk5B,OAAAzyB,OAAAyyB,OACAzW,eAAAhc,OAAAgc,eACAiuB,cAAAjqC,OAAAooB,yBACAjc,KAAAnM,OAAAmM,KACA5K,MAAAvB,OAAAqoB,oBACAxE,eAAA7jB,OAAA6jB,eACA/jB,QAAA3E,MAAA2E,QACAkqC,QACAE,mBAAA,SAAA7qC,EAAA+E,GACA,GAAAsd,GAAA1hB,OAAAooB,yBAAA/oB,EAAA+E,EACA,SAAAsd,MAAAI,WAAAJ,EAAA9U,WAGC,CACD,GAAA5B,MAAgBjH,eAChByB,KAAgBvF,SAChB6Y,KAAkB7M,YAAA7Q,UAElB+uC,EAAA,SAAAxf,GACA,GAAA1T,KACA,QAAA3X,KAAAqrB,GACA3f,EAAA1P,KAAAqvB,EAAArrB,IACA2X,EAAA7I,KAAA9O,EAGA,OAAA2X,IAGAmzB,EAAA,SAAAzf,EAAArrB,GACA,OAAgBiB,MAAAoqB,EAAArrB,KAGhB+qC,EAAA,SAAA1f,EAAArrB,EAAAwzB,GAEA,MADAnI,GAAArrB,GAAAwzB,EAAAvyB,MACAoqB,GAGA2f,EAAA,SAAAjrC,GACA,MAAAA,IAGAkrC,EAAA,SAAAlrC,GACA,IACA,MAAAW,QAAAX,GAAA4M,YAAA7Q,UAEA,MAAAe,GACA,MAAA2c,KAIA0xB,EAAA,SAAAnrC,GACA,IACA,yBAAAmG,EAAAlK,KAAA+D,GAEA,MAAAlD,GACA,UAIA7C,GAAAC,SACAuG,QAAA0qC,EACAr+B,KAAAg+B,EACA5oC,MAAA4oC,EACAnuB,eAAAquB,EACAJ,cAAAG,EACA3X,OAAA6X,EACAzmB,eAAA0mB,EACAP,QACAE,mBAAA,WACA,iBAKIO,IAAA,SAAAtR,EAAA7/B,GACJ,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,GACA,GAAAsP,GAAAhzB,EAAA5K,GAEA4K,GAAAtc,UAAA2O,OAAA,SAAAxM,EAAAotC,GACA,MAAAD,GAAA9vC,KAAA2C,EAAAotC,EAAAvP,IAGA1jB,EAAA3N,OAAA,SAAA6O,EAAArb,EAAAotC,GACA,MAAAD,GAAA9xB,EAAArb,EAAAotC,EAAAvP,UAIIwP,IAAA,SAAAzR,EAAA7/B,GACJ,YACAA,GAAAC,QAAA,SAAAme,EAAAmtB,EAAAxJ,GAMA,QAAAtc,KACA,MAAAnkB,MAEA,QAAAiwC,KACA,KAAAjwC,MAEA,QAAAkwC,GAAAzuC,GACA,kBACA,MAAAA,IAGA,QAAA0uC,GAAA1uC,GACA,kBACA,KAAAA,IAGA,QAAA2uC,GAAA/zB,EAAAg0B,EAAAC,GACA,GAAA1qC,EAMA,OAJAA,GADA6nC,GAAAD,EAAA6C,GACAC,EAAAJ,EAAAG,GAAAF,EAAAE,GAEAC,EAAAnsB,EAAA8rB,EAEA5zB,EAAA0kB,MAAAn7B,EAAA+nC,EAAA3iC,OAAAqlC,EAAArlC,QAGA,QAAAulC,GAAAF,GACA,GAAAtyB,GAAA/d,KAAA+d,QACAyyB,EAAAxwC,KAAAwwC,QAEAn0B,EAAA0B,EAAA6jB,WACA4O,EAAA9vC,KAAAqd,EAAA4jB,UACA6O,GAEA,IAAAxlC,SAAAqR,EAAA,CACA,GAAAilB,GAAAb,EAAApkB,EAAA0B,EACA,IAAAujB,YAAAxkB,GAEA,MADAwkB,KAAAE,UACA4O,EAAA9O,EAAA+O,EACAtyB,EAAAuyB,eAIA,MAAAvyB,GAAA0yB,cACAxG,EAAA1oC,EAAA8uC,EACApG,GAEAoG,EAIA,QAAAK,GAAA/qC,GACA,GAAAoY,GAAA/d,KAAA+d,QACAyyB,EAAAxwC,KAAAwwC,QAEAn0B,EAAA0B,EAAA6jB,WACA4O,EAAA9vC,KAAAqd,EAAA4jB,SAAAh8B,GACA6qC,EAAA7qC,EAEA,IAAAqF,SAAAqR,EAAA,CACA,GAAAilB,GAAAb,EAAApkB,EAAA0B,EACA,IAAAujB,YAAAxkB,GAEA,MADAwkB,KAAAE,UACA4O,EAAA9O,EAAA37B,GAAA,GAGA,MAAAA,GAvEA,GAAA08B,GAAA9D,EAAA,aACAkP,EAAApL,EAAAoL,uBACAD,EAAAnL,EAAAmL,YACAG,EAAAtL,EAAAsL,OAuEA7wB,GAAAtc,UAAAmwC,oBAAA,SAAAH,EAAAI,GACA,qBAAAJ,GAAA,MAAAxwC,MAAA4F,MAEA,IAAAirC,IACA9yB,QAAA/d,KACAwwC,UAGA,OAAAxwC,MAAA+gC,MACA6P,EAAAL,EAAAG,EACAE,EAAAL,EAAAvlC,cACA6lC,EAAA7lC,SAGA8R,EAAAtc,UAAAswC,OACAh0B,EAAAtc,UAAA,oBAAAgwC,GACA,MAAAxwC,MAAA2wC,oBAAAH,GAAA,IAGA1zB,EAAAtc,UAAA0V,IAAA,SAAAs6B,GACA,MAAAxwC,MAAA2wC,oBAAAH,GAAA,OAIGrN,YAAA,KAAe4N,IAAA,SAAAxS,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EACAk0B,EACAxQ,EACAC,GAQA,QAAAwQ,GAAAtrC,EAAAurC,EAAAC,GACA,OAAAlzB,GAAA,EAAmBA,EAAAizB,EAAApuC,SAA0Bmb,EAAA,CAC7CkzB,EAAA3F,cACA,IAAAhoC,GAAAw2B,EAAAkX,EAAAjzB,IAAAtY,EAEA,IADAwrC,EAAA1F,cACAjoC,IAAAmnC,EAAA,CACAwG,EAAA3F,cACA,IAAAnvB,GAAAS,EAAAlI,OAAA+1B,EAAAppC,EAEA,OADA4vC,GAAA1F,cACApvB,EAEA,GAAAilB,GAAAb,EAAAj9B,EAAA2tC,EACA,IAAA7P,YAAAxkB,GAAA,MAAAwkB,GAEA,YAGA,QAAA8P,GAAAC,EAAApZ,EAAAqZ,EAAA9L,GACA,GAAAznB,GAAA/d,KAAAuqC,SAAA,GAAAztB,GAAA0jB,EACAziB,GAAAgvB,qBACA/sC,KAAAuxC,OAAA/L,EACAxlC,KAAAwxC,mBAAAH,EACArxC,KAAAyxC,UAAAxZ,EACAj4B,KAAA0xC,WAAA1mC,OACAhL,KAAA2xC,eAAA,kBAAAL,IACAA,GAAAhxC,OAAA4wC,GACAA,EAjCA,GAAA7N,GAAA9E,EAAA,eACAp4B,EAAAk9B,EAAAl9B,UACAk8B,EAAA9D,EAAA,aACAoM,EAAAtI,EAAAsI,SACA3Q,EAAAqI,EAAArI,SACAkX,IA+BAE,GAAA5wC,UAAAud,QAAA,WACA,MAAA/d,MAAAuqC,UAGA6G,EAAA5wC,UAAAoxC,KAAA,WACA5xC,KAAA0xC,WAAA1xC,KAAAwxC,mBAAA9wC,KAAAV,KAAAyxC,WACAzxC,KAAAyxC,UACAzxC,KAAAwxC,mBAAAxmC,OACAhL,KAAA6xC,MAAA7mC,SAGAomC,EAAA5wC,UAAAsxC,UAAA,SAAAtuC,GACA,GAAAA,IAAAmnC,EACA,MAAA3qC,MAAAuqC,SAAAzG,gBAAAtgC,EAAAjC,GAAA,KAGA,IAAAoE,GAAAnC,EAAAmC,KACA,IAAAnC,EAAA6Z,QAAA,EACArd,KAAAuqC,SAAAnJ,iBAAAz7B,OACK,CACL,GAAA27B,GAAAb,EAAA96B,EAAA3F,KAAAuqC,SACA,MAAAjJ,YAAAxkB,MACAwkB,EACA2P,EAAA3P,EACAthC,KAAA2xC,eACA3xC,KAAAuqC,UACA,OAAAjJ,GAQA,WAPAthC,MAAA+xC,OACA,GAAA5rC,GACA,oGAAAtF,QAAA,KAAA8E,GACA,oBACA3F,KAAAuxC,OAAA59B,MAAA,MAAAlT,MAAA,MAAA6Q,KAAA,OAMAgwB,GAAAP,MACA/gC,KAAA6xC,MACA7xC,KAAA+xC,OACA/mC,OACAhL,KACA,QAKAoxC,EAAA5wC,UAAAuxC,OAAA,SAAAvO,GACAxjC,KAAAuqC,SAAAyC,kBAAAxJ,GACAxjC,KAAAuqC,SAAAiB,cACA,IAAAhoC,GAAAw2B,EAAAh6B,KAAA0xC,WAAA,UACAhxC,KAAAV,KAAA0xC,WAAAlO,EACAxjC,MAAAuqC,SAAAkB,cACAzrC,KAAA8xC,UAAAtuC,IAGA4tC,EAAA5wC,UAAAqxC,MAAA,SAAAlsC,GACA3F,KAAAuqC,SAAAiB,cACA,IAAAhoC,GAAAw2B,EAAAh6B,KAAA0xC,WAAAx0B,MAAAxc,KAAAV,KAAA0xC,WAAA/rC,EACA3F,MAAAuqC,SAAAkB,cACAzrC,KAAA8xC,UAAAtuC,IAGAsZ,EAAAk1B,UAAA,SAAAX,EAAAtB,GACA,qBAAAsB,GACA,SAAAlrC,GAAA,yEAEA,IAAAmrC,GAAAlsC,OAAA2qC,GAAAuB,aACAW,EAAAb,EACA5L,GAAA,GAAAp9B,QAAAo9B,KACA,mBACA,GAAAvK,GAAAoW,EAAApwC,MAAAjB,KAAAD,WACAmyC,EAAA,GAAAD,GAAAjnC,cAAAsmC,EACA9L,EAGA,OAFA0M,GAAAR,WAAAzW,EACAiX,EAAAL,MAAA7mC,QACAknC,EAAAn0B,YAIAjB,EAAAk1B,UAAAG,gBAAA,SAAAxvC,GACA,qBAAAA,GAAA,SAAAwD,GAAA,0DACA+qC,GAAA19B,KAAA7Q,IAGAma,EAAAo1B,MAAA,SAAAb,GACA,qBAAAA,GACA,MAAAL,GAAA,yEAEA,IAAAkB,GAAA,GAAAd,GAAAC,EAAArxC,MACAqc,EAAA61B,EAAAn0B,SAEA,OADAm0B,GAAAN,KAAA90B,EAAAo1B,OACA71B,MAIGooB,cAAA,GAAAtB,YAAA,KAAgC9hB,IAAA,SAAAkd,EAAA7/B,GACnC,YACAA,GAAAC,QACA,SAAAme,EAAAs1B,EAAA3R,EAAAD,GACA,IAAA6B,GAAA9D,EAAA,YACA8D,GAAAM,YACAN,EAAArI,SACAqI,EAAAsI,SA8DA7tB,EAAAxL,KAAA,WACA,GACA3O,GADAuY,EAAAnb,UAAA+C,OAAA,CAEA,IAAAoY,EAAA,qBAAAnb,WAAAmb,GAAA,CACAvY,EAAA5C,UAAAmb,EAGA,IAAAmB,GAyB6D,OAA7DwmB,GAAA9iC,UAAA+C,OAAiChD,EAAA,GAAAS,OAAAsiC,GAA4BC,EAAA,EAAiBD,EAAAC,IAAaA,EAAShjC,EAAAgjC,GAAA/iC,UAAA+iC,EACpGngC,IAAA7C,EAAAuY,KACA,IAAAgE,GAAA,GAAA+1B,GAAAtyC,GAAAie,SACA,OAAA/S,UAAArI,EAAA0Z,EAAAg2B,OAAA1vC,GAAA0Z,MAKG8mB,YAAA,KAAephB,IAAA,SAAAwc,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EACAs1B,EACApB,EACAvQ,EACAD,GAOA,QAAA8R,GAAAt0B,EAAArb,EAAA4vC,EAAApuC,GACAnE,KAAAwyC,aAAAx0B,GACAhe,KAAAuqC,SAAAwC,qBACA/sC,KAAAsqC,UAAA3nC,EACA3C,KAAAyyC,iBAAAtuC,IAAAq8B,EACA,GAAAjgC,OAAAP,KAAA8C,UACA,KACA9C,KAAA0yC,OAAAH,EACAvyC,KAAA2yC,UAAA,EACA3yC,KAAA4yC,OAAAL,GAAA,KAAAM,EACA7yC,KAAA8yC,OAAA9nC,OAAA,IAqFA,QAAAkH,GAAA8L,EAAArb,EAAAotC,EAAA5rC,GACA,GAAAouC,GAAA,gBAAAxC,IAAA,OAAAA,EACAA,EAAAgD,YACA,CAGA,OAFAR,GAAA,gBAAAA,IACAvlB,SAAAulB,OAAA,EAAAA,EAAA,EACA,GAAAD,GAAAt0B,EAAArb,EAAA4vC,EAAApuC,GA3GA,GAAAk+B,GAAA9D,EAAA,aACAvE,EAAAqI,EAAArI,SACA2Q,EAAAtI,EAAAsI,SACAqI,KACAH,IAcAxQ,GAAAwE,SAAAyL,EAAAF,GAEAE,EAAA9xC,UAAAyyC,MAAA,aAEAX,EAAA9xC,UAAA0yC,kBAAA,SAAAvtC,EAAAhF,GACA,GAAAkW,GAAA7W,KAAAmzC,QACArwC,EAAA9C,KAAA8C,SACAswC,EAAApzC,KAAAyyC,iBACAF,EAAAvyC,KAAA0yC,MACA,IAAA77B,EAAAlW,KAAAqyC,GAEA,GADAn8B,EAAAlW,GAAAgF,EACA4sC,GAAA,IACAvyC,KAAA2yC,YACA3yC,KAAAkgC,cACAlgC,KAAAqzC,eAAA,WAEK,CACL,GAAAd,GAAA,GAAAvyC,KAAA2yC,WAAAJ,EAGA,MAFA17B,GAAAlW,GAAAgF,MACA3F,MAAA4yC,OAAAp/B,KAAA7S,EAGA,QAAAyyC,MAAAzyC,GAAAgF,EAEA,IAAAykC,GAAApqC,KAAAsqC,UACArS,EAAAj4B,KAAAuqC,SAAA5I,QACA3hC,MAAAuqC,SAAAiB,cACA,IAAAnvB,GAAA2d,EAAAoQ,GAAA1pC,KAAAu3B,EAAAtyB,EAAAhF,EAAAmC,EAEA,IADA9C,KAAAuqC,SAAAkB,cACApvB,IAAAsuB,EAAA,MAAA3qC,MAAA2gC,QAAAtkB,EAAA9a,EAEA,IAAA+/B,GAAAb,EAAApkB,EAAArc,KAAAuqC,SACA,IAAAjJ,YAAAxkB,GAAA,CAEA,GADAwkB,IAAAE,UACAF,EAAAH,aAGA,MAFAoR,IAAA,GAAAvyC,KAAA2yC,YACA97B,EAAAlW,GAAAqyC,EACA1R,EAAAgS,mBAAAtzC,KAAAW,EACa,KAAA2gC,EAAAiS,eAGb,MAAAvzC,MAAA2gC,QAAAW,EAAAkS,UAFAn3B,GAAAilB,EAAAmS,SAKA58B,EAAAlW,GAAA0b,EAEA,GAAAq3B,KAAA1zC,KAAA2zC,cACAD,IAAA5wC,IACA,OAAAswC,EACApzC,KAAAmE,QAAA0S,EAAAu8B,GAEApzC,KAAA4zC,SAAA/8B,KAMAy7B,EAAA9xC,UAAA0/B,YAAA,WAIA,IAHA,GAAAjhB,GAAAjf,KAAA4yC,OACAL,EAAAvyC,KAAA0yC,OACA77B,EAAA7W,KAAAmzC,QACAl0B,EAAAnc,OAAA,GAAA9C,KAAA2yC,UAAAJ,GAAA,CACA,GAAAvyC,KAAAqzC,cAAA,MACA,IAAA1yC,GAAAse,EAAA5G,KACArY,MAAAkzC,kBAAAr8B,EAAAlW,QAIA2xC,EAAA9xC,UAAA2D,QAAA,SAAA0vC,EAAAh9B,GAIA,OAHAjT,GAAAiT,EAAA/T,OACAuZ,EAAA,GAAA9b,OAAAqD,GACA7B,EAAA,EACAkc,EAAA,EAAmBra,EAAAqa,IAASA,EAC5B41B,EAAA51B,KAAA5B,EAAAta,KAAA8U,EAAAoH,GAEA5B,GAAAvZ,OAAAf,EACA/B,KAAA4zC,SAAAv3B,IAGAi2B,EAAA9xC,UAAA4yC,gBAAA,WACA,MAAApzC,MAAAyyC,kBAYA31B,EAAAtc,UAAA0R,IAAA,SAAAvP,EAAAotC,GACA,wBAAAptC,GAAAquC,EAAA,2DAEA9+B,EAAAlS,KAAA2C,EAAAotC,EAAA,MAAAhyB,WAGAjB,EAAA5K,IAAA,SAAA8L,EAAArb,EAAAotC,EAAA5rC,GACA,wBAAAxB,GAAAquC,EAAA,2DACA9+B,EAAA8L,EAAArb,EAAAotC,EAAA5rC,GAAA4Z,cAMGolB,YAAA,KAAehhB,IAAA,SAAAoc,EAAA7/B,GAClB,YACAA,GAAAC,QACA,SAAAme,EAAA0jB,EAAAC,EAAAuQ,GACA,GAAA3O,GAAA9D,EAAA,aACAvE,EAAAqI,EAAArI,QAEAld,GAAA7L,OAAA,SAAAtO,GACA,qBAAAA,GACA,SAAAma,GAAA3W,UAAA,0DAEA,mBACA,GAAAkW,GAAA,GAAAS,GAAA0jB,EACAnkB,GAAA0wB,qBACA1wB,EAAAmvB,cACA,IAAA7lC,GAAAq0B,EAAAr3B,GAAA1B,MAAAjB,KAAAD,UAGA,OAFAsc,GAAAovB,cACApvB,EAAAy3B,sBAAAnuC,GACA0W,IAIAS,EAAAi3B,QAAAj3B,EAAA,gBAAAna,EAAA7C,EAAA+c,GACA,qBAAAla,GACA,MAAAquC,GAAA,0DAEA,IAAA30B,GAAA,GAAAS,GAAA0jB,EACAnkB,GAAA0wB,qBACA1wB,EAAAmvB,cACA,IAAA7lC,GAAA08B,EAAAn9B,QAAApF,GACAk6B,EAAAr3B,GAAA1B,MAAA4b,EAAA/c,GACAk6B,EAAAr3B,GAAAjC,KAAAmc,EAAA/c,EAGA,OAFAuc,GAAAovB,cACApvB,EAAAy3B,sBAAAnuC,GACA0W,GAGAS,EAAAtc,UAAAszC,sBAAA,SAAAnuC,GACAA,IAAA08B,EAAAsI,SACA3qC,KAAA8jC,gBAAAn+B,EAAApE,GAAA,MAEAvB,KAAAohC,iBAAAz7B,GAAA,OAKGw9B,YAAA,KAAe9gB,IAAA,SAAAkc,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,GAMA,QAAAk3B,GAAA7uC,EAAA8uC,GACA,GAAAl2B,GAAA/d,IACA,KAAAqiC,EAAAn9B,QAAAC,GAAA,MAAA+uC,GAAAxzC,KAAAqd,EAAA5Y,EAAA8uC,EACA,IAAA53B,GAAA2d,EAAAia,GAAAhzC,MAAA8c,EAAA4jB,UAAA,MAAArhC,OAAA6E,GACAkX,KAAAsuB,GACArO,EAAAsD,WAAAvjB,EAAA9a,GAIA,QAAA2yC,GAAA/uC,EAAA8uC,GACA,GAAAl2B,GAAA/d,KACAi4B,EAAAla,EAAA4jB,SACAtlB,EAAArR,SAAA7F,EACA60B,EAAAia,GAAAvzC,KAAAu3B,EAAA,MACA+B,EAAAia,GAAAvzC,KAAAu3B,EAAA,KAAA9yB,EACAkX,KAAAsuB,GACArO,EAAAsD,WAAAvjB,EAAA9a,GAGA,QAAA4yC,GAAA3Q,EAAAyQ,GACA,GAAAl2B,GAAA/d,IACA,KAAAwjC,EAAA,CACA,GAAA5yB,GAAAmN,EAAAyjB,UACA4S,EAAAxjC,EAAAy7B,uBACA+H,GAAA5F,MAAAhL,EACAA,EAAA4Q,EAEA,GAAA/3B,GAAA2d,EAAAia,GAAAvzC,KAAAqd,EAAA4jB,SAAA6B,EACAnnB,KAAAsuB,GACArO,EAAAsD,WAAAvjB,EAAA9a,GAlCA,GAAA8gC,GAAA9D,EAAA,aACAjC,EAAAiC,EAAA,cACAvE,EAAAqI,EAAArI,SACA2Q,EAAAtI,EAAAsI,QAmCA7tB,GAAAtc,UAAA6zC,QAAA,SAAAJ,EAAAlE,GACA,qBAAAkE,GAAA,CACA,GAAAK,GAAAJ,CACAlpC,UAAA+kC,GAAA3qC,OAAA2qC,GAAAsC,SACAiC,EAAAN,GAEAh0C,KAAA+gC,MACAuT,EACAH,EACAnpC,OACAhL,KACAi0C,GAGA,MAAAj0C,UAIGwkC,aAAA,EAAArB,YAAA,KAA8BxJ,IAAA,SAAA4E,EAAA7/B,GACjC,YACAA,GAAAC,QAAA,SAAAme,EAAAs1B,GACA,GAAA/P,GAAA9D,EAAA,aACAjC,EAAAiC,EAAA,cACAvE,EAAAqI,EAAArI,SACA2Q,EAAAtI,EAAAsI,QAEA7tB,GAAAtc,UAAA+zC,WAAA,SAAA/D,GACA,MAAAxwC,MAAA+gC,MAAA/1B,cAAAwlC,EAAAxlC,gBAGA8R,EAAAtc,UAAAihC,UAAA,SAAA+S,GACAx0C,KAAAy0C,qCACAz0C,KAAAwhC,UAAAkT,mBAAAF,IAIA13B,EAAAtc,UAAAm0C,mBAAA,SAAAh0C,GACA,WAAAA,EACAX,KAAA40C,kBACA50C,MAAAW,GAAA,GAAAA,EAAA,MAGAmc,EAAAtc,UAAAq0C,gBAAA,SAAAC,GACA,GAAAN,GAAAM,EAAAnvC,MACA6qC,EAAAsE,EAAAtE,QACAzyB,EAAA+2B,EAAA/2B,QACAka,EAAA6c,EAAA7c,SAEA5b,EAAA2d,EAAAwW,GAAA9vC,KAAAu3B,EAAAuc,EACA,IAAAn4B,IAAAsuB,GACA,SAAAtuB,EAAA9a,GACA,4BAAA8a,EAAA9a,EAAAsF,KAAA,CACA,GAAA4gC,GAAApF,EAAAyJ,eAAAzvB,EAAA9a,GACA8a,EAAA9a,EAAA,GAAA6G,OAAAi6B,EAAAh9B,SAAAgX,EAAA9a,GACAwc,GAAAivB,kBAAAvF,GACA1pB,EAAA0jB,UAAAplB,EAAA9a,QAEK8a,aAAAS,GACLT,EAAA0kB,MAAAhjB,EAAA0jB,UAAA,UAAA1jB,EAAA/S,QAEA+S,EAAA0jB,UAAAplB,IAKAS,EAAAtc,UAAAk0C,mBAAA,SAAAF,GAGA,OAFA5wC,GAAA5D,KAAAwjB,UACA1C,EAAA9gB,KAAAyhC,UACAxjB,EAAA,EAAmBra,EAAAqa,EAASA,IAAA,CAC5B,GAAAuyB,GAAAxwC,KAAA20C,mBAAA12B,GACAF,EAAA/d,KAAA+0C,WAAA92B,EACA,IAAAF,YAAAjB,GAWA,kBAAA0zB,GACAlU,EAAA7Y,OAAAzjB,KAAA60C,gBAAA70C,MACAwwC,UACAzyB,UACAka,SAAAj4B,KAAAg1C,YAAA/2B,GACAtY,MAAA6uC,IAGAlY,EAAA7Y,OAAA3C,EAAA/C,EAAAy2B,OAnBA,CACA,GAAAvc,GAAAj4B,KAAAg1C,YAAA/2B,EACA,mBAAAuyB,GACAA,EAAA9vC,KAAAu3B,EAAAuc,EAAAz2B,GACaka,YAAAma,KACbna,EAAAob,eACApb,EAAAgd,mBAAAT,EAAAz2B,SAmBGymB,aAAA,EAAArB,YAAA,KAA8B1F,IAAA,SAAAc,EAAA7/B,GACjC,YACAA,GAAAC,QAAA,WAqCA,QAAAme,GAAAo4B,GACA,qBAAAA,GACA,SAAA/uC,GAAA,yFAEA,IAAAnG,KAAAqR,cAAAyL,EACA,SAAA3W,GAAA,uFAEAnG,MAAA0hC,UAAA,EACA1hC,KAAA6sC,qBAAA7hC,OACAhL,KAAAm1C,mBAAAnqC,OACAhL,KAAA40C,kBAAA5pC,OACAhL,KAAAo1C,UAAApqC,OACAhL,KAAAq1C,WAAArqC,OACAhL,KAAAssC,cAAAthC,OACAkqC,IAAA1U,GAAAxgC,KAAAs1C,qBAAAJ,GAinBA,QAAAK,GAAA5vC,GACA,GAAAyE,GAAA,GAAA0S,GAAA0jB,EACAp2B,GAAAyiC,qBAAAlnC,EACAyE,EAAA+qC,mBAAAxvC,EACAyE,EAAAwqC,kBAAAjvC,EACAyE,EAAAgrC,UAAAzvC,EACAyE,EAAAirC,WAAA1vC,EACAyE,EAAAkiC,cAAA3mC,EA1qBA,GAAA6vC,GAAA,WACA,UAAArvC,GAAA,wEAEAqyB,EAAA,WACA,UAAA1b,GAAA24B,kBAAAz1C,KAAAwhC,YAEAwP,EAAA,SAAA1b,GACA,MAAAxY,GAAAlI,OAAA,GAAAzO,GAAAmvB,KAEA+M,EAAA9D,EAAA,aACAjC,EAAAiC,EAAA,cACA8E,EAAA9E,EAAA,eACAp4B,EAAA2W,EAAA3W,UAAAk9B,EAAAl9B,SACA2W,GAAAgQ,WAAAuW,EAAAvW,WACAhQ,EAAAwmB,kBAAAD,EAAAC,kBACAxmB,EAAA+xB,aAAAxL,EAAAwL,aACA/xB,EAAAyxB,iBAAAlL,EAAAkL,iBACAzxB,EAAAqyB,eAAA9L,EAAAkL,iBACAzxB,EAAAgyB,eAAAzL,EAAAyL,cACA,IAAAtO,GAAA,aACAkV,KACAzL,GAAmB1oC,EAAA,MACnBk/B,EAAAlC,EAAA,kBAAAzhB,EAAA0jB,GACA4R,EACA7T,EAAA,sBAAAzhB,EAAA0jB,EACAC,EAAAuQ,GACArM,EAAApG,EAAA,yBACA4M,EAAA5M,EAAA,sBAAAzhB,EAAA6nB,GAEA2G,EACA/M,EAAA,gBAAAzhB,EAAA6nB,EAAAwG,GACAjB,EAAA3L,EAAA,qBAAA0L,GACA0L,EAAApX,EAAA,yBACAqX,EAAAD,EAAAE,oBACAlL,EAAAtI,EAAAsI,SACA3Q,EAAAqI,EAAArI,QAopBA,OAloBAld,GAAAtc,UAAA6E,SAAA,WACA,0BAGAyX,EAAAtc,UAAAy8B,OAAAngB,EAAAtc,UAAA,kBAAAmC,GACA,GAAAiB,GAAA7D,UAAA+C,MACA,IAAAc,EAAA,GACA,GACAqa,GADA63B,EAAA,GAAAv1C,OAAAqD,EAAA,GACA7B,EAAA,CACA,KAAAkc,EAAA,EAAmBra,EAAA,EAAAqa,IAAaA,EAAA,CAChC,GAAApZ,GAAA9E,UAAAke,EACA,sBAAApZ,GAGA,MAAAiY,GAAAlI,OACA,GAAAzO,GAAA,4GAHA2vC,GAAA/zC,KAAA8C,EAMAixC,EAAAhzC,OAAAf,EACAY,EAAA5C,UAAAke,EACA,IAAA83B,GAAA,GAAA7L,GAAA4L,EAAAnzC,EAAA3C,KACA,OAAAA,MAAA+gC,MAAA/1B,OAAA+qC,EAAAlL,SAAA7/B,OACA+qC,EAAA/qC,QAEA,MAAAhL,MAAA+gC,MAAA/1B,OAAArI,EAAAqI,uBAGA8R,EAAAtc,UAAAg4B,QAAA,WACA,MAAAx4B,MAAA+gC,MAAAvI,IAAAxtB,OAAAhL,KAAAgL,SAGA8R,EAAAtc,UAAAoF,KAAA,SAAAy+B,EAAAC,EAAAC,GACA,GAAA4G,KAAAprC,UAAA+C,OAAA,GACA,kBAAAuhC,IACA,kBAAAC,GAAA,CACA,GAAAhP,GAAA,kDACA+M,EAAAC,YAAA+B,EACAtkC,WAAA+C,OAAA,IACAwyB,GAAA,KAAA+M,EAAAC,YAAAgC,IAEAtkC,KAAAktC,MAAA5X,GAEA,MAAAt1B,MAAA+gC,MAAAsD,EAAAC,EAAAC,EACAv5B,gBAGA8R,EAAAtc,UAAA6c,KAAA,SAAAgnB,EAAAC,EAAAC,GACA,GAAAxmB,GAAA/d,KAAA+gC,MAAAsD,EAAAC,EAAAC,EACAv5B,cACA+S,GAAAi4B,eAGAl5B,EAAAtc,UAAA6xC,OAAA,SAAAhO,EAAAC,GACA,MAAAtkC,MAAAsN,MAAAyzB,MAAAsD,EAAAC,EAAAt5B,OAAA0qC,EAAA1qC,SAGA8R,EAAAtc,UAAAijC,cAAA,WACA,OAAAzjC,KAAAi2C,cACAj2C,KAAAikC,gBAGAnnB,EAAAtc,UAAA01C,OAAA,WACA,GAAA75B,IACAi0B,aAAA,EACAG,YAAA,EACA0F,iBAAAnrC,OACAorC,gBAAAprC,OASA,OAPAhL,MAAAswC,eACAj0B,EAAA85B,iBAAAn2C,KAAA2F,QACA0W,EAAAi0B,aAAA,GACKtwC,KAAAywC,eACLp0B,EAAA+5B,gBAAAp2C,KAAAwjC,SACAnnB,EAAAo0B,YAAA,GAEAp0B,GAGAS,EAAAtc,UAAA8M,IAAA,WACA,UAAA8kC,GAAApyC,MAAA+d,WAGAjB,EAAAtc,UAAAulC,MAAA,SAAApjC,GACA,MAAA3C,MAAAi9B,OAAAoF,EAAAgU,wBAAA1zC,IAGAma,EAAA3L,GAAA,SAAAhM,GACA,MAAAA,aAAA2X,IAGAA,EAAAw5B,SAAA,SAAA3zC,GACA,GAAA0Z,GAAA,GAAAS,GAAA0jB,GACAh9B,EAAAw2B,EAAAr3B,GAAAizC,EAAAv5B,GAIA,OAHA7Y,KAAAmnC,GACAtuB,EAAAynB,gBAAAtgC,EAAAjC,GAAA,MAEA8a,GAGAS,EAAAxP,IAAA,SAAA0Q,GACA,UAAAo0B,GAAAp0B,GAAAD,WAGAjB,EAAAgB,MAAAhB,EAAAy5B,QAAA,WACA,GAAAx4B,GAAA,GAAAjB,GAAA0jB,EACA,WAAAmV,GAAA53B,IAGAjB,EAAA05B,KAAA,SAAA/xC,GACA,GAAA4X,GAAAokB,EAAAh8B,EACA,MAAA4X,YAAAS,IAAA,CACA,GAAA3X,GAAAkX,CACAA,GAAA,GAAAS,GAAA0jB,GACAnkB,EAAAo6B,kBAAAtxC,GAEA,MAAAkX,IAGAS,EAAAC,QAAAD,EAAA45B,UAAA55B,EAAA05B,KAEA15B,EAAAlI,OAAAkI,EAAA65B,SAAA,SAAAnT,GACA,GAAAnnB,GAAA,GAAAS,GAAA0jB,EAGA,OAFAnkB,GAAA0wB,qBACA1wB,EAAAynB,gBAAAN,GAAA,GACAnnB,GAGAS,EAAA85B,aAAA,SAAAj0C,GACA,qBAAAA,GAAA,SAAAwD,GAAA,0DACA,IAAAixB,GAAAkF,EAAA+C,SAEA,OADA/C,GAAA+C,UAAA18B,EACAy0B,GAGAta,EAAAtc,UAAAugC,MAAA,SACAsD,EACAC,EACAC,EACAtM,EACA4e,GAEA,GAAAC,GAAA9rC,SAAA6rC,EACAx6B,EAAAy6B,EAAAD,EAAA,GAAA/5B,GAAA0jB,EAEAsW,KACAz6B,EAAAklB,eAAAvhC,KAAA,GACAqc,EAAA0wB,qBAGA,IAAAn8B,GAAA5Q,KAAAwhC,SACA5wB,KAAA5Q,OACAgL,SAAAitB,MAAAj4B,KAAA2hC,UACAmV,GAAAz6B,EAAA06B,iBAGA,IAAAC,GACApmC,EAAAqmC,cAAA5S,EAAAC,EAAAC,EAAAloB,EAAA4b,EAOA,OALArnB,GAAAyiC,gBAAAziC,EAAAsmC,2BACA5a,EAAA7Y,OACA7S,EAAAumC,+BAAAvmC,EAAAomC,GAGA36B;EAGAS,EAAAtc,UAAA22C,+BAAA,SAAAx2C,GACAX,KAAAosC,yBAAApsC,KAAA0sC,6BACA1sC,KAAAo3C,iBAAAz2C,IAGAmc,EAAAtc,UAAAgjB,QAAA,WACA,cAAAxjB,KAAA0hC,WAGA5kB,EAAAtc,UAAAi0C,kCAAA,WACA,iBAAAz0C,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAA62C,aAAA,WACA,8BAAAr3C,KAAA0hC,YAGA5kB,EAAAtc,UAAA82C,WAAA,SAAA1zC,GACA5D,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,UACA,OAAA99B,GAGAkZ,EAAAtc,UAAA+2C,cAAA,WACAv3C,KAAA0hC,UAAA,UAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAg3C,aAAA,WACAx3C,KAAA0hC,UAAA,UAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAi3C,cAAA,WACAz3C,KAAA0hC,UAAA,UAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAw1C,YAAA,WACAh2C,KAAA0hC,UAAA,SAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAk3C,SAAA,WACA,gBAAA13C,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAAyjC,aAAA,WACA,gBAAAjkC,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAA0jC,gBAAA,WACAlkC,KAAA0hC,UAAA,SAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAqjC,kBAAA,WACA7jC,KAAA0hC,UAAA,UAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAu2C,eAAA,WACA/2C,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAm3C,iBAAA,WACA33C,KAAA0hC,UAAA,SAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAo3C,YAAA,WACA,eAAA53C,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAAw0C,YAAA,SAAAr0C,GACA,GAAA0b,GAAA,IAAA1b,EACAX,KAAAq1C,WACAr1C,KACA,EAAAW,EAAA,IACA,OAAAqK,UAAAqR,GAAArc,KAAA4hC,WACA5hC,KAAA2hC,SAEAtlB,GAGAS,EAAAtc,UAAAu0C,WAAA,SAAAp0C,GACA,WAAAA,EACAX,KAAAo1C,UACAp1C,KAAA,EAAAW,EAAA,MAGAmc,EAAAtc,UAAAq3C,sBAAA,SAAAl3C,GACA,WAAAA,EACAX,KAAA6sC,qBACA7sC,KAAA,EAAAW,EAAA,MAGAmc,EAAAtc,UAAAs3C,oBAAA,SAAAn3C,GACA,WAAAA,EACAX,KAAAm1C,mBACAn1C,KAAA,EAAAW,EAAA,MAGAmc,EAAAtc,UAAAu3C,kBAAA,SAAAC,EAAAr3C,GACA,GAAAs3C,GAAAD,EAAAH,sBAAAl3C,GACAiU,EAAAojC,EAAAF,oBAAAn3C,GACAmgB,EAAAk3B,EAAArD,mBAAAh0C,GACAod,EAAAi6B,EAAAjD,WAAAp0C,GACAs3B,EAAA+f,EAAAhD,YAAAr0C,EACAod,aAAAjB,IAAAiB,EAAAg5B,iBACA/2C,KAAAi3C,cAAAgB,EAAArjC,EAAAkM,EAAA/C,EAAAka,IAGAnb,EAAAtc,UAAAy2C,cAAA,SACAgB,EACArjC,EACAkM,EACA/C,EACAka,GAEA,GAAAt3B,GAAAX,KAAAwjB,SAOA,IALA7iB,GAAA,SACAA,EAAA,EACAX,KAAAs3C,WAAA,IAGA,IAAA32C,EACAX,KAAAo1C,UAAAr3B,EACA/S,SAAAitB,IAAAj4B,KAAAq1C,WAAApd,GACA,kBAAAggB,IAAAj4C,KAAA8sC,0BACA9sC,KAAA6sC,qBAAAoL,GACA,kBAAArjC,KAAA5U,KAAAm1C,mBAAAvgC,GACA,kBAAAkM,KAAA9gB,KAAA40C,kBAAA9zB,OACK,CACL,GAAAo3B,GAAA,EAAAv3C,EAAA,CACAX,MAAAk4C,EAAA,GAAAn6B,EACA/d,KAAAk4C,EAAA,GAAAjgB,EACA,kBAAAggB,KACAj4C,KAAAk4C,EAAA,GAAAD,GACA,kBAAArjC,KACA5U,KAAAk4C,EAAA,GAAAtjC,GACA,kBAAAkM,KACA9gB,KAAAk4C,EAAA,GAAAp3B,GAGA,MADA9gB,MAAAs3C,WAAA32C,EAAA,GACAA,GAGAmc,EAAAtc,UAAA23C,kBAAA,SAAAlgB,EAAAmgB,GACA,GAAAz3C,GAAAX,KAAAwjB,SAMA,IAJA7iB,GAAA,SACAA,EAAA,EACAX,KAAAs3C,WAAA,IAEA,IAAA32C,EACAX,KAAAo1C,UAAAgD,EACAp4C,KAAAq1C,WAAApd,MACK,CACL,GAAAigB,GAAA,EAAAv3C,EAAA,CACAX,MAAAk4C,EAAA,GAAAE,EACAp4C,KAAAk4C,EAAA,GAAAjgB,EAEAj4B,KAAAs3C,WAAA32C,EAAA,IAGAmc,EAAAtc,UAAA8yC,mBAAA,SAAA+E,EAAA13C,GACAX,KAAAm4C,kBAAAE,EAAA13C,IAGAmc,EAAAtc,UAAA4gC,iBAAA,SAAAz7B,EAAA2yC,GACA,IAAAt4C,KAAAy0C,oCAAA,CACA,GAAA9uC,IAAA3F,KACA,MAAAA,MAAA8jC,gBAAA0R,KAAA,KACA,IAAAlU,GAAAb,EAAA96B,EAAA3F,KACA,MAAAshC,YAAAxkB,IAAA,MAAA9c,MAAAu4C,SAAA5yC,EAEA,IAAA6yC,GAAA,GAAAF,EAAA,IACAt4C,MAAAuhC,eAAAD,EAAAkX,EACA,IAAAz6B,GAAAujB,EAAAE,SACA,IAAAzjB,EAAAojB,aAAA,CAEA,OADAv9B,GAAA5D,KAAAwjB,UACAvF,EAAA,EAAuBra,EAAAqa,IAASA,EAChCF,EAAAg6B,kBAAA/3C,KAAAie,EAEAje,MAAAy3C,gBACAz3C,KAAAs3C,WAAA,GACAt3C,KAAAy4C,aAAA16B,OACKA,GAAAw1B,eACLvzC,KAAAy2C,kBAAA14B,EAAA01B,UAEAzzC,KAAA04C,iBAAA36B,EAAAy1B,UACAz1B,EAAAsuB,2BAIAvvB,EAAAtc,UAAAsjC,gBACA,SAAAN,EAAAmV,EAAAC,GACAA,GACAvW,EAAAwW,+BAAArV,EAEA,IAAAiE,GAAApF,EAAAyW,kBAAAtV,GACAuV,EAAAtR,IAAAjE,CACAxjC,MAAAgtC,kBAAAvF,EAAAkR,EAAAI,GAAA,GACA/4C,KAAA2gC,QAAA6C,EAAAuV,EAAA/tC,OAAAy8B,IAGA3qB,EAAAtc,UAAA80C,qBAAA,SAAAJ,GACA,GAAAn3B,GAAA/d,IACAA,MAAA+sC,qBACA/sC,KAAAwrC,cACA,IAAAmN,IAAA,EACAl3C,EAAAu4B,EAAAkb,GAAA,SAAAvvC,GACA,OAAAoY,IACAA,EAAAqjB,iBAAAz7B,GACAoY,EAAA,OACK,SAAAylB,GACL,OAAAzlB,IACAA,EAAA+lB,gBAAAN,EAAAmV,GACA56B,EAAA,OAEA46B,IAAA,EACA34C,KAAAyrC,cAEAzgC,SAAAvJ,OAAAkpC,GAAA,OAAA5sB,IACAA,EAAA+lB,gBAAAriC,EAAAF,GAAA,MACAwc,EAAA,OAIAjB,EAAAtc,UAAAw4C,0BAAA,SACAxI,EAAAvY,EAAAtyB,EAAAoY,GAEA,IAAAA,EAAAk7B,cAAA,CACAl7B,EAAAytB,cACA,IAAA7nC,EAQA,IAJAA,EAHAs0B,IAAAyd,GAAA11C,KAAAi5C,cAGAjf,EAAAwW,GAAA9vC,KAAAu3B,EAAAtyB,GAFAq0B,EAAAwW,GAAAvvC,MAAAjB,KAAA2hC,SAAAh8B,GAIAoY,EAAA0tB,cAEA9nC,IAAAgnC,GAAAhnC,IAAAoa,GAAApa,IAAAsmC,EAAA,CACA,GAAA7sB,GAAAzZ,IAAAoa,EAAAy3B,IAAA7xC,EAAApC,CACAwc,GAAA+lB,gBAAA1mB,GAAA,UAEAW,GAAAqjB,iBAAAz9B,KAIAmZ,EAAAtc,UAAAghC,QAAA,WAEA,IADA,GAAAnlB,GAAArc,KACAqc,EAAAg7B,gBAAAh7B,IAAA68B,WACA,OAAA78B,IAGAS,EAAAtc,UAAA04C,UAAA,WACA,MAAAl5C,MAAAm1C,oBAGAr4B,EAAAtc,UAAAi4C,aAAA,SAAA16B,GACA/d,KAAAm1C,mBAAAp3B,GAGAjB,EAAAtc,UAAA24C,aAAA,WACAn5C,KAAAikC,iBACAjkC,KAAA4jC,oBAAA54B,SAIA8R,EAAAtc,UAAA+gC,eAAA,SAAAmC,EAAAzP,IACA,EAAAA,GAAA,GAAAyP,EAAAO,iBACAjkC,KAAAkkC,kBACAlkC,KAAA4jC,oBAAAF,IAEA,EAAAzP,GAAA,GAAAyP,EAAA9B,YACA5hC,KAAAkhC,YAAAwC,EAAA/B,WAIA7kB,EAAAtc,UAAA+3C,SAAA,SAAA5yC,GACA3F,KAAAy0C,qCACAz0C,KAAAy2C,kBAAA9wC,IAGAmX,EAAAtc,UAAAmgC,QAAA,SAAA6C,EAAA4V,GACAp5C,KAAAy0C,qCACAz0C,KAAA04C,iBAAAlV,EAAA4V,IAGAt8B,EAAAtc,UAAA42C,iBAAA,SAAAz2C,GACA,GAAAod,GAAA/d,KAAA+0C,WAAAp0C,GACA4c,EAAAQ,YAAAjB,EAEA,IAAAS,GAAAQ,EAAA65B,cAEA,MADA75B,GAAA45B,mBACArb,EAAA7Y,OAAAzjB,KAAAo3C,iBAAAp3C,KAAAW,EAEA,IAAA6vC,GAAAxwC,KAAAuzC,eACAvzC,KAAA63C,sBAAAl3C,GACAX,KAAA83C,oBAAAn3C,GAEAy4C,EACAp5C,KAAA8sC,wBAAA9sC,KAAAqsC,wBAAArhC,OACArF,EAAA3F,KAAAssC,cACArU,EAAAj4B,KAAAg1C,YAAAr0C,EAGAX,MAAAq5C,0BAAA14C,GAEA,kBAAA6vC,GACAjzB,EAGAvd,KAAAg5C,0BAAAxI,EAAAvY,EAAAtyB,EAAAoY,GAFAyyB,EAAA9vC,KAAAu3B,EAAAtyB,EAAAoY,GAIKka,YAAAma,GACLna,EAAAob,gBACArzC,KAAAuzC,eACAtb,EAAAib,kBAAAvtC,EAAAoY,GAGAka,EAAAqhB,iBAAA3zC,EAAAoY,IAGKR,IACLvd,KAAAuzC,eACAx1B,EAAAw6B,SAAA5yC,GAEAoY,EAAA4iB,QAAAh7B,EAAAyzC,IAIAz4C,GAAA,WAAAA,IACA27B,EAAAuD,YAAA7/B,KAAAs3C,WAAAt3C,KAAA,IAGA8c,EAAAtc,UAAA64C,0BAAA,SAAA14C,GACA,OAAAA,EACAX,KAAA8sC,0BACA9sC,KAAA6sC,qBAAA7hC,QAEAhL,KAAAm1C,mBACAn1C,KAAA40C,kBACA50C,KAAAq1C,WACAr1C,KAAAo1C,UAAApqC,WACK,CACL,GAAAktC,GAAA,EAAAv3C,EAAA,CACAX,MAAAk4C,EAAA,GACAl4C,KAAAk4C,EAAA,GACAl4C,KAAAk4C,EAAA,GACAl4C,KAAAk4C,EAAA,GACAl4C,KAAAk4C,EAAA,GAAAltC,SAIA8R,EAAAtc,UAAA02C,wBAAA,WACA,MACA,2BADAl3C,KAAA0hC,YAIA5kB,EAAAtc,UAAA+4C,yBAAA,WACAv5C,KAAA0hC,UAAA,YAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAg5C,2BAAA,WACAx5C,KAAA0hC,UAAA,WAAA1hC,KAAA0hC,WAGA5kB,EAAAtc,UAAAi5C,qBAAA,WACAnd,EAAA0D,eAAAhgC,MACAA,KAAAu5C,4BAGAz8B,EAAAtc,UAAAi2C,kBAAA,SAAA9wC,GACA,GAAAA,IAAA3F,KAAA,CACA,GAAAod,GAAAo4B,GAEA,OADAx1C,MAAAgtC,kBAAA5vB,GACApd,KAAA04C,iBAAAt7B,EAAApS,QAEAhL,KAAAu3C,gBACAv3C,KAAAssC,cAAA3mC,EACA3F,KAAAm5C,eAEAn5C,KAAAwjB,UAAA,GACAxjB,KAAAy5C,wBAIA38B,EAAAtc,UAAAk5C,2BAAA,SAAAlW,GACA,GAAAiE,GAAApF,EAAAyW,kBAAAtV,EACAxjC,MAAA04C,iBAAAlV,EAAAiE,IAAAjE,EAAAx4B,OAAAy8B,IAGA3qB,EAAAtc,UAAAk4C,iBAAA,SAAAlV,EAAAiE,GACA,GAAAjE,IAAAxjC,KAAA,CACA,GAAAod,GAAAo4B,GAEA,OADAx1C,MAAAgtC,kBAAA5vB,GACApd,KAAA04C,iBAAAt7B,GAMA,MAJApd,MAAAw3C,eACAx3C,KAAAssC,cAAA9I,EACAxjC,KAAAm5C,eAEAn5C,KAAA03C,eACApb,GAAAsD,WAAA,SAAAr+B,GAKA,KAJA,SAAAA,IACA+6B,EAAAyD,YACA4E,EAAAiD,mBAAA58B,OAAAzJ,GAEAA,GACSyJ,SAAAy8B,EAAAjE,EAAAiE,IAITz8B,SAAAy8B,OAAAjE,GACAxjC,KAAA2sC,sBAAAlF,QAGAznC,KAAAwjB,UAAA,EACAxjB,KAAAy5C,uBAEAz5C,KAAAgsC,qCAIAlvB,EAAAtc,UAAA2/B,gBAAA,WACAngC,KAAAw5C,4BAEA,QADA51C,GAAA5D,KAAAwjB,UACAvF,EAAA,EAAmBra,EAAAqa,EAASA,IAC5Bje,KAAAo3C,iBAAAn5B,IAIAnB,EAAA68B,yBAAAnE,EACAjX,EAAA,eAAAzhB,EAAA0jB,EAAAC,EAAAuQ,GACAzS,EAAA,aAAAzhB,EAAA0jB,EAAAC,GACAlC,EAAA,gBAAAzhB,EAAAmtB,EAAAxJ,GACAlC,EAAA,uBAAAzhB,GACAyhB,EAAA,+BAAAzhB,GACAyhB,EAAA,aAAAzhB,EAAAs1B,EAAA3R,EAAAD,GACA1jB,YACAyhB,EAAA,YAAAzhB,EAAAs1B,EAAApB,EAAAvQ,EAAAD,GACAjC,EAAA,cAAAzhB,EAAAk0B,EAAAvQ,EAAA6K,GACA/M,EAAA,mBAAAzhB,EAAAk0B,EAAAxQ,EAAAC,GACAlC,EAAA,gBAAAzhB,GACAyhB,EAAA,eAAAzhB,GACAyhB,EAAA,kBAAAzhB,EAAA0jB,GACAjC,EAAA,cAAAzhB,EAAAs1B,EAAA3R,EAAAuQ,GACAzS,EAAA,aAAAzhB,EAAA0jB,EAAAC,EAAAuQ,GACAzS,EAAA,eAAAzhB,EAAAs1B,EAAApB,EAAAvQ,EAAAD,GACAjC,EAAA,eAAAzhB,EAAAs1B,GACA7T,EAAA,iBAAAzhB,GACAyhB,EAAA,aAAAzhB,EAAAs1B,EAAApB,GACAzS,EAAA,iBAAAzhB,EAAAs1B,GACA7T,EAAA,YAAAzhB,GACAyhB,EAAA,aAAAzhB,EAAA0jB,GACAjC,EAAA,eAAAzhB,EAAA0jB,GACAjC,EAAA,eAAAzhB,EAAA0jB,GAEA6B,EAAAuX,iBAAA98B,GACAulB,EAAAuX,iBAAA98B,EAAAtc,WAYA+0C,GAAe/yC,EAAA,IACf+yC,GAAe9yC,EAAA,IACf8yC,GAAen1C,EAAA,IACfm1C,EAAA,GACAA,EAAA,cACAA,EAAAvqC,QACAuqC,GAAA,GACAA,EAAA,GAAAz4B,GAAA0jB,IACAmE,EAAA0D,UAAA/L,EAAAiD,eAAA8C,EAAAiG,eACAxrB,KAIG+8B,WAAA,EAAArV,aAAA,EAAAsV,YAAA,EAAAC,gBAAA,EAAAC,cAAA,EAAAC,sBAAA,EAAAC,oBAAA,EAAAC,eAAA,EAAAC,qBAAA,GAAAC,sBAAA,GAAAC,YAAA,GAAA7V,cAAA,GAAA8V,cAAA,GAAAC,eAAA,GAAAC,kBAAA,GAAAC,YAAA,GAAAC,WAAA,GAAAC,cAAA,GAAAC,eAAA,GAAAC,gBAAA,GAAAC,qBAAA,GAAAC,wBAAA,GAAAC,iBAAA,GAAAC,aAAA,GAAAC,YAAA,GAAAC,cAAA,GAAAC,cAAA,GAAAC,YAAA,GAAAC,8BAAA,GAAAC,iBAAA,GAAAC,cAAA,GAAAC,aAAA,GAAAvY,YAAA,KAAmmBzF,IAAA,SAAAa,EAAA7/B,GACtmB,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,EAAAC,EACAuQ,GAIA,QAAA2K,GAAAx2C,GACA,OAAAA,GACA,eACA,kBAIA,QAAAitC,GAAAv7B,GACA,GACA6sB,GADA3lB,EAAA/d,KAAAuqC,SAAA,GAAAztB,GAAA0jB,EAEA3pB,aAAAiG,KACA4mB,EAAA7sB,EACAkH,EAAAwjB,eAAAmC,EAAA,IAEA1jC,KAAAmzC,QAAAt8B,EACA7W,KAAAwjB,QAAA,EACAxjB,KAAA2zC,eAAA,EACA3zC,KAAAizC,MAAAjoC,OAAA,IApBA,GAAAq3B,GAAA9D,EAAA,aACAr5B,EAAAm9B,EAAAn9B,OAwIA,OAnHAktC,GAAA5xC,UAAAsC,OAAA,WACA,MAAA9C,MAAAwjB,SAGA4uB,EAAA5xC,UAAAud,QAAA,WACA,MAAA/d,MAAAuqC,UAGA6H,EAAA5xC,UAAAyyC,MAAA,QAAAz4B,GAAA4I,EAAAw4B,GACA,GAAA/kC,GAAA4pB,EAAAzgC,KAAAmzC,QAAAnzC,KAAAuqC,SACA,IAAA1zB,YAAAiG,GAAA,CAGA,GAFAjG,IAAA2qB,UACAxhC,KAAAmzC,QAAAt8B,GACAA,EAAA08B,eAOS,MAAA18B,GAAAsqB,iBACTtqB,GAAAkqB,MACAvmB,EACAxa,KAAA2gC,QACA31B,OACAhL,KACA47C,OAIA57C,MAAA2gC,QAAA9pB,EAAA28B,UAfA,IADA38B,IAAA48B,UACAvuC,EAAA2R,GAAA,CACA,GAAAuG,GAAA,GAAAN,GAAA3W,UAAA,gFAEA,YADAnG,MAAA67C,eAAAz+B,QAgBK,KAAAlY,EAAA2R,GAEL,WADA7W,MAAAuqC,SAAA5J,QAAAqQ,EAAA,iFAAAwC,UAIA,QAAA38B,EAAA/T,OAOA,YANA,KAAA84C,EACA57C,KAAA87C,qBAGA97C,KAAA4zC,SAAA+H,EAAAC,IAIA,IAAAh4C,GAAA5D,KAAA+7C,gBAAAllC,EAAA/T,OACA9C,MAAAwjB,QAAA5f,EACA5D,KAAAmzC,QAAAnzC,KAAAg8C,mBAAA,GAAAz7C,OAAAqD,GAAA5D,KAAAmzC,OAEA,QADAp1B,GAAA/d,KAAAuqC,SACAtsB,EAAA,EAAmBra,EAAAqa,IAASA,EAAA,CAC5B,GAAAg4B,GAAAj2C,KAAAqzC,cACA/R,EAAAb,EAAA5pB,EAAAoH,GAAAF,EACAujB,aAAAxkB,IACAwkB,IAAAE,UACAyU,EACA3U,EAAAoL,6BACapL,EAAAH,aACbG,EAAAgS,mBAAAtzC,KAAAie,GACaqjB,EAAAiS,eACbvzC,KAAAkzC,kBAAA5R,EAAAmS,SAAAx1B,GAEAje,KAAAs5C,iBAAAhY,EAAAkS,UAAAv1B,IAESg4B,GACTj2C,KAAAkzC,kBAAA5R,EAAArjB,KAKAm0B,EAAA5xC,UAAA6yC,YAAA,WACA,cAAArzC,KAAAmzC,SAGAf,EAAA5xC,UAAAozC,SAAA,SAAAjuC,GACA3F,KAAAmzC,QAAA,KACAnzC,KAAAuqC,SAAAgO,SAAA5yC,IAGAysC,EAAA5xC,UAAAq7C,eACAzJ,EAAA5xC,UAAAmgC,QAAA,SAAA6C,GACAxjC,KAAAmzC,QAAA,KACAnzC,KAAAuqC,SAAAzG,gBAAAN,GAAA,OAGA4O,EAAA5xC,UAAAy0C,mBAAA,SAAAT,EAAA7zC,GACAX,KAAAuqC,SAAA9I,WACA9gC,QACAgF,MAAA6uC,KAKApC,EAAA5xC,UAAA0yC,kBAAA,SAAAvtC,EAAAhF,GACAX,KAAAmzC,QAAAxyC,GAAAgF,CACA,IAAA+tC,KAAA1zC,KAAA2zC,cACAD,IAAA1zC,KAAAwjB,SACAxjB,KAAA4zC,SAAA5zC,KAAAmzC,UAIAf,EAAA5xC,UAAA84C,iBAAA,SAAA9V,GACAxjC,KAAA2zC,iBACA3zC,KAAA2gC,QAAA6C,IAGA4O,EAAA5xC,UAAAw7C,iBAAA,WACA,UAGA5J,EAAA5xC,UAAAu7C,gBAAA,SAAAn4C,GACA,MAAAA,IAGAwuC,KAGGjP,YAAA,KAAe/E,IAAA,SAAAG,EAAA7/B,GAClB,YASA,SAAAu9C,GAAAx3C,GACA,MAAAA,aAAA2D,QACAumC,EAAA1lB,eAAAxkB,KAAA2D,MAAA5H,UAIA,QAAA07C,GAAAz3C,GACA,GAAA4X,EACA,IAAA4/B,EAAAx3C,GAAA,CACA4X,EAAA,GAAAkyB,GAAA9pC,GACA4X,EAAAxV,KAAApC,EAAAoC,KACAwV,EAAA+lB,QAAA39B,EAAA29B,QACA/lB,EAAAmpB,MAAA/gC,EAAA+gC,KAEA,QADAj0B,GAAAo9B,EAAAp9B,KAAA9M,GACAwZ,EAAA,EAAuBA,EAAA1M,EAAAzO,SAAiBmb,EAAA,CACxC,GAAAvZ,GAAA6M,EAAA0M,EACAk+B,GAAAjvC,KAAAxI,KACA2X,EAAA3X,GAAAD,EAAAC,IAGA,MAAA2X,GAGA,MADAgmB,GAAAwW,+BAAAp0C,GACAA,EAGA,QAAAmxC,GAAA73B,GACA,gBAAAX,EAAAzX,GACA,UAAAoY,EAAA,CAEA,GAAAX,EAAA,CACA,GAAAg/B,GAAAF,EAAAG,EAAAj/B,GACAW,GAAAivB,kBAAAoP,GACAr+B,EAAA4iB,QAAAyb,OACS,IAAAr8C,UAAA+C,OAAA,GACgE,OAAzE+/B,GAAA9iC,UAAA+C,OAAyChD,EAAA,GAAAS,OAAAsiC,EAAA,GAAgCC,EAAA,EAAiBD,EAAAC,IAAaA,EAAShjC,EAAAgjC,EAAA,GAAA/iC,UAAA+iC,EAChH/kB,GAAAw6B,SAAAz4C,OAEAie,GAAAw6B,SAAA5yC,EAGAoY,GAAA,OAjDA,GAsDA43B,GAtDAtT,EAAA9D,EAAA,aACA8d,EAAAha,EAAAga,iBACAhZ,EAAA9E,EAAA,eACAsQ,EAAAxL,EAAAwL,aACAN,EAAAlL,EAAAkL,iBACA+N,EAAAja,EAAAia,YACA3N,EAAApQ,EAAA,YAOA4d,EAAA,gCAsDA,IAJAxG,EARA2G,EAQA,SAAAv+B,GACA/d,KAAA+d,WARA,SAAAA,GACA/d,KAAA+d,UACA/d,KAAAu8C,WAAA3G,EAAA73B,GACA/d,KAAAoqC,SAAApqC,KAAAu8C,YAQAD,EAAA,CACA,GAAA9yC,IACAyG,IAAA,WACA,MAAA2lC,GAAA51C,KAAA+d,UAGA4wB,GAAAvtB,eAAAu0B,EAAAn1C,UAAA,aAAAgJ,GACAmlC,EAAAvtB,eAAAu0B,EAAAn1C,UAAA,WAAAgJ,GAGAmsC,EAAAE,oBAAAD,EAEAD,EAAAn1C,UAAA6E,SAAA,WACA,kCAGAswC,EAAAn1C,UAAAuc,QACA44B,EAAAn1C,UAAAy3C,QAAA,SAAAtyC,GACA,KAAA3F,eAAA21C,IACA,SAAAxvC,WAAA,0KAEAnG,MAAA+d,QAAAqjB,iBAAAz7B,IAGAgwC,EAAAn1C,UAAAoU,OAAA,SAAA4uB,GACA,KAAAxjC,eAAA21C,IACA,SAAAxvC,WAAA,0KAEAnG,MAAA+d,QAAA+lB,gBAAAN,IAGAmS,EAAAn1C,UAAAsgB,SAAA,SAAAnb,GACA,KAAA3F,eAAA21C,IACA,SAAAxvC,WAAA,0KAEAnG,MAAA+d,QAAA0jB,UAAA97B,IAGAgwC,EAAAn1C,UAAAujC,OAAA,SAAA3mB,GACApd,KAAA+d,QAAAgmB,OAAA3mB,IAGAu4B,EAAAn1C,UAAAg8C,QAAA,WACAx8C,KAAA4U,OAAA,GAAAi6B,GAAA,aAGA8G,EAAAn1C,UAAAy1C,WAAA,WACA,MAAAj2C,MAAA+d,QAAAk4B,cAGAN,EAAAn1C,UAAA01C,OAAA,WACA,MAAAl2C,MAAA+d,QAAAm4B,UAGAx3C,EAAAC,QAAAg3C,IAEGlR,cAAA,GAAAwG,WAAA,GAAA9H,YAAA,KAA8CsZ,IAAA,SAAAle,EAAA7/B,GACjD,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,GAmBA,QAAAkc,GAAAh4C,GACA,OAAAi4C,EAAAzvC,KAAAxI,GAGA,QAAAk4C,GAAAj6C,GACA,IACA,MAAAA,GAAAk6C,qBAAA,EAEA,MAAAt7C,GACA,UAIA,QAAAu7C,GAAAr4C,EAAAC,EAAAq4C,GACA,GAAA53C,GAAAk9B,EAAA2a,yBAAAv4C,EAAAC,EAAAq4C,EACAE,EACA,OAAA93C,GAAAy3C,EAAAz3C,IAAA,EAEA,QAAA+3C,GAAA7gC,EAAA0gC,EAAAI,GACA,OAAAl/B,GAAA,EAAmBA,EAAA5B,EAAAvZ,OAAgBmb,GAAA,GACnC,GAAAvZ,GAAA2X,EAAA4B,EACA,IAAAk/B,EAAAjwC,KAAAxI,GAEA,OADA04C,GAAA14C,EAAA7D,QAAAs8C,EAAA,IACAp7C,EAAA,EAA2BA,EAAAsa,EAAAvZ,OAAgBf,GAAA,EAC3C,GAAAsa,EAAAta,KAAAq7C,EACA,SAAAj3C,GAAA,qGACAtF,QAAA,KAAAk8C,KAOA,QAAAM,GAAA54C,EAAAs4C,EAAAI,EAAAhuC,GAGA,OAFAoC,GAAA8wB,EAAAib,kBAAA74C,GACA4X,KACA4B,EAAA,EAAmBA,EAAA1M,EAAAzO,SAAiBmb,EAAA,CACpC,GAAAvZ,GAAA6M,EAAA0M,GACAtY,EAAAlB,EAAAC,GACA64C,EAAApuC,IAAAquC,GACA,EAAAA,EAAA94C,EAAAiB,EAAAlB,EACA,mBAAAkB,IACAi3C,EAAAj3C,IACAm3C,EAAAr4C,EAAAC,EAAAq4C,KACA5tC,EAAAzK,EAAAiB,EAAAlB,EAAA84C,IACAlhC,EAAA7I,KAAA9O,EAAAiB,GAIA,MADAu3C,GAAA7gC,EAAA0gC,EAAAI,GACA9gC,EAgIA,QAAAohC,GAAArT,EAAAnS,EAAA7U,EAAAzgB,GAMA,QAAA+6C,KACA,GAAAjM,GAAAxZ,CACAA,KAAA0lB,IAAAlM,EAAAzxC,KACA,IAAA+d,GAAA,GAAAjB,GAAA0jB,EACAziB,GAAAgvB,oBACA,IAAArX,GAAA,gBAAAzkB,IAAAjR,OAAA49C,EACA59C,KAAAiR,GAAAm5B,EACAznC,EAAAizC,EAAA73B,EACA,KACA2X,EAAAz0B,MAAAwwC,EAAAoM,EAAA99C,UAAA4C,IACS,MAAApB,GACTwc,EAAA+lB,gBAAAuY,EAAA96C,IAAA,MAEA,MAAAwc,GAlBA,GAAA6/B,GAAA,WAAmC,MAAA59C,SACnCiR,EAAAm5B,CAoBA,OAnBA,gBAAAn5B,KACAm5B,EAAAznC,GAiBA+6C,EAAAb,mBAAA,EACAa,EAOA,QAAAI,GAAAr5C,EAAAs4C,EAAA5tC,EAAA4uC,GAKA,OAJAZ,GAAA,GAAAx9C,QAAAq+C,EAAAjB,GAAA,KACA3mB,EACAinB,EAAA54C,EAAAs4C,EAAAI,EAAAhuC,GAEA8O,EAAA,EAAAra,EAAAwyB,EAAAtzB,OAAyCc,EAAAqa,EAASA,GAAA,GAClD,GAAAvZ,GAAA0xB,EAAAnY,GACAtb,EAAAyzB,EAAAnY,EAAA,GACAggC,EAAAv5C,EAAAq4C,CACAt4C,GAAAw5C,GAAAF,IAAAG,EACAA,EAAAx5C,EAAAi5C,EAAAj5C,EAAA/B,EAAAo6C,GACAgB,EAAAp7C,EAAA,WACA,MAAAu7C,GAAAx5C,EAAAi5C,EAAAj5C,EAAA/B,EAAAo6C,KAIA,MADA1a,GAAAuX,iBAAAn1C,GACAA,EAGA,QAAA05C,GAAA/T,EAAAnS,GACA,MAAAimB,GAAA9T,EAAAnS,EAAAjtB,OAAAo/B,GApPA,GA0EAgU,GA1EAT,KACAtb,EAAA9D,EAAA,aACAqX,EAAArX,EAAA,yBACAsX,oBACAgI,EAAAxb,EAAAwb,aACAxB,EAAAha,EAAAga,iBACA1Z,EAAAN,EAAAM,YACAx8B,EAAAo4B,EAAA,YAAAp4B,UACAk4C,EAAA,QACApB,GAA0BJ,mBAAA,GAC1BF,EACA,iEACAa,EAAA,SAAA32C,EAAAgC,GACA,MAAAw5B,GAAAO,aAAA/7B,IACA,MAAAA,EAAAyS,OAAA,KACA+oB,EAAAic,QAAAz1C,IAuDAm1C,EAAA,SAAApzC,GACA,MAAAA,GAAA/J,QAAA,gBAqJAq9C,EAAAvb,EACAyb,EACAX,CAyBA3gC,GAAAqhC,UAAA,SAAAx7C,EAAAs1B,GACA,qBAAAt1B,GACA,SAAAwD,GAAA,0DAEA,IAAAy2C,EAAAj6C,GACA,MAAAA,EAEA,IAAA0Z,GAAA8hC,EAAAx7C,EAAA5C,UAAA+C,OAAA,EAAA66C,EAAA1lB,EAEA,OADAoK,GAAAkc,gBAAA57C,EAAA0Z,EAAAqgC,GACArgC,GAGAS,EAAAghC,aAAA,SAAAltC,EAAAm/B,GACA,qBAAAn/B,IAAA,gBAAAA,GACA,SAAAzK,GAAA,+FAEA4pC,GAAA3qC,OAAA2qC,EACA,IAAAgN,GAAAhN,EAAAgN,MACA,iBAAAA,OAAAsB,EACA,IAAAlvC,GAAA4gC,EAAA5gC,MACA,mBAAAA,OAAAquC,EACA,IAAAO,GAAAhO,EAAAgO,WAGA,IAFA,kBAAAA,OAAAG,IAEA7b,EAAAO,aAAAma,GACA,SAAAjwB,YAAA,sEAIA,QADAvb,GAAA8wB,EAAAib,kBAAA1sC,GACAqN,EAAA,EAAmBA,EAAA1M,EAAAzO,SAAiBmb,EAAA,CACpC,GAAAtY,GAAAiL,EAAAW,EAAA0M,GACA,iBAAA1M,EAAA0M,IACAokB,EAAAic,QAAA34C,KACAm4C,EAAAn4C,EAAAnF,UAAAu8C,EAAA5tC,EAAA4uC,GACAD,EAAAn4C,EAAAo3C,EAAA5tC,EAAA4uC,IAIA,MAAAD,GAAAltC,EAAAmsC,EAAA5tC,EAAA4uC,OAKGS,WAAA,GAAAxD,wBAAA,GAAA7X,YAAA,KAAwDsb,IAAA,SAAAlgB,EAAA7/B,GAC3D,YACAA,GAAAC,QAAA,SACAme,EAAAs1B,EAAA3R,EAAAuQ,GAKA,QAAA0N,GAAAj6C,GAIA,OAHA8M,GAAAo9B,EAAAp9B,KAAA9M,GACAb,EAAA2N,EAAAzO,OACA+T,EAAA,GAAAtW,OAAA,EAAAqD,GACAqa,EAAA,EAAmBra,EAAAqa,IAASA,EAAA,CAC5B,GAAAvZ,GAAA6M,EAAA0M,EACApH,GAAAoH,GAAAxZ,EAAAC,GACAmS,EAAAoH,EAAAra,GAAAc,EAEA1E,KAAAwyC,aAAA37B,GAoCA,QAAA1J,GAAA6Q,GACA,GAAA3B,GACAsiC,EAAAle,EAAAziB,EAEA,OAAAJ,GAAA+gC,IAGAtiC,EADKsiC,YAAA7hC,GACL6hC,EAAA5d,MACAjkB,EAAA3P,MAAAnC,6BAEA,GAAA0zC,GAAAC,GAAA5gC,UAGA4gC,YAAA7hC,IACAT,EAAAklB,eAAAod,EAAA,GAEAtiC,GAXA20B,EAAA,6EAtDA,GAAA3O,GAAA9D,EAAA,aACA3gB,EAAAykB,EAAAzkB,SACA+wB,EAAApQ,EAAA,WAaA8D,GAAAwE,SAAA6X,EAAAtM,GAEAsM,EAAAl+C,UAAAyyC,MAAA,WACAjzC,KAAA8yC,OAAA9nC,OAAA,KAGA0zC,EAAAl+C,UAAA0yC,kBAAA,SAAAvtC,EAAAhF,GACAX,KAAAmzC,QAAAxyC,GAAAgF,CACA,IAAA+tC,KAAA1zC,KAAA2zC,cACA,IAAAD,GAAA1zC,KAAAwjB,QAAA,CAGA,OAFAre,MACAy5C,EAAA5+C,KAAA8C,SACAmb,EAAA,EAAAra,EAAA5D,KAAA8C,SAA4Cc,EAAAqa,IAASA,EACrD9Y,EAAAnF,KAAAmzC,QAAAl1B,EAAA2gC,IAAA5+C,KAAAmzC,QAAAl1B,EAEAje,MAAA4zC,SAAAzuC,KAIAu5C,EAAAl+C,UAAAy0C,mBAAA,SAAAtvC,EAAAhF,GACAX,KAAAuqC,SAAA9I,WACA/8B,IAAA1E,KAAAmzC,QAAAxyC,EAAAX,KAAA8C,UACA6C,WAIA+4C,EAAAl+C,UAAAw7C,iBAAA,WACA,UAGA0C,EAAAl+C,UAAAu7C,gBAAA,SAAAn4C,GACA,MAAAA,IAAA,GAsBAkZ,EAAAtc,UAAA2M,MAAA,WACA,MAAAA,GAAAnN,OAGA8c,EAAA3P,MAAA,SAAA6Q,GACA,MAAA7Q,GAAA6Q,OAIGitB,WAAA,GAAA9H,YAAA,KAA6B0b,IAAA,SAAAtgB,EAAA7/B,GAChC,YACA,SAAAogD,GAAA72B,EAAA82B,EAAAC,EAAAC,EAAAr7C,GACA,OAAA7B,GAAA,EAAmB6B,EAAA7B,IAASA,EAC5Bi9C,EAAAj9C,EAAAk9C,GAAAh3B,EAAAlmB,EAAAg9C,GACA92B,EAAAlmB,EAAAg9C,GAAA,OAIA,QAAA9f,GAAAigB,GACAl/C,KAAAm/C,UAAAD,EACAl/C,KAAAwjB,QAAA,EACAxjB,KAAAo/C,OAAA,EAGAngB,EAAAz+B,UAAA6+C,oBAAA,SAAAC,GACA,MAAAt/C,MAAAm/C,UAAAG,GAGArgB,EAAAz+B,UAAAy/B,SAAA,SAAAp2B,GACA,GAAA/G,GAAA9C,KAAA8C,QACA9C,MAAAu/C,eAAAz8C,EAAA,EACA,IAAAmb,GAAAje,KAAAo/C,OAAAt8C,EAAA9C,KAAAm/C,UAAA,CACAn/C,MAAAie,GAAApU,EACA7J,KAAAwjB,QAAA1gB,EAAA,GAGAm8B,EAAAz+B,UAAAg/C,YAAA,SAAA75C,GACA,GAAAu5C,GAAAl/C,KAAAm/C,SACAn/C,MAAAu/C,eAAAv/C,KAAA8C,SAAA,EACA,IAAA28C,GAAAz/C,KAAAo/C,OACAnhC,GAAAwhC,EAAA,EACAP,EAAA,EAAAA,IACAl/C,MAAAie,GAAAtY,EACA3F,KAAAo/C,OAAAnhC,EACAje,KAAAwjB,QAAAxjB,KAAA8C,SAAA,GAGAm8B,EAAAz+B,UAAAstB,QAAA,SAAAnrB,EAAAs1B,EAAApuB,GACA7J,KAAAw/C,YAAA31C,GACA7J,KAAAw/C,YAAAvnB,GACAj4B,KAAAw/C,YAAA78C,IAGAs8B,EAAAz+B,UAAAgT,KAAA,SAAA7Q,EAAAs1B,EAAApuB,GACA,GAAA/G,GAAA9C,KAAA8C,SAAA,CACA,IAAA9C,KAAAq/C,oBAAAv8C,GAIA,MAHA9C,MAAAigC,SAAAt9B,GACA3C,KAAAigC,SAAAhI,OACAj4B,MAAAigC,SAAAp2B,EAGA,IAAA9H,GAAA/B,KAAAo/C,OAAAt8C,EAAA,CACA9C,MAAAu/C,eAAAz8C,EACA,IAAA48C,GAAA1/C,KAAAm/C,UAAA,CACAn/C,MAAA+B,EAAA,EAAA29C,GAAA/8C,EACA3C,KAAA+B,EAAA,EAAA29C,GAAAznB,EACAj4B,KAAA+B,EAAA,EAAA29C,GAAA71C,EACA7J,KAAAwjB,QAAA1gB,GAGAm8B,EAAAz+B,UAAAof,MAAA,WACA,GAAA6/B,GAAAz/C,KAAAo/C,OACA/iC,EAAArc,KAAAy/C,EAKA,OAHAz/C,MAAAy/C,GAAAz0C,OACAhL,KAAAo/C,OAAAK,EAAA,EAAAz/C,KAAAm/C,UAAA,EACAn/C,KAAAwjB,UACAnH,GAGA4iB,EAAAz+B,UAAAsC,OAAA,WACA,MAAA9C,MAAAwjB,SAGAyb,EAAAz+B,UAAA++C,eAAA,SAAAD,GACAt/C,KAAAm/C,UAAAG,GACAt/C,KAAA2/C,UAAA3/C,KAAAm/C,WAAA,IAIAlgB,EAAAz+B,UAAAm/C,UAAA,SAAAT,GACA,GAAAU,GAAA5/C,KAAAm/C,SACAn/C,MAAAm/C,UAAAD,CACA,IAAAO,GAAAz/C,KAAAo/C,OACAt8C,EAAA9C,KAAAwjB,QACAq8B,EAAAJ,EAAA38C,EAAA88C,EAAA,CACAd,GAAA9+C,KAAA,EAAAA,KAAA4/C,EAAAC,IAGAnhD,EAAAC,QAAAsgC,OAEI6gB,IAAA,SAAAvhB,EAAA7/B,GACJ,YACAA,GAAAC,QAAA,SACAme,EAAA0jB,EAAAC,EAAAuQ,GASA,QAAA9a,GAAAlY,EAAA0lB,GACA,GAAApC,GAAAb,EAAAziB,EAEA,IAAAsjB,YAAAxkB,GACA,MAAAijC,GAAAze,EACK,KAAAp8B,EAAA8Y,GACL,MAAAgzB,GAAA,gFAGA,IAAA30B,GAAA,GAAAS,GAAA0jB,EACAx1B,UAAA04B,GACArnB,EAAAklB,eAAAmC,EAAA,EAIA,QAFAuU,GAAA57B,EAAAk8B,SACA3jC,EAAAyH,EAAAskB,QACA1iB,EAAA,EAAAra,EAAAoa,EAAAlb,OAA0Cc,EAAAqa,IAASA,EAAA,CACnD,GAAA9Y,GAAA6Y,EAAAC,IAEAjT,SAAA7F,GAAA8Y,IAAAD,KAIAlB,EAAA05B,KAAArxC,GAAA47B,MAAAkX,EAAArjC,EAAA5J,OAAAqR,EAAA,MAEA,MAAAA,GAhCA,GAAAnX,GAAAq5B,EAAA,aAAAr5B,QAEA66C,EAAA,SAAAhiC,GACA,MAAAA,GAAAnY,KAAA,SAAA8e,GACA,MAAAwR,GAAAxR,EAAA3G,KA+BAjB,GAAAoZ,KAAA,SAAAlY,GACA,MAAAkY,GAAAlY,EAAAhT,SAGA8R,EAAAtc,UAAA01B,KAAA,WACA,MAAAA,GAAAl2B,KAAAgL,YAKGm4B,YAAA,KAAe6c,IAAA,SAAAzhB,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EACAs1B,EACApB,EACAvQ,EACAD,GAIA,QAAAyf,GAAAjiC,EAAArb,EAAAu9C,EAAAC,GACAngD,KAAAwyC,aAAAx0B,GACAhe,KAAAuqC,SAAAwC,qBACA/sC,KAAAyyC,iBAAA0N,IAAA3f,KAAA,KACAxgC,KAAAogD,eAAAp1C,SAAAk1C,EACAlgD,KAAAqgD,WAAA,EACArgD,KAAAsgD,eAAAtgD,KAAAogD,eAAA,IACApgD,KAAAugD,aAAAv1C,MACA,IAAAs2B,GAAAb,EAAAyf,EAAAlgD,KAAAuqC,UACAoM,GAAA,EACAp5B,EAAA+jB,YAAAxkB,EACAS,KACA+jB,IAAAE,UACAF,EAAAH,aACAG,EAAAgS,mBAAAtzC,KAAA,IACSshC,EAAAiS,gBACT2M,EAAA5e,EAAAmS,SACAzzC,KAAAqgD,WAAA,IAEArgD,KAAA2gC,QAAAW,EAAAkS,WACAmD,GAAA,IAGAp5B,GAAAvd,KAAAogD,iBAAApgD,KAAAqgD,WAAA,GACArgD,KAAAsqC,UAAA3nC,EACA3C,KAAAwgD,OAAAN,EACAvJ,GAAA32C,KAAA8yC,OAAA9nC,OAAA,IA6FA,QAAAijC,GAAAjwB,EAAArb,EAAA89C,EAAAN,GACA,qBAAAx9C,GAAA,MAAAquC,GAAA,0DACA,IAAAtsB,GAAA,GAAAu7B,GAAAjiC,EAAArb,EAAA89C,EAAAN,EACA,OAAAz7B,GAAA3G,UA7HA,GAAAskB,GAAA9D,EAAA,aACAvE,EAAAqI,EAAArI,SACA2Q,EAAAtI,EAAAsI,QA6BAtI,GAAAwE,SAAAoZ,EAAA7N,GAEA6N,EAAAz/C,UAAAyyC,MAAA,aAEAgN,EAAAz/C,UAAAs7C,mBAAA,YACA97C,KAAAqgD,WAAArgD,KAAAogD,iBACApgD,KAAA4zC,SAAA,OAAA5zC,KAAAyyC,oBACAzyC,KAAAwgD,SAIAP,EAAAz/C,UAAA0yC,kBAAA,SAAAvtC,EAAAhF,GACA,GAAAkW,GAAA7W,KAAAmzC,OACAt8B,GAAAlW,GAAAgF,CACA,IAKA+6C,GALA59C,EAAA9C,KAAA8C,SACAswC,EAAApzC,KAAAyyC,iBACAkO,EAAA,OAAAvN,EACAwN,EAAA5gD,KAAAqgD,UACAQ,EAAA7gD,KAAAugD,YAEA,KAAAM,EAEA,IADAA,EAAA7gD,KAAAugD,aAAA,GAAAhgD,OAAAuC,GACA49C,EAAA,EAAgC59C,EAAA49C,IAAyBA,EACzDG,EAAAH,GAAA,CAqBA,IAlBAA,EAAAG,EAAAlgD,GAEA,IAAAA,GAAAX,KAAAogD,gBACApgD,KAAAwgD,OAAA76C,EACA3F,KAAAqgD,UAAAO,GAAA,EACAC,EAAAlgD,GAAA,IAAA+/C,EACA,KACK,KAAA//C,GACLX,KAAAwgD,OAAA76C,EACA3F,KAAAqgD,UAAAO,GAAA,GAEA,IAAAF,EACAG,EAAAlgD,GAAA,GAEAkgD,EAAAlgD,GAAA,EACAX,KAAAwgD,OAAA76C,GAGAi7C,EAAA,CAMA,OAFAvkC,GAFA+tB,EAAApqC,KAAAsqC,UACArS,EAAAj4B,KAAAuqC,SAAA5I,SAGA1jB,EAAAje,KAAAsgD,eAAqCx9C,EAAAmb,IAAYA,EAEjD,GADAyiC,EAAAG,EAAA5iC,GACA,IAAAyiC,EAAA,CAIA,OAAAA,EAAA,MAaA,IAZA/6C,EAAAkR,EAAAoH,GACAje,KAAAuqC,SAAAiB,eACAmV,GACAvN,EAAA5/B,KAAA7N,GACA0W,EAAA2d,EAAAoQ,GAAA1pC,KAAAu3B,EAAAtyB,EAAAsY,EAAAnb,IAGAuZ,EAAA2d,EAAAoQ,GACA1pC,KAAAu3B,EAAAj4B,KAAAwgD,OAAA76C,EAAAsY,EAAAnb,GAEA9C,KAAAuqC,SAAAkB,cAEApvB,IAAAsuB,EAAA,MAAA3qC,MAAA2gC,QAAAtkB,EAAA9a,EAEA,IAAA+/B,GAAAb,EAAApkB,EAAArc,KAAAuqC,SACA,IAAAjJ,YAAAxkB,GAAA,CAEA,GADAwkB,IAAAE,UACAF,EAAAH,aAEA,MADA0f,GAAA5iC,GAAA,EACAqjB,EAAAgS,mBAAAtzC,KAAAie,EACa,KAAAqjB,EAAAiS,eAGb,MAAAvzC,MAAA2gC,QAAAW,EAAAkS,UAFAn3B,GAAAilB,EAAAmS,SAMAzzC,KAAAsgD,eAAAriC,EAAA,EACAje,KAAAwgD,OAAAnkC,MAhCArc,MAAAsgD,eAAAriC,EAAA,CAmCAje,MAAA4zC,SAAA+M,EAAAvN,EAAApzC,KAAAwgD,UASA1jC,EAAAtc,UAAAytC,OAAA,SAAAtrC,EAAA89C,GACA,MAAAxS,GAAAjuC,KAAA2C,EAAA89C,EAAA,OAGA3jC,EAAAmxB,OAAA,SAAAjwB,EAAArb,EAAA89C,EAAAN,GACA,MAAAlS,GAAAjwB,EAAArb,EAAA89C,EAAAN,OAIGhd,YAAA,KAAe2d,IAAA,SAAAviB,EAAA7/B,GAClB,YACA,IAAA4gC,EACA,IAAAf,EAAA,aAAA2K,OAAA,CACA,GAAA6X,GAAAviC,EAAAwiC,SAAAha,KAAArzB,MAAA,KAAAzB,IAAA3M,OACA+5B,GAAA,IAAAyhB,EAAA,IAAAA,EAAA,OAAAA,EAAA,KACAjpC,EAAA6G,aAAAH,EAAAC,aAEA,mBAAAI,mBACAygB,EAAA,SAAA38B,GACA,GAAAs+C,GAAAniD,SAAAqgB,cAAA,OACAC,EAAA,GAAAP,kBAAAlc,EAEA,OADAyc,GAAAE,QAAA2hC,GAA+B1hC,YAAA,IAC/B,WAA2B0hC,EAAAC,UAAAC,OAAA,SAE3B7hB,EAAAnZ,UAAA,GAGAmZ,EADA,mBAAAzf,YACA,SAAAld,GACAkd,WAAAld,EAAA,IAIA,WACA,SAAAyF,OAAA,kEAGA1J,GAAAC,QAAA2gC,IAEG6D,YAAA,KAAeie,IAAA,SAAA7iB,EAAA7/B,GAClB,YACAA,GAAAC,QACA,SAAAme,EAAAs1B,GAIA,QAAAiP,GAAAxqC,GACA7W,KAAAwyC,aAAA37B,GAJA,GAAA4+B,GAAA34B,EAAA24B,kBACApT,EAAA9D,EAAA,YAKA8D,GAAAwE,SAAAwa,EAAAjP,GAEAiP,EAAA7gD,UAAA8gD,iBAAA,SAAA3gD,EAAA4gD,GACAvhD,KAAAmzC,QAAAxyC,GAAA4gD,CACA,IAAA7N,KAAA1zC,KAAA2zC,cACAD,IAAA1zC,KAAAwjB,SACAxjB,KAAA4zC,SAAA5zC,KAAAmzC,UAIAkO,EAAA7gD,UAAA0yC,kBAAA,SAAAvtC,EAAAhF,GACA,GAAA0b,GAAA,GAAAo5B,EACAp5B,GAAAqlB,UAAA,UACArlB,EAAAiwB,cAAA3mC,EACA3F,KAAAshD,iBAAA3gD,EAAA0b,IAEAglC,EAAA7gD,UAAA84C,iBAAA,SAAA9V,EAAA7iC,GACA,GAAA0b,GAAA,GAAAo5B,EACAp5B,GAAAqlB,UAAA,UACArlB,EAAAiwB,cAAA9I,EACAxjC,KAAAshD,iBAAA3gD,EAAA0b,IAGAS,EAAA0kC,OAAA,SAAAxjC,GACA,UAAAqjC,GAAArjC,GAAAD,WAGAjB,EAAAtc,UAAAghD,OAAA,WACA,UAAAH,GAAArhD,MAAA+d,cAIGolB,YAAA,KAAese,IAAA,SAAAljB,EAAA7/B,GAClB,YACAA,GAAAC,QACA,SAAAme,EAAAs1B,EAAApB,GAOA,QAAAvS,GAAA5nB,GACA7W,KAAAwyC,aAAA37B,GACA7W,KAAA0hD,SAAA,EACA1hD,KAAA2hD,SAAA,EACA3hD,KAAA4hD,cAAA,EA2FA,QAAAC,GAAA7jC,EAAA8jC,GACA,MAAAA,QAAA,EAAAA,EACA,MAAA9Q,GAAA,iEAEA,IAAA30B,GAAA,GAAAoiB,GAAAzgB,GACAD,EAAA1B,EAAA0B,SAGA,OAFA1B,GAAAqiB,WAAAojB,GACAzlC,EAAA7B,OACAuD,EA7GA,GAAAskB,GAAA9D,EAAA,aACAzR,EAAAyR,EAAA,eAAAzR,WACAgiB,EAAAvQ,EAAA,eAAAuQ,eACA5pC,EAAAm9B,EAAAn9B,OASAm9B,GAAAwE,SAAApI,EAAA2T,GAEA3T,EAAAj+B,UAAAyyC,MAAA,WACA,GAAAjzC,KAAA4hD,aAAA,CAGA,OAAA5hD,KAAA0hD,SAEA,WADA1hD,MAAA4zC,YAGA5zC,MAAA8yC,OAAA9nC,OAAA,GACA,IAAA+2C,GAAA78C,EAAAlF,KAAAmzC,UACAnzC,KAAAqzC,eACA0O,GACA/hD,KAAA0hD,SAAA1hD,KAAAgiD,uBACAhiD,KAAA2gC,QAAA3gC,KAAAiiD,eAAAjiD,KAAA8C,aAIA27B,EAAAj+B,UAAAga,KAAA,WACAxa,KAAA4hD,cAAA,EACA5hD,KAAAizC,SAGAxU,EAAAj+B,UAAAm+B,UAAA,WACA3+B,KAAA2hD,SAAA,GAGAljB,EAAAj+B,UAAAshD,QAAA,WACA,MAAA9hD,MAAA0hD,UAGAjjB,EAAAj+B,UAAAk+B,WAAA,SAAA1pB,GACAhV,KAAA0hD,SAAA1sC,GAGAypB,EAAAj+B,UAAA0yC,kBAAA,SAAAvtC,GACA3F,KAAAkiD,cAAAv8C,GACA3F,KAAAmiD,eAAAniD,KAAA8hD,YACA9hD,KAAAmzC,QAAArwC,OAAA9C,KAAA8hD,UAEA9hD,KAAA4zC,SADA,IAAA5zC,KAAA8hD,WAAA9hD,KAAA2hD,QACA3hD,KAAAmzC,QAAA,GAEAnzC,KAAAmzC,WAKA1U,EAAAj+B,UAAA84C,iBAAA,SAAA9V,GAEA,GADAxjC,KAAAoiD,aAAA5e,GACAxjC,KAAA8hD,UAAA9hD,KAAAgiD,sBAAA,CAEA,OADAzgD,GAAA,GAAAutC,GACA7wB,EAAAje,KAAA8C,SAAmCmb,EAAAje,KAAAmzC,QAAArwC,SAAyBmb,EAC5D1c,EAAAiS,KAAAxT,KAAAmzC,QAAAl1B,GAEAje,MAAA2gC,QAAAp/B,KAIAk9B,EAAAj+B,UAAA2hD,WAAA,WACA,MAAAniD,MAAA2zC,gBAGAlV,EAAAj+B,UAAA6hD,UAAA,WACA,MAAAriD,MAAAmzC,QAAArwC,OAAA9C,KAAA8C,UAGA27B,EAAAj+B,UAAA4hD,aAAA,SAAA5e,GACAxjC,KAAAmzC,QAAA3/B,KAAAgwB,IAGA/E,EAAAj+B,UAAA0hD,cAAA,SAAAv8C,GACA3F,KAAAmzC,QAAAnzC,KAAA2zC,kBAAAhuC,GAGA84B,EAAAj+B,UAAAwhD,oBAAA,WACA,MAAAhiD,MAAA8C,SAAA9C,KAAAqiD,aAGA5jB,EAAAj+B,UAAAyhD,eAAA,SAAAjtC,GACA,GAAAotB,GAAA,qCACApiC,KAAA0hD,SAAA,4BAAA1sC,EAAA,QACA,WAAA8X,GAAAsV,IAGA3D,EAAAj+B,UAAAs7C,mBAAA,WACA97C,KAAA2gC,QAAA3gC,KAAAiiD,eAAA,KAcAnlC,EAAA+kC,KAAA,SAAA7jC,EAAA8jC,GACA,MAAAD,GAAA7jC,EAAA8jC,IAGAhlC,EAAAtc,UAAAqhD,KAAA,SAAAC,GACA,MAAAD,GAAA7hD,KAAA8hD,IAGAhlC,EAAA8hB,kBAAAH,KAGGgG,cAAA,GAAAtB,YAAA,KAAgCmf,IAAA,SAAA/jB,EAAA7/B,GACnC,YACAA,GAAAC,QAAA,SAAAme,GACA,QAAA24B,GAAA13B,GACA/S,SAAA+S,GACAA,IAAAyjB,UACAxhC,KAAA0hC,UAAA3jB,EAAA2jB,UACA1hC,KAAAssC,cAAAvuB,EAAAuuB,gBAGAtsC,KAAA0hC,UAAA,EACA1hC,KAAAssC,cAAAthC,QAIAyqC,EAAAj1C,UAAAmF,MAAA,WACA,IAAA3F,KAAAswC,cACA,SAAAnqC,WAAA,4FAEA,OAAAnG,MAAAssC,eAGAmJ,EAAAj1C,UAAAulC,MACA0P,EAAAj1C,UAAAgjC,OAAA,WACA,IAAAxjC,KAAAywC,aACA,SAAAtqC,WAAA,0FAEA,OAAAnG,MAAAssC,eAGAmJ,EAAAj1C,UAAA8vC,YACAxzB,EAAAtc,UAAA+yC,aAAA,WACA,iBAAAvzC,KAAA0hC,WAAA,GAGA+T,EAAAj1C,UAAAiwC,WACA3zB,EAAAtc,UAAAy4C,YAAA,WACA,iBAAAj5C,KAAA0hC,WAAA,GAGA+T,EAAAj1C,UAAA+hD,UACAzlC,EAAAtc,UAAA2gC,WAAA,WACA,sBAAAnhC,KAAA0hC,YAGA+T,EAAAj1C,UAAAy1C,WACAn5B,EAAAtc,UAAA6yC,YAAA,WACA,iBAAArzC,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAA+hD,UAAA,WACA,MAAAviD,MAAAwhC,UAAAL,cAGArkB,EAAAtc,UAAAiwC,WAAA,WACA,MAAAzwC,MAAAwhC,UAAAyX,eAGAn8B,EAAAtc,UAAA8vC,YAAA,WACA,MAAAtwC,MAAAwhC,UAAA+R,gBAGAz2B,EAAAtc,UAAAy1C,WAAA,WACA,MAAAj2C,MAAAwhC,UAAA6R,eAGAv2B,EAAAtc,UAAAizC,OAAA,WACA,MAAAzzC,MAAAssC,eAGAxvB,EAAAtc,UAAAgzC,QAAA,WAEA,MADAxzC,MAAA0sC,6BACA1sC,KAAAssC,eAGAxvB,EAAAtc,UAAAmF,MAAA,WACA,GAAAiL,GAAA5Q,KAAAwhC,SACA,KAAA5wB,EAAA0/B,cACA,SAAAnqC,WAAA,4FAEA,OAAAyK,GAAA07B,eAGAxvB,EAAAtc,UAAAgjC,OAAA,WACA,GAAA5yB,GAAA5Q,KAAAwhC,SACA,KAAA5wB,EAAA6/B,aACA,SAAAtqC,WAAA,0FAGA,OADAyK,GAAA87B,6BACA97B,EAAA07B,eAIAxvB,EAAA24B,0BAGI+M,IAAA,SAAAjkB,EAAA7/B,GACJ,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,GAKA,QAAAC,GAAAh8B,EAAA6B,GACA,GAAAsX,EAAAnZ,GAAA,CACA,GAAAA,YAAAqY,GACA,MAAArY,EAEA,IAAAg+C,EAAAh+C,GAAA,CACA,GAAA4X,GAAA,GAAAS,GAAA0jB,EAQA,OAPA/7B,GAAAs8B,MACA1kB,EAAAo6B,kBACAp6B,EAAAq9B,2BACAr9B,EAAAq4B,mBACAr4B,EACA,MAEAA,EAEA,GAAAzW,GAAAy8B,EAAArI,SAAA0oB,GAAAj+C,EACA,IAAAmB,IAAA+kC,EAAA,CACArkC,KAAAklC,cACA,IAAAnvB,GAAAS,EAAAlI,OAAAhP,EAAArE,EAEA,OADA+E,MAAAmlC,cACApvB,EACS,qBAAAzW,GACT,MAAA+8C,GAAAl+C,EAAAmB,EAAAU,GAGA,MAAA7B,GAGA,QAAAi+C,GAAAj+C,GACA,MAAAA,GAAAmB,KAIA,QAAA68C,GAAAh+C,GACA,MAAAm+C,GAAAliD,KAAA+D,EAAA,aAGA,QAAAk+C,GAAAh/C,EAAAiC,EAAAU,GAiBA,QAAAu8C,GAAAl9C,GACAoY,IACApa,IAAAgC,EACAoY,EAAA+lB,gBACAhnB,EAAA68B,4BAAA,MAEA57B,EAAAqjB,iBAAAz7B,GAEAoY,EAAA,MAGA,QAAA+kC,GAAAtf,GACAzlB,IACAA,EAAA+lB,gBAAAN,EAAAmV,GAAA,GACA56B,EAAA,MAGA,QAAAglC,GAAAp9C,GACAoY,GACA,kBAAAA,GAAA0jB,WACA1jB,EAAA0jB,UAAA97B,GApCA,GAAAoY,GAAA,GAAAjB,GAAA0jB,GACAnkB,EAAA0B,CACAzX,MAAAklC,eACAztB,EAAAgvB,qBACAzmC,KAAAmlC,aACA,IAAAkN,IAAA,EACAn1C,EAAA6+B,EAAArI,SAAAp0B,GAAAlF,KAAAiD,EACAk/C,EACAC,EACAC,EA8BA,OA7BApK,IAAA,EACA56B,GAAAva,IAAAmnC,IACA5sB,EAAA+lB,gBAAAtgC,EAAAjC,GAAA,MACAwc,EAAA,MA0BA1B,EAlFA,GAAAgmB,GAAA9D,EAAA,aACAoM,EAAAtI,EAAAsI,SACA/sB,EAAAykB,EAAAzkB,SAmCAglC,KAAgBz5C,cAgDhB,OAAAs3B,MAGG0C,YAAA,KAAe6f,IAAA,SAAAzkB,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EAAA0jB,GAgCA,QAAAyiB,GAAAt9C,GACA,GAAAo3B,GAAA/8B,IAGA,OAFA+8B,aAAAx3B,UAAAw3B,MACAmmB,aAAAnmB,GACAp3B,EAGA,QAAAw9C,GAAA3f,GACA,GAAAzG,GAAA/8B,IAGA,MAFA+8B,aAAAx3B,UAAAw3B,MACAmmB,aAAAnmB,GACAyG,EA1CA,GAAAnB,GAAA9D,EAAA,aACAsQ,EAAA/xB,EAAA+xB,aAEAuU,EAAA,SAAArlC,EAAAqkB,GACA,GAAArkB,EAAAwkC,YAAA,CACA,gBAAAngB,KACAA,EAAA,sBAEA,IAAAhlB,GAAA,GAAAyxB,GAAAzM,EACAC,GAAAwW,+BAAAz7B,GACAW,EAAAivB,kBAAA5vB,GACAW,EAAAwlB,QAAAnmB,KAGAimC,EAAA,SAAA19C,GAAkC,MAAA29C,IAAAtjD,MAAA6tC,WAAAloC,IAClC29C,EAAAxmC,EAAAwmC,MAAA,SAAA39C,EAAA49C,GACA,GAAAv4C,SAAAu4C,EAAA,CACAA,EAAA59C,EACAA,EAAAqF,MACA,IAAAqR,GAAA,GAAAS,GAAA0jB,EAEA,OADA3gB,YAAA,WAA+BxD,EAAAk8B,YAAkBgL,GACjDlnC,EAGA,MADAknC,MACAzmC,EAAAC,QAAApX,GAAAo7B,MAAAsiB,EAAA,UAAAE,EAAAv4C,QAGA8R,GAAAtc,UAAA8iD,MAAA,SAAAC,GACA,MAAAD,GAAAtjD,KAAAujD,IAiBAzmC,EAAAtc,UAAAg8C,QAAA,SAAA+G,EAAAnhB,GACAmhB,IACA,IAAAlnC,GAAArc,KAAA4F,OAAAo+B,aACA3nB,GAAAunB,oBAAA5jC,IACA,IAAA+8B,GAAAld,WAAA,WACAujC,EAAA/mC,EAAA+lB,IACKmhB,EACL,OAAAlnC,GAAA0kB,MAAAkiB,EAAAE,EAAAn4C,OAAA+xB,EAAA/xB,YAKGm4B,YAAA,KAAeqgB,IAAA,SAAAjlB,EAAA7/B,GAClB,YACAA,GAAAC,QAAA,SAAAme,EAAAk0B,EAAAvQ,EACA6K,GAKA,QAAAmY,GAAAC,GAEA,OADA9/C,GAAA8/C,EAAA5gD,OACAmb,EAAA,EAAuBra,EAAAqa,IAASA,EAAA,CAChC,GAAAsjC,GAAAmC,EAAAzlC,EACA,IAAAsjC,EAAA9Q,aACA,MAAA3zB,GAAAlI,OAAA2sC,EAAAxb,QAEA2d,GAAAzlC,GAAAsjC,EAAAjV,cAEA,MAAAoX,GAGA,QAAA/V,GAAApsC,GACAse,WAAA,WAA8B,KAAAte,IAAS,GAGvC,QAAAoiD,GAAAC,GACA,GAAAtiB,GAAAb,EAAAmjB,EAOA,OANAtiB,KAAAsiB,GACA,kBAAAA,GAAAC,eACA,kBAAAD,GAAAE,cACAF,EAAAC,iBACAviB,EAAAyiB,eAAAH,EAAAE,gBAEAxiB,EAEA,QAAA0iB,GAAAC,EAAA1C,GAIA,QAAA72B,KACA,GAAAzM,GAAAra,EAAA,MAAAyY,GAAAU,SACA,IAAAukB,GAAAqiB,EAAAM,EAAAhmC,KACA,IAAAqjB,YAAAxkB,IACAwkB,EAAAuiB,gBAAA,CACA,IACAviB,EAAAb,EACAa,EAAAwiB,eAAAI,WAAA3C,GACA0C,EAAAlmC,SACiB,MAAAxc,GACjB,MAAAosC,GAAApsC,GAEA,GAAA+/B,YAAAxkB,GACA,MAAAwkB,GAAAP,MAAArW,EAAAijB,EACA,gBAGAjjB,IApBA,GAAAzM,GAAA,EACAra,EAAAqgD,EAAAnhD,OACAuZ,EAAAS,EAAAgB,OAqBA,OADA4M,KACArO,EAAA0B,QAGA,QAAAomC,GAAAx+C,GACA,GAAA47C,GAAA,GAAA9L,EAGA,OAFA8L,GAAAjV,cAAA3mC,EACA47C,EAAA7f,UAAA,UACAsiB,EAAAhkD,KAAAuhD,GAAA1T,WAAAloC,GAGA,QAAAy+C,GAAA5gB,GACA,GAAA+d,GAAA,GAAA9L,EAGA,OAFA8L,GAAAjV,cAAA9I,EACA+d,EAAA7f,UAAA,UACAsiB,EAAAhkD,KAAAuhD,GAAAzT,UAAAtK,GAGA,QAAA6gB,GAAA3kC,EAAA3B,EAAAzX,GACAtG,KAAAskD,MAAA5kC,EACA1f,KAAAuqC,SAAAxsB,EACA/d,KAAAukD,SAAAj+C,EAoCA,QAAAk+C,GAAA7hD,EAAAob,EAAAzX,GACAtG,KAAAwyC,aAAA7vC,EAAAob,EAAAzX,GASA,QAAAm+C,GAAA9+C,GACA,MAAA0+C,GAAAK,WAAA/+C,IACA3F,KAAAikD,UAAAjkD,KAAAW,OAAAojD,eAAAp+C,GACAA,EAAAoY,WAEApY,EA7HA,GAAAQ,GAAAo4B,EAAA,eAAAp4B,UACA0gC,EAAAtI,EAAA,aAAAsI,SACA4O,EAAA34B,EAAA24B,iBA2EA4O,GAAA7jD,UAAAkf,KAAA,WACA,MAAA1f,MAAAskD,OAGAD,EAAA7jD,UAAAud,QAAA,WACA,MAAA/d,MAAAuqC,UAGA8Z,EAAA7jD,UAAAmkD,SAAA,WACA,MAAA3kD,MAAA+d,UAAAuyB,cACAtwC,KAAA+d,UAAApY,QAEA,MAGA0+C,EAAA7jD,UAAA0jD,WAAA,SAAA3C,GACA,GAAAoD,GAAA3kD,KAAA2kD,WACAr+C,EAAAtG,KAAAukD,QACAv5C,UAAA1E,KAAAklC,cACA,IAAAnvB,GAAA,OAAAsoC,EACA3kD,KAAA4kD,UAAAD,EAAApD,GAAA,IAIA,OAHAv2C,UAAA1E,KAAAmlC,cACAzrC,KAAAuqC,SAAAsa,mBACA7kD,KAAAskD,MAAA,KACAjoC,GAGAgoC,EAAAK,WAAA,SAAAI,GACA,aAAAA,GACA,kBAAAA,GAAAH,UACA,kBAAAG,GAAAZ,YAMArd,EAAA2d,EAAAH,GAEAG,EAAAhkD,UAAAokD,UAAA,SAAAD,EAAApD,GACA,GAAA5+C,GAAA3C,KAAA0f,MACA,OAAA/c,GAAAjC,KAAAikD,IAAApD,IAWAzkC,EAAAioC,MAAA,WACA,GAAAnhD,GAAA7D,UAAA+C,MACA,MAAAc,EAAA,MAAAotC,GACA,sDACA,IAAAruC,GAAA5C,UAAA6D,EAAA,EACA,sBAAAjB,GAAA,MAAAquC,GAAA,0DACAptC,IAEA,QADAqgD,GAAA,GAAA1jD,OAAAqD,GACAqa,EAAA,EAAuBra,EAAAqa,IAASA,EAAA,CAChC,GAAA0mC,GAAA5kD,UAAAke,EACA,IAAAomC,EAAAK,WAAAC,GAAA,CACA,GAAAK,GAAAL,CACAA,KAAA5mC,UACA4mC,EAAAZ,eAAAiB,OACa,CACb,GAAA1jB,GAAAb,EAAAkkB,EACArjB,aAAAxkB,KACA6nC,EACArjB,EAAAP,MAAA0jB,EAAA,WACAR,YACAtjD,MAAAsd,GACqBjT,SAGrBi5C,EAAAhmC,GAAA0mC,EAGA,GAAA5mC,GAAAjB,EAAA0kC,OAAAyC,GACAr+C,KAAA69C,GACA79C,KAAA,SAAAkR,GACAiH,EAAAytB,cACA,IAAAnvB,EACA,KACAA,EAAA1Z,EAAA1B,MAAA+J,OAAA8L,GACiB,QACjBiH,EAAA0tB,cAEA,MAAApvB,KAEA0kB,MACAojB,EAAAC,EAAAp5C,OAAAi5C,EAAAj5C,OAEA,OADAi5C,GAAAlmC,UACAA,GAGAjB,EAAAtc,UAAAujD,eAAA,SAAAiB,GACAhlD,KAAA0hC,UAAA,OAAA1hC,KAAA0hC,UACA1hC,KAAAilD,UAAAD,GAGAloC,EAAAtc,UAAAqjD,cAAA,WACA,cAAA7jD,KAAA0hC,WAAA,GAGA5kB,EAAAtc,UAAAsjD,aAAA,WACA,MAAA9jD,MAAAilD,WAGAnoC,EAAAtc,UAAAqkD,iBAAA,WACA7kD,KAAA0hC,UAAA,QAAA1hC,KAAA0hC,UACA1hC,KAAAilD,UAAAj6C,QAGA8R,EAAAtc,UAAAwkD,SAAA,SAAAriD,GACA,qBAAAA,GACA,UAAA6hD,GAAA7hD,EAAA3C,KAAAsrC,IAEA,UAAAnlC,OAKGs+B,cAAA,GAAAtB,YAAA,KAAgC+hB,IAAA,SAAA3mB,EAAA7/B,EAAAC,GACnC,YAqBA,SAAAwmD,KACA,IACA,MAAAC,GAAAnkD,MAAAjB,KAAAD,WACK,MAAAwB,GAEL,MADAopC,GAAAppC,IACAopC,GAGA,QAAA3Q,GAAAr3B,GAEA,MADAyiD,GAAAziD,EACAwiD,EAuBA,QAAA3X,GAAAroC,GACA,aAAAA,QAAA,GAAAA,KAAA,GACA,gBAAAA,IAAA,gBAAAA,GAIA,QAAAyY,GAAAjY,GACA,OAAA6nC,EAAA7nC,GAGA,QAAA02C,GAAAgJ,GACA,MAAA7X,GAAA6X,GAEA,GAAAj9C,OAAAk9C,EAAAD,IAFAA,EAKA,QAAAxH,GAAAjtC,EAAA20C,GACA,GAEAtnC,GAFAra,EAAAgN,EAAA9N,OACAuZ,EAAA,GAAA9b,OAAAqD,EAAA,EAEA,KAAAqa,EAAA,EAAera,EAAAqa,IAASA,EACxB5B,EAAA4B,GAAArN,EAAAqN,EAGA,OADA5B,GAAA4B,GAAAsnC,EACAlpC,EAGA,QAAA2gC,GAAAv4C,EAAAC,EAAA8gD,GACA,IAAA7W,EAAAS,MAQA,SAAiBjmC,eAAAzI,KAAA+D,EAAAC,GAAAD,EAAAC,GAAAsG,MAPjB,IAAAktB,GAAA9yB,OAAAooB,yBAAA/oB,EAAAC,EACA,cAAAwzB,EACA,MAAAA,EAAAjoB,KAAA,MAAAioB,EAAAlmB,IACAkmB,EAAAvyB,MACA6/C,EAHA,OAUA,QAAA9d,GAAAjjC,EAAAoC,EAAAlB,GACA,GAAA6nC,EAAA/oC,GAAA,MAAAA,EACA,IAAAqiB,IACAnhB,QACAshB,cAAA,EACAD,YAAA,EACAE,UAAA,EAGA,OADAynB,GAAAvtB,eAAA3c,EAAAoC,EAAAigB,GACAriB,EAQA,QAAAkpC,GAAAlsC,GACA,KAAAA,GA2CA,QAAA68C,GAAA37C,GACA,IACA,qBAAAA,GAAA,CACA,GAAA4O,GAAAo9B,EAAAhoC,MAAAhE,EAAAnC,UACA,OAAAmuC,GAAAS,MAAA79B,EAAAzO,OAAA,EACAyO,EAAAzO,OAAA,KACA,IAAAyO,EAAAzO,QAAA,gBAAAyO,EAAA,IAEA,SACK,MAAAhQ,GACL,UAIA,QAAAq4C,GAAAn1C,GAEA,QAAAxB,MAEA,MADAA,GAAAzC,UAAAiE,EACAxB,EAKA,QAAA2/B,GAAAh4B,GACA,MAAA66C,GAAAv4C,KAAAtC,GAGA,QAAA86C,GAAA1wC,EAAA2wC,EAAA5I,GAEA,OADA1gC,GAAA,GAAA9b,OAAAyU,GACAiJ,EAAA,EAAkBjJ,EAAAiJ,IAAWA,EAC7B5B,EAAA4B,GAAA0nC,EAAA1nC,EAAA8+B,CAEA,OAAA1gC,GAGA,QAAAipC,GAAA7gD,GACA,IACA,MAAAA,GAAA,GACK,MAAAlD,GACL,oCAIA,QAAAs3C,GAAAt3C,GACA,IACAmmC,EAAAnmC,EAAA,oBAEA,MAAAqkD,KAGA,QAAAvP,GAAA90C,GACA,aAAAA,GAAA,EACAA,YAAA6G,OAAA,uBAAAmmC,kBACAhtC,EAAA,mBAGA,QAAAuqC,GAAArnC,GACA,MAAAA,aAAA2D,QAAAumC,EAAAW,mBAAA7qC,EAAA,SAkBA,QAAA69B,GAAA79B,GACA,SAAaY,SAAA3E,KAAA+D,GAGb,QAAA85C,GAAAz5C,EAAAyC,EAAA4H,GAEA,OADAoC,GAAAo9B,EAAAhoC,MAAA7B,GACAmZ,EAAA,EAAmBA,EAAA1M,EAAAzO,SAAiBmb,EAAA,CACpC,GAAAvZ,GAAA6M,EAAA0M,EACA9O,GAAAzK,IACAiqC,EAAAvtB,eAAA7Z,EAAA7C,EAAAiqC,EAAAU,cAAAvqC,EAAAJ,KA9OA,GAAAiqC,GAAApQ,EAAA,YACAoE,EAAA,mBAAArjC,WACAg9C,EAAA,WACA,IACA,GAAAvsB,KAMA,OALA4e,GAAAvtB,eAAA2O,EAAA,KACA9f,IAAA,WACA,YAGA,IAAA8f,EAAA9sB,EAEA,MAAA1B,GACA,aAKAopC,GAAgBppC,MAChB6jD,EAcAve,EAAA,SAAAgf,EAAAC,GAGA,QAAAv6C,KACAvL,KAAAqR,YAAAw0C,EACA7lD,KAAAwyC,aAAAsT,CACA;IAAA,GAAA/iB,KAAA+iB,GAAAtlD,UACAoiD,EAAAliD,KAAAolD,EAAAtlD,UAAAuiC,IACA,MAAAA,EAAAzpB,OAAAypB,EAAAjgC,OAAA,KAEA9C,KAAA+iC,EAAA,KAAA+iB,EAAAtlD,UAAAuiC,IATA,GAAA6f,MAAoBz5C,cAepB,OAFAoC,GAAA/K,UAAAslD,EAAAtlD,UACAqlD,EAAArlD,UAAA,GAAA+K,GACAs6C,EAAArlD,WAyDAitC,EAAA,WACA,iBAAAztC,MACCU,KAAA,UAMD48C,EAAA,WACA,GAAA3O,EAAAS,MAAA,CACA,GAAA2W,GAAA3gD,OAAA5E,UACAikB,EAAArf,OAAAqoB,mBACA,iBAAAhpB,GAGA,IAFA,GAAA4X,MACA2pC,EAAA5gD,OAAAye,OAAA,MACA,MAAApf,OAAAshD,GAAA,CACA,GAAAx0C,EACA,KACAA,EAAAkT,EAAAhgB,GACiB,MAAAlD,GACjB,MAAA8a,GAEA,OAAA4B,GAAA,EAA+BA,EAAA1M,EAAAzO,SAAiBmb,EAAA,CAChD,GAAAvZ,GAAA6M,EAAA0M,EACA,KAAA+nC,EAAAthD,GAAA,CACAshD,EAAAthD,IAAA,CACA,IAAAwzB,GAAA9yB,OAAAooB,yBAAA/oB,EAAAC,EACA,OAAAwzB,GAAA,MAAAA,EAAAjoB,KAAA,MAAAioB,EAAAlmB,KACAqK,EAAA7I,KAAA9O,IAGAD,EAAAkqC,EAAA1lB,eAAAxkB,GAEA,MAAA4X,IAGA,gBAAA5X,GACA,GAAA4X,KAEA,QAAA3X,KAAAD,GACA4X,EAAA7I,KAAA9O,EAEA,OAAA2X,OA4BAopC,EAAA,wBAsCA3M,EAAA,WACA,mBAAA1wC,OAOA,SAAAzC,GACA,MAAAmmC,GAAAnmC,KACA,GAAAyC,OAAAk9C,EAAA3/C,KARA,SAAAA,GACA,GAAAmmC,EAAAnmC,GAAA,MAAAA,EACA,KAAiB,SAAAyC,OAAAk9C,EAAA3/C,IACjB,MAAAyX,GAAwB,MAAAA,QAwBxBf,GACAiiC,UACA1b,eACA0a,oBACAN,2BACArP,UACAzoC,QAAAypC,EAAAzpC,QACAo3C,cACA5U,oBACA8F,cACA5vB,WACA+kB,cACAgI,WACA3Q,WACA6M,WACAgX,eACAxB,mBACA5O,yBACAmM,mBACA8L,cACArgD,SAAAigD,EACAxZ,iBACAgN,oBACAzC,0BACAwC,iCACAvW,cACAic,kBACArV,OAAA,mBAAA1qB,IACA,qBAAA8jB,EAAA9jB,GAAAhf,cAEA,KAAK,SAAA4I,OAAoB,MAAA7G,GAAY8a,EAAAisB,cAAA/mC,EACrC7C,EAAAC,QAAA0d,IAEG4uB,WAAA,UAAmB,SACE,mBAAAhsC,SAAA,OAAAA,OAAuDA,OAAA22B,EAAA32B,OAAA6d,QAA+G,mBAAAqI,OAAA,OAAAA,OAAyDA,KAAAyQ,EAAAzQ,KAAArI,WbisSzNpc,KAAK/B,EAASC,EAAoB,IAAM,WAAa,MAAOoB,WAIpFy8C,GACA,SAAS/9C,EAAQC,EAASC,Gc5sbhC,QAAAqnD,KACA,MAAAtnD,GAAAkD,OAAAqkD,IAAAvnD,EAAAkD,OAAAiB,QAWA,QAAAxB,GAAArB,GAGA,QAAAkmD,MAKA,QAAAC,KAEA,GAAAjhC,GAAAihC,EAGAC,GAAA,GAAAx6C,MACA03C,EAAA8C,GAAAC,GAAAD,EACAlhC,GAAAhlB,KAAAojD,EACAp+B,EAAAiS,KAAAkvB,EACAnhC,EAAAkhC,OACAC,EAAAD,EAGA,MAAAlhC,EAAAtmB,YAAAsmB,EAAAtmB,UAAAF,EAAAE,aACA,MAAAsmB,EAAA9kB,OAAA8kB,EAAAtmB,YAAAsmB,EAAA9kB,MAAA4lD,IAEA,IAAAnmD,GAAAS,MAAAC,UAAAC,MAAAC,KAAAX,UAEAD,GAAA,GAAAnB,EAAA4nD,OAAAzmD,EAAA,IAEA,gBAAAA,GAAA,KAEAA,GAAA,MAAAQ,OAAAR,GAIA,IAAAa,GAAA,CACAb,GAAA,GAAAA,EAAA,GAAAe,QAAA,sBAAApB,EAAA+mD,GAEA,UAAA/mD,EAAA,MAAAA,EACAkB,IACA,IAAA8lD,GAAA9nD,EAAAmD,WAAA0kD,EACA,sBAAAC,GAAA,CACA,GAAAthD,GAAArF,EAAAa,EACAlB,GAAAgnD,EAAA/lD,KAAAykB,EAAAhgB,GAGArF,EAAAgB,OAAAH,EAAA,GACAA,IAEA,MAAAlB,KAGA,kBAAAd,GAAAkB,aACAC,EAAAnB,EAAAkB,WAAAoB,MAAAkkB,EAAArlB,GAEA,IAAA4mD,GAAAN,EAAArlD,KAAApC,EAAAoC,KAAA7B,QAAA6B,IAAA6M,KAAA1O,QACAwnD,GAAAzlD,MAAAkkB,EAAArlB,GAlDAqmD,EAAAC,SAAA,EAoDAA,WAAA,CAEA,IAAAzjD,GAAAhE,EAAAynD,QAAAnmD,GAAAmmD,EAAAD,CAIA,OAFAxjD,GAAA1C,YAEA0C,EAWA,QAAAR,GAAAhB,GACAxC,EAAAuC,KAAAC,EAKA,QAHAwS,IAAAxS,GAAA,IAAAwS,MAAA,UACA/P,EAAA+P,EAAA7Q,OAEAmb,EAAA,EAAiBra,EAAAqa,EAASA,IAC1BtK,EAAAsK,KACA9c,EAAAwS,EAAAsK,GAAApd,QAAA,aACA,MAAAM,EAAA,GACAxC,EAAAgoD,MAAAnzC,KAAA,GAAA7T,QAAA,IAAAwB,EAAAklC,OAAA,SAEA1nC,EAAAgI,MAAA6M,KAAA,GAAA7T,QAAA,IAAAwB,EAAA,OAWA,QAAAylD,KACAjoD,EAAAwD,OAAA,IAWA,QAAAikD,GAAAv/C,GACA,GAAAoX,GAAAra,CACA,KAAAqa,EAAA,EAAAra,EAAAjF,EAAAgoD,MAAA7jD,OAAyCc,EAAAqa,EAASA,IAClD,GAAAtf,EAAAgoD,MAAA1oC,GAAA/Q,KAAArG,GACA,QAGA,KAAAoX,EAAA,EAAAra,EAAAjF,EAAAgI,MAAA7D,OAAyCc,EAAAqa,EAASA,IAClD,GAAAtf,EAAAgI,MAAAsX,GAAA/Q,KAAArG,GACA,QAGA,UAWA,QAAA0/C,GAAAphD,GACA,MAAAA,aAAAiD,OAAAjD,EAAAqgC,OAAArgC,EAAAi9B,QACAj9B,EA3LAxG,EAAAD,EAAAC,QAAA2C,EACA3C,EAAA4nD,SACA5nD,EAAAioD,UACAjoD,EAAAwD,SACAxD,EAAAynD,UACAznD,EAAAuB,SAAAtB,EAAA,IAMAD,EAAAgI,SACAhI,EAAAgoD,SAQAhoD,EAAAmD,aAMA,IAMAwkD,GANAJ,EAAA,Gds6bMzH,GACA,SAAS//C,Gel6bf,QAAAmoD,GAAAj8C,GACA,GAAAnL,GAAA,6EAAAqnD,KAAAl8C,EACA,IAAAnL,EAAA,CACA,GAAAgG,GAAA+qB,WAAA/wB,EAAA,IACAsL,GAAAtL,EAAA,UAAAD,aACA,QAAAuL,GACA,YACA,WACA,QACA,MAAAtF,GAAAiqB,CACA,YACA,UACA,QACA,MAAAjqB,GAAAq/C,CACA,aACA,WACA,QACA,MAAAr/C,GAAAshD,CACA,eACA,aACA,QACA,MAAAthD,GAAA+V,CACA,eACA,aACA,QACA,MAAA/V,GAAA8gB,CACA,UACA,MAAA9gB,KAYA,QAAAuhD,GAAAzD,GACA,MAAAA,IAAAuB,EAAA//C,KAAAkiD,MAAA1D,EAAAuB,GAAA,IACAvB,GAAAwD,EAAAhiD,KAAAkiD,MAAA1D,EAAAwD,GAAA,IACAxD,GAAA/nC,EAAAzW,KAAAkiD,MAAA1D,EAAA/nC,GAAA,IACA+nC,GAAAh9B,EAAAxhB,KAAAkiD,MAAA1D,EAAAh9B,GAAA,IACAg9B,EAAA,KAWA,QAAA2D,GAAA3D,GACA,MAAA4D,GAAA5D,EAAAuB,EAAA,QACAqC,EAAA5D,EAAAwD,EAAA,SACAI,EAAA5D,EAAA/nC,EAAA,WACA2rC,EAAA5D,EAAAh9B,EAAA,WACAg9B,EAAA,MAOA,QAAA4D,GAAA5D,EAAA99C,EAAAoB,GACA,MAAApB,GAAA89C,EAAA,OACA,IAAA99C,EAAA89C,EAAAx+C,KAAA2P,MAAA6uC,EAAA99C,GAAA,IAAAoB,EACA9B,KAAA4P,KAAA4uC,EAAA99C,GAAA,IAAAoB,EAAA,IAzGA,GAAA0f,GAAA,IACA/K,EAAA,GAAA+K,EACAwgC,EAAA,GAAAvrC,EACAspC,EAAA,GAAAiC,EACAr3B,EAAA,OAAAo1B,CAeApmD,GAAAC,QAAA,SAAAwG,EAAA4qC,GAEA,MADAA,SACA,gBAAA5qC,GAAA0hD,EAAA1hD,GACA4qC,UACAmX,EAAA/hD,GACA6hD,EAAA7hD,KfkicM26C,GACA,SAASphD,EAAQC,EAASC,GAE/B,YAEA,IAAI++B,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnF2iD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMC,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,sCgBtkcjHmb,EAAQqc,EAAA/+B,EAAM,KACd6oD,EAAmB9pB,EAAA/+B,EAAM,KAEnB8oD,EAAc/oD,EAAd+oD,eAAc,WAEd,QAFAA,GAECC,GhBykcTH,EAAgBxnD,KgB3kcR0nD,GAGT1nD,KAAK4nD,cAAgBD,GAAgBF,EACrCznD,KAAK6nD,YACL7nD,KAAKqqC,WAAa,GAAI1d,KhB4qcvB,MA/FAy6B,GgBllcUM,EAAc,MAYzBI,QhB6kcKniD,MgB7kcC,WACJ,GAAIkX,GAAM7c,KAAK4nD,cACXG,EAAOlrC,EAAImrC,YACfD,GAAKE,QAAQprC,EAAItE,aACjBwvC,EAAKG,chB+kcFhhC,UAAU,EACVD,cAAc,GgB7kcf0gC,chBglcC13C,IgBhlcW,WACd,MAAOjQ,MAAK4nD,ehBklcT3gC,cAAc,GgB/kcnBkhC,ShBklcKxiD,MgBllcE,WACL,IAAI3F,KAAKooD,WAAT,CACApoD,KAAKooD,YAAa,CAClB,QAAgCC,GAAhCC,EAAmBtoD,KAAK6nD,SAAQhgC,OAAA6C,cAAA29B,EAAAC,EAAAprC,QAAAG,MAAA,ChBolczB,GgBplcEkrC,GAAMF,EAAA1iD,KAAmB4iD,GAAOJ,UACzC,OAAoCK,GAApCC,EAAqBzoD,KAAKqqC,WAAUxiB,OAAA6C,cAAA89B,EAAAC,EAAAvrC,QAAAG,MAAA,ChBslc7B,GgBtlcEuG,GAAQ4kC,EAAA7iD,KAAqBie,GAASukC,UAC/CnoD,KAAK6nD,SAAW,KAChB7nD,KAAKqqC,WAAa,OhBylcfnjB,UAAU,EACVD,cAAc,GgBvlcnBshC,QhB0lcK5iD,MgB1lcC,SAAC+iD,GhB2lcA,GAAIC,GAAQ3oD,IgB1lcjB,OAAOA,MAAK4oD,qBAAqBF,GAChC9iD,KAAK,SAAAijD,GhB2lcC,MgB3lccF,GAAKG,aAAaD,KACtCjjD,KAAK,SAAAmjD,GACJ,GAAIJ,EAAKP,WAAY,KAAM,IAAIhgD,OAAM,oCACrC,IAAImgD,GAAS,GAAIS,GAAML,EAAOI,EAE9B,OADAJ,GAAKd,SAASr0C,KAAK+0C,GACZA,KhB8lcNrhC,UAAU,EACVD,cAAc,GgB3lcnB2hC,sBhB8lcKjjD,MgB9lce,SAAC+iD,GACnB,MAAIA,aAA6BO,aACxBnsC,QAAQC,QAAQ2rC,GAEhBpnC,EAASonC,GAAmBlnC,GAAG,gBhBimcrC0F,UAAU,EACVD,cAAc,GgB9lcnB6hC,chBimcKnjD,MgBjmcO,SAACkjD,GhBkmcN,GAAIF,GAAQ3oD,IgBjmcjB,OAAO,IAAI8c,SAAQ,SAACC,EAASnI,GAC3B+zC,EAAKhB,aAAauB,gBAAgBL,EAChC,SAAgCE,GAC9BhsC,EAAQgsC,IAEV,SAAgCxnD,GAC9BqT,EAAO,2BAA6BrT,QhBomcvC2lB,UAAU,EACVD,cAAc,GgB/lcnBkiC,ehBkmcKxjD,MgBlmcQ,SAACie,GACZ5jB,KAAKqqC,WAAWh9B,IAAIuW,IhBomcjBsD,UAAU,EACVD,cAAc,GgBlmcnBmiC,iBhBqmcKzjD,MgBrmcU,SAACie,GACd5jB,KAAKqqC,WAAU,UAAQzmB,IhBumcpBsD,UAAU,EACVD,cAAc,KgB7qcRygC,KA0EPsB,EAAM,WAEC,QAFPA,GAEQK,EAAgBN,GhBymczBvB,EAAgBxnD,KgB3mcfgpD,GAGFhpD,KAAKspD,QAAUD,EACfrpD,KAAKupD,QAAUR,EhB+nchB,MAlBA3B,GgBjncG4B,EAAM,MAOVQ,MhB4mcK7jD,MgB5mcD,SAAC29C,EAAOtc,GACV,MAAO,IAAIyiB,GAAazpD,KAAKspD,QAAStpD,KAAKupD,QAASjG,EAAOtc,IhB8mcxD9f,UAAU,EACVD,cAAc,GgB5mcnBkhC,ShB+mcKxiD,MgB/mcE,WACL3F,KAAKspD,QAAU,KACftpD,KAAKupD,QAAU,MhBincZriC,UAAU,EACVD,cAAc,KgB/ncf+hC,KAkBAS,EAAY,WAEL,QAFPA,GAEQJ,EAAgBK,EAAQpG,EAAOtc,GhBoncxC,GAAI2hB,GAAQ3oD,IACZwnD,GAAgBxnD,KgBvncfypD,GAGFzpD,KAAKspD,QAAUD,CACf,IAAI/iD,GAAU+iD,EAAe1B,aACzB9vC,EAASvR,EAAQqjD,oBACrB9xC,GAAO6xC,OAASA,CAChB,IAAI3B,GAAOzhD,EAAQ0hD,YACnBnwC,GAAOowC,QAAQF,GACfA,EAAKE,QAAQjhB,GAAQ1gC,EAAQiS,aAC7BvY,KAAK4pD,QAAU/xC,EACf7X,KAAK6pD,MAAQ9B,EACblwC,EAAO9C,MAAOuuC,EAAYv+C,KAAKC,IAAI,EAAGsB,EAAQwjD,YAAcxG,GAAtC,GACtBzjC,WAAW,WhBuncR,MgBvncc8oC,GAAKhsB,QAA2C,KAAlC2mB,EAAQoG,EAAOK,SAAW,MACzD/pD,KAAKspD,QAAQH,cAAcnpD,MhBopc5B,MAzBAonD,GgBzocGqC,EAAY,MAiBhB9sB,MhB0ncKh3B,MgB1ncD,WACG3F,KAAK4pD,UACV5pD,KAAK4pD,QAAQjtB,KAAK,GAClB38B,KAAK4pD,QAAQ1B,aACbloD,KAAK6pD,MAAM3B,aACXloD,KAAK4pD,QAAU,KACf5pD,KAAK6pD,MAAQ,KACb7pD,KAAKspD,QAAQF,gBAAgBppD,MACzBA,KAAKgqD,QAAQhqD,KAAKgqD,WhB6ncnB9iC,UAAU,EACVD,cAAc,GgB3ncnBkhC,ShB8ncKxiD,MgB9ncE,WACL3F,KAAK28B,QhBgocFzV,UAAU,EACVD,cAAc,KgB9pcfwiC,IhBqqcL9qD,GAAQ,WgBnocM+oD,EhBoocdtiD,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ87C,GACA,SAAS/iD,GiB1wcf,QAAAurD,KAIA,QAAApjC,GAAA1M,GAEA,MADA0M,GAAAqjC,SAAA/vC,GACAA,EAJA,GAAAgwC,MAAA1pD,MAAAC,KAAAX,UAaA,OANA8mB,GAAAqjC,SAAA,SAAA/vC,GACA,OAAA8D,GAAA,EAAmBA,EAAAksC,EAAArnD,OAAoBmb,IACvCisC,EAAAC,EAAAlsC,GAAA9D,IAIA0M,EAgBA,QAAAqjC,GAAAE,EAAAzkD,GAGA,GAFAykD,IAAA7kD,SAAA6kD,EAAA,UACAA,IAAAnhD,SAAAmhD,EAAA,UACA,gBAAAA,IACA,SAAAzkD,KAAAykD,EAAA,SAAAhiD,OAAA,eAAAgiD,OACG,sBAAAA,IACH,qBAAAA,GAAAF,SACAE,EAAAF,SAAAvkD,OACK,MAAAA,YAAAykD,IACL,SAAAhiD,OAAA,4BAAAgiD,OAEG,oBAAAA,GAIH,SAAAhiD,OAAA,iBAHA,KAAAzC,EAAA,SAAAyC,OAAA,sBACAiiD,GAAAD,EAAAzkD,IAMA,QAAA0kD,GAAAD,EAAAjwC,GACA,OAAA3Q,KAAA4gD,GAAA,CACA,KAAA5gD,IAAA2Q,IACA,SAAA/R,OAAA,sBAAAoB,EAAA,IAEA,KACA0gD,EAAAE,EAAA5gD,GAAA2Q,EAAA3Q,IACK,MAAAjI,GACL,SAAA6G,OAAA,sBAAAoB,EAAA,MAAAjI,EAAA6gC,WA5DA1jC,EAAAC,QAAAsrD,EAqBAA,EAAAK,MAAA,SAAAF,GACA,QAAAG,GAAApwC,GAEA,MADAowC,GAAAL,SAAA/vC,GACAA,EAMA,MAJAowC,GAAAL,SAAA,SAAAvkD,GACA,OAAAA,GAAAqF,SAAArF,GACAukD,EAAAE,EAAAzkD,IAEA4kD,IjBszcM/G,GACA,SAAS9kD,EAAQC,EAASC,IkBt1chC,SAAA4rD,GAiEA,QAAAA,GAAAC,EAAAC,EAAAC,GACA,KAAA3qD,eAAAwqD,IACA,UAAAA,GAAAC,EAAAC,EAAAC,EAEA,IAGA7nD,GAHAiI,QAAA0/C,EAIA,eAAA1/C,EACAjI,EAAA2nD,EAAA,EAAAA,IAAA,QACA,eAAA1/C,EACA,WAAA2/C,IACAD,EAAAG,EAAAH,IACA3nD,EAAA0nD,EAAAK,WAAAJ,EAAAC,OACG,eAAA3/C,GAAA,OAAA0/C,EAKH,SAAAtkD,WAAA,kDAJA,YAAAskD,EAAA1/C,MAAA7F,EAAAulD,EAAA/qC,QACA+qC,IAAA/qC,MACA5c,GAAA2nD,EAAA3nD,OAAA,EAAAiC,KAAA2P,OAAA+1C,EAAA3nD,QAAA,EAIA,GAAA9C,KAAA8C,OAAAgoD,EACA,SAAAh+B,YAAA,0DACAg+B,EAAAzlD,SAAA,aAEA,IAAA0lD,EACAP,GAAAQ,oBAEAD,EAAAP,EAAAS,SAAA,GAAAC,YAAApoD,KAGAioD,EAAA/qD,KACA+qD,EAAAjoD,SACAioD,EAAAI,WAAA,EAGA,IAAAltC,EACA,IAAAusC,EAAAQ,qBAAA,gBAAAP,GAAAI,WAEAE,EAAAK,KAAAX,OACG,IAAAY,EAAAZ,GAEH,GAAAD,EAAAc,SAAAb,GACA,IAAAxsC,EAAA,EAAiBnb,EAAAmb,EAAYA,IAC7B8sC,EAAA9sC,GAAAwsC,EAAAc,UAAAttC,OAEA,KAAAA,EAAA,EAAiBnb,EAAAmb,EAAYA,IAC7B8sC,EAAA9sC,IAAAwsC,EAAAxsC,GAAA,iBAEG,eAAAlT,EACHggD,EAAAhhB,MAAA0gB,EAAA,EAAAC,OACG,eAAA3/C,IAAAy/C,EAAAQ,sBAAAL,EACH,IAAA1sC,EAAA,EAAenb,EAAAmb,EAAYA,IAC3B8sC,EAAA9sC,GAAA,CAIA,OAAA8sC,GAsLA,QAAAS,GAAAT,EAAAU,EAAAC,EAAA5oD,GACA4oD,EAAAnmD,OAAAmmD,IAAA,CACA,IAAAz1B,GAAA80B,EAAAjoD,OAAA4oD,CACA5oD,IAGAA,EAAAyC,OAAAzC,GACAA,EAAAmzB,IACAnzB,EAAAmzB,IAJAnzB,EAAAmzB,CASA,IAAA01B,GAAAF,EAAA3oD,MACA,IAAA6oD,EAAA,eAAAvjD,OAAA,qBAEAtF,GAAA6oD,EAAA,IACA7oD,EAAA6oD,EAAA,EAEA,QAAA1tC,GAAA,EAAiBnb,EAAAmb,EAAYA,IAAA,CAC7B,GAAA2tC,GAAAlsD,SAAA+rD,EAAAplB,OAAA,EAAApoB,EAAA,MACA,IAAA6H,MAAA8lC,GAAA,SAAAxjD,OAAA,qBACA2iD,GAAAW,EAAAztC,GAAA2tC,EAEA,MAAA3tC,GAGA,QAAA4tC,GAAAd,EAAAU,EAAAC,EAAA5oD,GACA,GAAAgpD,GAAAC,EAAAC,EAAAP,GAAAV,EAAAW,EAAA5oD,EACA,OAAAgpD,GAGA,QAAAG,GAAAlB,EAAAU,EAAAC,EAAA5oD,GACA,GAAAgpD,GAAAC,EAAAG,EAAAT,GAAAV,EAAAW,EAAA5oD,EACA,OAAAgpD,GAGA,QAAAK,GAAApB,EAAAU,EAAAC,EAAA5oD,GACA,MAAAmpD,GAAAlB,EAAAU,EAAAC,EAAA5oD,GAGA,QAAAspD,GAAArB,EAAAU,EAAAC,EAAA5oD,GACA,GAAAgpD,GAAAC,EAAAM,EAAAZ,GAAAV,EAAAW,EAAA5oD,EACA,OAAAgpD,GAGA,QAAAQ,GAAAvB,EAAAU,EAAAC,EAAA5oD,GACA,GAAAgpD,GAAAC,EAAAQ,EAAAd,GAAAV,EAAAW,EAAA5oD,EAAA,EACA,OAAAgpD,GAmEA,QAAAU,GAAAzB,EAAAh2C,EAAAge,GACA,MACA05B,GAAAC,cADA,IAAA33C,GAAAge,IAAAg4B,EAAAjoD,OACAioD,EAEAA,EAAAtqD,MAAAsU,EAAAge,IAIA,QAAA45B,GAAA5B,EAAAh2C,EAAAge,GACA,GAAA9V,GAAA,GACAuS,EAAA,EACAuD,GAAAhuB,KAAAe,IAAAilD,EAAAjoD,OAAAiwB,EAEA,QAAA9U,GAAAlJ,EAAqBge,EAAA9U,EAASA,IAC9B8sC,EAAA9sC,IAAA,KACAhB,GAAA2vC,EAAAp9B,GAAAvmB,OAAAmpB,aAAA24B,EAAA9sC,IACAuR,EAAA,IAEAA,GAAA,IAAAu7B,EAAA9sC,GAAA5Y,SAAA,GAIA,OAAA4X,GAAA2vC,EAAAp9B,GAGA,QAAAq9B,GAAA9B,EAAAh2C,EAAAge,GACA,GAAA1W,GAAA,EACA0W,GAAAhuB,KAAAe,IAAAilD,EAAAjoD,OAAAiwB,EAEA,QAAA9U,GAAAlJ,EAAqBge,EAAA9U,EAASA,IAC9B5B,GAAApT,OAAAmpB,aAAA24B,EAAA9sC,GAEA,OAAA5B,GAGA,QAAAywC,GAAA/B,EAAAh2C,EAAAge,GACA,MAAA85B,GAAA9B,EAAAh2C,EAAAge,GAGA,QAAAg6B,GAAAhC,EAAAh2C,EAAAge,GACA,GAAAnvB,GAAAmnD,EAAAjoD,SAEAiS,GAAA,EAAAA,OAAA,KACAge,GAAA,EAAAA,KAAAnvB,KAAAmvB,EAAAnvB,EAGA,QADAgF,GAAA,GACAqV,EAAAlJ,EAAqBge,EAAA9U,EAASA,IAC9BrV,GAAAokD,EAAAjC,EAAA9sC,GAEA,OAAArV,GAGA,QAAAqkD,GAAAlC,EAAAh2C,EAAAge,GAGA,OAFAm6B,GAAAnC,EAAAtqD,MAAAsU,EAAAge,GACA9V,EAAA,GACAgB,EAAA,EAAiBA,EAAAivC,EAAApqD,OAAkBmb,GAAA,EACnChB,GAAAhU,OAAAmpB,aAAA86B,EAAAjvC,GAAA,IAAAivC,EAAAjvC,EAAA,GAEA,OAAAhB,GA0CA,QAAAkwC,GAAAzB,EAAAthC,EAAAtnB,GACA,GAAA4oD,EAAA,SAAAA,EACA,SAAA5+B,YAAA,qBACA,IAAA4+B,EAAAthC,EAAAtnB,EACA,SAAAgqB,YAAA,yCA2GA,QAAAsgC,GAAArC,EAAAplD,EAAA+lD,EAAAthC,EAAAplB,EAAAc,GACA,IAAA0kD,EAAAc,SAAAP,GAAA,SAAA5kD,WAAA,mCACA,IAAAR,EAAAX,GAAAc,EAAAH,EAAA,SAAAQ,WAAA,yBACA,IAAAulD,EAAAthC,EAAA2gC,EAAAjoD,OAAA,SAAAqD,WAAA,sBAaA,QAAAknD,GAAAtC,EAAAplD,EAAA+lD,EAAA4B,GACA,EAAA3nD,MAAA,MAAAA,EAAA,EACA,QAAAsY,GAAA,EAAAlc,EAAAgD,KAAAe,IAAAilD,EAAAjoD,OAAA4oD,EAAA,GAAuD3pD,EAAAkc,EAAOA,IAC9D8sC,EAAAW,EAAAztC,IAAAtY,EAAA,QAAA2nD,EAAArvC,EAAA,EAAAA,MACA,GAAAqvC,EAAArvC,EAAA,EAAAA,GA4BA,QAAAsvC,GAAAxC,EAAAplD,EAAA+lD,EAAA4B,GACA,EAAA3nD,MAAA,WAAAA,EAAA,EACA,QAAAsY,GAAA,EAAAlc,EAAAgD,KAAAe,IAAAilD,EAAAjoD,OAAA4oD,EAAA,GAAuD3pD,EAAAkc,EAAOA,IAC9D8sC,EAAAW,EAAAztC,GAAAtY,IAAA,GAAA2nD,EAAArvC,EAAA,EAAAA,GAAA,IAgGA,QAAAuvC,GAAAzC,EAAAplD,EAAA+lD,EAAAthC,EAAAplB,EAAAc,GACA,GAAAH,EAAAX,GAAAc,EAAAH,EAAA,SAAAQ,WAAA,yBACA,IAAAulD,EAAAthC,EAAA2gC,EAAAjoD,OAAA,SAAAqD,WAAA,sBAGA,QAAAsnD,GAAA1C,EAAAplD,EAAA+lD,EAAA4B,EAAAI,GAIA,MAHAA,IACAF,EAAAzC,EAAAplD,EAAA+lD,EAAA,gDACAiC,EAAA5jB,MAAAghB,EAAAplD,EAAA+lD,EAAA4B,EAAA,MACA5B,EAAA,EAWA,QAAAkC,GAAA7C,EAAAplD,EAAA+lD,EAAA4B,EAAAI,GAIA,MAHAA,IACAF,EAAAzC,EAAAplD,EAAA+lD,EAAA,kDACAiC,EAAA5jB,MAAAghB,EAAAplD,EAAA+lD,EAAA4B,EAAA,MACA5B,EAAA,EAmKA,QAAAd,GAAAhgD,GAIA,IAFAA,EAAAijD,EAAAjjD,GAAA/J,QAAAitD,EAAA,IAEAljD,EAAA9H,OAAA,OACA8H,GAAA,GAEA,OAAAA,GAGA,QAAAijD,GAAAjjD,GACA,MAAAA,GAAAJ,KAAAI,EAAAJ,OACAI,EAAA/J,QAAA,iBAGA,QAAAwqD,GAAAZ,GACA,MAAAvlD,GAAAulD,IAAAD,EAAAc,SAAAb,IACAA,GAAA,gBAAAA,IACA,gBAAAA,GAAA3nD,OAGA,QAAAkqD,GAAAvnD,GACA,UAAAA,EAAA,IAAAA,EAAAJ,SAAA,IACAI,EAAAJ,SAAA,IAGA,QAAA2mD,GAAAphD,GAEA,OADAmjD,MACA9vC,EAAA,EAAiBA,EAAArT,EAAA9H,OAAgBmb,IAAA,CACjC,GAAAxb,GAAAmI,EAAA2O,WAAA0E,EACA,SAAAxb,EACAsrD,EAAAv6C,KAAA/Q,OACK,CACL,GAAAsS,GAAAkJ,CACAxb,IAAA,cAAAA,GAAAwb,GAEA,QADA8oC,GAAAiH,mBAAApjD,EAAAnK,MAAAsU,EAAAkJ,EAAA,IAAAooB,OAAA,GAAA1yB,MAAA,KACA5R,EAAA,EAAqBA,EAAAglD,EAAAjkD,OAAcf,IACnCgsD,EAAAv6C,KAAA9T,SAAAqnD,EAAAhlD,GAAA,MAIA,MAAAgsD,GAGA,QAAA7B,GAAAthD,GAEA,OADAmjD,MACA9vC,EAAA,EAAiBA,EAAArT,EAAA9H,OAAgBmb,IAEjC8vC,EAAAv6C,KAAA,IAAA5I,EAAA2O,WAAA0E,GAEA,OAAA8vC,GAGA,QAAAxB,GAAA3hD,GAGA,OAFAxK,GAAA6tD,EAAAC,EACAH,KACA9vC,EAAA,EAAiBA,EAAArT,EAAA9H,OAAgBmb,IACjC7d,EAAAwK,EAAA2O,WAAA0E,GACAgwC,EAAA7tD,GAAA,EACA8tD,EAAA9tD,EAAA,IACA2tD,EAAAv6C,KAAA06C,GACAH,EAAAv6C,KAAAy6C,EAGA,OAAAF,GAGA,QAAA1B,GAAAzhD,GACA,MAAA6hD,GAAA0B,YAAAvjD,GAGA,QAAAmhD,GAAA9jC,EAAA+2B,EAAA0M,EAAA5oD,EAAAsrD,GACAA,IAAAtrD,KAAAsrD,EACA,QAAAnwC,GAAA,EAAiBnb,EAAAmb,KACjBA,EAAAytC,GAAA1M,EAAAl8C,QAAAmb,GAAAgK,EAAAnlB,QAD6Bmb,IAG7B+gC,EAAA/gC,EAAAytC,GAAAzjC,EAAAhK,EAEA,OAAAA,GAGA,QAAA2uC,GAAAhiD,GACA,IACA,MAAAyjD,oBAAAzjD,GACG,MAAAwS,GACH,MAAAnU,QAAAmpB,aAAA;;;;;;AAlhCA,GAAAq6B,GAAA7tD,EAAA,KACA+uD,EAAA/uD,EAAA,KACAsG,EAAAtG,EAAA,IAEAD,GAAA6rD,SACA7rD,EAAA2vD,WAAA9D,EACA7rD,EAAA4vD,kBAAA,GACA/D,EAAAgE,SAAA,IAEA,IAAA1D,GAAA,UAwBAN,GAAAQ,oBAAA,WACA,IACA,GAAAD,GAAA,GAAA9B,aAAA,GACAnrB,EAAA,GAAAotB,YAAAH,EAEA,OADAjtB,GAAA2wB,IAAA,WAA2B,WAC3B,KAAA3wB,EAAA2wB,OACA,kBAAA3wB,GAAA4wB,UACA,OAAAxD,YAAA,GAAAwD,SAAA,KAAA7D,WACG,MAAAtpD,GACH,aA4EAipD,EAAAc,SAAA,SAAA7oD,GACA,cAAAA,MAAA0oD,YAGAX,EAAAmE,QAAA,SAAAnsD,EAAAC,GACA,IAAA+nD,EAAAc,SAAA9oD,KAAAgoD,EAAAc,SAAA7oD,GACA,SAAA0D,WAAA,4BAIA,QAFAxC,GAAAnB,EAAAM,OACA4sB,EAAAjtB,EAAAK,OACAmb,EAAA,EAAAra,EAAAmB,KAAAe,IAAAnC,EAAA+rB,GAAuC9rB,EAAAqa,GAAAzb,EAAAyb,KAAAxb,EAAAwb,GAA0BA,KAKjE,MAJAA,KAAAra,IACAD,EAAAnB,EAAAyb,GACAyR,EAAAjtB,EAAAwb,IAEAyR,EAAA/rB,EAAA,GACAA,EAAA+rB,EAAA,EACA,GAGA86B,EAAAoE,WAAA,SAAAlE,GACA,OAAAzhD,OAAAyhD,GAAAlrD,eACA,UACA,WACA,YACA,YACA,aACA,aACA,UACA,WACA,YACA,cACA,eACA,QACA,SACA,WAIAgrD,EAAAlqD,OAAA,SAAAsC,EAAAisD,GACA,IAAA3pD,EAAAtC,GAAA,SAAAuD,WAAA,uCAEA,QAAAvD,EAAAE,OACA,UAAA0nD,GAAA,EACG,QAAA5nD,EAAAE,OACH,MAAAF,GAAA,EAGA,IAAAqb,EACA,IAAAjT,SAAA6jD,EAEA,IADAA,EAAA,EACA5wC,EAAA,EAAeA,EAAArb,EAAAE,OAAiBmb,IAChC4wC,GAAAjsD,EAAAqb,GAAAnb,MAIA,IAAAioD,GAAA,GAAAP,GAAAqE,GACAvoC,EAAA,CACA,KAAArI,EAAA,EAAaA,EAAArb,EAAAE,OAAiBmb,IAAA,CAC9B,GAAApZ,GAAAjC,EAAAqb,EACApZ,GAAA+B,KAAAmkD,EAAAzkC,GACAA,GAAAzhB,EAAA/B,OAEA,MAAAioD,IAGAP,EAAAK,WAAA,SAAAjgD,EAAA8/C,GACA,GAAAruC,EAEA,QADAzR,GAAA,GACA8/C,GAAA,QACA,YACA,aACA,UACAruC,EAAAzR,EAAA9H,MACA,MACA,YACA,YACA,cACA,eACAuZ,EAAA,EAAAzR,EAAA9H,MACA,MACA,WACAuZ,EAAAzR,EAAA9H,SAAA,CACA,MACA,YACA,YACAuZ,EAAA2vC,EAAAphD,GAAA9H,MACA,MACA,cACAuZ,EAAAgwC,EAAAzhD,GAAA9H,MACA,MACA,SACAuZ,EAAAzR,EAAA9H,OAEA,MAAAuZ,IAIAmuC,EAAAhqD,UAAAsC,OAAAkI,OACAw/C,EAAAhqD,UAAAkjC,OAAA14B,OAGAw/C,EAAAhqD,UAAA6E,SAAA,SAAAqlD,EAAA31C,EAAAge,GACA,GAAA+7B,IAAA,CAQA,IANA/5C,KAAA,EACAge,EAAA/nB,SAAA+nB,GAAAtgB,MAAAsgB,EAAA/yB,KAAA8C,OAAAiwB,IAAA,EAEA23B,MAAA,QACA,EAAA31C,MAAA,GACAge,EAAA/yB,KAAA8C,SAAAiwB,EAAA/yB,KAAA8C,QACAiS,GAAAge,EAAA,QAEA,QACA,OAAA23B,GACA,UACA,MAAAqC,GAAA/sD,KAAA+U,EAAAge,EAEA,YACA,YACA,MAAA45B,GAAA3sD,KAAA+U,EAAAge,EAEA,aACA,MAAA85B,GAAA7sD,KAAA+U,EAAAge,EAEA,cACA,MAAA+5B,GAAA9sD,KAAA+U,EAAAge,EAEA,cACA,MAAAy5B,GAAAxsD,KAAA+U,EAAAge,EAEA,YACA,YACA,cACA,eACA,MAAAk6B,GAAAjtD,KAAA+U,EAAAge,EAEA,SACA,GAAA+7B,EACA,SAAA3oD,WAAA,qBAAAukD,EACAA,MAAA,IAAAlrD,cACAsvD,GAAA,IAKAtE,EAAAhqD,UAAAuuD,OAAA,SAAAtsD,GACA,IAAA+nD,EAAAc,SAAA7oD,GAAA,SAAA0D,WAAA,4BACA,YAAAqkD,EAAAmE,QAAA3uD,KAAAyC,IAGA+nD,EAAAhqD,UAAAwuD,QAAA,WACA,GAAApkD,GAAA,GACA5F,EAAArG,EAAA4vD,iBAMA,OALAvuD,MAAA8C,OAAA,IACA8H,EAAA5K,KAAAqF,SAAA,QAAAL,GAAAvF,MAAA,SAAkD6R,KAAA,KAClDtR,KAAA8C,OAAAkC,IACA4F,GAAA,UAEA,WAAAA,EAAA,KAGA4/C,EAAAhqD,UAAAmuD,QAAA,SAAAlsD,GACA,IAAA+nD,EAAAc,SAAA7oD,GAAA,SAAA0D,WAAA,4BACA,OAAAqkD,GAAAmE,QAAA3uD,KAAAyC,IAIA+nD,EAAAhqD,UAAAyP,IAAA,SAAAy7C,GAEA,MADAxsD,SAAA6B,IAAA,6DACAf,KAAAurD,UAAAG,IAIAlB,EAAAhqD,UAAAwR,IAAA,SAAAhQ,EAAA0pD,GAEA,MADAxsD,SAAA6B,IAAA,6DACAf,KAAAivD,WAAAjtD,EAAA0pD,IAsDAlB,EAAAhqD,UAAAupC,MAAA,SAAA0hB,EAAAC,EAAA5oD,EAAA4nD,GAGA,GAAA19B,SAAA0+B,GACA1+B,SAAAlqB,KACA4nD,EAAA5nD,EACAA,EAAAkI,YAEG,CACH,GAAAkkD,GAAAxE,CACAA,GAAAgB,EACAA,EAAA5oD,EACAA,EAAAosD,EAGAxD,EAAAnmD,OAAAmmD,IAAA,CACA,IAAAz1B,GAAAj2B,KAAA8C,OAAA4oD,CACA5oD,IAGAA,EAAAyC,OAAAzC,GACAA,EAAAmzB,IACAnzB,EAAAmzB,IAJAnzB,EAAAmzB,EAOAy0B,EAAAzhD,OAAAyhD,GAAA,QAAAlrD,aAEA,IAAA6c,EACA,QAAAquC,GACA,UACAruC,EAAAmvC,EAAAxrD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,YACA,YACAuZ,EAAAwvC,EAAA7rD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,aACAuZ,EAAA4vC,EAAAjsD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,cACAuZ,EAAA8vC,EAAAnsD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,cACAuZ,EAAA+vC,EAAApsD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,YACA,YACA,cACA,eACAuZ,EAAAiwC,EAAAtsD,KAAAyrD,EAAAC,EAAA5oD,EACA,MACA,SACA,SAAAqD,WAAA,qBAAAukD,GAEA,MAAAruC,IAGAmuC,EAAAhqD,UAAA01C,OAAA,WACA,OACAnrC,KAAA,SACA2U,KAAAnf,MAAAC,UAAAC,MAAAC,KAAAV,KAAAmvD,MAAAnvD,KAAA,KAiEAwqD,EAAAhqD,UAAAC,MAAA,SAAAsU,EAAAge,GACA,GAAAnvB,GAAA5D,KAAA8C,MAuBA,IAtBAiS,MACAge,EAAA/nB,SAAA+nB,EAAAnvB,IAAAmvB,EAEA,EAAAhe,GACAA,GAAAnR,EACA,EAAAmR,IACAA,EAAA,IACGA,EAAAnR,IACHmR,EAAAnR,GAGA,EAAAmvB,GACAA,GAAAnvB,EACA,EAAAmvB,IACAA,EAAA,IACGA,EAAAnvB,IACHmvB,EAAAnvB,GAGAmR,EAAAge,IACAA,EAAAhe,GAEAy1C,EAAAQ,oBACA,MAAAR,GAAAS,SAAAjrD,KAAA0uD,SAAA35C,EAAAge,GAIA,QAFAq8B,GAAAr8B,EAAAhe,EACAs6C,EAAA,GAAA7E,GAAA4E,EAAApkD,QAAA,GACAiT,EAAA,EAAmBmxC,EAAAnxC,EAAcA,IACjCoxC,EAAApxC,GAAAje,KAAAie,EAAAlJ,EAEA,OAAAs6C,IAcA7E,EAAAhqD,UAAA+qD,UAAA,SAAAG,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA9C,KAAA0rD,IAGAlB,EAAAhqD,UAAA8uD,aAAA,SAAA5D,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA9C,KAAA0rD,GAAA1rD,KAAA0rD,EAAA,OAGAlB,EAAAhqD,UAAA+uD,aAAA,SAAA7D,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA9C,KAAA0rD,IAAA,EAAA1rD,KAAA0rD,EAAA,IAGAlB,EAAAhqD,UAAAgvD,aAAA,SAAA9D,EAAAgC,GAIA,MAHAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,SAEA9C,KAAA0rD,GACA1rD,KAAA0rD,EAAA,MACA1rD,KAAA0rD,EAAA,QACA,SAAA1rD,KAAA0rD,EAAA,IAGAlB,EAAAhqD,UAAAivD,aAAA,SAAA/D,EAAAgC,GAIA,MAHAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QAEA,SAAA9C,KAAA0rD,IACA1rD,KAAA0rD,EAAA,OACA1rD,KAAA0rD,EAAA,MACA1rD,KAAA0rD,EAAA,KAGAlB,EAAAhqD,UAAAkvD,SAAA,SAAAhE,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA,IAAA9C,KAAA0rD,GAEA,QAAA1rD,KAAA0rD,GAAA,GADA1rD,KAAA0rD,IAIAlB,EAAAhqD,UAAAmvD,YAAA,SAAAjE,EAAAgC,GACAA,GACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,OACA,IAAAqC,GAAAnF,KAAA0rD,GAAA1rD,KAAA0rD,EAAA,KACA,cAAAvmD,EAAA,WAAAA,KAGAqlD,EAAAhqD,UAAAovD,YAAA,SAAAlE,EAAAgC,GACAA,GACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,OACA,IAAAqC,GAAAnF,KAAA0rD,EAAA,GAAA1rD,KAAA0rD,IAAA,CACA,cAAAvmD,EAAA,WAAAA,KAGAqlD,EAAAhqD,UAAAqvD,YAAA,SAAAnE,EAAAgC,GAIA,MAHAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QAEA9C,KAAA0rD,GACA1rD,KAAA0rD,EAAA,MACA1rD,KAAA0rD,EAAA,OACA1rD,KAAA0rD,EAAA,QAGAlB,EAAAhqD,UAAAsvD,YAAA,SAAApE,EAAAgC,GAIA,MAHAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QAEA9C,KAAA0rD,IAAA,GACA1rD,KAAA0rD,EAAA,OACA1rD,KAAA0rD,EAAA,MACA1rD,KAAA0rD,EAAA,IAGAlB,EAAAhqD,UAAAuvD,YAAA,SAAArE,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA6qD,EAAAqC,KAAAhwD,KAAA0rD,GAAA,SAGAlB,EAAAhqD,UAAAyvD,YAAA,SAAAvE,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA6qD,EAAAqC,KAAAhwD,KAAA0rD,GAAA,SAGAlB,EAAAhqD,UAAA0vD,aAAA,SAAAxE,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA6qD,EAAAqC,KAAAhwD,KAAA0rD,GAAA,SAGAlB,EAAAhqD,UAAA2vD,aAAA,SAAAzE,EAAAgC,GAGA,MAFAA,IACAP,EAAAzB,EAAA,EAAA1rD,KAAA8C,QACA6qD,EAAAqC,KAAAhwD,KAAA0rD,GAAA,SASAlB,EAAAhqD,UAAAyuD,WAAA,SAAAtpD,EAAA+lD,EAAAgC,GAOA,MANA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,SACAlB,EAAAQ,sBAAArlD,EAAAZ,KAAA2P,MAAA/O,IACA3F,KAAA0rD,GAAA/lD,EACA+lD,EAAA,GAWAlB,EAAAhqD,UAAA4vD,cAAA,SAAAzqD,EAAA+lD,EAAAgC,GASA,MARA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,WACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,EACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACG0nD,EAAArtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAA6vD,cAAA,SAAA1qD,EAAA+lD,EAAAgC,GASA,MARA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,WACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,IAAA,EACA3F,KAAA0rD,EAAA,GAAA/lD,GACG0nD,EAAArtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAUAlB,EAAAhqD,UAAA8vD,cAAA,SAAA3qD,EAAA+lD,EAAAgC,GAWA,MAVA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,gBACAlB,EAAAQ,qBACAhrD,KAAA0rD,EAAA,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,EACA3F,KAAA0rD,GAAA/lD,GACG4nD,EAAAvtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAA+vD,cAAA,SAAA5qD,EAAA+lD,EAAAgC,GAWA,MAVA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,gBACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,EACA3F,KAAA0rD,EAAA,GAAA/lD,GACG4nD,EAAAvtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAAgwD,UAAA,SAAA7qD,EAAA+lD,EAAAgC,GAQA,MAPA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,YACAlB,EAAAQ,sBAAArlD,EAAAZ,KAAA2P,MAAA/O,IACA,EAAAA,MAAA,IAAAA,EAAA,GACA3F,KAAA0rD,GAAA/lD,EACA+lD,EAAA,GAGAlB,EAAAhqD,UAAAiwD,aAAA,SAAA9qD,EAAA+lD,EAAAgC,GASA,MARA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,gBACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,EACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACG0nD,EAAArtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAAkwD,aAAA,SAAA/qD,EAAA+lD,EAAAgC,GASA,MARA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,gBACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,IAAA,EACA3F,KAAA0rD,EAAA,GAAA/lD,GACG0nD,EAAArtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAAmwD,aAAA,SAAAhrD,EAAA+lD,EAAAgC,GAWA,MAVA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,0BACAlB,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,EACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,EACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,IACG4nD,EAAAvtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAGAlB,EAAAhqD,UAAAowD,aAAA,SAAAjrD,EAAA+lD,EAAAgC,GAYA,MAXA/nD,MACA+lD,KAAA,EACAgC,GACAN,EAAAptD,KAAA2F,EAAA+lD,EAAA,0BACA,EAAA/lD,MAAA,WAAAA,EAAA,GACA6kD,EAAAQ,qBACAhrD,KAAA0rD,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,GACA3F,KAAA0rD,EAAA,GAAA/lD,IAAA,EACA3F,KAAA0rD,EAAA,GAAA/lD,GACG4nD,EAAAvtD,KAAA2F,EAAA+lD,GAAA,GACHA,EAAA,GAeAlB,EAAAhqD,UAAAqwD,aAAA,SAAAlrD,EAAA+lD,EAAAgC,GACA,MAAAD,GAAAztD,KAAA2F,EAAA+lD,GAAA,EAAAgC,IAGAlD,EAAAhqD,UAAAswD,aAAA,SAAAnrD,EAAA+lD,EAAAgC,GACA,MAAAD,GAAAztD,KAAA2F,EAAA+lD,GAAA,EAAAgC,IAUAlD,EAAAhqD,UAAAuwD,cAAA,SAAAprD,EAAA+lD,EAAAgC,GACA,MAAAE,GAAA5tD,KAAA2F,EAAA+lD,GAAA,EAAAgC,IAGAlD,EAAAhqD,UAAAwwD,cAAA,SAAArrD,EAAA+lD,EAAAgC,GACA,MAAAE,GAAA5tD,KAAA2F,EAAA+lD,GAAA,EAAAgC,IAIAlD,EAAAhqD,UAAAoG,KAAA,SAAAgK,EAAAqgD,EAAAl8C,EAAAge,GACA,GAAAlb,GAAA7X,IAOA,IALA+U,MAAA,GACAge,GAAA,IAAAA,MAAA/yB,KAAA8C,QACAmuD,MAAA,GAGAl+B,IAAAhe,GACA,IAAAnE,EAAA9N,QAAA,IAAA+U,EAAA/U,OAAA,CAGA,GAAAiS,EAAAge,EAAA,SAAA5sB,WAAA,0BACA,MAAA8qD,MAAArgD,EAAA9N,OACA,SAAAqD,WAAA,4BACA,MAAA4O,MAAA8C,EAAA/U,OAAA,SAAAqD,WAAA,4BACA,MAAA4sB,KAAAlb,EAAA/U,OAAA,SAAAqD,WAAA,0BAGA4sB,GAAA/yB,KAAA8C,SACAiwB,EAAA/yB,KAAA8C,QACA8N,EAAA9N,OAAAmuD,EAAAl+B,EAAAhe,IACAge,EAAAniB,EAAA9N,OAAAmuD,EAAAl8C,EAEA,IAAAnR,GAAAmvB,EAAAhe,CAEA,QAAAnR,IAAA4mD,EAAAQ,oBACA,OAAA/sC,GAAA,EAAmBra,EAAAqa,EAASA,IAC5BrN,EAAAqN,EAAAgzC,GAAAjxD,KAAAie,EAAAlJ,OAGAnE,GAAAw6C,KAAAprD,KAAA0uD,SAAA35C,IAAAnR,GAAAqtD,KAKAzG,EAAAhqD,UAAA+yB,KAAA,SAAA5tB,EAAAoP,EAAAge,GAKA,GAJAptB,MAAA,GACAoP,MAAA,GACAge,MAAA/yB,KAAA8C,QAEAiS,EAAAge,EAAA,SAAA5sB,WAAA,cAGA,IAAA4sB,IAAAhe,GACA,IAAA/U,KAAA8C,OAAA,CAEA,KAAAiS,MAAA/U,KAAA8C,OAAA,SAAAqD,WAAA,sBACA,MAAA4sB,KAAA/yB,KAAA8C,OAAA,SAAAqD,WAAA,oBAEA,IAAA8X,EACA,oBAAAtY,GACA,IAAAsY,EAAAlJ,EAAmBge,EAAA9U,EAASA,IAC5Bje,KAAAie,GAAAtY,MAEG,CACH,GAAAunD,GAAAlB,EAAArmD,EAAAN,YACAzB,EAAAspD,EAAApqD,MACA,KAAAmb,EAAAlJ,EAAmBge,EAAA9U,EAASA,IAC5Bje,KAAAie,GAAAivC,EAAAjvC,EAAAra,GAIA,MAAA5D,QAOAwqD,EAAAhqD,UAAA0wD,cAAA,WACA,sBAAAhG,YAAA,CACA,GAAAV,EAAAQ,oBACA,UAAAR,GAAAxqD,MAAA0pD,MAGA,QADAqB,GAAA,GAAAG,YAAAlrD,KAAA8C,QACAmb,EAAA,EAAAra,EAAAmnD,EAAAjoD,OAAuCc,EAAAqa,EAASA,GAAA,EAChD8sC,EAAA9sC,GAAAje,KAAAie,EAEA,OAAA8sC,GAAArB,OAGA,SAAAvjD,WAAA,sDAOA,IAAAgrD,GAAA3G,EAAAhqD,SAKAgqD,GAAAS,SAAA,SAAAntB,GAoDA,MAnDAA,GAAAzsB,YAAAm5C,EACA1sB,EAAAqtB,WAAA,EAGArtB,EAAAszB,KAAAtzB,EAAA7tB,IACA6tB,EAAAstB,KAAAttB,EAAA9rB,IAGA8rB,EAAA7tB,IAAAkhD,EAAAlhD,IACA6tB,EAAA9rB,IAAAm/C,EAAAn/C,IAEA8rB,EAAAiM,MAAAonB,EAAApnB,MACAjM,EAAAz4B,SAAA8rD,EAAA9rD,SACAy4B,EAAAuzB,eAAAF,EAAA9rD,SACAy4B,EAAAoY,OAAAib,EAAAjb,OACApY,EAAAixB,OAAAoC,EAAApC,OACAjxB,EAAA6wB,QAAAwC,EAAAxC,QACA7wB,EAAAl3B,KAAAuqD,EAAAvqD,KACAk3B,EAAAr9B,MAAA0wD,EAAA1wD,MACAq9B,EAAAytB,UAAA4F,EAAA5F,UACAztB,EAAAwxB,aAAA6B,EAAA7B,aACAxxB,EAAAyxB,aAAA4B,EAAA5B,aACAzxB,EAAA0xB,aAAA2B,EAAA3B,aACA1xB,EAAA2xB,aAAA0B,EAAA1B,aACA3xB,EAAA4xB,SAAAyB,EAAAzB,SACA5xB,EAAA6xB,YAAAwB,EAAAxB,YACA7xB,EAAA8xB,YAAAuB,EAAAvB,YACA9xB,EAAA+xB,YAAAsB,EAAAtB,YACA/xB,EAAAgyB,YAAAqB,EAAArB,YACAhyB,EAAAiyB,YAAAoB,EAAApB,YACAjyB,EAAAmyB,YAAAkB,EAAAlB,YACAnyB,EAAAoyB,aAAAiB,EAAAjB,aACApyB,EAAAqyB,aAAAgB,EAAAhB,aACAryB,EAAAmxB,WAAAkC,EAAAlC,WACAnxB,EAAAsyB,cAAAe,EAAAf,cACAtyB,EAAAuyB,cAAAc,EAAAd,cACAvyB,EAAAwyB,cAAAa,EAAAb,cACAxyB,EAAAyyB,cAAAY,EAAAZ,cACAzyB,EAAA0yB,UAAAW,EAAAX,UACA1yB,EAAA2yB,aAAAU,EAAAV,aACA3yB,EAAA4yB,aAAAS,EAAAT,aACA5yB,EAAA6yB,aAAAQ,EAAAR,aACA7yB,EAAA8yB,aAAAO,EAAAP,aACA9yB,EAAA+yB,aAAAM,EAAAN,aACA/yB,EAAAgzB,aAAAK,EAAAL,aACAhzB,EAAAizB,cAAAI,EAAAJ,cACAjzB,EAAAkzB,cAAAG,EAAAH,cACAlzB,EAAAvK,KAAA49B,EAAA59B,KACAuK,EAAAkxB,QAAAmC,EAAAnC,QACAlxB,EAAAozB,cAAAC,EAAAD,cAEApzB,EAGA,IAAAgwB,GAAA,kBlBm7c8BptD,KAAK/B,EAASC,EAAoB,IAAI4rD,SAI9DtF,GACA,SAASxmD,EAAQC,ImB13evB,SAAAmZ,GACApZ,EAAAC,QADA,mBAAAM,QACAA,OACC,mBAAA6Y,GACDA,OnBi4e8BpX,KAAK/B,EAAU,WAAa,MAAOqB,WAI3DsxD,GACA,SAAS5yD,EAAQC,GAEtB,YoB14eM,SAAS4yD,GAASC,GACvB,OACEhwC,GAAE,SAACzW,EAAM+V,GACP,MAAO,IAAIhE,SAAQ,SAACC,EAASnI,GAC3B,GAAI68C,GAAK,GAAIC,eACbD,GAAGE,KAAK,MAAOH,GAAK,GACpBC,EAAGG,aAAe7mD,EAClB0mD,EAAG9vC,OAAU,WACQ,OAAd8vC,EAAGI,OACN90C,EAAQ00C,EAAGK,UAEXl9C,EAAO,GAAIxM,OAAK,sBAAuBopD,EAAG,UAAUC,EAAGI,UAG3DJ,EAAG7vC,QAAU,WpB84eV,MoB94egBhN,GAAO,GAAIxM,OAAK,sBAAuBopD,KACtD1wC,IAAU2wC,EAAGM,WAAa,SAAAxwD,GpBg5e3B,MoBh5egCuf,GAASE,OAAOzf,EAAEwf,OAAQxf,EAAEsf,SAC/D4wC,EAAGO,KAAK,UpB43efrzD,EoB54ee4yD,WpBu6ef5yD,EAAQ,WoBj5eM4yD,EpBk5ednsD,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJssD,GACA,SAASvzD,EAAQC,EAASC,GqBl5ehC,QAAAszD,KACAlyD,KAAAmyD,SAAA,KACAnyD,KAAAoyD,QAAA,KACApyD,KAAAqyD,KAAA,KACAryD,KAAAsyD,KAAA,KACAtyD,KAAAw0B,KAAA,KACAx0B,KAAAuyD,SAAA,KACAvyD,KAAAwyD,KAAA,KACAxyD,KAAAyyD,OAAA,KACAzyD,KAAA0yD,MAAA,KACA1yD,KAAA2yD,SAAA,KACA3yD,KAAA0T,KAAA,KACA1T,KAAA4yD,KAAA,KAqDA,QAAAC,GAAArB,EAAAsB,EAAAC,GACA,GAAAvB,GAAA5zC,EAAA4zC,gBAAAU,GAAA,MAAAV,EAEA,IAAAlzB,GAAA,GAAA4zB,EAEA,OADA5zB,GAAAuoB,MAAA2K,EAAAsB,EAAAC,GACAz0B,EA6OA,QAAA00B,GAAAvuD,GAMA,MADAwuD,GAAAxuD,OAAAouD,EAAApuD,IACAA,YAAAytD,GACAztD,EAAA+hD,SADA0L,EAAA1xD,UAAAgmD,OAAA9lD,KAAA+D,GA4DA,QAAAyuD,GAAAr7C,EAAAs7C,GACA,MAAAN,GAAAh7C,GAAA,MAAAkF,QAAAo2C,GAOA,QAAAC,GAAAv7C,EAAAs7C,GACA,MAAAt7C,GACAg7C,EAAAh7C,GAAA,MAAAw7C,cAAAF,GADAA,EAyRA,QAAAF,GAAAppD,GACA,sBAAAA,GAGA,QAAA+T,GAAA/T,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAypD,GAAAzpD,GACA,cAAAA,EAEA,QAAA0pD,GAAA1pD,GACA,aAAAA,EA5qBA,GAAA2pD,GAAA50D,EAAA,IAEAD,GAAAkoD,MAAAgM,EACAl0D,EAAAoe,QAAAm2C,EACAv0D,EAAA00D,cAAAD,EACAz0D,EAAA6nD,OAAAwM,EAEAr0D,EAAAuzD,KAqBA,IAAAuB,GAAA,oBACAC,EAAA,WAIAC,GAAA,mCAGAC,GAAA,IAAgB,IAAK,kBAAAtzD,OAAAqzD,GAGrBE,GAAA,KAAAvzD,OAAAszD,GAKAE,GAAA,gBAAqC,KAAAxzD,OAAAuzD,GACrCE,GAAA,aACAC,EAAA,IACAC,EAAA,wBACAC,EAAA,8BAEAC,GACAC,YAAA,EACAC,eAAA,GAGAC,GACAF,YAAA,EACAC,eAAA,GAGAE,GACAC,MAAA,EACAC,OAAA,EACAC,KAAA,EACAC,QAAA,EACAC,MAAA,EACAC,SAAA,EACAC,UAAA,EACAC,QAAA,EACAC,WAAA,EACAC,SAAA,GAEAC,EAAAt2D,EAAA,IAUAszD,GAAA1xD,UAAAqmD,MAAA,SAAA2K,EAAAsB,EAAAC,GACA,IAAAE,EAAAzB,GACA,SAAArrD,WAAA,+CAAAqrD,GAGA,IAAA2D,GAAA3D,CAIA2D,KAAA3qD,MAEA,IAAA0T,GAAAu1C,EAAA3M,KAAAqO,EACA,IAAAj3C,EAAA,CACAA,IAAA,EACA,IAAAk3C,GAAAl3C,EAAA1e,aACAQ,MAAAmyD,SAAAiD,EACAD,IAAA9uB,OAAAnoB,EAAApb,QAOA,GAAAiwD,GAAA70C,GAAAi3C,EAAA11D,MAAA,yBACA,GAAA2yD,GAAA,OAAA+C,EAAA9uB,OAAA,MACA+rB,GAAAl0C,GAAAo2C,EAAAp2C,KACAi3C,IAAA9uB,OAAA,GACArmC,KAAAoyD,SAAA,GAIA,IAAAkC,EAAAp2C,KACAk0C,GAAAl0C,IAAAq2C,EAAAr2C,IAAA,CAmBA,OADAm3C,GAAA,GACAp3C,EAAA,EAAmBA,EAAA81C,EAAAjxD,OAA4Bmb,IAAA,CAC/C,GAAAq3C,GAAAH,EAAAxkD,QAAAojD,EAAA91C,GACA,MAAAq3C,IAAA,KAAAD,KAAAC,KACAD,EAAAC,GAKA,GAAAjD,GAAAkD,CAGAA,GAFA,KAAAF,EAEAF,EAAAtjD,YAAA,KAIAsjD,EAAAtjD,YAAA,IAAAwjD,GAKA,KAAAE,IACAlD,EAAA8C,EAAA10D,MAAA,EAAA80D,GACAJ,IAAA10D,MAAA80D,EAAA,GACAv1D,KAAAqyD,KAAAhE,mBAAAgE,IAIAgD,EAAA,EACA,QAAAp3C,GAAA,EAAmBA,EAAA61C,EAAAhxD,OAAyBmb,IAAA,CAC5C,GAAAq3C,GAAAH,EAAAxkD,QAAAmjD,EAAA71C,GACA,MAAAq3C,IAAA,KAAAD,KAAAC,KACAD,EAAAC,GAGA,KAAAD,IACAA,EAAAF,EAAAryD,QAEA9C,KAAAsyD,KAAA6C,EAAA10D,MAAA,EAAA40D,GACAF,IAAA10D,MAAA40D,GAGAr1D,KAAAw1D,YAIAx1D,KAAAuyD,SAAAvyD,KAAAuyD,UAAA,EAIA,IAAAkD,GAAA,MAAAz1D,KAAAuyD,SAAA,IACA,MAAAvyD,KAAAuyD,SAAAvyD,KAAAuyD,SAAAzvD,OAAA,EAGA,KAAA2yD,EAEA,OADAC,GAAA11D,KAAAuyD,SAAA5+C,MAAA,MACAsK,EAAA,EAAAuI,EAAAkvC,EAAA5yD,OAA2C0jB,EAAAvI,EAAOA,IAAA,CAClD,GAAAiF,GAAAwyC,EAAAz3C,EACA,IAAAiF,IACAA,EAAAzjB,MAAAw0D,GAAA,CAEA,OADA0B,GAAA,GACA5zD,EAAA,EAAA4xB,EAAAzQ,EAAApgB,OAA0C6wB,EAAA5xB,EAAOA,IAKjD4zD,GAJAzyC,EAAA3J,WAAAxX,GAAA,IAIA,IAEAmhB,EAAAnhB,EAIA,KAAA4zD,EAAAl2D,MAAAw0D,GAAA,CACA,GAAA2B,GAAAF,EAAAj1D,MAAA,EAAAwd,GACA43C,EAAAH,EAAAj1D,MAAAwd,EAAA,GACA63C,EAAA5yC,EAAAzjB,MAAAy0D,EACA4B,KACAF,EAAApiD,KAAAsiD,EAAA,IACAD,EAAA/nC,QAAAgoC,EAAA,KAEAD,EAAA/yD,SACAqyD,EAAA,IAAAU,EAAAvkD,KAAA,KAAA6jD,GAEAn1D,KAAAuyD,SAAAqD,EAAAtkD,KAAA,IACA,SAaA,GANAtR,KAAAuyD,SADAvyD,KAAAuyD,SAAAzvD,OAAAkxD,EACA,GAGAh0D,KAAAuyD,SAAA/yD,eAGAi2D,EAAA,CAOA,OAFAM,GAAA/1D,KAAAuyD,SAAA5+C,MAAA,KACAqiD,KACA/3C,EAAA,EAAqBA,EAAA83C,EAAAjzD,SAAwBmb,EAAA,CAC7C,GAAAsI,GAAAwvC,EAAA93C,EACA+3C,GAAAxiD,KAAA+S,EAAA9mB,MAAA,kBACA,OAAA+zD,EAAAyC,OAAA1vC,MAEAvmB,KAAAuyD,SAAAyD,EAAA1kD,KAAA,KAGA,GAAAlH,GAAApK,KAAAw0B,KAAA,IAAAx0B,KAAAw0B,KAAA,GACAuyB,EAAA/mD,KAAAuyD,UAAA,EACAvyD,MAAAsyD,KAAAvL,EAAA38C,EACApK,KAAA4yD,MAAA5yD,KAAAsyD,KAIAmD,IACAz1D,KAAAuyD,SAAAvyD,KAAAuyD,SAAAlsB,OAAA,EAAArmC,KAAAuyD,SAAAzvD,OAAA,GACA,MAAAqyD,EAAA,KACAA,EAAA,IAAAA,IAOA,IAAAhB,EAAAiB,GAKA,OAAAn3C,GAAA,EAAAuI,EAAAqtC,EAAA/wD,OAA0C0jB,EAAAvI,EAAOA,IAAA,CACjD,GAAAi4C,GAAArC,EAAA51C,GACAk4C,EAAAnI,mBAAAkI,EACAC,KAAAD,IACAC,EAAAp9B,OAAAm9B,IAEAf,IAAAxhD,MAAAuiD,GAAA5kD,KAAA6kD,GAMA,GAAA3D,GAAA2C,EAAAxkD,QAAA,IACA,MAAA6hD,IAEAxyD,KAAAwyD,KAAA2C,EAAA9uB,OAAAmsB,GACA2C,IAAA10D,MAAA,EAAA+xD,GAEA,IAAA4D,GAAAjB,EAAAxkD,QAAA,IAoBA,IAnBA,KAAAylD,GACAp2D,KAAAyyD,OAAA0C,EAAA9uB,OAAA+vB,GACAp2D,KAAA0yD,MAAAyC,EAAA9uB,OAAA+vB,EAAA,GACAtD,IACA9yD,KAAA0yD,MAAAwC,EAAArO,MAAA7mD,KAAA0yD,QAEAyC,IAAA10D,MAAA,EAAA21D,IACGtD,IAEH9yD,KAAAyyD,OAAA,GACAzyD,KAAA0yD,UAEAyC,IAAAn1D,KAAA2yD,SAAAwC,GACAZ,EAAAa,IACAp1D,KAAAuyD,WAAAvyD,KAAA2yD,WACA3yD,KAAA2yD,SAAA,KAIA3yD,KAAA2yD,UAAA3yD,KAAAyyD,OAAA,CACA,GAAAroD,GAAApK,KAAA2yD,UAAA,GACApsC,EAAAvmB,KAAAyyD,QAAA,EACAzyD,MAAA0T,KAAAtJ,EAAAmc,EAKA,MADAvmB,MAAA4yD,KAAA5yD,KAAAwmD,SACAxmD,MAcAkyD,EAAA1xD,UAAAgmD,OAAA,WACA,GAAA6L,GAAAryD,KAAAqyD,MAAA,EACAA,KACAA,EAAArE,mBAAAqE,GACAA,IAAAxxD,QAAA,YACAwxD,GAAA,IAGA,IAAAF,GAAAnyD,KAAAmyD,UAAA,GACAQ,EAAA3yD,KAAA2yD,UAAA,GACAH,EAAAxyD,KAAAwyD,MAAA,GACAF,GAAA,EACAI,EAAA,EAEA1yD,MAAAsyD,KACAA,EAAAD,EAAAryD,KAAAsyD,KACGtyD,KAAAuyD,WACHD,EAAAD,GAAA,KAAAryD,KAAAuyD,SAAA5hD,QAAA,KACA3Q,KAAAuyD,SACA,IAAAvyD,KAAAuyD,SAAA,KACAvyD,KAAAw0B,OACA89B,GAAA,IAAAtyD,KAAAw0B,OAIAx0B,KAAA0yD,OACA90C,EAAA5d,KAAA0yD,QACAttD,OAAAmM,KAAAvR,KAAA0yD,OAAA5vD,SACA4vD,EAAAwC,EAAAhzD,UAAAlC,KAAA0yD,OAGA,IAAAD,GAAAzyD,KAAAyyD,QAAAC,GAAA,IAAAA,GAAA,EAsBA,OApBAP,IAAA,MAAAA,EAAA9rB,OAAA,MAAA8rB,GAAA,KAIAnyD,KAAAoyD,WACAD,GAAAoC,EAAApC,KAAAG,KAAA,GACAA,EAAA,MAAAA,GAAA,IACAK,GAAA,MAAAA,EAAAr5C,OAAA,KAAAq5C,EAAA,IAAAA,IACGL,IACHA,EAAA,IAGAE,GAAA,MAAAA,EAAAl5C,OAAA,KAAAk5C,EAAA,IAAAA,GACAC,GAAA,MAAAA,EAAAn5C,OAAA,KAAAm5C,EAAA,IAAAA,GAEAE,IAAA9xD,QAAA,iBAAApB,GACA,MAAAuuD,oBAAAvuD,KAEAgzD,IAAA5xD,QAAA,WAEAsxD,EAAAG,EAAAK,EAAAF,EAAAD,GAOAN,EAAA1xD,UAAAuc,QAAA,SAAAo2C,GACA,MAAAnzD,MAAAqzD,cAAAR,EAAAM,GAAA,OAAA3M,UAQA0L,EAAA1xD,UAAA6yD,cAAA,SAAAF,GACA,GAAAF,EAAAE,GAAA,CACA,GAAAkD,GAAA,GAAAnE,EACAmE,GAAAxP,MAAAsM,GAAA,MACAA,EAAAkD,EAGA,GAAA7yD,GAAA,GAAA0uD,EAUA,IATA9sD,OAAAmM,KAAAvR,MAAA8P,QAAA,SAAA6jB,GACAnwB,EAAAmwB,GAAA3zB,KAAA2zB,IACG3zB,MAIHwD,EAAAgvD,KAAAW,EAAAX,KAGA,KAAAW,EAAAP,KAEA,MADApvD,GAAAovD,KAAApvD,EAAAgjD,SACAhjD,CAIA,IAAA2vD,EAAAf,UAAAe,EAAAhB,SAcA,MAZA/sD,QAAAmM,KAAA4hD,GAAArjD,QAAA,SAAA6jB,GACA,aAAAA,IACAnwB,EAAAmwB,GAAAw/B,EAAAx/B,MAIA4gC,EAAA/wD,EAAA2uD,WACA3uD,EAAA+uD,WAAA/uD,EAAAmvD,WACAnvD,EAAAkQ,KAAAlQ,EAAAmvD,SAAA,KAGAnvD,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,CAGA,IAAA2vD,EAAAhB,UAAAgB,EAAAhB,WAAA3uD,EAAA2uD,SAAA,CASA,IAAAoC,EAAApB,EAAAhB,UAKA,MAJA/sD,QAAAmM,KAAA4hD,GAAArjD,QAAA,SAAA6jB,GACAnwB,EAAAmwB,GAAAw/B,EAAAx/B,KAEAnwB,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,CAIA,IADAA,EAAA2uD,SAAAgB,EAAAhB,SACAgB,EAAAb,MAAAgC,EAAAnB,EAAAhB,UASA3uD,EAAAmvD,SAAAQ,EAAAR,aATA,CAEA,IADA,GAAA2D,IAAAnD,EAAAR,UAAA,IAAAh/C,MAAA,KACA2iD,EAAAxzD,UAAAqwD,EAAAb,KAAAgE,EAAA12C,WACAuzC,EAAAb,OAAAa,EAAAb,KAAA,IACAa,EAAAZ,WAAAY,EAAAZ,SAAA,IACA,KAAA+D,EAAA,IAAAA,EAAAxoC,QAAA,IACAwoC,EAAAxzD,OAAA,GAAAwzD,EAAAxoC,QAAA,IACAtqB,EAAAmvD,SAAA2D,EAAAhlD,KAAA,KAWA,GAPA9N,EAAAivD,OAAAU,EAAAV,OACAjvD,EAAAkvD,MAAAS,EAAAT,MACAlvD,EAAA8uD,KAAAa,EAAAb,MAAA,GACA9uD,EAAA6uD,KAAAc,EAAAd,KACA7uD,EAAA+uD,SAAAY,EAAAZ,UAAAY,EAAAb,KACA9uD,EAAAgxB,KAAA2+B,EAAA3+B,KAEAhxB,EAAAmvD,UAAAnvD,EAAAivD,OAAA,CACA,GAAAroD,GAAA5G,EAAAmvD,UAAA,GACApsC,EAAA/iB,EAAAivD,QAAA,EACAjvD,GAAAkQ,KAAAtJ,EAAAmc,EAIA,MAFA/iB,GAAA4uD,QAAA5uD,EAAA4uD,SAAAe,EAAAf,QACA5uD,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,EAGA,GAAA+yD,GAAA/yD,EAAAmvD,UAAA,MAAAnvD,EAAAmvD,SAAAr5C,OAAA,GACAk9C,EACArD,EAAAb,MACAa,EAAAR,UAAA,MAAAQ,EAAAR,SAAAr5C,OAAA,GAEAm9C,EAAAD,GAAAD,GACA/yD,EAAA8uD,MAAAa,EAAAR,SACA+D,EAAAD,EACAE,EAAAnzD,EAAAmvD,UAAAnvD,EAAAmvD,SAAAh/C,MAAA,SACA2iD,EAAAnD,EAAAR,UAAAQ,EAAAR,SAAAh/C,MAAA,SACAijD,EAAApzD,EAAA2uD,WAAAoC,EAAA/wD,EAAA2uD,SA2BA,IApBAyE,IACApzD,EAAA+uD,SAAA,GACA/uD,EAAAgxB,KAAA,KACAhxB,EAAA8uD,OACA,KAAAqE,EAAA,GAAAA,EAAA,GAAAnzD,EAAA8uD,KACAqE,EAAA7oC,QAAAtqB,EAAA8uD,OAEA9uD,EAAA8uD,KAAA,GACAa,EAAAhB,WACAgB,EAAAZ,SAAA,KACAY,EAAA3+B,KAAA,KACA2+B,EAAAb,OACA,KAAAgE,EAAA,GAAAA,EAAA,GAAAnD,EAAAb,KACAgE,EAAAxoC,QAAAqlC,EAAAb,OAEAa,EAAAb,KAAA,MAEAmE,MAAA,KAAAH,EAAA,SAAAK,EAAA,KAGAH,EAEAhzD,EAAA8uD,KAAAa,EAAAb,MAAA,KAAAa,EAAAb,KACAa,EAAAb,KAAA9uD,EAAA8uD,KACA9uD,EAAA+uD,SAAAY,EAAAZ,UAAA,KAAAY,EAAAZ,SACAY,EAAAZ,SAAA/uD,EAAA+uD,SACA/uD,EAAAivD,OAAAU,EAAAV,OACAjvD,EAAAkvD,MAAAS,EAAAT,MACAiE,EAAAL,MAEG,IAAAA,EAAAxzD,OAGH6zD,UACAA,EAAAt+C,MACAs+C,IAAAr2D,OAAAg2D,GACA9yD,EAAAivD,OAAAU,EAAAV,OACAjvD,EAAAkvD,MAAAS,EAAAT,UACG,KAAAa,EAAAJ,EAAAV,QAAA,CAIH,GAAAmE,EAAA,CACApzD,EAAA+uD,SAAA/uD,EAAA8uD,KAAAqE,EAAA/2C,OAIA,IAAAi3C,GAAArzD,EAAA8uD,MAAA9uD,EAAA8uD,KAAA3hD,QAAA,OACAnN,EAAA8uD,KAAA3+C,MAAA,OACAkjD,KACArzD,EAAA6uD,KAAAwE,EAAAj3C,QACApc,EAAA8uD,KAAA9uD,EAAA+uD,SAAAsE,EAAAj3C,SAWA,MARApc,GAAAivD,OAAAU,EAAAV,OACAjvD,EAAAkvD,MAAAS,EAAAT,MAEAY,EAAA9vD,EAAAmvD,WAAAW,EAAA9vD,EAAAivD,UACAjvD,EAAAkQ,MAAAlQ,EAAAmvD,SAAAnvD,EAAAmvD,SAAA,KACAnvD,EAAAivD,OAAAjvD,EAAAivD,OAAA,KAEAjvD,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,EAGA,IAAAmzD,EAAA7zD,OAWA,MARAU,GAAAmvD,SAAA,KAGAnvD,EAAAkQ,KADAlQ,EAAAivD,OACA,IAAAjvD,EAAAivD,OAEA,KAEAjvD,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,CAcA,QARA0X,GAAAy7C,EAAAl2D,MAAA,OACAq2D,GACAtzD,EAAA8uD,MAAAa,EAAAb,QAAA,MAAAp3C,GAAA,OAAAA,IACA,KAAAA,EAIA67C,EAAA,EACA94C,EAAA04C,EAAA7zD,OAA8Bmb,GAAA,EAAQA,IACtC/C,EAAAy7C,EAAA14C,GACA,KAAA/C,EACAy7C,EAAA71D,OAAAmd,EAAA,GACK,OAAA/C,GACLy7C,EAAA71D,OAAAmd,EAAA,GACA84C,KACKA,IACLJ,EAAA71D,OAAAmd,EAAA,GACA84C,IAKA,KAAAN,IAAAC,EACA,KAAUK,IAAMA,EAChBJ,EAAA7oC,QAAA,OAIA2oC,GAAA,KAAAE,EAAA,IACAA,EAAA,UAAAA,EAAA,GAAAr9C,OAAA,IACAq9C,EAAA7oC,QAAA,IAGAgpC,GAAA,MAAAH,EAAArlD,KAAA,KAAA+0B,OAAA,KACAswB,EAAAnjD,KAAA,GAGA,IAAAwjD,GAAA,KAAAL,EAAA,IACAA,EAAA,UAAAA,EAAA,GAAAr9C,OAAA,EAGA,IAAAs9C,EAAA,CACApzD,EAAA+uD,SAAA/uD,EAAA8uD,KAAA0E,EAAA,GACAL,EAAA7zD,OAAA6zD,EAAA/2C,QAAA,EAIA,IAAAi3C,GAAArzD,EAAA8uD,MAAA9uD,EAAA8uD,KAAA3hD,QAAA,OACAnN,EAAA8uD,KAAA3+C,MAAA,OACAkjD,KACArzD,EAAA6uD,KAAAwE,EAAAj3C,QACApc,EAAA8uD,KAAA9uD,EAAA+uD,SAAAsE,EAAAj3C,SAyBA,MArBA62C,MAAAjzD,EAAA8uD,MAAAqE,EAAA7zD,OAEA2zD,IAAAO,GACAL,EAAA7oC,QAAA,IAGA6oC,EAAA7zD,OAIAU,EAAAmvD,SAAAgE,EAAArlD,KAAA,MAHA9N,EAAAmvD,SAAA,KACAnvD,EAAAkQ,KAAA,MAMA4/C,EAAA9vD,EAAAmvD,WAAAW,EAAA9vD,EAAAivD,UACAjvD,EAAAkQ,MAAAlQ,EAAAmvD,SAAAnvD,EAAAmvD,SAAA,KACAnvD,EAAAivD,OAAAjvD,EAAAivD,OAAA,KAEAjvD,EAAA6uD,KAAAc,EAAAd,MAAA7uD,EAAA6uD,KACA7uD,EAAA4uD,QAAA5uD,EAAA4uD,SAAAe,EAAAf,QACA5uD,EAAAovD,KAAApvD,EAAAgjD,SACAhjD,GAGA0uD,EAAA1xD,UAAAg1D,UAAA,WACA,GAAAlD,GAAAtyD,KAAAsyD,KACA99B,EAAAk/B,EAAA5M,KAAAwL,EACA99B,KACAA,IAAA,GACA,MAAAA,IACAx0B,KAAAw0B,OAAA6R,OAAA,IAEAisB,IAAAjsB,OAAA,EAAAisB,EAAAxvD,OAAA0xB,EAAA1xB,SAEAwvD,IAAAtyD,KAAAuyD,SAAAD,KrBu8eM2E,GACA,SAASv4D,GsB1ngBfA,EAAAC,QAAA,SAAAD,GAQA,MAPAA,GAAAw4D,kBACAx4D,EAAAy4D,UAAA,aACAz4D,EAAA+H,SAEA/H,EAAA04D,YACA14D,EAAAw4D,gBAAA,GAEAx4D,ItBkogBM24D,GACA,SAAS34D,GuB1ogBfA,EAAAC,QAAA,SAAA24D,EAAAC,EAAAC,EAAA3wD,EAAA4wD,GACAz3D,KAAAw3D,aACAx3D,KAAA6G,QAAA0wD,EAAA1wD,KAAAywD,GACAt3D,KAAAy3D,SvBmpgBMC,IACA,SAASh5D,EAAQC,GwBxpgBvB,GAAAg5D,GAAA,oEAEC,SAAAh5D,GACD,YAYA,SAAAi5D,GAAAznD,GACA,GAAAoiB,GAAApiB,EAAAoJ,WAAA,EACA,OAAAgZ,KAAAslC,EACA,GACAtlC,IAAAulC,EACA,GACApsC,EAAA6G,EACA,GACA7G,EAAA,GAAA6G,EACAA,EAAA7G,EAAA,MACAqsC,EAAA,GAAAxlC,EACAA,EAAAwlC,EACAC,EAAA,GAAAzlC,EACAA,EAAAylC,EAAA,GADA,OAIA,QAAAC,GAAAC,GAuBA,QAAA1kD,GAAAxR,GACA87B,EAAAq6B,KAAAn2D,EAvBA,GAAAic,GAAAlc,EAAAykB,EAAAgJ,EAAA4oC,EAAAt6B,CAEA,IAAAo6B,EAAAp1D,OAAA,IACA,SAAAsF,OAAA,iDAQA,IAAAxE,GAAAs0D,EAAAp1D,MACAs1D,GAAA,MAAAF,EAAA5+C,OAAA1V,EAAA,WAAAs0D,EAAA5+C,OAAA1V,EAAA,OAGAk6B,EAAA,GAAAu6B,GAAA,EAAAH,EAAAp1D,OAAA,EAAAs1D,GAGA5xC,EAAA4xC,EAAA,EAAAF,EAAAp1D,OAAA,EAAAo1D,EAAAp1D,MAEA,IAAAq1D,GAAA,CAMA,KAAAl6C,EAAA,EAAAlc,EAAA,EAAoBykB,EAAAvI,EAAOA,GAAA,EAAAlc,GAAA,EAC3BytB,EAAAooC,EAAAM,EAAA5+C,OAAA2E,KAAA,GAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,QAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,OAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,IACAzK,GAAA,SAAAgc,IAAA,IACAhc,GAAA,MAAAgc,IAAA,GACAhc,EAAA,IAAAgc,EAYA,OATA,KAAA4oC,GACA5oC,EAAAooC,EAAAM,EAAA5+C,OAAA2E,KAAA,EAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,OACAzK,EAAA,IAAAgc,IACG,IAAA4oC,IACH5oC,EAAAooC,EAAAM,EAAA5+C,OAAA2E,KAAA,GAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,OAAA25C,EAAAM,EAAA5+C,OAAA2E,EAAA,OACAzK,EAAAgc,GAAA,OACAhc,EAAA,IAAAgc,IAGAsO,EAGA,QAAAw6B,GAAAC,GAMA,QAAAtC,GAAAuC,GACA,MAAAb,GAAAr+C,OAAAk/C,GAGA,QAAAC,GAAAD,GACA,MAAAvC,GAAAuC,GAAA,OAAAvC,EAAAuC,GAAA,OAAAvC,EAAAuC,GAAA,MAAAvC,EAAA,GAAAuC,GAVA,GAAAv6C,GAGAy6C,EAAA51D,EAFA61D,EAAAJ,EAAAz1D,OAAA,EACA81D,EAAA,EAYA,KAAA36C,EAAA,EAAAnb,EAAAy1D,EAAAz1D,OAAA61D,EAAiD71D,EAAAmb,EAAYA,GAAA,EAC7Dy6C,GAAAH,EAAAt6C,IAAA,KAAAs6C,EAAAt6C,EAAA,OAAAs6C,EAAAt6C,EAAA,GACA26C,GAAAH,EAAAC,EAIA,QAAAC,GACA,OACAD,EAAAH,IAAAz1D,OAAA,GACA81D,GAAA3C,EAAAyC,GAAA,GACAE,GAAA3C,EAAAyC,GAAA,MACAE,GAAA,IACA,MACA,QACAF,GAAAH,IAAAz1D,OAAA,OAAAy1D,IAAAz1D,OAAA,GACA81D,GAAA3C,EAAAyC,GAAA,IACAE,GAAA3C,EAAAyC,GAAA,MACAE,GAAA3C,EAAAyC,GAAA,MACAE,GAAA,IAIA,MAAAA,GA7GA,GAAAP,GAAA,mBAAAnN,YACAA,WACA3qD,MAEAs3D,EAAA,IAAAt+C,WAAA,GACAu+C,EAAA,IAAAv+C,WAAA,GACAmS,EAAA,IAAAnS,WAAA,GACAy+C,EAAA,IAAAz+C,WAAA,GACAw+C,EAAA,IAAAx+C,WAAA,EAwGA5a,GAAAwvD,YAAA8J,EACAt5D,EAAA+tD,cAAA4L,GACsD35D,IxB+pgBhDk6D,IACA,SAASn6D,EAAQC,GyBvxgBvBA,EAAAqxD,KAAA,SAAAtG,EAAAgC,EAAAoN,EAAAC,EAAAC,GACA,GAAAz3D,GAAAia,EACAy9C,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAE,EAAA,GACAn7C,EAAA66C,EAAAE,EAAA,IACAlU,EAAAgU,EAAA,KACAvyC,EAAAmjC,EAAAgC,EAAAztC,EAOA,KALAA,GAAA6mC,EAEAvjD,EAAAglB,GAAA,IAAA6yC,GAAA,EACA7yC,KAAA6yC,EACAA,GAAAH,EACQG,EAAA,EAAW73D,EAAA,IAAAA,EAAAmoD,EAAAgC,EAAAztC,MAAA6mC,EAAAsU,GAAA,GAKnB,IAHA59C,EAAAja,GAAA,IAAA63D,GAAA,EACA73D,KAAA63D,EACAA,GAAAL,EACQK,EAAA,EAAW59C,EAAA,IAAAA,EAAAkuC,EAAAgC,EAAAztC,MAAA6mC,EAAAsU,GAAA,GAEnB,OAAA73D,EACAA,EAAA,EAAA43D,MACG,IAAA53D,IAAA23D,EACH,MAAA19C,GAAA1J,IAAAW,KAAA8T,EAAA,KAEA/K,IAAAzW,KAAAgpB,IAAA,EAAAgrC,GACAx3D,GAAA43D,EAEA,OAAA5yC,EAAA,MAAA/K,EAAAzW,KAAAgpB,IAAA,EAAAxsB,EAAAw3D,IAGAp6D,EAAAorC,MAAA,SAAA2f,EAAA/jD,EAAA+lD,EAAAoN,EAAAC,EAAAC,GACA,GAAAz3D,GAAAia,EAAApb,EACA64D,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAG,EAAA,KAAAN,EAAAh0D,KAAAgpB,IAAA,OAAAhpB,KAAAgpB,IAAA,SACA9P,EAAA66C,EAAA,EAAAE,EAAA,EACAlU,EAAAgU,EAAA,KACAvyC,EAAA,EAAA5gB,GAAA,IAAAA,GAAA,IAAAA,EAAA,GAmCA,KAjCAA,EAAAZ,KAAAipB,IAAAroB,GAEAmgB,MAAAngB,IAAA8M,MAAA9M,GACA6V,EAAAsK,MAAAngB,GAAA,IACApE,EAAA23D,IAEA33D,EAAAwD,KAAA2P,MAAA3P,KAAAhE,IAAA4E,GAAAZ,KAAAktB,KACAtsB,GAAAvF,EAAA2E,KAAAgpB,IAAA,GAAAxsB,IAAA,IACAA,IACAnB,GAAA,GAGAuF,GADApE,EAAA43D,GAAA,EACAE,EAAAj5D,EAEAi5D,EAAAt0D,KAAAgpB,IAAA,IAAAorC,GAEAxzD,EAAAvF,GAAA,IACAmB,IACAnB,GAAA,GAGAmB,EAAA43D,GAAAD,GACA19C,EAAA,EACAja,EAAA23D,GACK33D,EAAA43D,GAAA,GACL39C,GAAA7V,EAAAvF,EAAA,GAAA2E,KAAAgpB,IAAA,EAAAgrC,GACAx3D,GAAA43D,IAEA39C,EAAA7V,EAAAZ,KAAAgpB,IAAA,EAAAorC,EAAA,GAAAp0D,KAAAgpB,IAAA,EAAAgrC,GACAx3D,EAAA,IAIQw3D,GAAA,EAAWrP,EAAAgC,EAAAztC,GAAA,IAAAzC,EAAAyC,GAAA6mC,EAAAtpC,GAAA,IAAAu9C,GAAA,GAInB,IAFAx3D,KAAAw3D,EAAAv9C,EACAy9C,GAAAF,EACQE,EAAA,EAAUvP,EAAAgC,EAAAztC,GAAA,IAAA1c,EAAA0c,GAAA6mC,EAAAvjD,GAAA,IAAA03D,GAAA,GAElBvP,EAAAgC,EAAAztC,EAAA6mC,IAAA,IAAAv+B,IzB+xgBM+yC,IACA,SAAS56D,G0B72gBf,GAAAwG,GAAA3E,MAAA2E,QAMA0F,EAAAxF,OAAA5E,UAAA6E,QAmBA3G,GAAAC,QAAAuG,GAAA,SAAAC,GACA,QAAAA,GAAA,kBAAAyF,EAAAlK,KAAAyE,K1B03gBMo0D,IACA,SAAS76D,EAAQC,EAASC,GAE/B,GAAI46D,I2B55gBL,SAAA96D,EAAAoZ,IACC,SAAA2hD,GAgED,QAAA1zB,GAAAh7B,GACA,KAAA+hB,YAAAuW,EAAAt4B,IAWA,QAAAmH,GAAAwS,EAAA/hB,GAGA,IAFA,GAAAG,GAAA4hB,EAAA5hB,OACAU,KACAV,KACAU,EAAAV,GAAAH,EAAA+hB,EAAA5hB,GAEA,OAAAU,GAaA,QAAAk2D,GAAAjO,EAAA9oD,GACA,GAAAwW,GAAAsyC,EAAA93C,MAAA,KACAnQ,EAAA,EACA2V,GAAArW,OAAA,IAGAU,EAAA2V,EAAA,OACAsyC,EAAAtyC,EAAA,IAGAsyC,IAAA5qD,QAAA84D,EAAA,IACA,IAAAC,GAAAnO,EAAA93C,MAAA,KACAkmD,EAAA3nD,EAAA0nD,EAAAj3D,GAAA2O,KAAA,IACA,OAAA9N,GAAAq2D,EAgBA,QAAAC,GAAArO,GAMA,IALA,GAGA9lD,GACAsb,EAJA23C,KACAlkC,EAAA,EACA5xB,EAAA2oD,EAAA3oD,OAGAA,EAAA4xB,GACA/uB,EAAA8lD,EAAAlyC,WAAAmb,KACA/uB,GAAA,cAAAA,GAAA7C,EAAA4xB,GAEAzT,EAAAwqC,EAAAlyC,WAAAmb,KACA,cAAAzT,GACA23C,EAAAplD,OAAA,KAAA7N,IAAA,UAAAsb,GAAA,QAIA23C,EAAAplD,KAAA7N,GACA+uB,MAGAkkC,EAAAplD,KAAA7N,EAGA,OAAAizD,GAWA,QAAAmB,GAAAr1C,GACA,MAAAxS,GAAAwS,EAAA,SAAA/e,GACA,GAAAizD,GAAA,EAOA,OANAjzD,GAAA,QACAA,GAAA,MACAizD,GAAAoB,EAAAr0D,IAAA,eACAA,EAAA,WAAAA,GAEAizD,GAAAoB,EAAAr0D,KAEG2L,KAAA,IAYH,QAAA2oD,GAAAC,GACA,UAAAA,EAAA,GACAA,EAAA,GAEA,GAAAA,EAAA,GACAA,EAAA,GAEA,GAAAA,EAAA,GACAA,EAAA,GAEAhiB,EAcA,QAAAiiB,GAAAC,EAAAC,GAGA,MAAAD,GAAA,UAAAA,KAAA,GAAAC,IAAA,GAQA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAA9mC,GAAA,CAGA,KAFA4mC,EAAAE,EAAA/lD,EAAA6lD,EAAAG,GAAAH,GAAA,EACAA,GAAA7lD,EAAA6lD,EAAAC,GAC+BD,EAAAI,EAAAC,GAAA,EAAmCjnC,GAAAukB,EAClEqiB,EAAA7lD,EAAA6lD,EAAAI,EAEA,OAAAjmD,GAAAif,GAAAgnC,EAAA,GAAAJ,KAAAM,IAUA,QAAAjD,GAAAkD,GAEA,GAEAlyD,GAIAmyD,EACAh5D,EACApB,EACAq6D,EACAC,EACAtnC,EACAymC,EACA/7B,EAEA68B,EAfAtC,KACAuC,EAAAL,EAAAh4D,OAEAmb,EAAA,EACAxY,EAAA21D,EACAC,EAAAC,CAqBA,KALAP,EAAAD,EAAAjpD,YAAA0pD,GACA,EAAAR,IACAA,EAAA,GAGAh5D,EAAA,EAAag5D,EAAAh5D,IAAWA,EAExB+4D,EAAAvhD,WAAAxX,IAAA,KACAgkC,EAAA,aAEA6yB,EAAAplD,KAAAsnD,EAAAvhD,WAAAxX,GAMA,KAAApB,EAAAo6D,EAAA,EAAAA,EAAA,IAAyCI,EAAAx6D,GAAqB,CAO9D,IAAAq6D,EAAA/8C,EAAAg9C,EAAA,EAAAtnC,EAAAukB,EAEAv3C,GAAAw6D,GACAp1B,EAAA,iBAGAq0B,EAAAH,EAAAa,EAAAvhD,WAAA5Y,OAEAy5D,GAAAliB,GAAAkiB,EAAA1lD,GAAA8mD,EAAAv9C,GAAAg9C,KACAl1B,EAAA,YAGA9nB,GAAAm8C,EAAAa,EACA58B,EAAAg9B,GAAA1nC,EAAA8nC,EAAA9nC,GAAA0nC,EAAAT,IAAAjnC,EAAA0nC,IAEAh9B,EAAA+7B,GAfsDzmC,GAAAukB,EAmBtDgjB,EAAAhjB,EAAA7Z,EACA48B,EAAAvmD,EAAA8mD,EAAAN,IACAn1B,EAAA,YAGAk1B,GAAAC,CAIAtyD,GAAAgwD,EAAA91D,OAAA,EACAu4D,EAAAf,EAAAr8C,EAAA+8C,EAAApyD,EAAA,GAAAoyD,GAIAtmD,EAAAuJ,EAAArV,GAAA4yD,EAAA/1D,GACAsgC,EAAA,YAGAtgC,GAAAiP,EAAAuJ,EAAArV,GACAqV,GAAArV,EAGAgwD,EAAA93D,OAAAmd,IAAA,EAAAxY,GAIA,MAAAs0D,GAAAnB,GAUA,QAAA3C,GAAA6E,GACA,GAAAr1D,GACA80D,EACAmB,EACAC,EACAN,EACAt5D,EACAyZ,EACAogD,EACAjoC,EACA0K,EACAw9B,EAGAV,EAEAW,EACAZ,EACAa,EANAnD,IAoBA,KAXAkC,EAAAhB,EAAAgB,GAGAK,EAAAL,EAAAh4D,OAGA2C,EAAA21D,EACAb,EAAA,EACAc,EAAAC,EAGAv5D,EAAA,EAAao5D,EAAAp5D,IAAiBA,EAC9B85D,EAAAf,EAAA/4D,GACA,IAAA85D,GACAjD,EAAAplD,KAAAwmD,EAAA6B,GAeA,KAXAH,EAAAC,EAAA/C,EAAA91D,OAMA64D,GACA/C,EAAAplD,KAAA+nD,GAIAJ,EAAAO,GAAA,CAIA,IAAAlgD,EAAAggD,EAAAz5D,EAAA,EAA0Bo5D,EAAAp5D,IAAiBA,EAC3C85D,EAAAf,EAAA/4D,GACA85D,GAAAp2D,GAAA+V,EAAAqgD,IACArgD,EAAAqgD,EAcA,KARAC,EAAAJ,EAAA,EACAlgD,EAAA/V,EAAAiP,GAAA8mD,EAAAjB,GAAAuB,IACA/1B,EAAA,YAGAw0B,IAAA/+C,EAAA/V,GAAAq2D,EACAr2D,EAAA+V,EAEAzZ,EAAA,EAAco5D,EAAAp5D,IAAiBA,EAO/B,GANA85D,EAAAf,EAAA/4D,GAEA0D,EAAAo2D,KAAAtB,EAAAiB,GACAz1B,EAAA,YAGA81B,GAAAp2D,EAAA,CAEA,IAAAm2D,EAAArB,EAAA5mC,EAAAukB,EACA7Z,EAAAg9B,GAAA1nC,EAAA8nC,EAAA9nC,GAAA0nC,EAAAT,IAAAjnC,EAAA0nC,IACAh9B,EAAAu9B,GAFkDjoC,GAAAukB,EAKlD6jB,EAAAH,EAAAv9B,EACA68B,EAAAhjB,EAAA7Z,EACAu6B,EAAAplD,KACAwmD,EAAAG,EAAA97B,EAAA09B,EAAAb,EAAA,KAEAU,EAAAlnD,EAAAqnD,EAAAb,EAGAtC,GAAAplD,KAAAwmD,EAAAG,EAAAyB,EAAA,KACAP,EAAAf,EAAAC,EAAAuB,EAAAJ,GAAAC,GACApB,EAAA,IACAmB,IAIAnB,IACA90D,EAGA,MAAAmzD,GAAAtnD,KAAA,IAcA,QAAA0qD,GAAAlB,GACA,MAAApB,GAAAoB,EAAA,SAAArP,GACA,MAAAwQ,GAAA/uD,KAAAu+C,GACAmM,EAAAnM,EAAAhrD,MAAA,GAAAjB,eACAisD,IAeA,QAAAyQ,GAAApB,GACA,MAAApB,GAAAoB,EAAA,SAAArP,GACA,MAAA0Q,GAAAjvD,KAAAu+C,GACA,OAAAwK,EAAAxK,GACAA,IAvdA,GAIA2Q,IAJA,gBAAAz9D,QACAA,EAAAuK,UAAAvK,EACA,gBAAAD,QACAA,EAAAwK,UAAAxK,EACA,gBAAAoZ,QAEAskD,EAAAtkD,SAAAskD,GACAA,EAAAn9D,SAAAm9D,GACAA,EAAAj3C,OAAAi3C,KAEA3C,EAAA2C,EAQA,IAAA5I,GAGAgI,EAAA,WAGAtjB,EAAA,GACAujB,EAAA,EACAb,EAAA,GACAC,EAAA,GACAH,EAAA,IACAY,EAAA,GACAF,EAAA,IACAG,EAAA,IAGAU,EAAA,QACAE,EAAA,eACAxC,EAAA,4BAGAt2B,GACAg5B,SAAA,kDACAC,YAAA,iDACAC,gBAAA,iBAIA5B,EAAAziB,EAAAujB,EACA/mD,EAAA3P,KAAA2P,MACAslD,EAAA/wD,OAAAmpB,YA8aAohC,IAMAzS,QAAA,QAQAyb,MACA5E,OAAAkC,EACA7D,OAAA8D,GAEAnC,SACA3B,SACAiG,UACAF,aAWAxC,EAAA,WACA,MAAAhG,IACG9yD,KAAA/B,EAAAC,EAAAD,EAAAD,KAAAsM,SAAAwuD,IAAA96D,EAAAC,QAAA66D,KAaFx5D,Q3B45gB6BU,KAAK/B,EAASC,EAAoB,IAAIF,GAAU,WAAa,MAAOsB,WAI5Fy8D,IACA,SAAS/9D,EAAQC,EAASC,G4B/5hBhC,QAAA89D,KACA18D,KAAA28D,QAAA,GAAAC,GACA58D,KAAA68D,QAAA,GAAAC,GACA98D,KAAA+8D,eAAA,GAAAC,GAfA,GAAAJ,GAAAh+D,EAAA,KACAk+D,EAAAl+D,EAAA,KACAo+D,EAAAp+D,EAAA,IAEAF,GAAAC,QAAA+9D,EAsBAA,EAAAl8D,UAAAy8D,cAAA,SAAAC,EAAAC,GACA,MAAAn9D,MAAA+8D,eAAAE,cAAAC,EAAAC,K5B27hBMC,IACA,SAAS1+D,G6Bp9hBf,QAAAk+D,KACA58D,KAAAskD,SACAtkD,KAAAq9D,YARA3+D,EAAAC,QAAAi+D,EAkBAA,EAAAp8D,UAAA0tC,KAAA,SAAA9D,GACA,OAAAnsB,KAAAje,MAAAskD,MACAla,EAAAnsB,EAAAje,KAAAskD,MAAArmC,KAWA2+C,EAAAp8D,UAAAyP,IAAA,SAAApJ,GACA,MAAA7G,MAAAskD,MAAAz9C,EAAArH,gBAUAo9D,EAAAp8D,UAAA88D,OAAA,SAAAz2D,GACA,MAAA7G,MAAAq9D,SAAAx2D,EAAArH,gBAUAo9D,EAAAp8D,UAAAwR,IAAA,SAAAnL,EAAAlB,GACA,GAAAjB,GAAAmC,EAAArH,aACAQ,MAAAskD,MAAA5/C,GAAAiB,GACG3F,KAAAq9D,SAAA34D,KAAA1E,KAAAq9D,SAAA34D,QAAA8O,KAAA7N,K7Bu+hBG43D,IACA,SAAS7+D,G8BxhiBf,QAAAo+D,KACA98D,KAAAw9D,YATA9+D,EAAAC,QAAAm+D,EAoBAA,EAAAt8D,UAAA6M,IAAA,SAAA8M,GACA,UAAAA,EAAAoa,QACA,OAAAtW,GAAA,EAAmBA,EAAAje,KAAAw9D,SAAA16D,OAA0Bmb,IAAA,CAC7C,GAAA/Q,GAAAlN,KAAAw9D,SAAAv/C,EACA,IAAA/Q,EAAAqnB,UAAApa,EAAAoa,SACArnB,EAAAgwD,UAAA/iD,EAAA+iD,SACAhwD,EAAAiwD,WAAAhjD,EAAAgjD,SAEA,YADAn9D,KAAAw9D,SAAAv/C,GAAA9D,GAKAna,KAAAw9D,SAAAhqD,KAAA2G,IASA2iD,EAAAt8D,UAAA8M,IAAA,WACA,MAAAtN,MAAAw9D,SAAA/8D,SASAq8D,EAAAt8D,UAAAi9D,UAAA,WACA,GAAA76D,GAAA5C,KAAAsN,KAIA,OAHA1K,GAAAwS,KAAA,SAAA5S,EAAAC,GACA,MAAAD,GAAA06D,QAAA16D,EAAA26D,UAAA16D,EAAAy6D,QAAAz6D,EAAA06D,YAEAv6D,I9B2kiBM86D,IACA,SAASh/D,EAAQC,EAASC,G+BtniBhC,QAAA++D,GAAAC,GACA59D,KAAA69D,UAAAD,EAAA1rD,IAAA4rD,GAlBA,GAAAA,GAAAl/D,EAAA,IAQAF,GAAAC,QAAAg/D,EAaAA,EAAAn9D,UAAA69B,EAAA,SAAA16B,GACA,OAAAsa,GAAA,EAAiBA,EAAAje,KAAA69D,UAAA/6D,OAA2Bmb,IAC5C,GAAAA,EAAA,GAAAje,KAAA69D,UAAA/6D,QAAAa,GAAA3D,KAAA69D,UAAA5/C,EAAA,GAAAta,EAAA,CACA,GAAAo6D,GAAA/9D,KAAA69D,UAAA5/C,EACA,OAAA8/C,GAAA1/B,GAAA16B,EAAAo6D,EAAAp6D,GAAAo6D,EAAAC,KAKAL,EAAAn9D,UAAAmD,EAAA,SAAA06B,GACA,OAAApgB,GAAA,EAAiBA,EAAAje,KAAA69D,UAAA/6D,OAA2Bmb,IAC5C,GAAAA,EAAA,GAAAje,KAAA69D,UAAA/6D,QAAAu7B,GAAAr+B,KAAA69D,UAAA5/C,EAAA,GAAAogB,EAAA,CACA,GAAA0/B,GAAA/9D,KAAA69D,UAAA5/C,EACA,OAAA8/C,GAAAp6D,GAAA06B,EAAA0/B,EAAA1/B,GAAA0/B,EAAAC,M/BkpiBMC,IACA,SAASv/D,GgC5qiBf,QAAAs+D,KACAh9D,KAAAmzC,WAPAz0C,EAAAC,QAAAq+D,EAgBAA,EAAAx8D,UAAAwR,IAAA,SAAAkrD,EAAAv3D,GACA3F,KAAAmzC,QAAA+pB,GAAAv3D,GAQAq3D,EAAAx8D,UAAAyP,IAAA,SAAAitD,GACA,MAAAl9D,MAAAmzC,QAAA+pB,IAAA,GAQAF,EAAAx8D,UAAA09D,SAAA,SAAAhB,GACA,SAAAl9D,KAAAiQ,IAAAitD,IAQAF,EAAAx8D,UAAAy8D,cAAA,SAAAC,EAAAC,GAEA,OADArnD,GAAA,EACAmI,EAAA,EAAiBi/C,EAAAj/C,EAAaA,IAAAnI,GAAA9V,KAAAk+D,SAAAjgD,EAC9B,OAAAnI,GAAA9V,KAAAk+D,SAAAhB,GAAAC,IhC+riBMgB,IACA,SAASz/D,GiC/uiBf,QAAAe,GAAA2+D,GACA,GAAAC,IAAA,CACA,QACAC,KAAA,SAAAtqC,EAAAoW,GACA,GAAAi0B,EAAA,MAAAr+D,KACA,IAAAP,GAAA2+D,EAAA3+D,MAAAu0B,EAKA,OAJAv0B,KACA4+D,GAAA,EACAj0B,EAAA3qC,IAEAO,MAEAu+D,OAAA,SAAAn0B,GACA,MAAAi0B,GAAAr+D,SACAoqC,OAhBA1rC,EAAAC,QAAAc,GjC6wiBM++D,IACA,SAAS9/D,EAAQC,EAASC,IkC/wiBhC,SAAAkZ,EAAA0G,GA4HA,QAAAwwC,GAAAvqD,EAAAg6D,GAEA,GAAA5hD,IACA6hD,QACAC,QAAAC,EAkBA,OAfA7+D,WAAA+C,QAAA,IAAA+Z,EAAAgiD,MAAA9+D,UAAA,IACAA,UAAA+C,QAAA,IAAA+Z,EAAAhb,OAAA9B,UAAA,IACA++D,EAAAL,GAEA5hD,EAAAkiD,WAAAN,EACGA,GAEH9/D,EAAA2Z,QAAAuE,EAAA4hD,GAGAO,EAAAniD,EAAAkiD,cAAAliD,EAAAkiD,YAAA,GACAC,EAAAniD,EAAAgiD,SAAAhiD,EAAAgiD,MAAA,GACAG,EAAAniD,EAAAhb,UAAAgb,EAAAhb,QAAA,GACAm9D,EAAAniD,EAAAoiD,iBAAApiD,EAAAoiD,eAAA,GACApiD,EAAAhb,SAAAgb,EAAA8hD,QAAAO,GACAC,EAAAtiD,EAAApY,EAAAoY,EAAAgiD,OAoCA,QAAAK,GAAAt0D,EAAAw0D,GACA,GAAApgE,GAAAgwD,EAAAqQ,OAAAD,EAEA,OAAApgE,GACA,KAAAgwD,EAAAntD,OAAA7C,GAAA,OAAA4L,EACA,KAAAokD,EAAAntD,OAAA7C,GAAA,OAEA4L,EAKA,QAAAg0D,GAAAh0D,GACA,MAAAA,GAIA,QAAA00D,GAAA56C,GACA,GAAA8tC,KAMA,OAJA9tC,GAAA5U,QAAA,SAAA3K,GACAqtD,EAAArtD,IAAA,IAGAqtD,EAIA,QAAA2M,GAAAtiD,EAAAlX,EAAA45D,GAGA,GAAA1iD,EAAAoiD,eACAt5D,GACA6c,EAAA7c,EAAAqpD,UAEArpD,EAAAqpD,UAAArwD,EAAAqwD,WAEArpD,EAAA0L,aAAA1L,EAAA0L,YAAA7Q,YAAAmF,GAAA,CACA,GAAA0W,GAAA1W,EAAAqpD,QAAAuQ,EAAA1iD,EAIA,OAHAo2C,GAAA52C,KACAA,EAAA8iD,EAAAtiD,EAAAR,EAAAkjD,IAEAljD,EAIA,GAAAmjD,GAAAC,EAAA5iD,EAAAlX,EACA,IAAA65D,EACA,MAAAA,EAIA,IAAAjuD,GAAAnM,OAAAmM,KAAA5L,GACA+5D,EAAAJ,EAAA/tD,EAQA,IANAsL,EAAAkiD,aACAxtD,EAAAnM,OAAAqoB,oBAAA9nB,IAKAg6D,EAAAh6D,KACA4L,EAAAZ,QAAA,eAAAY,EAAAZ,QAAA,mBACA,MAAAivD,GAAAj6D,EAIA,QAAA4L,EAAAzO,OAAA,CACA,GAAA0f,EAAA7c,GAAA,CACA,GAAAkB,GAAAlB,EAAAkB,KAAA,KAAAlB,EAAAkB,KAAA,EACA,OAAAgW,GAAA8hD,QAAA,YAAA93D,EAAA,eAEA,GAAAg5D,EAAAl6D,GACA,MAAAkX,GAAA8hD,QAAAh/D,OAAAa,UAAA6E,SAAA3E,KAAAiF,GAAA,SAEA,IAAAm6D,EAAAn6D,GACA,MAAAkX,GAAA8hD,QAAA9yD,KAAArL,UAAA6E,SAAA3E,KAAAiF,GAAA,OAEA,IAAAg6D,EAAAh6D,GACA,MAAAi6D,GAAAj6D,GAIA,GAAAuyC,GAAA,GAAAxzB,GAAA,EAAAq7C,GAAA,IAA4C,IAS5C,IANA76D,EAAAS,KACA+e,GAAA,EACAq7C,GAAA,UAIAv9C,EAAA7c,GAAA,CACA,GAAAF,GAAAE,EAAAkB,KAAA,KAAAlB,EAAAkB,KAAA,EACAqxC,GAAA,aAAAzyC,EAAA,IAkBA,GAdAo6D,EAAAl6D,KACAuyC,EAAA,IAAAv4C,OAAAa,UAAA6E,SAAA3E,KAAAiF,IAIAm6D,EAAAn6D,KACAuyC,EAAA,IAAArsC,KAAArL,UAAAw/D,YAAAt/D,KAAAiF,IAIAg6D,EAAAh6D,KACAuyC,EAAA,IAAA0nB,EAAAj6D,IAGA,IAAA4L,EAAAzO,UAAA4hB,GAAA,GAAA/e,EAAA7C,QACA,MAAAi9D,GAAA,GAAA7nB,EAAA6nB,EAAA,EAGA,MAAAR,EACA,MAAAM,GAAAl6D,GACAkX,EAAA8hD,QAAAh/D,OAAAa,UAAA6E,SAAA3E,KAAAiF,GAAA,UAEAkX,EAAA8hD,QAAA,qBAIA9hD,GAAA6hD,KAAAlrD,KAAA7N,EAEA,IAAAizD,EAWA,OATAA,GADAl0C,EACAu7C,EAAApjD,EAAAlX,EAAA45D,EAAAG,EAAAnuD,GAEAA,EAAAW,IAAA,SAAAxN,GACA,MAAAw7D,GAAArjD,EAAAlX,EAAA45D,EAAAG,EAAAh7D,EAAAggB,KAIA7H,EAAA6hD,KAAArmD,MAEA8nD,EAAAvH,EAAA1gB,EAAA6nB,GAIA,QAAAN,GAAA5iD,EAAAlX,GACA,GAAAq5D,EAAAr5D,GACA,MAAAkX,GAAA8hD,QAAA,wBACA,IAAA1L,EAAAttD,GAAA,CACA,GAAAy6D,GAAA,IAAAn+D,KAAAC,UAAAyD,GAAA9E,QAAA,aACAA,QAAA,YACAA,QAAA,eACA,OAAAgc,GAAA8hD,QAAAyB,EAAA,UAEA,MAAAC,GAAA16D,GACAkX,EAAA8hD,QAAA,GAAAh5D,EAAA,UACAm5D,EAAAn5D,GACAkX,EAAA8hD,QAAA,GAAAh5D,EAAA,WAEA2tD,EAAA3tD,GACAkX,EAAA8hD,QAAA,eADA,OAKA,QAAAiB,GAAAj6D,GACA,UAAAyC,MAAA5H,UAAA6E,SAAA3E,KAAAiF,GAAA,IAIA,QAAAs6D,GAAApjD,EAAAlX,EAAA45D,EAAAG,EAAAnuD,GAEA,OADAqnD,MACA36C,EAAA,EAAAuI,EAAA7gB,EAAA7C,OAAmC0jB,EAAAvI,IAAOA,EAE1C26C,EAAAplD,KADArK,EAAAxD,EAAAsD,OAAAgV,IACAiiD,EAAArjD,EAAAlX,EAAA45D,EAAAG,EACAz2D,OAAAgV,IAAA,GAEA,GASA,OANA1M,GAAAzB,QAAA,SAAApL,GACAA,EAAAjF,MAAA,UACAm5D,EAAAplD,KAAA0sD,EAAArjD,EAAAlX,EAAA45D,EAAAG,EACAh7D,GAAA,MAGAk0D,EAIA,QAAAsH,GAAArjD,EAAAlX,EAAA45D,EAAAG,EAAAh7D,EAAAggB,GACA,GAAA7d,GAAA+D,EAAAstB,CAsCA,IArCAA,EAAA9yB,OAAAooB,yBAAA7nB,EAAAjB,KAAyDiB,QAAAjB,IACzDwzB,EAAAjoB,IAEArF,EADAstB,EAAAlmB,IACA6K,EAAA8hD,QAAA,6BAEA9hD,EAAA8hD,QAAA,sBAGAzmC,EAAAlmB,MACApH,EAAAiS,EAAA8hD,QAAA,uBAGAx1D,EAAAu2D,EAAAh7D,KACAmC,EAAA,IAAAnC,EAAA,KAEAkG,IACAiS,EAAA6hD,KAAA/tD,QAAAunB,EAAAvyB,OAAA,GAEAiF,EADA0oD,EAAAiM,GACAJ,EAAAtiD,EAAAqb,EAAAvyB,MAAA,MAEAw5D,EAAAtiD,EAAAqb,EAAAvyB,MAAA45D,EAAA,GAEA30D,EAAA+F,QAAA,WAEA/F,EADA8Z,EACA9Z,EAAA+I,MAAA,MAAAzB,IAAA,SAAAozB,GACA,WAAAA,IACWh0B,KAAA,MAAA+0B,OAAA,GAEX,KAAAz7B,EAAA+I,MAAA,MAAAzB,IAAA,SAAAozB,GACA,YAAAA,IACWh0B,KAAA,QAIX1G,EAAAiS,EAAA8hD,QAAA,yBAGAK,EAAAn4D,GAAA,CACA,GAAA6d,GAAAhgB,EAAAjF,MAAA,SACA,MAAAmL,EAEA/D,GAAA5E,KAAAC,UAAA,GAAAwC,GACAmC,EAAApH,MAAA,iCACAoH,IAAAw/B,OAAA,EAAAx/B,EAAA/D,OAAA,GACA+D,EAAAgW,EAAA8hD,QAAA93D,EAAA,UAEAA,IAAAhG,QAAA,YACAA,QAAA,YACAA,QAAA,gBACAgG,EAAAgW,EAAA8hD,QAAA93D,EAAA,WAIA,MAAAA,GAAA,KAAA+D,EAIA,QAAAu1D,GAAAvH,EAAA1gB,EAAA6nB,GACA,GAAAO,GAAA,EACAx9D,EAAA81D,EAAA3qB,OAAA,SAAA7W,EAAAmpC,GAGA,MAFAD,KACAC,EAAA5vD,QAAA,UAAA2vD,IACAlpC,EAAAmpC,EAAA1/D,QAAA,sBAAAiC,OAAA,GACG,EAEH,OAAAA,GAAA,GACAi9D,EAAA,IACA,KAAA7nB,EAAA,GAAAA,EAAA,OACA,IACA0gB,EAAAtnD,KAAA,SACA,IACAyuD,EAAA,GAGAA,EAAA,GAAA7nB,EAAA,IAAA0gB,EAAAtnD,KAAA,UAAAyuD,EAAA,GAMA,QAAA76D,GAAAs7D,GACA,MAAAjgE,OAAA2E,QAAAs7D,GAIA,QAAA1B,GAAAj1D,GACA,uBAAAA,GAIA,QAAAypD,GAAAzpD,GACA,cAAAA,EAIA,QAAA0pD,GAAA1pD,GACA,aAAAA,EAIA,QAAAw2D,GAAAx2D,GACA,sBAAAA,GAIA,QAAAopD,GAAAppD,GACA,sBAAAA,GAIA,QAAA42D,GAAA52D,GACA,sBAAAA,GAIA,QAAAm1D,GAAAn1D,GACA,gBAAAA,EAIA,QAAAg2D,GAAAa,GACA,MAAA9iD,GAAA8iD,IAAA,oBAAAC,EAAAD,GAIA,QAAA9iD,GAAA/T,GACA,sBAAAA,IAAA,OAAAA,EAIA,QAAAi2D,GAAAhb,GACA,MAAAlnC,GAAAknC,IAAA,kBAAA6b,EAAA7b,GAIA,QAAA6a,GAAAp+D,GACA,MAAAqc,GAAArc,KACA,mBAAAo/D,EAAAp/D,gBAAA6G,QAIA,QAAAoa,GAAA3Y,GACA,wBAAAA,GAIA,QAAA2jC,GAAA3jC,GACA,cAAAA,GACA,iBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,mBAAAA,GAMA,QAAA82D,GAAA5wC,GACA,MAAA3qB,QAAA5E,UAAA6E,SAAA3E,KAAAqvB,GAIA,QAAA6wC,GAAAn7D,GACA,UAAAA,EAAA,IAAAA,EAAAJ,SAAA,IAAAI,EAAAJ,SAAA,IAQA,QAAAw7D,KACA,GAAA/b,GAAA,GAAAj5C,MACAi1D,GAAAF,EAAA9b,EAAAic,YACAH,EAAA9b,EAAAkc,cACAJ,EAAA9b,EAAAmc,eAAA3vD,KAAA,IACA,QAAAwzC,EAAAoc,UAAAC,EAAArc,EAAAsc,YAAAN,GAAAxvD,KAAA,KAqCA,QAAAnI,GAAA1E,EAAA+E,GACA,MAAApE,QAAA5E,UAAA2I,eAAAzI,KAAA+D,EAAA+E,GAnjBA,GAAA63D,GAAA,UACA1iE,GAAA6nD,OAAA,SAAAvjD,GACA,IAAAgwD,EAAAhwD,GAAA,CAEA,OADA45D,MACA5+C,EAAA,EAAmBA,EAAAle,UAAA+C,OAAsBmb,IACzC4+C,EAAArpD,KAAAw7C,EAAAjvD,UAAAke,IAEA,OAAA4+C,GAAAvrD,KAAA,KAsBA,OAnBA2M,GAAA,EACAne,EAAAC,UACA6D,EAAA9D,EAAAgD,OACA8H,EAAA3B,OAAAhG,GAAApC,QAAAwgE,EAAA,SAAA19D,GACA,UAAAA,EAAA,SACA,IAAAsa,GAAAra,EAAA,MAAAD,EACA,QAAAA,GACA,eAAAsF,QAAAnJ,EAAAme,KACA,gBAAA1Y,QAAAzF,EAAAme,KACA,UACA,IACA,MAAAhc,MAAAC,UAAApC,EAAAme,MACS,MAAAmF,GACT,mBAEA,QACA,MAAAzf,MAGAA,EAAA7D,EAAAme,GAAuBra,EAAAqa,EAASta,EAAA7D,IAAAme,GAEhCrT,GADA0oD,EAAA3vD,KAAAia,EAAAja,GACA,IAAAA,EAEA,IAAAqrD,EAAArrD,EAGA,OAAAiH,IAOAjM,EAAAw4D,UAAA,SAAAx0D,EAAA2yB,GAaA,QAAAgsC,KACA,IAAAC,EAAA,CACA,GAAA/iD,EAAAgjD,iBACA,SAAAp5D,OAAAktB,EACO9W,GAAAijD,iBACPviE,QAAAuoC,MAAAnS,GAEAp2B,QAAA6mC,MAAAzQ,GAEAisC,GAAA,EAEA,MAAA5+D,GAAA1B,MAAAjB,KAAAD,WAtBA,GAAAi/D,EAAAlnD,EAAA0G,SACA,kBACA,MAAA7f,GAAAw4D,UAAAx0D,EAAA2yB,GAAAr0B,MAAAjB,KAAAD,WAIA,IAAAye,EAAAkjD,iBAAA,EACA,MAAA/+D,EAGA,IAAA4+D,IAAA,CAeA,OAAAD,GAIA,IACAK,GADAC,IAEAjjE,GAAAkjE,SAAA,SAAA7vD,GAIA,GAHAgtD,EAAA2C,KACAA,EAAAnjD,EAAAwB,IAAA8hD,YAAA,IACA9vD,IAAA+vD,eACAH,EAAA5vD,GACA,MAAArS,QAAA,MAAAqS,EAAA,WAAA9E,KAAAy0D,GAAA,CACA,GAAAK,GAAAxjD,EAAAwjD,GACAJ,GAAA5vD,GAAA,WACA,GAAAsjB,GAAA32B,EAAA6nD,OAAAvlD,MAAAtC,EAAAoB,UACAb,SAAA6mC,MAAA,YAAA/zB,EAAAgwD,EAAA1sC,QAGAssC,GAAA5vD,GAAA,YAGA,OAAA4vD,GAAA5vD,IAoCArT,EAAAqwD,UAIAA,EAAAntD,QACAogE,MAAA,MACAC,QAAA,MACAC,WAAA,MACAC,SAAA,MACAC,OAAA,OACAC,MAAA,OACAC,OAAA,OACAC,MAAA,OACAC,MAAA,OACAC,OAAA,OACAC,SAAA,OACAC,KAAA,OACAC,QAAA,QAIA7T,EAAAqQ,QACAyD,QAAA,OACAl9C,OAAA,SACAm9C,UAAA,SACA/3D,UAAA,OACAg4D,OAAA,OACAvX,OAAA,QACAwX,KAAA,UAEAC,OAAA,OAkRAvkE,EAAAuG,UAKAvG,EAAAmgE,YAKAngE,EAAA20D,SAKA30D,EAAA40D,oBAKA50D,EAAA0hE,WAKA1hE,EAAAs0D,WAKAt0D,EAAA8hE,WAKA9hE,EAAAqgE,cAKArgE,EAAAkhE,WAKAlhE,EAAAif,WAKAjf,EAAAmhE,SAMAnhE,EAAAghE,UAKAhhE,EAAA6jB,aAUA7jB,EAAA6uC,cAEA7uC,EAAA2sD,SAAA1sD,EAAA,IAYA,IAAAuiE,IAAA,sDACA,kBAaAxiE,GAAAoC,IAAA,WACA7B,QAAA6B,IAAA,UAAA8/D,IAAAliE,EAAA6nD,OAAAvlD,MAAAtC,EAAAoB,aAiBApB,EAAAkoC,SAAAjoC,EAAA,KAEAD,EAAA2Z,QAAA,SAAA6qD,EAAA91D,GAEA,IAAAA,IAAAuQ,EAAAvQ,GAAA,MAAA81D,EAIA,KAFA,GAAA5xD,GAAAnM,OAAAmM,KAAAlE,GACA4Q,EAAA1M,EAAAzO,OACAmb,KACAklD,EAAA5xD,EAAA0M,IAAA5Q,EAAAkE,EAAA0M,GAEA,OAAAklD,MlCwxiB8BziE,KAAK/B,EAAU,WAAa,MAAOqB,SAAYpB,EAAoB,MAI3FwkE,IACA,SAAS1kE,EAAQC,EAASC,GAE/B,YAEA,IAAIykE,GAA0B,SAAU5+D,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,GAAQ6+D,UAAW7+D,IAE7Fk5B,EAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnF2iD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMC,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,sCmC12jBjHuU,EAACijB,EAAA/+B,EAAM,KACP8oD,EAAc/pB,EAAA/+B,EAAM,KACf2kE,EAAaF,EAAAzkE,EAAM,KAElB4kE,EAAW7kE,EAAX6kE,YAAW,WACX,QADAA,GACCC,EAAQC,GnC+2jBjBlc,EAAgBxnD,KmCh3jBRwjE,GAETxjE,KAAK2jE,QAAUF,EACfzjE,KAAKspD,QAAUoa,GAAU,GAAIhc,GnC46jB9B,MAzDAN,GmCt3jBUoc,EAAW,MAKtBI,UnCm3jBKj+D,MmCn3jBG,SAACk+D,EAAWC,EAAcC,GnCo3jB3B,GAAIpb,GAAQ3oD,KmCn3jBbgkE,EAAYH,EAAUG,QACtBriD,EAAY4hD,EAAc3iD,MAAMojD,EAAMlhE,OAAQghE,GAC9CG,EAAYV,EAAc3iD,MAAMojD,EAAMlhE,OAAQihE,GAC9CviE,EAAY,SAAAqF,GnCq3jBT,MmCr3jBiB8hD,GAAKub,YAAYr9D,EAAM8a,EAAQsiD,GACvD,OAAOnnD,SAAQ5K,IAAI8xD,EAAOxiE,GAAMoE,KAAK8U,EAAE/R,YnCw3jBpCue,UAAU,EACVD,cAAc,GmCv3jBnBi9C,anC03jBKv+D,MmC13jBM,SAACkB,EAAM8a,EAAQsiD,GnC23jBnB,GAAItb,GAAQ3oD,ImC13jBjB,OAAOA,MAAKmkE,SAASt9D,GAAMjB,KACzB,SAAAgvD,GnC23jBK,MmC33jBGA,GAAK5E,OACV95C,IAAI,WnC23jBA,MmC33jBMyL,GAAO9a,KACjBjB,KAAK,SAAA8jD,GnC43jBD,MmC53jBWf,GAAKyb,QAAQ1a,KAC5BxzC,IAAI,WnC63jBA,MmC73jBM+tD,GAASp9D,KACnBjB,KAAK,SAAA2iD,GnC83jBD,OmC93jBY1hD,EAAM0hD,KAAQ,SACxB,SAAAhnD,GAEL,MADArC,SAAQ6mC,MAAM,qBAAuBl/B,EAAMtF,GACpC,QAEX,WnC+3jBK,MmC/3jBC,SnCk4jBL2lB,UAAU,EACVD,cAAc,GmCh4jBnBm9C,SnCm4jBKz+D,MmCn4jBE,SAAC+jD,GACN,MAAO1pD,MAAKspD,QAAQf,OAAOmB,InCq4jBxBxiC,UAAU,EACVD,cAAc,GmCp4jBnBk9C,UnCu4jBKx+D,MmCv4jBG,SAACkB,GnCw4jBF,GAAI8hD,GAAQ3oD,ImCv4jBjB,OAAOA,MAAK2jE,QAAQ/O,KAAK/tD,GAAK,SACrB,WnCw4jBF,MmCx4jBQ8hD,GAAKgb,QAAQ/O,KAAK/tD,EAAKhG,QAAQ,SAAU;InC24jBrDqmB,UAAU,EACVD,cAAc,KmC36jBRu8C,InCi7jBZ7kE,GAAQ,WmC94jBM6kE,EnC+4jBdp+D,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ0+D,IACA,SAAS3lE,EAAQC,EAASC,GAE/B,YoCz3jBD,SAAS0lE,GAAW/iD,GAClB,MAAOD,GAASC,EAAK9gB,MAAM,EAAG,KAAK+gB,GAAG,QACnC5b,KAAK,SAAA2+D,GACJ,GAAc,eAAVA,EACF,KAAM,IAAIn8D,OAAM,uBAElB,OAAOkZ,GAASC,EAAK9gB,MAAM,GAAI,KAAK+gB,GAAG,iBAExC5b,KAAK,SAAA8jD,GACJ,GAAIhlC,GAAQ,GAAIwmC,YAAWxB,GACvB5mD,EAAS4hB,EAAM,IACNA,EAAM,IAAM,IACZA,EAAM,IAAM,KACZA,EAAM,IAAM,GACzB,OAAO5hB,KAER8C,KAAK,SAAA4+D,GpCogkBL,MoCpgkBuBjjD,GAAK9gB,MAAM,GAAK+jE,KpC22jB3C,GAAInB,GAA0B,SAAU5+D,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,GAAQ6+D,UAAW7+D,IAE7Fk5B,EAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnFggE,EAAiB,SAAU3mC,EAAK7f,GAAK,GAAI1d,MAAM2E,QAAQ44B,GAAQ,MAAOA,EAAY,IAAIjW,OAAO6C,WAAYtlB,QAAO04B,GAAM,CAAiB,IAAK,GAAwCuqB,GAAxD8G,KAAoB7G,EAAYxqB,EAAIjW,OAAO6C,cAAsB29B,EAAQC,EAAUprC,QAAQG,OAAS8xC,EAAK37C,KAAK60C,EAAM1iD,QAAYsY,GAAKkxC,EAAKrsD,SAAWmb,KAAY,MAAOkxC,GAAe,KAAM,IAAIhpD,WAAU,yDAEvUihD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMC,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,sCoCz8jB/G4W,EAAOne,EAAe,IAAtBme,QACF2nD,EAAe/mC,EAAA/+B,EAAS,MACxB8b,EAACijB,EAAA/+B,EAAuB,KACxB2yD,EAAQ5zB,EAAA/+B,EAAgB,KACxB0iB,EAAQqc,EAAA/+B,EAAgB,KACxB+lE,EAAMhnC,EAAA/+B,EAAkB,MACnB2kE,EAAaF,EAAAzkE,EAAM,KACxBgmE,EAAQjnC,EAAA/+B,EAAgB,KAElBimE,EAAsBlmE,EAAtBkmE,uBAAsB,WACtB,QADAA,GACCrT,GpCk9jBT,GAAI7I,GAAQ3oD,IACZwnD,GAAgBxnD,KoCp9jBR6kE,EAET,IAAIC,GAAOJ,EAAgB92D,KAAK,KAAM5N,KACtCA,MAAK+kE,KAAOvT,EACZsT,EAAK,WAAY,WpCq9jBd,MoCp9jBDvT,GAASx0C,EAAQ4rC,EAAKoc,KAAM,kBAAkBvjD,GAAG,QAC9C5b,KAAK,SAAAgF,GpCo9jBL,MoCp9jBY3I,MAAK4kD,MAAMj8C,OAC5Bk6D,EAAK,OAAQ,WpCu9jBV,MoCt9jBDnc,GAAKqc,SAASp/D,KACZ,SAAAo/D,GpCs9jBC,MoCt9jBWA,GAASC,KAAK/yD,IAAI,SAAAjL,GpCu9jB3B,MoCv9jBmC,IAAIi+D,GAAGvc,EAAO1hD,SACxDjH,KAAK8gB,UACHxT,IAAU,GAAIs3D,GACdxrD,QAAU,GAAIwrD,IAEhB5kE,KAAKmlE,aAAe5B,EAAcriD,YAAYlhB,KAAK8gB,SAASxT,IAC1Dq3D,EAAO,EAAG,SAACnT,GpCy9jBV,MoCz9jBkBD,GAASC,GAAKhwC,GAAG,OAAQmnC,EAAK7nC,SAAS1H,SACvDxT,KAAK0+D,MpCqgkBX,MAzCAld,GoC5+jBUyd,EAAsB,MAkB7BrT,KpC49jBCvhD,IoC59jBE,WACL,MAAOjQ,MAAK+kE,MpC89jBT99C,cAAc,GoC59jBnB2tC,MpC+9jBKjvD,MoC/9jBD,SAACkB,GpCg+jBE,GAAI8hD,GAAQ3oD,IoC/9jBjB,OAAOA,MAAKglE,SAASp/D,KAAK,SAAAo/D,GACxB,GAAIpQ,GAAOl6C,EAAErL,KAAK,SAAAulD,GpCi+jBX,MoCj+jBmBA,GAAK/tD,OAASA,GAAMm+D,EAAShB,MACvD,KAAKpP,EAAM,KAAM,IAAIxsD,OAAM,mBAAqBvB,EAChD,OAAO,IAAIu+D,GAAyBzc,EAAOiM,EAAKyQ,QpCq+jB/Cn+C,UAAU,EACVD,cAAc,GoCn+jBnBq+C,SpCs+jBK3/D,MoCt+jBE,SAAC0/D,GpCu+jBD,GAAIE,GAAOd,EoCt+jBUY,EAAG,GAAxB1kE,EAAK4kE,EAAA,GAAExwD,EAAKwwD,EAAA,GAAExyC,EAAGwyC,EAAA,EACtB,OAAOvlE,MAAKilE,KACTr/D,KAAK,SAAAq/D,GpC0+jBD,MoC1+jBSA,GAAKtkE,KAClBiF,KAAK,SAAAy/D,GpC2+jBD,MoC3+jBQA,GAAI7jE,SAChBoE,KAAK,SAAA4/D,GpC4+jBD,MoC5+jBYA,GAAQ/kE,MAAMsU,EAAOge,MpC++jBrC7L,UAAU,EACVD,cAAc,KoCjhkBR49C,KAqCPO,EAAyB,WAClB,QADPA,GACQnhB,EAAWohB,GpCm/jBpB7d,EAAgBxnD,KoCp/jBfolE,GAEFplE,KAAKylE,WAAaxhB,EAClBjkD,KAAKulE,KAAOF,EpCmgkBb,MAZAje,GoC1/jBGge,EAAyB,MAK7BpV,MpCu/jBKrqD,MoCv/jBD,WACF,MAAO3F,MAAKylE,WAAWH,QAAQtlE,KAAKulE,MACjC3/D,KAAK,SAAA2b,GpCu/jBD,MoCv/jBSD,GAASC,GAAMC,GAAG,kBpC0/jB/B0F,UAAU,EACVD,cAAc,KoClgkBfm+C,KAWAF,EAAG,WACI,QADPA,GACQjhB,EAAWh9C,GpC+/jBpBugD,EAAgBxnD,KoChgkBfklE,GAEFllE,KAAKylE,WAAaxhB,EAClBjkD,KAAK+kE,KAAOhoD,EAAQknC,EAAUuN,IAAKvqD,EAAKyM,MpC6gkBzC,MAVA0zC,GoCtgkBG8d,EAAG,MAKP1jE,MpCmgkBKmE,MoCngkBD,WACF,MAAO3F,MAAKuqC,WAAavqC,KAAKuqC,SAC5BvqC,KAAKylE,WAAWN,aAAanlE,KAAK+kE,QpCogkBjC79C,UAAU,EACVD,cAAc,KoC5gkBfi+C,IpCmhkBLvmE,GAAQ,WoCxgkBMkmE,EpCyhkBdz/D,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ+/D,IACA,SAAShnE,EAAQC,EAASC,GqCpikBhC,QAAA+mE,GAAAvH,EAAAh0B,GACAg0B,EAAAzqD,MAAA,cACAzB,IAAA,SAAAozB,GAA2B,MAAAA,GAAA96B,SAC3BsF,QAAA,SAAAw1B,EAAA3kC,GACAypC,EAAA9E,EAAA3kC,EAAA,KApEA,GAAAlB,GAAAb,EAAA,KACA89D,EAAA99D,EAAA,IAEAD,GAAAinE,QAAA,SAAAxH,GAmCA,QAAAyH,GAAA3I,EAAA3oC,EAAAk3B,EAAAqa,GACA,GAAAC,GAAAhhE,KAAA2P,MAAA+2C,EAAA3oD,OAAA,EACA,QAAAijE,EACA,OAAA9nD,GAAA,EAAmB8nD,EAAA9nD,EAAWA,IAAA,CAC9B,GAAAtY,GAAA8lD,EAAAplB,OAAA,EAAApoB,EAAA,GACAk/C,EAAAl/C,EAAA8nD,CACA,QAAApgE,GACAqgE,EAAAnJ,QAAAxvD,KACA6vD,UACAC,WACAx3D,QACA4uB,UACAuxC,gBAKA,QAAAp/B,GAAAo/B,EAAA1jC,GACA5+B,EAAAyiE,SAAAzyD,MACAsyD,aACA1jC,YArDA,GAAA4jC,GAAA,GAAAtJ,GAEAl5D,GACA0iE,gBAAA,EACAC,iBAAA,EACAC,mBAAA,EACAJ,QACAC,YAwBA,OArBAN,GAAAvH,EAAA,SAAAA,EAAA0H,GAEA,MAAA1H,EAAA9kD,OAAA,IACA7Z,EAAA2+D,GACAE,KAAA,+BAAA9iD,GACAhY,EAAA2iE,kBAAA,EACAH,EAAAjJ,eAAA/qD,KAAAwJ,EAAA,IAAAA,EAAA,MAEA8iD,KAAA,mCAAA9iD,GACAhY,EAAA2iE,kBAAA,EACAN,GAAArqD,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAsqD,KAEAxH,KAAA,kCAAA9iD,GACAhY,EAAA0iE,iBAAA,EACAF,EAAArJ,QAAA3qD,IAAAwJ,EAAA,GAAAA,EAAA,MAXA/b,QAaA,WACAinC,EAAAo/B,EAAA,uBAIAtiE,IrC+okBM6iE,IACA,SAAS3nE,EAAQC,EAASC,GsC5pkBhC,QAAA0nE,GAAAC,GACAA,EAAAz2D,QAAA02D,EAAAtc,UACAlqD,KAAAymE,OAAAF,EAqCA,QAAAG,GAAAV,GACAhmE,KAAA2mE,OAAAX,EAhEA,GAAAQ,GAAA5nE,EAAA,IAEAF,GAAAC,QAAA2nE,CAEA,IAAAM,IACAC,SACAnqD,IAAWoqD,OAAA,KACX/4B,IAAW+4B,OAAA,KACXxoD,IAAWwoD,OAAA,KACXnmD,IAAWmmD,OAAA,KACXj3B,IAAWi3B,OAAA,KACXzlD,IAAWylD,OAAA,KACX/kD,IAAW+kD,OAAA,KACX92B,IAAW82B,OAAA,OAsBXR,GAAA9lE,UAAAwU,MAAA,WACA,MAAAhV,MAAAymE,OAAA3jE,QASAwjE,EAAA9lE,UAAA8M,IAAA,WACA,MAAAtN,MAAAymE,OAAAhmE,SAWA6lE,EAAAS,aAAA,SAAAf,EAAAj2B,GACAA,OACA,IAAAi3B,GAAA,GAAAN,GAAAV,EACA,OAAAgB,GAAAC,SAOAP,EAAAlmE,UAAAymE,MAAA,WAQA,MAPAjnE,MAAAymE,UACAzmE,KAAAknE,aACAlnE,KAAAmnE,gBAAAP,EAAAC,QACA7mE,KAAAw9D,SAAAx9D,KAAA2mE,OAAA9J,QAAAY,YACAz9D,KAAAw9D,SAAA1tD,QAAA,SAAAqK,GACAna,KAAAonE,QAAAjtD,IACGvM,KAAA5N,OACH,GAAAsmE,GAAAtmE,KAAAymE,SAGAC,EAAAlmE,UAAA4mE,QAAA,SAAAjtD,GACA,UAAAA,EAAAoa,QACAv0B,KAAAqnE,kBAAAltD,OAEA,QAAAA,EAAAoa,QAAAjb,OAAA,IACA,gBACAtZ,KAAAqnE,kBAAAltD,EACA,MACA,iBACAna,KAAAsnE,gBAAAntD,KAMAusD,EAAAlmE,UAAA6mE,kBAAA,SAAAltD,GACA,GAAAoa,GAAAv0B,KAAAunE,kBAAAptD,EAAAoa,SACAizC,EAAAxnE,KAAAynE,SAAAttD,EACAna,MAAAymE,OAAAjzD,MACAg0D,OACAV,OAAA9mE,KAAA0nE,WAAAnzC,MAIAmyC,EAAAlmE,UAAA8mE,gBAAA,SAAAntD,GACA,GAAAoa,GAAAv0B,KAAAunE,kBAAAptD,EAAAoa,SACAizC,EAAAxnE,KAAAynE,SAAAttD,EACA,IAAAna,KAAAknE,UAAA3yC,GAAA,CACA,GAAAozC,GAAA3nE,KAAAknE,UAAA3yC,EACAozC,GAAAC,QAAAJ,EACAxnE,KAAAymE,OAAAjzD,KAAAm0D,SACK3nE,MAAAknE,UAAA3yC,OAELv0B,MAAAknE,UAAA3yC,IACAizC,OACAK,SAAA1tD,EAAAxU,MACAmhE,OAAA9mE,KAAA0nE,WAAAvtD,EAAAoa,WAKAmyC,EAAAlmE,UAAAinE,SAAA,SAAAttD,GACA,MAAAna,MAAA2mE,OAAA1J,cAAA9iD,EAAA+iD,QAAA/iD,EAAAgjD,WAGAuJ,EAAAlmE,UAAAknE,WAAA,SAAAnzC,GACA,MAAAv0B,MAAAmnE,gBAAA5yC,IAGAmyC,EAAAlmE,UAAA+mE,kBAAA,SAAAhzC,GACA,MAAAA,GAAA1zB,QAAA,UAAAA,QAAA,YtC8rkBMinE,IACA,SAASppE,EAAQC,EAASC,GuC/zkBhC,GAAAqrD,GAAArrD,EAAA,IAEAmpE,EAAA,GAAA9d,IACA6c,OAAA79D,QAMAvK,GAAAC,QAAA,GAAAsrD,IAMAud,KAAAjiE,OAMAuhE,OAAA7c,EAAAK,MAAAyd,GAMAF,SAAA5+D,UvCy0kBM++D,IACA,SAAStpE,EAAQC,EAASC,GwCr2kBhC,GAAAqrD,GAAArrD,EAAA,GAKAF,GAAAC,QAAA,GAAAsrD,IAMA5rB,EAAA94B,OAMA5B,EAAA4B,OAMAy4D,GAAAz4D,UxCg3kBM0iE,IACA,SAASvpE,EAAQC,EAASC,GyC53kBhC,QAAAspE,GAAAC,EAAAC,GACA,GAAA5yC,IAAe6yC,IAAAF,EAAAX,KAAA,EAAAc,QAAA,GACf1K,IAAmBv/B,EAAA,EAAA16B,EAAA,EAAAq6D,GAAAmK,EAAA,IACnBC,KAAA3nE,QACA2nE,EAAAhzD,KAAA,SAAA5S,EAAAC,GACA,MAAAD,GAAAglE,KAAA/kE,EAAA+kE,MAAAe,EAAA/lE,EAAAuI,MAAAw9D,EAAA9lE,EAAAsI,QAEAq9D,EAAAt4D,QAAA,SAAA89B,GACA,GAAA45B,GAAA55B,EAAA45B,KACAc,EAAA9yC,EAAA8yC,QAAA,IAAAd,EAAAhyC,EAAAgyC,MAAAhyC,EAAA6yC,GACA,QAAAz6B,EAAA7iC,MACA,UACAyqB,EAAA6yC,IAAAz6B,EAAAy6B,IACAzK,EAAApqD,MAAqB6qB,EAAAiqC,EAAA3kE,EAAA6jE,EAAAxJ,GAAAxoC,EAAA6yC,IAAA,IACrB,MACA,YACAzK,EAAApqD,MAAqB6qB,EAAAiqC,EAAA3kE,EAAA6jE,EAAAxJ,GAAA,IACrBsK,GAAA,IAAA16B,EAAA46B,WAAA,GAAAhzC,EAAA6yC,IACAzK,EAAApqD,MAAqB6qB,EAAAiqC,EAAA3kE,EAAA6jE,EAAAxJ,GAAAxoC,EAAA6yC,IAAA,IACrB,MACA,SACA,SAAAjgE,OAAA,gCAEAotB,EAAAgyC,OACAhyC,EAAA8yC,YAEAtoE,KAAAyoE,WAAA,GAAA9K,GAAAC,GAnCA,GAAAD,GAAA/+D,EAAA,IAKAF,GAAAC,QAAAupE,CAEA,IAAAK,IAAkBF,IAAA,EAAA1rC,KAAA,EA+BlBurC,GAAA1nE,UAAAkoE,cAAA,SAAAlB,GACA,MAAAxnE,MAAAyoE,WAAApqC,EAAAmpC,IAGAU,EAAA1nE,UAAAmoE,cAAA,SAAAL,GACA,MAAAtoE,MAAAyoE,WAAA9kE,EAAA2kE,IAGAJ,EAAAnB,aAAA,SAAAf,GACA,GAAAoC,KAeA,OAdApC,GAAAnJ,QAAAvvD,MAAAwC,QAAA,SAAAqK,GACA,GAAAkuD,GACAb,EAAAxB,EAAA/I,cAAA9iD,EAAA+iD,QAAA/iD,EAAAgjD,SACA,WAAAhjD,EAAAoa,QACA8zC,EAAA3oE,SAAAya,EAAAxU,MAAA,IACAyiE,EAAA50D,MAAoBzI,KAAA,MAAAy8D,OAAAa,YACf,WAAAluD,EAAAoa,QACL8zC,EAAArC,EAAArJ,QAAA1sD,IAAA,MAAAkK,EAAAxU,OACAyiE,EAAA50D,MAAoBzI,KAAA,MAAAy8D,OAAAa,YACf,WAAAluD,EAAAoa,QAAA,CACL,GAAAi0C,GAAAxC,EAAArJ,QAAA1sD,IAAA,OAAAkK,EAAAxU,OAAA,EACAyiE,GAAA50D,MAAoBzI,KAAA,OAAAy8D,OAAAgB,iBAGpB,GAAAN,IAAAlC,EAAArJ,QAAA1sD,IAAA,WAAAm4D,KzCk5kBMQ,IACA,SAASlqE,G0Cr9kBf,YAEA,SAAAgmE,GAAAvqD,EAAAtT,EAAAgiE,EAAA7hD,GACA5hB,OAAAgc,eAAAjH,EAAAtT,GACAoJ,IAAA,WACA,GAAAjO,GAAA6mE,EAAAnoE,KAAAV,KAEA,OADAoF,QAAAgc,eAAAphB,KAAA6G,GAAyClB,MAAA3D,EAAAglB,eAAAE,UAAA,IACzCllB,GAEAgQ,IAAA,SAAAhQ,GAEA,MADAoD,QAAAgc,eAAAphB,KAAA6G,GAAyClB,MAAA3D,EAAAglB,eAAAE,UAAA,IACzCllB,GAEAglB,eACAC,cAAA,IAIAvoB,EAAAC,QAAA+lE,G1C49kBMoE,IACA,SAASpqE,G2C/+kBf,YAmEA,SAAAqqE,GAAAhsD,EAAApa,EAAAwiB,EAAArlB,GACAE,KAAA+c,UACA/c,KAAA2C,KACA3C,KAAAmlB,QAAA,KACAnlB,KAAAF,OArEApB,EAAAC,QAAA,SAAAqqE,GAEA,QAAArE,GAAArlB,EAAA38C,GAEA,QAAAwxB,GAAAxxB,EAAAwiB,EAAArlB,GACA,GAAAw/C,EAAA,CACAA,GACA,IAAA97C,GAAA,GAAAsZ,GAAA,SAAAC,GACAA,EAAApa,EAAA1B,MAAAkkB,EAAArlB,KAGA,OADA0D,GAAAoC,KAAAqjE,KACAzlE,EAEA,UAAAsZ,GAAA,SAAAC,GACAkC,EAAAzL,KAAA,GAAAu1D,GAAAhsD,EAAApa,EAAAwiB,EAAArlB,MAIA,QAAAmpE,KAEA,GADA3pB,IACArgC,EAAAnc,OAAA,CACA,GAAAoa,GAAA+B,EAAAW,OACA1C,GAAAH,QAAAoX,EAAAjX,EAAAva,GAAAua,EAAAiI,KAAAjI,EAAApd,QAnBA,GAAAmf,KAsBA,sBAAAqgC,IAAA,gBAAA38C,GAAA,CACA,GAAA+1D,GAAA/1D,CACAA,GAAA28C,EACAA,EAAAoZ,EAEA,wBAAA/1D,GACA,WAEA,OADA7C,MACAme,EAAA,EAAuBA,EAAAle,UAAA+C,OAAsBmb,IAC7Cne,EAAA0T,KAAAzT,UAAAke,GAEA,OAAAkW,GAAAxxB,EAAA3C,KAAAF,IAGA,SAAA6C,GAEA,OADA7C,MACAme,EAAA,EAAuBA,EAAAle,UAAA+C,OAAsBmb,IAC7Cne,EAAA0T,KAAAzT,UAAAke,GAEA,OAAAkW,GAAAxxB,EAAA3C,KAAAF,IA3CA,GAAAgd,EA+CA,oBAAA/c,WAAA,oBAAAA,WAAA,IAEA,GADA+c,EAAApe,EAAAC,QAAAme,QACA,kBAAAA,GACA,SAAA1U,OAAA,qFAEA,OAAAu8D,GAAA5kE,UAAA,GAAAA,UAAA,IAGA,MADA+c,GAAAksD,EACArE,GAKA,kBAAA7nD,WACApe,EAAAC,QAAAme,kB3C8/kBMosD,IACA,SAASxqE,EAAQC,EAASC,GAE/B,Y4CzjlBM,SAASuqE,KACd,GAAIC,IACEtpD,MAAO,WACPupD,WACE,cAEFC,OAAQ,IACRC,MAAO,aACPC,YACE,wBAGJC,EAAS,GAAIC,GACb3rD,EAAU0rD,EAAOjoE,MACnBmoE,IAAQ,GAAIC,GAAY,sCACxBnG,OAAQ,GAAIoB,GAAuB,+BAErCgF,GAAcC,QAAQ,GAAIC,IAAeN,SAAQL,UACjDrrD,EAAQnY,KAAK,WACXikE,EAAcC,QAAQ,QAEvBzsD,O5CsilBF,GAAIsgB,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,EAEvF9F,G4C7jlBewqE,M5C8jlBf,I4CrklBMU,GAAalsC,EAAA/+B,EAAM,MACnBmrE,EAAYpsC,EAAA/+B,EAAM,MAClB8qE,EAAU/rC,EAAA/+B,EAAM,MAEhBgrE,EAAWjsC,EAAA/+B,EAAM,MACjBimE,EAAsBlnC,EAAA/+B,EAAM,K5C0llBlCwG,QAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJqkE,IACA,SAAStrE,EAAQC,EAASC,IAEH,SAAS4rD,GAAS,Y6CzglB/C,SAASyf,GAAiBnpD,GACxB,MAAO,IAAIhE,SAAQ,SAACC,GAClB,GAAIzW,GAAU,GAAI4jE,GAAeppD,EACjCxa,GAAQ6jE,IAAI,WACVvrE,EAAA2C,EACE,EACA,W7C6rlBC,M6C7rlBYwb,GAAQne,EAAQ,MAC7B,OAMR,QAASwrE,GAAQ1gB,GAEf,MADAA,GAAS,GAAIc,GAAO,GAAIU,YAAWxB,IAC5B5sC,QAAQqhC,UAAUksB,EAAIC,OAAOC,WAAW7gB,G7C4/kBhD,GAAI2Z,GAA0B,SAAU5+D,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,GAAQ6+D,UAAW7+D,IAE7Fk5B,EAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnF2iD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMijB,EAAY,SAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIvkE,WAAU,iEAAoEukE,GAAeD,GAASjqE,UAAY4E,OAAOye,OAAO6mD,GAAcA,EAAWlqE,WAAa6Q,aAAe1L,MAAO8kE,EAAUzjD,YAAY,EAAOE,UAAU,EAAMD,cAAc,KAAeyjD,IAAYD,EAAS76C,UAAY86C,IAE9ZljB,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,sC6ClnlBjHwW,EAAEghB,EAAA/+B,EAAM,KACRyrE,EAAG1sC,EAAA/+B,EAAM,MAETgmE,EAAQjnC,EAAA/+B,EAAgB,KACnB2kE,EAAaF,EAAAzkE,EAAM,KAEtB+rE,EAAY/rE,EAAQ,KAApB+rE,aACFT,EAAcvsC,EAAA/+B,EAAQ,MAEtB4kE,EAAW7lC,EAAA/+B,EAAW,MACtBsuD,EAAKvvB,EAAA/+B,EAAiB,MAEzBgsE,GACFC,OAAQ,SAAA/pD,G7CwnlBL,M6CvnlBOA,GAASD,MAAK,GAAMC,EAAS1H,QAAO,MAAM0H,EAASD,MAAU,IACvEiqD,MAAQ,SAAAhqD,G7CynlBL,M6CxnlBOA,GAASG,OACnB8pD,MAAQ,SAAAjqD,G7C0nlBL,M6CznlBOA,GAASD,MAAK,GACTqsC,EAAMpsC,EAAS1H,SAAQ,MAAM8zC,EAAMpsC,EAASD,OAAW,KAG3D6oD,EAAU/qE,EAAV+qE,WAAU,SAASiB,GACnB,QADAjB,K7C0nlBRliB,EAAgBxnD,K6C1nlBR0pE,GAET1pE,KAAKgrE,U7CiwlBN,MApIAR,G6C/nlBUd,EAAmBiB,G7CiolB7BvjB,E6CjolBUsiB,EAAU,MAIjBuB,O7C+nlBCh7D,I6C/nlBI,WACP,MAAOjQ,MAAKgrE,Q7CiolBT/jD,cAAc,G6C/nlBnBzlB,M7CkolBKmE,M6ClolBD,SAACyjE,GACH,MAAOzsD,GAAGsf,mBAAAI,KAAA,QAAA6uC,K7CmolBH,G6ClolBDltD,G7CkolBK2qC,EAAQ3oD,IAEZ,OAAOi8B,oBAAmBjlB,KAAK,SAAqBm0D,GAClD,OAAU,OAAQA,EAAY/zC,KAAO+zC,EAAYjuD,MAC/C,IAAK,GAKH,M6C3olBPc,IACFotD,SAAUziB,EAAK0iB,cACfjC,KAAUzgB,EAAK2iB,UAAUlC,I7CwolBhB+B,EAAYjuD,KAAO,E6CtolBxBJ,QAAQxP,KAAK0Q,EAASotD,SAAUptD,EAASorD,M7CwolBtC,KAAK,GACL,IAAK,MACH,MAAO+B,GAAYxuC,SAEtBuuC,EAAYlrE,Q6C3olBpB4N,KAAK5N,Q7C8olBJknB,UAAU,EACVD,cAAc,G6C7olBnBokD,a7CgplBK1lE,M6ChplBM,WACT,GAAImb,IACFyqD,OAAQvrE,KAAKwrE,MAAM,sBAA2BZ,EAAWG,OACzDU,KAAQzrE,KAAKwrE,MAAM,gBAErB,OAAO7uD,GAAGsf,mBAAAI,KAAA,QAAA6uC,K7CgplBH,G6C/olBDQ,GACAD,EAEAnlE,C7C6olBC,OAAO21B,oBAAmBjlB,KAAK,SAAqBm0D,GAClD,OAAU,OAAQA,EAAY/zC,KAAO+zC,EAAYjuD,MAC/C,IAAK,GAEH,MADAiuD,GAAYjuD,KAAO,E6CnplBJ+sD,EAAiBnpD,EAASyqD,O7CqplB3C,KAAK,GAGH,M6CxplBPG,GAAYP,EAAAtwC,K7CuplBLswC,EAAYjuD,KAAO,E6CtplBJwuD,EAAalqE,KAAK,0BAChBsf,EAAS2qD,K7CuplB5B,KAAK,GAGH,M6C3plBPA,GAAIN,EAAAtwC,KAEJv0B,EAAgB,GAAIolE,GAAa1pD,QAAQypD,G7CyplB3BN,EAAYpwC,OAAO,U6CxplB5B0wC,OAAMnlE,W7CyplBN,KAAK,GACL,IAAK,MACH,MAAO6kE,GAAYxuC,SAEtBuuC,EAAYlrE,Q6C5plBpB4N,KAAK5N,Q7C+plBJknB,UAAU,EACVD,cAAc,G6C9plBnBqkD,W7CiqlBK3lE,M6CjqlBI,SAACyjE,G7CkqlBH,G6CjqlBCO,GAAgBP,EAAhBO,IAAKlG,EAAW2F,EAAX3F,OACP3iD,GACF6oD,IAAQ3pE,KAAKwrE,MAAM,WAAa7B,EAAI9iE,KAAU+jE,EAAWG,OACzDY,MAAQ3rE,KAAKwrE,MAAM,kBAA2BZ,EAAWG,OACzDa,KAAQ5rE,KAAKwrE,MAAM,yBACnBK,MAAQ7rE,KAAKwrE,MAAM,iBACnBM,IAAQ9rE,KAAKwrE,MAAM,eACnB5T,OAAQ53D,KAAKwrE,MAAM,iBAA2BZ,EAAWE,OAU3D,OARIrH,GAAO3iD,WACL2iD,EAAO3iD,SAAS1H,SAClBmqD,EAAc31D,KAAK61D,EAAO3iD,SAAS1H,QAAS0H,EAAS6qD,OAEnDlI,EAAO3iD,SAASxT,KAClBi2D,EAAc31D,KAAK61D,EAAO3iD,SAASxT,IAAKwT,EAAS8qD,OAG9CjvD,EAAGsf,mBAAAI,KAAA,QAAA6uC,K7CkqlBH,G6CjqlBDxhB,GACA7xC,EACAk0D,EACA/F,EACAnC,EACAmI,EACAH,C7C4plBC,OAAO5vC,oBAAmBjlB,KAAK,SAAqBm0D,GAClD,OAAU,OAAQA,EAAY/zC,KAAO+zC,EAAYjuD,MAC/C,IAAK,GAEH,MADAiuD,GAAYjuD,KAAO,E6CrqlBJysD,EAAI3Z,KAAKlvC,EAAS6oD,I7CuqlBnC,KAAK,GAGH,M6C1qlBPjgB,GAAMyhB,EAAAtwC,K7CyqlBCswC,EAAYjuD,KAAO,E6CxqlBJktD,EAAQ1gB,E7C0qlBzB,KAAK,GAOH,M6CjrlBP7xC,GAAMszD,EAAAtwC,KACNkxC,EAAgB1B,EAAI4B,SAASrG,QAAQ/tD,GACrCmuD,EAAgB+F,EAAc/F,MAC9BnC,EAAgBwG,EAAI6B,UAAUnF,aAAaf,GAC3CgG,EAAgB,GAAIxI,GAAYC,G7C4qlBzB0H,EAAYjuD,KAAO,G6C3qlBJ8uD,EAAYpI,SAASC,EACzB/iD,EAAS+qD,MAAO/qD,EAAS82C,O7C4qlBtC,KAAK,I6C7qlBViU,EAAKV,EAAAtwC,KAET37B,QAAQ6B,IAAI8qE,E7C8qlBH,KAAK,IACL,IAAK,MACH,MAAOV,GAAYxuC,SAEtBuuC,EAAYlrE,Q6CjrlBpB4N,KAAK5N,Q7CorlBJknB,UAAU,EACVD,cAAc,G6CnrlBnBukD,O7CsrlBK7lE,M6CtrlBA,SAACy4D,EAAM3X,G7CurlBL,GAAIkC,GAAQ3oD,I6CtrlBjBymD,GAAYA,GAAamkB,EAAWC,MACpC,IAAI/pD,GAAW,GAAI8jD,GACfuH,GAAS/N,KAAMA,EAAMt9C,SAAU,KAAMsrD,aAAc,GAOvD,OANApsE,MAAKgrE,OAAOx3D,KAAK24D,GACjBrrD,EAASK,MAAM,WACbgrD,EAAKC,aAAe3lB,EAAU3lC,GAC9BqrD,EAAKrrD,SAAeA,EAASA,SAC7B6nC,EAAKpoC,KAAK,cAELO,G7CyrlBJoG,UAAU,EACVD,cAAc,K6C/vlBRyiD,GAAmBiB,E7CuxlB/BhsE,GAAQ,W6C5rlBM+qE,E7C6rlBdtkE,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,MAEoBjF,KAAK/B,EAASC,EAAoB,IAAI4rD,SAI9D6hB,IACA,SAAS3tE,EAAQC,EAASC,GAE/B,Y8CrzlBc,SAASmrE,GAAYxE,GAClC,QAAS+G,KACP,OACElD,OACArD,MAAO0D,EAAOwB,MAAM/4D,IAAI,SAAAq6D,G9Ci0lBrB,G8Cj0lBwBnO,GAAImO,EAAJnO,KAAMgO,EAAYG,EAAZH,aAActrD,EAAQyrD,EAARzrD,Q9Co0lB5C,Q8Cn0lBDs9C,KAAUA,EACVt9C,SAAUsrD,EAAY,KAAQA,EAAY,IAAM,GAChDI,MAAUznE,KAAKkiD,MAAkB,IAAXnmC,GAAmB,GAAK,Q9CwzlBnD,G8C/zlBoC2oD,GAAMlE,EAANkE,OAAQL,EAAI7D,EAAJ6D,IAW7C,OAAO,UAASp2D,GACd,GAAI0M,GAAO4sD,IACPG,EAAO,GAAIC,IAAO3lE,GAAIiM,EAAW0M,QAErC,OADA+pD,GAAOvpD,GAAG,WAAY,W9Co0lBnB,M8Cp0lByBusD,GAAKz6D,IAAIs6D,OAC9B,WAEL,MADAt5D,GAAUkuC,UAAU7zC,IAAI,cACjByP,QAAQwmC,MAAM,O9CsylB1B,GAAI3lB,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,EAEvF/F,GAAOC,Q8CzzlBgBorE,C9C0zlBvB,I8C7zlBM2C,GAAI/uC,EAAA/+B,EAAM,K9C+zlBhBA,G8C9zlBM,M9C+1lBD+tE,IACA,SAASjuE,EAAQC,EAASC,GAE/B,YAEA,IAAI++B,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnF2iD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMC,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,sC+Cz2lBjHorD,EAAQ5zB,EAAA/+B,EAAM,KACZguE,EAAQhuE,EAAQ,KAAhBguE,SAEIhD,EAAWjrE,EAAXirE,YAAW,WACX,QADAA,GACCpY,G/C42lBThK,EAAgBxnD,K+C72lBR4pE,GAET5pE,KAAK+kE,KAAOvT,E/Cg4lBb,MAhBApK,G+Cl3lBUwiB,EAAW,MAItB5Z,M/Cg3lBKrqD,M+Ch3lBD,SAACmb,GACH,MAAOywC,GAASvxD,KAAK+kE,MAAMvjD,GAAG,cAAeV,I/Ck3lB1CoG,UAAU,EACVD,cAAc,G+Cj3lBfpgB,M/Co3lBCoJ,I+Cp3lBG,WACN,MAAO28D,GAAS5sE,KAAK+kE,O/Cs3lBlB99C,cAAc,K+C93lBR2iD,I/Co4lBZjrE,GAAQ,W+Cx3lBMirE,E/Cy3lBdxkE,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJknE,IACA,SAASnuE,EAAQC,EAASC,GAE/B,YgD73lBD,SAASkuE,GAAOC,GACVA,GAAWA,EAAQC,aAAeluE,SAASmuE,MAC7CnuE,SAASmuE,KAAKj4C,YAAY+3C,GhD63lB7B,GAAIpvC,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,GAEnF2iD,EAAuB,SAAUC,EAAOC,EAAaC,GAAqBD,GAAaliD,OAAOmoB,iBAAiB85B,EAAOC,GAAkBC,GAAeniD,OAAOmoB,iBAAiB85B,EAAM7mD,UAAW+mD,IAEhMC,EAAkB,SAAU5jC,EAAUiD,GAAe,KAAMjD,YAAoBiD,IAAgB,KAAM,IAAI1gB,WAAU,qCAEvHvH,GgDz5lBM,GhD25lBN,IgD15lBM+d,GAAEghB,EAAA/+B,EAAM,KAEFsuE,EAAYvuE,EAAZuuE,aAAY,WACZ,QADAA,KhD45lBR1lB,EAAgBxnD,KgD55lBRktE,GhDi8lBV,MAlCA9lB,GgD/5lBU8lB,EAAY,MAGvBpD,ShD85lBKnkE,MgD95lBE,SAACwnE,GACN,MAAOxwD,GAAEsf,mBAAAI,KAAC,QAAA6uC,KhD+5lBH,GgD15lBD6B,GhD05lBKpkB,EAAQ3oD,IAEZ,OAAOi8B,oBAAmBjlB,KAAK,SAAqBm0D,GAClD,OAAU,OAAQA,EAAY/zC,KAAO+zC,EAAYjuD,MAC/C,IAAK,GACH,IgDn6lBPyrC,EAAKykB,KAAI,ChDo6lBAjC,EAAYjuD,KAAO,CACnB,OAGF,MADAiuD,GAAYjuD,KAAO,EgDt6lBtBJ,QAAQC,QAAQ4rC,EAAKykB,OhDw6lBpB,KAAK,GgDv6lBZN,EAAOnkB,EAAK0kB,ehDy6lBL,KAAK,GgDv6lBVN,EAAUjuE,SAASqgB,cAAc,OACrC4tD,EAAQO,UAAY,QACpBxuE,SAASmuE,KAAKl4C,YAAYg4C,GAC1BpkB,EAAKykB,KAAOD,EAAMJ,EhDy6lBT,KAAK,GACL,IAAK,MACH,MAAO5B,GAAYxuC,SAEtBuuC,EAAYlrE,UAGnBknB,UAAU,EACVD,cAAc,KgD77lBRimD,KAuBFtpD,EAAQjlB,EAARilB,SAAW,GAAIspD,EhDq7lBzBvuE,GAAQ,WgDp7lBMilB,EhDq7lBdxe,OAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ4nE,IACA,SAAS7uE,EAAQC,EAASC,GAE/B,YiDv9lBM,SAAS8tE,GAAKc,GACnB,MAAO,UAAsBz9B,GAC3B,MAAO,IAAI09B,GAAQroE,OAAOwoB,QAAS4/C,YAAYz9B,KjDu9lBlD,GAAIpS,GAAkB,SAAUl5B,GAAO,MAAOA,IAAOA,EAAIm5B,WAAan5B,EAAI,WAAaA,EAEvF9F,GiD39lBe+tE,MjD49lBf,IiD99lBMe,GAAO9vC,EAAA/+B,EAAM,KjDq+lBnBwG,QAAOgc,eAAeziB,EAAS,cAC7BgH,OAAO,KAKJ+nE,IACA,SAAShvE,EAAQC,EAASC,GkD5+lBhCD,EAAA2rE,OAAA1rE,EAAA,KACAD,EAAAstE,SAAArtE,EAAA,KAEAD,EAAA+9D,SAAA99D,EAAA,KACAD,EAAAi+D,WAAAh+D,EAAA,KACAD,EAAAm+D,WAAAl+D,EAAA,KAEAD,EAAAg/D,UAAA/+D,EAAA,KACAD,EAAAq+D,eAAAp+D,EAAA,KACAD,EAAA2nE,MAAA1nE,EAAA,KACAD,EAAAupE,OAAAtpE,EAAA,KACAD,EAAAgvE,SAAA/uE,EAAA,KACAD,EAAAutE,UAAAttE,EAAA,MlDo/lBMgvE,IACA,SAASlvE,EAAQC,EAASC,GmD//lBhC,QAAAstE,GAAAh6D,GACAlS,KAAAgG,KAAAkM,EAHA,GAAAkR,GAAAxkB,EAAA,IAMAstE,GAAA1rE,UAAAyP,IAAA,SAAAmkB,GACA,MAAAp0B,MAAAgG,KAAAouB,EAAA50B,gBAGA0sE,EAAA1rE,UAAAwjE,MAAA,WACA,MAAA5gD,GAAA1M,KAAA0M,EAAAvM,OAAA7W,KAAAgG,QAGAkmE,EAAAnF,aAAA,SAAAf,GACA,GAAA9zD,KAMA,OALA8zD,GAAArJ,QAAAzuB,KAAA,SAAArnC,EAAAlB,GACA,GAAAlG,GAAAoH,EAAApH,MAAA,eACAA,KACAyS,EAAAzS,EAAA,GAAAD,eAAAmG,KAEA,GAAAumE,GAAAh6D,IAGAxT,EAAAC,QAAAutE,GnDygmBM2B,IACA,SAASnvE,EAAQC,EAASC,GoDlimBhC,GAAAkvE,GAAAlvE,EAAA,KACAsZ,EAAAtZ,EAAA,KACAmvE,EAAAnvE,EAAA,KAMAovE,GALApvE,EAAA,KACAA,EAAA,MAKA,GAAAkvE,GACA,GAAA51D,GAAA+1D,SACA,GAAA/1D,GAAAg2D,SACA,GAAAH,GAAAI,KACA,GAAAJ,GAAAK,QAGA1vE,GAAAC,QAAA0vE,OAAA,SAAA3kB,GAIA,OADA4kB,MACArwD,EAAA,EAAiB,IAAAA,EAASA,IAC1BqwD,EAAArwD,GAAA,CAEA,QAAAA,GAAAyrC,EAAA5mD,OAAA,EAAiCmb,GAAA,EAAQA,IACzCqwD,EAAA,IAAA5kB,EAAAzrC,KAGA,QADAswD,IAAA,EACAtwD,EAAA,IAAoB,KAAAA,EAAWA,GAAA,EAC/B,MAAAqwD,EAAArwD,GAAA,CACAswD,GAAA,CACA,OAIA,GAAAjoE,IACAgoE,aACAC,WACAC,UAAA9kB,EACA+kB,WAAA/kB,EAAA5mD,OACA4rE,YAAAhlB,EACAilB,UAAAjlB,EAAA5mD,QAGArD,EAAAuuE,EAAA97D,IAAA,SAAAqlD,GACA,MAAAA,GAAA93D,MAAA6G,KACG6I,OAAA,SAAA1P,GACH,QAAAA,IACG2V,KAAA,SAAA5S,EAAAC,GACH,MAAAD,GAAAg1D,WAAA/0D,EAAA+0D,aACGn/C,KAEH,OAAA5Y,KAAAoH,KAAA,OpD2imBM+nE,IACA,SAASlwE,EAAQC,EAASC,GqDtlmBhC,QAAAiwE,MAVA,GAAAxsC,GAAAzjC,EAAA,KACAkwE,EAAAlwE,EAAA,GAWAiwE,GAAAruE,UAAAf,MAAA,SAAA63D,GAeA,GAAAr5C,GAAAlc,EACAgtE,EAIAC,EAHAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAIA/Q,EAAA9G,EAAAoX,YACAU,EAAA9X,EAAAqX,SAEAU,GACA,IAAApxD,EAAA,EAAemxD,EAAAnxD,EAAaA,IAAA,CAC5B,OAAAmgD,EAAAngD,GAAA,CACAqxD,EACA,IAAAP,EAAA,EAAwBA,EAAA/uE,KAAAuvE,gBAAAzsE,OAAoCisE,IAAA,CAC5D,GAAAS,GAAAxvE,KAAAuvE,gBAAAR,EAEA,MAAAK,EAAAnxD,EAAAuxD,EAAA1sE,QAAA,CAGA,IAAAf,EAAA,EAAuBA,EAAAytE,EAAA1sE,OAAgBf,IACvC,GAAAytE,EAAAztE,IAAAq8D,EAAAngD,EAAAlc,GACA,QAAAutE,EAGAL,KACAhxD,GAAAuxD,EAAA1sE,OAAA,CACA,SAAAusE,IAGAH,KAIA,IAAA9Q,EAAAngD,IAAA,IAAAmgD,EAAAngD,KACAkxD,IAIA,UAAAF,EACA,MAQAD,GAAA,IAAAC,EAAA,IAAAC,IAAAD,EAAAC,GAKA,EAAAD,EAAAE,IACAH,GAAA,OAAAC,EAAAE,KAEA,GAAAH,EAAA,QAAAF,GAAAxX,EAAAt3D,KAAAgvE,KAGAtwE,EAAAC,QAAA8wE,YAAA,WACAzvE,KAAA6G,KAAA,WACA,qBAEA7G,KAAAuvE,kBACA,cACA,cACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YAGAltC,EAAAwE,SAAAnoC,EAAAC,QAAA8wE,YAAAZ,GAIAnwE,EAAAC,QAAA+wE,YAAA,WACA1vE,KAAA6G,KAAA,WACA,qBAEA7G,KAAAuvE,kBACA,eAGAltC,EAAAwE,SAAAnoC,EAAAC,QAAA+wE,YAAAb,GAIAnwE,EAAAC,QAAAgxE,YAAA,WACA3vE,KAAA6G,KAAA,WACA,qBAEA7G,KAAAuvE,kBACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,QACA,SAGAltC,EAAAwE,SAAAnoC,EAAAC,QAAAgxE,YAAAd,IrDummBMe,IACA,SAASlxE,EAAQC,EAASC,GsD9umBhC,QAAAixE,GAAA/xC,EAAAgyC,GACA,QAAAzgE,GAAAyuB,EAAAgyC,EAAAC,EAAAC,GACA,GAAAD,EAAAC,EACA,QAOA,IAAAC,GAAAlrE,KAAA2P,MAAAq7D,EAAAC,IAAA,EACA,OAAAF,GAAAhyC,EAAAmyC,GACA5gE,EAAAyuB,EAAAgyC,EAAAG,EAAA,EAAAD,GAEAF,EAAAhyC,EAAAmyC,GACA5gE,EAAAyuB,EAAAgyC,EAAAC,EAAAE,EAAA,GAEAA,EAGA,MAAA5gE,GAAAyuB,EAAAgyC,EAAA,EAAAhyC,EAAAh7B,OAAA,GAcA,QAAAotE,KAEAlwE,KAAAmwE,UAAA,EACAnwE,KAAAW,MAAA,EACAX,KAAAowE,UAAA,EACApwE,KAAA+lC,OAAA,EACA/lC,KAAAqd,MAAA,EAEArd,KAAA27B,MAAA,WACA37B,KAAAmwE,UAAA,EACAnwE,KAAAW,MAAA,GACAX,KAAAowE,UAAA,EACApwE,KAAA+lC,OAAA,EACA/lC,KAAAqd,MAAA,GAGArd,KAAAqwE,SAAA,SAAA/Y,GACA,GAAAt3D,KAAAowE,WAAA9Y,EAAAmX,WAEA,MADAzuE,MAAAqd,MAAA,EACA,EAEA,IAAAizD,GAAA,IAAAhZ,EAAAkX,UAAAxuE,KAAAowE,YACA,OAAAE,IAaA,QAAAvC,MAqOA,QAAAwC,GAAAxnD,EAAAuuC,GACAvuC,EAAApoB,MAAAooB,EAAAqnD,UACArnD,EAAAgd,OAAA,CACA,IAAAyqC,GAAA,EACAC,EAAA,EACAC,EAAA,CA4CA,OAzCAF,GAAAznD,EAAAonD,UAAApnD,EAAAsnD,SAAA/Y,GACA,EAAAkZ,EAEAznD,EAAA1L,MAAA,EAGA,KAAAmzD,IAIAC,EAAA1nD,EAAAsnD,SAAA/Y,GACAvuC,EAAAonD,UAAApnD,EAAAonD,WAAA,EAAAM,EACAD,GAAA,UAAAA,EAEA,IAAAC,IACA1nD,EAAAgd,OAAA,GAIA,KAAAyqC,EAYA,KAAAA,IAGAE,EAAA3nD,EAAAsnD,SAAA/Y,GACAvuC,EAAAonD,UAAApnD,EAAAonD,WAAA,EAAAO,EACA,IAAAA,IACA3nD,EAAAgd,OAAA,IAXA,IAAA0qC,IACA1nD,EAAAgd,OAAA,IAcA,GAAAhd,EAAA1L,KAjWA,GAAAglB,GAAAzjC,EAAA,KACAkwE,EAAAlwE,EAAA,GAsFAmvE,GAAAvtE,UAAAf,MAAA,SAAA63D,GAEA,GAAAqZ,GAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAvZ,EAAA,EAEAzuC,EAAA,GAAAmnD,EAEAc,GAAA,CACA,IAAAjoD,EAAA4S,QAAsB37B,KAAAixE,SAAAloD,EAAAuuC,IAA0B,CAEhD,GADAyZ,IACAhoD,EAAAgd,MACA+qC,QACO,CACP,GAAAI,GAAA,WAAAnoD,EAAAonD,SAEA,MAAAe,EACAP,KAEAC,IACA,MAAA5wE,KAAAmxE,aAEAtB,EAAA7vE,KAAAmxE,YAAAD,IAAA,GACAL,KAKA,GAAAC,GAAA,KAAAA,GAAAF,EAGA,KAAAI,GAIA,OAAAJ,GAAA,GAAAE,EAMAtZ,EAJA,GAAAoZ,GAAA,GAAAG,EAIA,EAKA,OASA,OAAAD,EAAAF,EACApZ,EAAA,MAIA,UAAAx3D,KAAAmxE,YAIA3Z,EAAA,GAAAoZ,EAAA,GAAAE,EACAtZ,EAAA,MACAA,EAAA,SAEK,CAIL,GAAA4Z,GAAArsE,KAAAhE,IAAAyvB,WAAAogD,GAAA,GACAS,EAAA,GAAAD,CACA5Z,GAAAzyD,KAAA2P,MAAA3P,KAAAhE,IAAA8vE,EAAA,GAAAQ,EAAA,IACA7Z,EAAAzyD,KAAAe,IAAA0xD,EAAA,MAIA,UAAAA,EAAA,QAAAsX,GAAAxX,EAAAt3D,KAAAw3D,IAgBAuW,EAAAvtE,UAAAywE,SAAA,aAOAvyE,EAAAC,QAAAwvE,KAAA,WACAnuE,KAAA6G,KAAA,WACA,mBAEA7G,KAAAsxE,SAAA,WACA,YAMAtxE,KAAAmxE,aACA,4DACA,4DACA,4DACA,4DACA,4DACA,2CAGAnxE,KAAAixE,SAAA,SAAAloD,EAAAuuC,GACAvuC,EAAApoB,MAAAooB,EAAAqnD,UACArnD,EAAAgd,OAAA,CAEA,IAAAyqC,EAEA,IADAA,EAAAznD,EAAAonD,UAAApnD,EAAAsnD,SAAA/Y,GACA,EAAAkZ,EACA,QAEA,SAAAA,KAAA,UAAAA,EACA,QAEA,IAAAC,GAAA1nD,EAAAsnD,SAAA/Y,EACA,UAAAmZ,GACA,GAEA1nD,EAAAonD,UAAAK,GAAA,EAAAC,EACAA,GAAA,SAAAA,MAAA,UAAAA,IAEA1nD,EAAAgd,OAAA,IAEA,KAGA1D,EAAAwE,SAAAnoC,EAAAC,QAAAwvE,KAAAJ,GAOArvE,EAAAC,QAAA4yE,KAAA,WACAvxE,KAAA6G,KAAA,WACA,cAEA7G,KAAAsxE,SAAA,WACA,YAKAtxE,KAAAmxE,aACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,qCAEAnxE,KAAAixE,SAAA,SAAAloD,EAAAuuC,GACAvuC,EAAApoB,MAAAooB,EAAAqnD,UACArnD,EAAAgd,OAAA,CAEA,IAAAyqC,GAAAznD,EAAAonD,UAAApnD,EAAAsnD,SAAA/Y,EAEA,MAAAkZ,EACA,QAGA,SAAAA,GAAA,KAAAA,EACA,QAEA,IAAAC,GAAA1nD,EAAAsnD,SAAA/Y,EAEA,UAAAmZ,GACA,GAEA1nD,EAAAonD,UAAApnD,EAAAonD,WAAA,EAAAM,GAEA,GAAAA,GAAA,KAAAA,GAAA,KAAAA,KACA1nD,EAAAgd,OAAA,IAEA,KAGA1D,EAAAwE,SAAAnoC,EAAAC,QAAA4yE,KAAAxD,GAuEArvE,EAAAC,QAAA6yE,OAAA,WACAxxE,KAAA6G,KAAA,WACA,gBAEA7G,KAAAsxE,SAAA,WACA,YAMAtxE,KAAAmxE,aACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,6DAGAnxE,KAAAixE,SAAAV,GAEAluC,EAAAwE,SAAAnoC,EAAAC,QAAA6yE,OAAAzD,GAQArvE,EAAAC,QAAAyvE,OAAA,WACApuE,KAAA6G,KAAA,WACA,gBAEA7G,KAAAsxE,SAAA,WACA,YAMAtxE,KAAAmxE,aACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,6DAGAnxE,KAAAixE,SAAAV,GAEAluC,EAAAwE,SAAAnoC,EAAAC,QAAAyvE,OAAAL,GAOArvE,EAAAC,QAAA8yE,SAAA,WACAzxE,KAAA6G,KAAA,WACA,iBAEA7G,KAAAsxE,SAAA,WACA,YAQAtxE,KAAAixE,SAAA,SAAAloD,EAAAuuC,GACAvuC,EAAApoB,MAAAooB,EAAAqnD,UACArnD,EAAAgd,OAAA,CACA,IAAAyqC,GAAA,EACAC,EAAA,EACAC,EAAA,EACAgB,EAAA,CACAC,GAEA,GADAnB,EAAAznD,EAAAonD,UAAApnD,EAAAsnD,SAAA/Y,GACA,EAAAkZ,EAEAznD,EAAA1L,MAAA,MAGA,WAAAmzD,GAMA,GAFAC,EAAA1nD,EAAAsnD,SAAA/Y,GACAvuC,EAAAonD,UAAApnD,EAAAonD,WAAA,EAAAM,EACAD,GAAA,UAAAA,EAAA,CAEA,GAAAC,GAAA,SAAAA,MAAA,SAAAA,EACA,KAAAkB,EAGA,IAAAlB,GAAA,QAAAA,IACAC,EAAA3nD,EAAAsnD,SAAA/Y,GACAoZ,GAAA,UAAAA,IACAgB,EAAA3oD,EAAAsnD,SAAA/Y,GACAoa,GAAA,QAAAA,IAAA,CACA3oD,EAAAonD,UAAApnD,EAAAonD,WAAA,GAAAO,GAAA,EAAAgB,CACA,MAAAC,GAIA5oD,EAAAgd,OAAA,OAIA,UAAAhd,EAAA1L,MAMArd,KAAAmxE,aACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,8DAGA9uC,EAAAwE,SAAAnoC,EAAAC,QAAA8yE,SAAA1D,ItD2vmBM6D,IACA,SAASlzE,EAAQC,EAASC,GuDzunBhC,QAAAizE,GAAAC,EAAAC,GACA,GAAAC,GAAA,QAEAhyE,MAAAiyE,UAAA,EACAjyE,KAAAkyE,MAAA,EAEAlyE,KAAAmyE,UAAAL,EACA9xE,KAAAoyE,QAAAL,EAEA/xE,KAAAqyE,WAAA,EACAryE,KAAAsyE,SAAA,EAEAtyE,KAAAuyE,UAKAvyE,KAAAyyD,OAAA,SAAApzD,EAAAsG,GACA,GAAAhF,GAAA,CAUA,OARAtB,GAAAsB,EAAA,KAAAgF,IAAAhF,GAAA,IACAtB,EAAAsB,EAAA,KAAAgF,IAAAhF,GAAA,IACAtB,EAAAsB,EAAA,IAAAgF,IAAAhF,GAAA,GACAtB,EAAAsB,EAAA,IAAAgF,IAAAhF,GAAA,GACAtB,EAAAsB,EAAA,IAAAgF,IAAAhF,GAAA,GACAtB,EAAAsB,EAAA,IAAAgF,IAAAhF,GAAA,GACAtB,EAAAsB,GAAAgF,IAAAhF,GAAA,GAEA,EAAAA,GAAAtB,EAAAsB,IAAAgF,EACA,GAEAhF,GAGAX,KAAA23D,OAAA,SAAA6a,GACAxyE,KAAAqyE,YAAA,EACAryE,KAAAyyD,OAAAzyD,KAAAmyE,UAAAK,IAAA,IACAxyE,KAAAsyE,UAAA,IAIAtyE,KAAAyyE,QAAA,SAAAhwE,GACAzC,KAAAkyE,OAAAlyE,KAAAkyE,OAAA,QAAAzvE,GAAAuvE,EACAhyE,KAAA23D,OAAA33D,KAAAkyE,QAGAlyE,KAAAqwE,SAAA,SAAA/Y,GACA,MAAAt3D,MAAAiyE,WAAA3a,EAAAqX,UACA,GAEA,IAAArX,EAAAoX,YAAA1uE,KAAAiyE,cAGAjyE,KAAA6mD,MAAA,SAAAyQ,EAAAob,GACA,GAAAjwE,GAAAkwE,GAAA,CAGA,KAFA3yE,KAAAuyE,UAAAG,GAEAjwE,EAAAzC,KAAAqwE,SAAA/Y,KAAA,IACA,GAAAsb,GAAA5yE,KAAAoyE,QAAA3vE,EAGA,IAAAmwE,IACAA,GAAA5yE,KAAAuyE,WAAAI,GACA3yE,KAAAyyE,QAAAG,GAGAD,EAAAC,GAAA5yE,KAAAuyE,WAKAvyE,KAAAyyE,QAAAzyE,KAAAuyE,UAEA,IAAAM,GAAA7yE,KAAAsyE,SAAAtyE,KAAAqyE,UAIA,OAAAQ,GAAA,IACA,GAEA9tE,KAAA2P,MAAA,IAAAm+D,IAIA,QAAAC,GAAAC,EAAAC,GACAhzE,KAAAizE,MAAAF,EACA/yE,KAAAkzE,QAAAF,EAGA,QAAAG,MAjGA,GAAA9wC,GAAAzjC,EAAA,KACAkwE,EAAAlwE,EAAA,GAiGAu0E,GAAA3yE,UAAA+xE,UAAA,GACAY,EAAA3yE,UAAA4yE,OAAA,aACAD,EAAA3yE,UAAA4xE,QAAA,aACAe,EAAA3yE,UAAAf,MAAA,SAAA63D,GAEA,GAAA8b,GAAApzE,KAAAozE,SACAC,EAAA9yE,MAAA2E,QAAAkuE,MAAA,YAAAN,EAEA,KAAAO,EAAA,CACA,GAAAC,GAAA,GAAAzB,GAAAuB,EAAApzE,KAAAoyE,WACA5a,EAAA8b,EAAAzsB,MAAAyQ,EAAAt3D,KAAAuyE,UACA,WAAA/a,EAAA,QAAAsX,GAAAxX,EAAAt3D,KAAAw3D,GAMA,OAHA+b,GAAA,GACA9b,EAAA,KAEAx5C,EAAAm1D,EAAAtwE,OAAA,EAAiCmb,GAAA,EAAQA,IAAA,CACzC,GAAAu1D,GAAAJ,EAAAn1D,GAEAq1D,EAAA,GAAAzB,GAAA2B,EAAAN,QAAAlzE,KAAAoyE,WACA5a,EAAA8b,EAAAzsB,MAAAyQ,EAAAt3D,KAAAuyE,UACA/a,GAAA+b,IACAA,EAAA/b,EACAC,EAAA+b,EAAAP,OAIA,GAAApsE,GAAA7G,KAAA6G,KAAAywD,EACA,WAAAic,EAAA,QAAAzE,GAAAxX,EAAAt3D,KAAAuzE,EAAA1sE,EAAA4wD,IAIA/4D,EAAAC,QAAA80E,WAAA,WACAzzE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,wBACA,yBACA,yBACA,yBACA,gCACA,gCACA,+BACA,gCACA,gCACA,gCACA,+BACA,kCAIApyE,KAAAozE,OAAA,WACA,OACA,GAAAN,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,mEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,kEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,oEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,sEAKA9yE,KAAA6G,KAAA,SAAAywD,GACA,MAAAA,MAAAiX,SAAA,8BAGAlsC,EAAAwE,SAAAnoC,EAAAC,QAAA80E,WAAAN,GAGAz0E,EAAAC,QAAA+0E,WAAA,WACA1zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,4BACA,8BACA,6BACA,8BACA,gCACA,gCACA,+BACA,gCACA,gCACA,gCACA,+BACA,iCAIApyE,KAAAozE,OAAA,WACA,OACA,GAAAN,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,yEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,oEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,mEAEA,GAAAA,GAAA,MACA,gEACA,gEACA,gEACA,gEACA,+DACA,gEACA,gEACA;EAKA9yE,KAAA6G,KAAA,SAAAywD,GACA,MAAAA,MAAAiX,SAAA,8BAGAlsC,EAAAwE,SAAAnoC,EAAAC,QAAA+0E,WAAAP,GAGAz0E,EAAAC,QAAAg1E,WAAA,WACA3zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,+BACA,+BACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,+BACA,iCAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,gEACA,sEACA,wEACA,wEACA,wEACA,wEACA,yEAIApzE,KAAA6G,KAAA,WACA,oBAGA7G,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAg1E,WAAAR,GAGAz0E,EAAAC,QAAAi1E,WAAA,WACA5zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,+BACA,gCACA,gCACA,2BACA,gCACA,2BACA,wBACA,0BAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,wEACA,wEACA,wEACA,wEACA,wEACA,wEACA,0EAIApzE,KAAA6G,KAAA,WACA,oBAGA7G,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAi1E,WAAAT,GAGAz0E,EAAAC,QAAAk1E,WAAA,WACA7zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,0BACA,wBACA,yBACA,8BACA,gCACA,gCACA,+BACA,gCACA,gCACA,gCACA,gCACA,iCAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,gEACA,uEACA,wEACA,wEACA,wEACA,wEACA,yEAIApzE,KAAA6G,KAAA,SAAAywD,GACA,MAAAA,MAAAiX,SAAA,6BAGAvuE,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAk1E,WAAAV,GAEAz0E,EAAAC,QAAAm1E,WAAA,WAEA9zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,yBACA,wBACA,wBACA,wBACA,wBACA,wBACA,gCACA,gCACA,gCACA,6BAIApyE,KAAAozE,OAAA,WACA,OACA,GAAAN,GAAA,MACA,gEACA,gEACA,sEACA,wEACA,wEACA,wEACA,wEACA,0EAEA,GAAAA,GAAA,MACA,gEACA,gEACA,sEACA,wEACA,wEACA,wEACA,wEACA,4EAKA9yE,KAAA6G,KAAA,SAAAywD,GACA,MAAAA,MAAAiX,SAAA,6BAGAvuE,KAAAsxE,SAAA,WACA,aAIAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAm1E,WAAAX,GAGAz0E,EAAAC,QAAAo1E,WAAA,WACA/zE,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,wBACA,yBACA,yBACA,yBACA,gCACA,gCACA,+BACA,gCACA,gCACA,gCACA,+BACA,kCAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,gEACA,sEAIApzE,KAAA6G,KAAA,SAAAywD,GACA,MAAAA,MAAAiX,SAAA,6BAGAvuE,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAo1E,WAAAZ,GAGAz0E,EAAAC,QAAAq1E,aAAA,WACAh0E,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,2BACA,6BACA,yBACA,6BACA,4BACA,2BACA,4BACA,8BACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,kCAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,gEACA,sEACA,wEACA,wEACA,wEACA,wEACA,0EAIApzE,KAAA6G,KAAA,WACA,sBAGA7G,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAq1E,aAAAb,GAGAz0E,EAAAC,QAAAs1E,aAAA,WACAj0E,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,0BACA,8BACA,yBACA,4BACA,wBACA,yBACA,yBACA,wBACA,gCACA,gCACA,+BACA,gCACA,gCACA,gCACA,yBACA,8BAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,wEACA,wEACA,wEACA,wEACA,wEACA,wEACA,0EAIApzE,KAAA6G,KAAA,WACA,sBAGA7G,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAs1E,aAAAd,GAGAz0E,EAAAC,QAAAu1E,OAAA,WACAl0E,KAAAoyE,QAAA,WACA,OACA,wBACA,wBACA,wBACA,wBACA,uBACA,wBACA,wBACA,wBACA,4BACA,gCACA,gCACA,2BACA,4BACA,gCACA,gCACA,2BACA,wBACA,wBACA,wBACA,wBACA,yBACA,wBACA,yBACA,wBACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,kCAIApyE,KAAAozE,OAAA,WACA,OACA,gEACA,gEACA,sEACA,wEACA,wEACA,wEACA,wEACA,0EAIApzE,KAAA6G,KAAA,WACA,gBAGA7G,KAAAsxE,SAAA,WACA,aAGAjvC,EAAAwE,SAAAnoC,EAAAC,QAAAu1E,OAAAf,IvDqxnBMgB,IACA,SAASz1E,EAAQC,EAASC,GwDxlpBhC,QAAAw1E,MA3CA,GAAA/xC,GAAAzjC,EAAA,KACAkwE,EAAAlwE,EAAA,GAMAF,GAAAC,QAAAsvE,SAAA,WACAjuE,KAAA6G,KAAA,WACA,kBAEA7G,KAAAP,MAAA,SAAA63D,GACA,GAAAwD,GAAAxD,EAAAkX,SAEA,OAAA1T,GAAAh4D,QAAA,aAAAg4D,EAAA,eAAAA,EAAA,IACA,GAAAgU,GAAAxX,EAAAt3D,KAAAw3D,WAAA,KAGA,OAIA94D,EAAAC,QAAAuvE,SAAA,WACAluE,KAAA6G,KAAA,WACA,kBAEA7G,KAAAP,MAAA,SAAA63D,GACA,GAAAwD,GAAAxD,EAAAkX,SAEA,OAAA1T,GAAAh4D,QAAA,aAAAg4D,EAAA,eAAAA,EAAA,IAEAA,EAAAh4D,QAAA,MAAAg4D,EAAA,OAAAA,EAAA,GAEA,KAEA,GAAAgU,GAAAxX,EAAAt3D,KAAAw3D,WAAA,KAIA,OAKA4c,EAAA5zE,UAAAf,MAAA,SAAA63D,GACA,GAAAwD,GAAAxD,EAAAkX,UACAj8B,EAAA+kB,EAAAmX,WAAA,IACA4F,EAAA,EACAC,EAAA,EACAC,GAAA,EACA/c,EAAA,CAEA,OAAAjlB,EACA,WAEA,QAAAvyC,KAAAw0E,QAAA1Z,EAAA,KACAyZ,GAAA,EAEA,QAAAt2D,GAAA,EAAiBs0B,EAAAt0B,EAAWA,GAAA,GAC5B,GAAAw2D,GAAAz0E,KAAAw0E,QAAA1Z,EAAA78C,EAEA,GAAAw2D,MAAA,SAAAA,GAAA,cAAAA,EACAH,GAAA,EAEAD,GAAA,EAmBA,MAdAE,IAAA,GAAAD,EACA9c,EAAA,IACG+c,GAAAF,EAAA,GAAAC,EACH9c,EAAA,GACG6c,EAAA,MAAAC,EACH9c,EAAA,IACG6c,EAAA,MAAAC,EACH9c,EAAA,GACG6c,EAAA,GAAAC,IAEH9c,EAAA,IAIA,GAAAA,EAAA,QAAAsX,GAAAxX,EAAAt3D,KAAAw3D,IAGA94D,EAAAC,QAAA+1E,SAAA,WACA10E,KAAA6G,KAAA,WACA,kBAEA7G,KAAAw0E,QAAA,SAAA1Z,EAAAn6D,GACA,WAAAm6D,EAAAn6D,EAAA,aAAAm6D,EAAAn6D,EAAA,SACA,IAAAm6D,EAAAn6D,EAAA,WAAAm6D,EAAAn6D,EAAA,KAGA0hC,EAAAwE,SAAAnoC,EAAAC,QAAA+1E,SAAAN,GAEA11E,EAAAC,QAAAg2E,SAAA,WACA30E,KAAA6G,KAAA,WACA,kBAEA7G,KAAAw0E,QAAA,SAAA1Z,EAAAn6D,GACA,WAAAm6D,EAAAn6D,EAAA,aAAAm6D,EAAAn6D,EAAA,SACA,IAAAm6D,EAAAn6D,EAAA,WAAAm6D,EAAAn6D,EAAA,KAGA0hC,EAAAwE,SAAAnoC,EAAAC,QAAAg2E,SAAAP,IxD0opBMQ,IACA,SAASl2E,EAAQC,EAASC,GyDpvpBhC,GAAAkwE,GAAAlwE,EAAA,GAKAF,GAAAC,QAAA,WACAqB,KAAA6G,KAAA,WACA,eAEA7G,KAAAP,MAAA,SAAA63D,GAEA,GAKAE,GALA+c,GAAA,EACAF,EAAA,EACAC,EAAA,EACAxZ,EAAAxD,EAAAkX,UACAqG,EAAA,CAGAvd,GAAAmX,YAAA,GACA,UAAA3T,EAAA,eAAAA,EAAA,eAAAA,EAAA,MACAyZ,GAAA,EAIA,QAAAt2D,GAAA,EAAmBA,EAAAq5C,EAAAmX,WAAoBxwD,IAAA,CACvC,GAAAxb,GAAAq4D,EAAA78C,EACA,YAAAxb,GAAA,CAIA,aAAAA,GACAoyE,EAAA,MACO,cAAApyE,GACPoyE,EAAA,MACO,cAAApyE,GACPoyE,EAAA,MACO,CAEP,GADAP,IACAA,EAAA,EACA,KACAO,GAAA,EAIA,KACA52D,MACAA,GAAAq5C,EAAAmX,aAFa,CAKb,aAAA3T,EAAA78C,IAAA,CACAq2D,GACA,OAEA,QAAAO,EAAA,CACAR,GACA,UAQA,GADA7c,EAAA,EACA+c,GAAA,GAAAD,EACA9c,EAAA,QACA,IAAA+c,GAAAF,EAAA,GAAAC,EACA9c,EAAA,OACA,IAAA6c,EAAA,MAAAC,EACA9c,EAAA,QACA,IAAA6c,EAAA,MAAAC,EACA9c,EAAA,OACA,OAAA6c,GAAA,GAAAC,EAEA9c,EAAA,OACA,MAAA6c,EAAA,GAAAC,GAIA,WAFA9c,GAAA,GAIA,UAAAsX,GAAAxX,EAAAt3D,KAAAw3D,MzD8vpBMsd,IACA,SAASp2E,EAAQC,EAASC,GAE/B,GAAI46D,I0Dl1pBL,SAAA96D,EAAAoZ,IASC,WAwRD,QAAAi9D,GAAApvE,EAAA6S,GACA,GAAA7S,IAAA6S,EAAA,CACA,GAAAw8D,GAAArvE,MACAsvE,EAAAz8D,KAEA,IAAA7S,EAAA6S,IAAAw8D,GAAA,mBAAArvE,IAAAsvE,EACA,QAEA,IAAAz8D,EAAA7S,IAAAsvE,GAAA,mBAAAz8D,IAAAw8D,EACA,SAGA,SAYA,QAAAE,GAAAxwD,EAAA/e,EAAAwvE,GACA,GAAAxvE,MACA,MAAAyvE,GAAA1wD,EAAAywD,EAKA,KAHA,GAAAx0E,IAAAw0E,GAAA,KACAryE,EAAA4hB,EAAA5hB,SAEAnC,EAAAmC,GACA,GAAA4hB,EAAA/jB,KAAAgF,EACA,MAAAhF,EAGA,UAaA,QAAA00E,GAAA3wD,EAAA4wD,GACA,GAAAxyE,GAAA4hB,EAAA5hB,MAGA,KADA4hB,EAAAtP,KAAAkgE,GACAxyE,KACA4hB,EAAA5hB,GAAA4hB,EAAA5hB,GAAA6C,KAEA,OAAA+e,GAWA,QAAA6wD,GAAA5vE,GACA,sBAAAA,GACAA,EAEA,MAAAA,EAAA,GAAAA,EAAA,GAUA,QAAA6vE,GAAA/pB,GACA,MAAAA,GAAAlyC,WAAA,GAYA,QAAAk8D,GAAAhqB,EAAAiqB,GAIA,IAHA,GAAA/0E,GAAA,GACAmC,EAAA2oD,EAAA3oD,SAEAnC,EAAAmC,GAAA4yE,EAAA/kE,QAAA86C,EAAAnyC,OAAA3Y,IAAA,KACA,MAAAA,GAYA,QAAAg1E,GAAAlqB,EAAAiqB,GAGA,IAFA,GAAA/0E,GAAA8qD,EAAA3oD,OAEAnC,KAAA+0E,EAAA/kE,QAAA86C,EAAAnyC,OAAA3Y,IAAA,KACA,MAAAA,GAYA,QAAAi1E,GAAAz7D,EAAA3B,GACA,MAAAu8D,GAAA56D,EAAA07D,SAAAr9D,EAAAq9D,WAAA17D,EAAAxZ,MAAA6X,EAAA7X,MAYA,QAAAm1E,GAAA37D,EAAA3B,GAMA,IALA,GAAA7X,GAAA,GACAo1E,EAAA57D,EAAA07D,SACAG,EAAAx9D,EAAAq9D,SACA/yE,EAAAizE,EAAAjzE,SAEAnC,EAAAmC,GAAA,CACA,GAAAU,GAAAuxE,EAAAgB,EAAAp1E,GAAAq1E,EAAAr1E,GACA,IAAA6C,EACA,MAAAA,GAUA,MAAA2W,GAAAxZ,MAAA6X,EAAA7X,MAUA,QAAAs1E,GAAAC,GACA,MAAAC,IAAAD,GAUA,QAAAE,GAAAC,GACA,MAAAC,IAAAD,GAWA,QAAAE,GAAAF,GACA,WAAAG,GAAAH,GAaA,QAAAjB,GAAA1wD,EAAAywD,EAAAsB,GAIA,IAHA,GAAA3zE,GAAA4hB,EAAA5hB,OACAnC,EAAA81E,EAAAtB,GAAAryE,GAAAqyE,GAAA,KAEAsB,EAAA91E,QAAAmC,GAAA,CACA,GAAA0V,GAAAkM,EAAA/jB,EACA,IAAA6X,MACA,MAAA7X,GAGA,SAUA,QAAA+1E,GAAA/wE,GACA,MAAAA,IAAA,gBAAAA,KAAA,EAWA,QAAAgxE,GAAAC,GACA,YAAAA,MAAA,OAAAA,GAAA,IAAAA,GAAA,KAAAA,GAAA,MAAAA,GAAA,MAAAA,GACAA,GAAA,aAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,OAAAA,GAAA,OAAAA,GAYA,QAAAC,GAAAnyD,EAAAoyD,GAMA,IALA,GAAAn2E,GAAA,GACAmC,EAAA4hB,EAAA5hB,OACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GACA4hB,EAAA/jB,KAAAm2E,IACApyD,EAAA/jB,GAAAq2E,EACAxzE,IAAAuzE,GAAAp2E,EAGA,OAAA6C,GAYA,QAAAyzE,GAAAvyD,EAAAwyD,GAOA,IANA,GAAAxY,GACA/9D,EAAA,GACAmC,EAAA4hB,EAAA5hB,OACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,GACA2L,EAAA4qE,IAAAvxE,EAAAhF,EAAA+jB,GAAA/e,CAEAhF,IAAA+9D,IAAApyD,IACAoyD,EAAApyD,EACA9I,IAAAuzE,GAAApxE,GAGA,MAAAnC,GAWA,QAAA2zE,GAAA1rB,GAIA,IAHA,GAAA9qD,GAAA,GACAmC,EAAA2oD,EAAA3oD,SAEAnC,EAAAmC,GAAA6zE,EAAAlrB,EAAAlyC,WAAA5Y,MACA,MAAAA,GAWA,QAAAy2E,GAAA3rB,GAGA,IAFA,GAAA9qD,GAAA8qD,EAAA3oD,OAEAnC,KAAAg2E,EAAAlrB,EAAAlyC,WAAA5Y,MACA,MAAAA,GAUA,QAAA02E,GAAAhB,GACA,MAAAiB,IAAAjB,GAwCA,QAAAkB,GAAAjxE,GAyMA,QAAAkxE,GAAA7xE,GACA,GAAA+wE,EAAA/wE,KAAAT,GAAAS,kBAAA8xE,IAAA,CACA,GAAA9xE,YAAA+xE,GACA,MAAA/xE,EAEA,IAAAwD,GAAAzI,KAAAiF,EAAA,cAAAwD,GAAAzI,KAAAiF,EAAA,eACA,MAAAgyE,IAAAhyE,GAGA,UAAA+xE,GAAA/xE,GAWA,QAAA+xE,GAAA/xE,EAAAiyE,EAAAxP,GACApoE,KAAA63E,YAAAlyE,EACA3F,KAAA83E,YAAA1P,MACApoE,KAAA+3E,YAAAH,EAoIA,QAAAH,GAAA9xE,GACA3F,KAAA63E,YAAAlyE,EACA3F,KAAA83E,YAAA,KACA93E,KAAAg4E,QAAA,EACAh4E,KAAAi4E,cAAA,EACAj4E,KAAAk4E,cAAA,EACAl4E,KAAAm4E,cAAA,KACAn4E,KAAAo4E,cAAAC,GACAr4E,KAAAs4E,UAAA,KAWA,QAAAC,KACA,GAAAnQ,GAAApoE,KAAA83E,YACAU,EAAAx4E,KAAAm4E,cACAM,EAAAz4E,KAAAs4E,UACA90E,EAAA,GAAAi0E,GAAAz3E,KAAA63E,YASA,OAPAr0E,GAAAs0E,YAAA1P,EAAAsQ,GAAAtQ,GAAA,KACA5kE,EAAAw0E,QAAAh4E,KAAAg4E,QACAx0E,EAAAy0E,cAAAj4E,KAAAi4E,cACAz0E,EAAA00E,aAAAl4E,KAAAk4E,aACA10E,EAAA20E,cAAAK,EAAAE,GAAAF,GAAA,KACAh1E,EAAA40E,cAAAp4E,KAAAo4E,cACA50E,EAAA80E,UAAAG,EAAAC,GAAAD,GAAA,KACAj1E,EAWA,QAAAm1E,KACA,GAAA34E,KAAAk4E,aAAA,CACA,GAAA10E,GAAA,GAAAi0E,GAAAz3E,KACAwD,GAAAw0E,QAAA,GACAx0E,EAAA00E,cAAA,MAEA10E,GAAAxD,KAAA8N,QACAtK,EAAAw0E,SAAA,EAEA,OAAAx0E,GAWA,QAAAo1E,KACA,GAAAl0D,GAAA1kB,KAAA63E,YAAAlyE,OACA,KAAAT,GAAAwf,GACA,MAAAm0D,IAAAn0D,EAAA1kB,KAAA83E,YAEA,IAAAgB,GAAA94E,KAAAg4E,QACAe,EAAA,EAAAD,EACArM,EAAAuM,GAAA,EAAAt0D,EAAA5hB,OAAA9C,KAAAs4E,WACAvjE,EAAA03D,EAAA13D,MACAge,EAAA05C,EAAA15C,IACAjwB,EAAAiwB,EAAAhe,EACAkkE,EAAAj5E,KAAAi4E,cACAiB,EAAAC,GAAAr2E,EAAA9C,KAAAo4E,eACAz3E,EAAAo4E,EAAAhmD,EAAAhe,EAAA,EACAyjE,EAAAx4E,KAAAm4E,cACAiB,EAAAZ,IAAA11E,OAAA,EACAi0E,EAAA,EACAvzE,IAEA61E,GACA,KAAAv2E,KAAAo2E,EAAAnC,GAAA,CACAp2E,GAAAm4E,CAKA,KAHA,GAAAQ,GAAA,GACA3zE,EAAA+e,EAAA/jB,KAEA24E,EAAAF,GAAA,CACA,GAAA15D,GAAA84D,EAAAc,GACApC,EAAAx3D,EAAAw3D,SACA5qE,EAAA4qE,EAAAvxE,EAAAhF,EAAA+jB,GACA3Z,EAAA2U,EAAA3U,IAEA,IAAAA,GAAAwuE,EACA5zE,EAAA2G,MACW,KAAAA,EAAA,CACX,GAAAvB,GAAAyuE,EACA,QAAAH,EAEA,MAAAA,IAIAJ,EACAA,IAEAz1E,EAAAuzE,KAAApxE,EAGA,MAAAnC,GAaA,QAAAi2E,MACAz5E,KAAA05E,YAYA,QAAAC,IAAAj1E,GACA,MAAA1E,MAAAoQ,IAAA1L,UAAA1E,MAAA05E,SAAAh1E,GAYA,QAAAk1E,IAAAl1E,GACA,mBAAAA,EAAAsG,EAAAhL,KAAA05E,SAAAh1E,GAYA,QAAAm1E,IAAAn1E,GACA,mBAAAA,GAAAyE,GAAAzI,KAAAV,KAAA05E,SAAAh1E,GAaA,QAAAo1E,IAAAp1E,EAAAiB,GAIA,MAHA,aAAAjB,IACA1E,KAAA05E,SAAAh1E,GAAAiB,GAEA3F,KAYA,QAAA+5E,IAAAljE,GACA,GAAA/T,GAAA+T,IAAA/T,OAAA,CAGA,KADA9C,KAAA0f,MAAmB8yC,KAAAwnB,GAAA,MAAAhoE,IAAA,GAAA2a,KACnB7pB,KACA9C,KAAAwT,KAAAqD,EAAA/T,IAaA,QAAAm3E,IAAAtwE,EAAAhE,GACA,GAAA+Z,GAAA/V,EAAA+V,KACAlc,EAAA,gBAAAmC,IAAAiY,GAAAjY,GAAA+Z,EAAA1N,IAAA5B,IAAAzK,GAAA+Z,EAAA8yC,KAAA7sD,EAEA,OAAAnC,GAAA,KAWA,QAAA02E,IAAAv0E,GACA,GAAA+Z,GAAA1f,KAAA0f,IACA,iBAAA/Z,IAAAiY,GAAAjY,GACA+Z,EAAA1N,IAAA3E,IAAA1H,GAEA+Z,EAAA8yC,KAAA7sD,IAAA,EAcA,QAAA+yE,IAAA7gE,EAAA6M,GACA,GAAA/jB,GAAA,GACAmC,EAAA+U,EAAA/U,MAGA,KADA4hB,MAAAnkB,GAAAuC,MACAnC,EAAAmC,GACA4hB,EAAA/jB,GAAAkX,EAAAlX,EAEA,OAAA+jB,GAYA,QAAAy1D,IAAAz1D,EAAAwyD,GAIA,IAHA,GAAAv2E,GAAA,GACAmC,EAAA4hB,EAAA5hB,SAEAnC,EAAAmC,GACAo0E,EAAAxyD,EAAA/jB,KAAA+jB,MAAA,IAIA,MAAAA,GAYA,QAAA01D,IAAA11D,EAAAwyD,GAGA,IAFA,GAAAp0E,GAAA4hB,EAAA5hB,OAEAA,KACAo0E,EAAAxyD,EAAA5hB,KAAA4hB,MAAA,IAIA,MAAAA,GAaA,QAAA21D,IAAA31D,EAAA7L,GAIA,IAHA,GAAAlY,GAAA,GACAmC,EAAA4hB,EAAA5hB,SAEAnC,EAAAmC,GACA,IAAA+V,EAAA6L,EAAA/jB,KAAA+jB,GACA,QAGA,UAYA,QAAA41D,IAAA51D,EAAA7L,GAMA,IALA,GAAAlY,GAAA,GACAmC,EAAA4hB,EAAA5hB,OACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EACAkY,GAAAlT,EAAAhF,EAAA+jB,KACAlhB,IAAAuzE,GAAApxE,GAGA,MAAAnC,GAYA,QAAA+2E,IAAA71D,EAAAwyD,GAKA,IAJA,GAAAv2E,GAAA,GACAmC,EAAA4hB,EAAA5hB,OACAU,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GACAU,EAAA7C,GAAAu2E,EAAAxyD,EAAA/jB,KAAA+jB,EAEA,OAAAlhB,GAUA,QAAAg3E,IAAA91D,GAKA,IAJA,GAAA/jB,GAAA,GACAmC,EAAA4hB,EAAA5hB,OACAU,EAAAi3E,KAEA95E,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EACAgF,GAAAnC,IACAA,EAAAmC,GAGA,MAAAnC,GAUA,QAAAk3E,IAAAh2D,GAKA,IAJA,GAAA/jB,GAAA,GACAmC,EAAA4hB,EAAA5hB,OACAU,EAAA60E,KAEA13E,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EACA6C,GAAAmC,IACAnC,EAAAmC,GAGA,MAAAnC,GAeA,QAAAm3E,IAAAj2D,EAAAwyD,EAAA0D,EAAAC,GACA,GAAAl6E,GAAA,GACAmC,EAAA4hB,EAAA5hB,MAKA,KAHA+3E,GAAA/3E,IACA83E,EAAAl2D,IAAA/jB,MAEAA,EAAAmC,GACA83E,EAAA1D,EAAA0D,EAAAl2D,EAAA/jB,KAAA+jB,EAEA,OAAAk2D,GAeA,QAAAE,IAAAp2D,EAAAwyD,EAAA0D,EAAAC,GACA,GAAA/3E,GAAA4hB,EAAA5hB,MAIA,KAHA+3E,GAAA/3E,IACA83E,EAAAl2D,IAAA5hB,IAEAA,KACA83E,EAAA1D,EAAA0D,EAAAl2D,EAAA5hB,KAAA4hB,EAEA,OAAAk2D,GAaA,QAAAG,IAAAr2D,EAAA7L,GAIA,IAHA,GAAAlY,GAAA,GACAmC,EAAA4hB,EAAA5hB,SAEAnC,EAAAmC,GACA,GAAA+V,EAAA6L,EAAA/jB,KAAA+jB,GACA,QAGA,UAWA,QAAAs2D,IAAAC,EAAAC,GACA,yBAAAD,GAAAC,EAAAD,EAgBA,QAAAE,IAAAF,EAAAC,EAAAx2E,EAAAyV,GACA,yBAAA8gE,IAAA9xE,GAAAzI,KAAAyZ,EAAAzV,GAEAu2E,EADAC,EAcA,QAAAE,IAAAjhE,EAAAtC,EAAAwjE,GACA,GAAAluE,GAAAoE,GAAAsG,EACA,KAAAwjE,EACA,MAAAC,IAAAzjE,EAAAsC,EAAAhN,EAKA,KAHA,GAAAxM,GAAA,GACAmC,EAAAqK,EAAArK,SAEAnC,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,GACAgF,EAAAwU,EAAAzV,GACAlB,EAAA63E,EAAA11E,EAAAkS,EAAAnT,KAAAyV,EAAAtC,IAEArU,UAAAmC,WACA,mBAAAA,IAAAjB,IAAAyV,MACAA,EAAAzV,GAAAlB,GAGA,MAAA2W,GAYA,QAAAohE,IAAAC,EAAAruE,GAOA,IANA,GAAAxM,GAAA,GACAmC,EAAA04E,EAAA14E,OACA24E,EAAAC,GAAA54E,GACA64E,EAAAxuE,EAAArK,OACAU,EAAAjD,GAAAo7E,KAEAh7E,EAAAg7E,GAAA,CACA,GAAAj3E,GAAAyI,EAAAxM,EACA86E,IACA/2E,EAAA8rB,WAAA9rB,GACAlB,EAAA7C,GAAAsiC,GAAAv+B,EAAA5B,GAAA04E,EAAA92E,GAAAsG,GAEAxH,EAAA7C,GAAA66E,EAAA92E,GAGA,MAAAlB,GAYA,QAAA83E,IAAAzjE,EAAAsC,EAAAhN,GACAA,IACAA,EAAAgN,EACAA,KAKA,KAHA,GAAAxZ,GAAA,GACAmC,EAAAqK,EAAArK,SAEAnC,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACAwZ,GAAAzV,GAAAmT,EAAAnT,GAEA,MAAAyV,GAYA,QAAAyhE,IAAAzhE,EAAA0hE,GAIA,IAHA,GAAAl7E,GAAA,GACAmC,EAAA+4E,EAAA/4E,SAEAnC,EAAAmC,GAAA,CACA,GAAA4B,GAAAm3E,EAAAl7E,EACAwZ,GAAAzV,GAAAo3E,GAAA3hE,EAAAzV,GAAAq3E,EAAA5hE,GAEA,MAAAA,GAaA,QAAA6hE,IAAAnzE,EAAAo4B,EAAAg7C,GACA,GAAAlxE,SAAAlC,EACA,mBAAAkC,EACA,mBAAAk2B,IAAAi7C,GAAArzE,GACAszE,GAAAtzE,EAAAo4B,EAAAg7C,GACApzE,EAEA,MAAAA,EACAE,GAEA,UAAAgC,EACAqxE,GAAAvzE,GAEA,mBAAAo4B,GACAo7C,GAAAxzE,EAAA,IACAyzE,GAAAzzE,EAAA,GAAAo4B,GAiBA,QAAAs7C,IAAA52E,EAAA62E,EAAAnB,EAAA32E,EAAAyV,EAAAzC,EAAAC,GACA,GAAAnU,EAIA,IAHA63E,IACA73E,EAAA2W,EAAAkhE,EAAA11E,EAAAjB,EAAAyV,GAAAkhE,EAAA11E,IAEA,mBAAAnC,GACA,MAAAA,EAEA,KAAAoa,GAAAjY,GACA,MAAAA,EAEA,IAAA81E,GAAAv2E,GAAAS,EACA,IAAA81E,GAEA,GADAj4E,EAAAi5E,GAAA92E,IACA62E,EACA,MAAA9D,IAAA/yE,EAAAnC,OAEO,CACP,GAAAkf,GAAAg6D,GAAAh8E,KAAAiF,GACAg3E,EAAAj6D,GAAAk6D,CAEA,IAAAl6D,GAAAm6D,IAAAn6D,GAAAo6D,KAAAH,GAAAxiE,GAMA,MAAA4iE,IAAAr6D,GACAs6D,GAAAr3E,EAAA+c,EAAA85D,GACAriE,EAAAxU,IANA,IADAnC,EAAAy5E,GAAAN,KAA8Ch3E,IAC9C62E,EACA,MAAAlB,IAAA31E,EAAAnC,EAAA+N,GAAA5L,IASA+R,UACAC,SAGA,KADA,GAAA7U,GAAA4U,EAAA5U,OACAA,KACA,GAAA4U,EAAA5U,IAAA6C,EACA,MAAAgS,GAAA7U,EAWA,OAPA4U,GAAAlE,KAAA7N,GACAgS,EAAAnE,KAAAhQ,IAGAi4E,EAAAtB,GAAA+C,IAAAv3E,EAAA,SAAAw3E,EAAAz4E,GACAlB,EAAAkB,GAAA63E,GAAAY,EAAAX,EAAAnB,EAAA32E,EAAAiB,EAAA+R,EAAAC,KAEAnU,EAiCA,QAAA45E,IAAAv0E,EAAAw0E,EAAAv9E,EAAAq1E,GACA,qBAAAtsE,GACA,SAAA1C,IAAAm3E,EAEA,OAAAz9D,IAAA,WAAoChX,EAAA5H,MAAA+J,EAAAuyE,GAAAz9E,EAAAq1E,KAAqDkI,GAYzF,QAAAG,IAAA94D,EAAA7N,GACA,GAAA/T,GAAA4hB,IAAA5hB,OAAA,EACAU,IAEA,KAAAV,EACA,MAAAU,EAEA,IAAA7C,GAAA,GACAgQ,EAAA8sE,KACAC,EAAA/sE,GAAAukE,EACAvrE,EAAA+zE,GAAA7mE,EAAA/T,QAAA,KAAA66E,GAAA9mE,GACA+mE,EAAA/mE,EAAA/T,MAEA6G,KACAgH,EAAAspE,GACAyD,GAAA,EACA7mE,EAAAlN,EAEA0vE,GACA,OAAA14E,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EAEA,IAAA+8E,GAAA/3E,MAAA,CAEA,IADA,GAAAk4E,GAAAD,EACAC,KACA,GAAAhnE,EAAAgnE,KAAAl4E,EACA,QAAA0zE,EAGA71E,GAAAgQ,KAAA7N,OAEAgL,GAAAkG,EAAAlR,GAAA,GACAnC,EAAAgQ,KAAA7N,GAGA,MAAAnC,GAYA,QAAAs6E,IAAAtC,EAAAtE,GACA,GAAAp0E,GAAA04E,IAAA14E,OAAA,CACA,KAAA44E,GAAA54E,GACA,MAAAo6E,IAAA1B,EAAAtE,EAKA,KAHA,GAAAv2E,GAAA,GACA6pB,EAAAzG,GAAAy3D,KAEA76E,EAAAmC,GACAo0E,EAAA1sD,EAAA7pB,KAAA6pB,MAAA,IAIA,MAAAgxD,GAYA,QAAAuC,IAAAvC,EAAAtE,GACA,GAAAp0E,GAAA04E,IAAA14E,OAAA,CACA,KAAA44E,GAAA54E,GACA,MAAAk7E,IAAAxC,EAAAtE,EAGA,KADA,GAAA1sD,GAAAzG,GAAAy3D,GACA14E,KACAo0E,EAAA1sD,EAAA1nB,KAAA0nB,MAAA,IAIA,MAAAgxD,GAaA,QAAAyC,IAAAzC,EAAA3iE,GACA,GAAArV,IAAA,CAKA,OAJAs6E,IAAAtC,EAAA,SAAA71E,EAAAhF,EAAA66E,GAEA,MADAh4E,KAAAqV,EAAAlT,EAAAhF,EAAA66E,KAGAh4E,EAaA,QAAA06E,IAAAx5D,EAAA/e,EAAAoP,EAAAge,GACA,GAAAjwB,GAAA4hB,EAAA5hB,MAaA,KAXAiS,EAAA,MAAAA,EAAA,GAAAA,GAAA,EACA,EAAAA,IACAA,KAAAjS,EAAA,EAAAA,EAAAiS,GAEAge,EAAA,mBAAAA,MAAAjwB,KAAAiwB,GAAA,EACA,EAAAA,IACAA,GAAAjwB,GAEAA,EAAAiS,EAAAge,EAAA,EAAAA,IAAA,EACAhe,KAAA,EAEAjS,EAAAiS,GACA2P,EAAA3P,KAAApP,CAEA,OAAA+e,GAYA,QAAAy5D,IAAA3C,EAAA3iE,GACA,GAAArV,KAMA,OALAs6E,IAAAtC,EAAA,SAAA71E,EAAAhF,EAAA66E,GACA3iE,EAAAlT,EAAAhF,EAAA66E,IACAh4E,EAAAgQ,KAAA7N,KAGAnC,EAgBA,QAAA46E,IAAA5C,EAAA3iE,EAAAwlE,EAAAC,GACA,GAAA96E,EAOA,OANA66E,GAAA7C,EAAA,SAAA71E,EAAAjB,EAAA82E,GACA,MAAA3iE,GAAAlT,EAAAjB,EAAA82E,IACAh4E,EAAA86E,EAAA55E,EAAAiB,GACA,GAFA,SAKAnC,EAcA,QAAA+6E,IAAA75D,EAAA83D,EAAAgC,EAAArJ,GAMA,IALA,GAAAx0E,IAAAw0E,GAAA,KACAryE,EAAA4hB,EAAA5hB,OACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EAEA,IAAA+1E,EAAA/wE,IAAA+1E,GAAA/1E,EAAA7C,UAAAoC,GAAAS,IAAA84E,GAAA94E,IAAA,CACA62E,IAEA72E,EAAA44E,GAAA54E,EAAA62E,EAAAgC,GAEA,IAAAE,GAAA,GACAC,EAAAh5E,EAAA7C,MAGA,KADAU,EAAAV,QAAA67E,IACAD,EAAAC,GACAn7E,IAAAuzE,GAAApxE,EAAA+4E,OAESF,KACTh7E,IAAAuzE,GAAApxE,GAGA,MAAAnC,GAeA,QAAAo7E,IAAAzkE,EAAA+8D,EAAA2H,GAMA,IALA,GAAAl+E,GAAA,GACA6pB,EAAAzG,GAAA5J,GACAhN,EAAA0xE,EAAA1kE,GACArX,EAAAqK,EAAArK,SAEAnC,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACA,IAAAu2E,EAAA1sD,EAAA9lB,KAAA8lB,MAAA,EACA,MAGA,MAAArQ,GAaA,QAAA2kE,IAAA3kE,EAAA+8D,EAAA2H,GAKA,IAJA,GAAAr0D,GAAAzG,GAAA5J,GACAhN,EAAA0xE,EAAA1kE,GACArX,EAAAqK,EAAArK,OAEAA,KAAA,CACA,GAAA4B,GAAAyI,EAAArK,EACA,IAAAo0E,EAAA1sD,EAAA9lB,KAAA8lB,MAAA,EACA,MAGA,MAAArQ,GAYA,QAAA4kE,IAAA5kE,EAAA+8D,GACA,MAAA0H,IAAAzkE,EAAA+8D,EAAA3tE,IAYA,QAAA2zE,IAAA/iE,EAAA+8D,GACA,MAAA0H,IAAAzkE,EAAA+8D,EAAA3lE,IAYA,QAAAysE,IAAA7jE,EAAA+8D,GACA,MAAA4H,IAAA3kE,EAAA+8D,EAAA3lE,IAYA,QAAAytE,IAAA7kE,EAAAhN,GAMA,IALA,GAAAxM,GAAA,GACAmC,EAAAqK,EAAArK,OACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACA6hB,IAAArI,EAAAzV,MACAlB,IAAAuzE,GAAAryE,GAGA,MAAAlB,GAcA,QAAAy7E,IAAAzD,EAAA7uE,EAAA7M,GACA,GAAAa,GAAA,GACAg8E,EAAA,kBAAAhwE,GACA7J,EAAA04E,IAAA14E,OAAA,EACAU,EAAAk4E,GAAA54E,GAAAvC,GAAAuC,KAMA,OAJAg7E,IAAAtC,EAAA,SAAA71E,GACA,GAAAkD,GAAA8zE,EAAAhwE,EAAA,MAAAhH,KAAAgH,EACAnJ,KAAA7C,GAAAkI,IAAA5H,MAAA0E,EAAA7F,GAAAkL,IAEAxH,EAgBA,QAAA07E,IAAAv5E,EAAA6S,EAAA6iE,EAAA8D,EAAAznE,EAAAC,GAEA,GAAAhS,IAAA6S,EAEA,WAAA7S,GAAA,EAAAA,GAAA,EAAA6S,CAEA,IAAA4mE,SAAAz5E,GACA05E,QAAA7mE,EAGA,mBAAA4mE,GAAA,UAAAA,GAAA,YAAAC,GAAA,UAAAA,GACA,MAAA15E,GAAA,MAAA6S,EAEA7S,OAAA6S,MAEA8mE,GAAA35E,EAAA6S,EAAA0mE,GAAA7D,EAAA8D,EAAAznE,EAAAC,GAkBA,QAAA2nE,IAAAnlE,EAAA3B,EAAA+mE,EAAAlE,EAAA8D,EAAAznE,EAAAC,GACA,GAAA6nE,GAAAt6E,GAAAiV,GACAslE,EAAAv6E,GAAAsT,GACAknE,EAAAC,EACAC,EAAAD,CAEAH,KACAE,EAAAhD,GAAAh8E,KAAAyZ,GACAulE,GAAA5C,EACA4C,EAAA7C,GACS6C,GAAA7C,KACT2C,EAAAK,GAAA1lE,KAGAslE,IACAG,EAAAlD,GAAAh8E,KAAA8X,GACAonE,GAAA9C,EACA8C,EAAA/C,GACS+C,GAAA/C,KACT4C,EAAAI,GAAArnE,IAGA,IAAAsnE,GAAAJ,GAAA7C,GACAkD,EAAAH,GAAA/C,GACAmD,EAAAN,GAAAE,CAEA,IAAAI,IAAAR,IAAAM,EACA,MAAAG,IAAA9lE,EAAA3B,EAAAknE,EAEA,IAAAQ,GAAAJ,GAAA32E,GAAAzI,KAAAyZ,EAAA,eACAgmE,EAAAJ,GAAA52E,GAAAzI,KAAA8X,EAAA,cAEA,IAAA0nE,GAAAC,EACA,MAAAZ,GAAAW,EAAA/lE,EAAAxU,QAAAwU,EAAAgmE,EAAA3nE,EAAA7S,QAAA6S,EAAA6iE,EAAA8D,EAAAznE,EAAAC,EAEA,KAAAqoE,EACA,QAIAtoE,WACAC,SAGA,KADA,GAAA7U,GAAA4U,EAAA5U,OACAA,KACA,GAAA4U,EAAA5U,IAAAqX,EACA,MAAAxC,GAAA7U,IAAA0V,CAIAd,GAAAlE,KAAA2G,GACAxC,EAAAnE,KAAAgF,EAEA,IAAAhV,IAAAg8E,EAAAY,GAAAC,IAAAlmE,EAAA3B,EAAA+mE,EAAAlE,EAAA8D,EAAAznE,EAAAC,EAKA,OAHAD,GAAAW,MACAV,EAAAU,MAEA7U,EAeA,QAAA88E,IAAAnmE,EAAAhN,EAAA0J,EAAA0pE,EAAAlF,GACA,GAAAv4E,GAAAqK,EAAArK,MACA,UAAAqX,EACA,OAAArX,CAKA,KAHA,GAAAnC,GAAA,GACA6/E,GAAAnF,IAEA16E,EAAAmC,GACA,GAAA09E,GAAAD,EAAA5/E,GACAkW,EAAAlW,KAAAwZ,EAAAhN,EAAAxM,KACAwI,GAAAzI,KAAAyZ,EAAAhN,EAAAxM,IAEA,QAIA,KADAA,EAAA,KACAA,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACA,IAAA6/E,GAAAD,EAAA5/E,GACA,GAAA6C,GAAA2F,GAAAzI,KAAAyZ,EAAAzV,OACS,CACT,GAAA+7E,GAAAtmE,EAAAzV,GACAg8E,EAAA7pE,EAAAlW,EAEA6C,GAAA63E,IAAAoF,EAAAC,EAAAh8E,GAAAsG,EACA,mBAAAxH,KACAA,EAAA07E,GAAAwB,EAAAD,EAAApF,GAAA,IAGA,IAAA73E,EACA,SAGA,SAYA,QAAAm9E,IAAAnF,EAAAtE,GACA,GAAA1zE,KAIA,OAHAs6E,IAAAtC,EAAA,SAAA71E,EAAAjB,EAAA82E,GACAh4E,EAAAgQ,KAAA0jE,EAAAvxE,EAAAjB,EAAA82E,MAEAh4E,EAUA,QAAA44E,IAAAvkE,GACA,GAAA1K,GAAAoE,GAAAsG,GACA/U,EAAAqK,EAAArK,MAEA,OAAAA,EAAA,CACA,GAAA4B,GAAAyI,EAAA,GACAxH,EAAAkS,EAAAnT,EAEA,IAAAk8E,GAAAj7E,GACA,gBAAAwU,GACA,aAAAA,GAAAxU,IAAAwU,EAAAzV,IAAAyE,GAAAzI,KAAAyZ,EAAAzV,IAOA,IAHA,GAAAmS,GAAAtW,GAAAuC,GACAy9E,EAAAhgF,GAAAuC,GAEAA,KACA6C,EAAAkS,EAAA1K,EAAArK,IACA+T,EAAA/T,GAAA6C,EACA46E,EAAAz9E,GAAA89E,GAAAj7E,EAEA,iBAAAwU,GACA,MAAAmmE,IAAAnmE,EAAAhN,EAAA0J,EAAA0pE,IAaA,QAAAjE,IAAA53E,EAAAiB,GACA,MAAAi7E,IAAAj7E,GACA,SAAAwU,GACA,aAAAA,KAAAzV,KAAAiB,GAGA,SAAAwU,GACA,aAAAA,GAAA+kE,GAAAv5E,EAAAwU,EAAAzV,GAAA,UAgBA,QAAAm8E,IAAA1mE,EAAAtC,EAAAwjE,EAAA3jE,EAAAC,GACA,GAAAmpE,GAAApF,GAAA7jE,EAAA/U,UAAAoC,GAAA2S,IAAAgoE,GAAAhoE,GAoBA,QAlBAipE,EAAA3G,GAAA+C,IAAArlE,EAAA,SAAA6oE,EAAAh8E,EAAAmT,GACA,GAAA6+D,EAAAgK,GAGA,MAFAhpE,WACAC,UACAopE,GAAA5mE,EAAAtC,EAAAnT,EAAAm8E,GAAAxF,EAAA3jE,EAAAC,EAEA,IAAAhS,GAAAwU,EAAAzV,GACAlB,EAAA63E,IAAA11E,EAAA+6E,EAAAh8E,EAAAyV,EAAAtC,GAAA7M,EACA0yE,EAAA,mBAAAl6E,EAEAk6E,KACAl6E,EAAAk9E,IAEAI,GAAA,mBAAAt9E,KACAk6E,IAAAl6E,UAAAmC,WACAwU,EAAAzV,GAAAlB,KAGA2W,EAkBA,QAAA4mE,IAAA5mE,EAAAtC,EAAAnT,EAAAs8E,EAAA3F,EAAA3jE,EAAAC,GAIA,IAHA,GAAA7U,GAAA4U,EAAA5U,OACA49E,EAAA7oE,EAAAnT,GAEA5B,KACA,GAAA4U,EAAA5U,IAAA49E,EAEA,YADAvmE,EAAAzV,GAAAiT,EAAA7U,GAIA,IAAA6C,GAAAwU,EAAAzV,GACAlB,EAAA63E,IAAA11E,EAAA+6E,EAAAh8E,EAAAyV,EAAAtC,GAAA7M,EACA0yE,EAAA,mBAAAl6E,EAEAk6E,KACAl6E,EAAAk9E,EACAhF,GAAAgF,EAAA59E,UAAAoC,GAAAw7E,IAAAb,GAAAa,IACAl9E,EAAA0B,GAAAS,GACAA,EACAA,EAAA+yE,GAAA/yE,MAEAs7E,GAAAP,IAAAjC,GAAAiC,GACAl9E,EAAAi7E,GAAA94E,GACAu7E,GAAAv7E,GACAs7E,GAAAt7E,QAGA+3E,GAAA,GAKAhmE,EAAAlE,KAAAktE,GACA/oE,EAAAnE,KAAAhQ,GAEAk6E,EAEAvjE,EAAAzV,GAAAs8E,EAAAx9E,EAAAk9E,EAAArF,EAAA3jE,EAAAC,IACOnU,UAAAmC,WACPwU,EAAAzV,GAAAlB,GAWA,QAAA64E,IAAA33E,GACA,gBAAAyV,GACA,aAAAA,EAAAnP,EAAAmP,EAAAzV,IAaA,QAAAy8E,IAAAz8D,EAAA08D,GACA,GAAAt+E,GAAAs+E,EAAAt+E,OACAU,EAAA+3E,GAAA72D,EAAA08D,EAGA,KADAA,EAAAhsE,KAAA2/D,GACAjyE,KAAA,CACA,GAAAnC,GAAA6vB,WAAA4wD,EAAAt+E,GACA,IAAAnC,GAAA0gF,GAAAp+C,GAAAtiC,GAAA,CACA,GAAA0gF,GAAA1gF,CACAG,IAAAJ,KAAAgkB,EAAA/jB,EAAA,IAGA,MAAA6C,GAYA,QAAA89E,IAAAx7E,EAAAd,GACA,MAAAc,GAAA4O,GAAA6sE,MAAAv8E,EAAAc,EAAA,IAiBA,QAAA07E,IAAAhG,EAAAtE,EAAA0D,EAAA6G,EAAApD,GAMA,MALAA,GAAA7C,EAAA,SAAA71E,EAAAhF,EAAA66E,GACAZ,EAAA6G,GACAA,GAAA,EAAA97E,GACAuxE,EAAA0D,EAAAj1E,EAAAhF,EAAA66E,KAEAZ,EAyBA,QAAA2C,IAAA74D,EAAA3P,EAAAge,GACA,GAAApyB,GAAA,GACAmC,EAAA4hB,EAAA5hB,MAEAiS,GAAA,MAAAA,EAAA,GAAAA,GAAA,EACA,EAAAA,IACAA,KAAAjS,EAAA,EAAAA,EAAAiS,GAEAge,EAAA,mBAAAA,MAAAjwB,KAAAiwB,GAAA,EACA,EAAAA,IACAA,GAAAjwB,GAEAA,EAAAiS,EAAAge,EAAA,EAAAA,EAAAhe,IAAA,EACAA,KAAA,CAGA,KADA,GAAAvR,GAAAjD,GAAAuC,KACAnC,EAAAmC,GACAU,EAAA7C,GAAA+jB,EAAA/jB,EAAAoU,EAEA,OAAAvR,GAaA,QAAAk+E,IAAAlG,EAAA3iE,GACA,GAAArV,EAMA,OAJAs6E,IAAAtC,EAAA,SAAA71E,EAAAhF,EAAA66E,GAEA,MADAh4E,GAAAqV,EAAAlT,EAAAhF,EAAA66E,IACAh4E,MAEAA,EAYA,QAAAm+E,IAAAj9D,EAAAwyD,GACA,GAAAv2E,GAAA,GACAgQ,EAAA8sE,KACA36E,EAAA4hB,EAAA5hB,OACA46E,EAAA/sE,GAAAukE,EACA0M,EAAAlE,GAAA56E,GAAA,IACA47D,EAAAkjB,GAAAjE,KACAn6E,IAEAk7D,IACA/tD,EAAAspE,GACAyD,GAAA,IAEAkE,GAAA,EACAljB,EAAAwY,KAAA1zE,EAEA61E,GACA,OAAA14E,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,GACA2L,EAAA4qE,IAAAvxE,EAAAhF,EAAA+jB,GAAA/e,CAEA,IAAA+3E,GAAA/3E,MAAA,CAEA,IADA,GAAAk8E,GAAAnjB,EAAA57D,OACA++E,KACA,GAAAnjB,EAAAmjB,KAAAv1E,EACA,QAAA+sE,EAGAnC,IACAxY,EAAAlrD,KAAAlH,GAEA9I,EAAAgQ,KAAA7N,OAEAgL,GAAA+tD,EAAApyD,GAAA,KACA4qE,GAAA0K,IACAljB,EAAAlrD,KAAAlH,GAEA9I,EAAAgQ,KAAA7N,IAGA,MAAAnC,GAaA,QAAAs+E,IAAA3nE,EAAAhN,GAKA,IAJA,GAAAxM,GAAA,GACAmC,EAAAqK,EAAArK,OACAU,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GACAU,EAAA7C,GAAAwZ,EAAAhN,EAAAxM,GAEA,OAAA6C,GAaA,QAAAq1E,IAAAlzE,EAAAyiE,GACA,GAAA5kE,GAAAmC,CACAnC,aAAAi0E,KACAj0E,IAAAmC,QAKA,KAHA,GAAAhF,GAAA,GACAmC,EAAAslE,EAAAtlE,SAEAnC,EAAAmC,GAAA,CACA,GAAAhD,IAAA0D,GACAoqC,EAAAw6B,EAAAznE,EAEA6S,IAAAvS,MAAAnB,EAAA8tC,EAAA9tC,MACA0D,EAAAoqC,EAAA/kC,KAAA5H,MAAA2sC,EAAA3M,QAAAnhC,GAEA,MAAA0D,GAeA,QAAAu+E,IAAAr9D,EAAA/e,EAAAq8E,GACA,GAAAC,GAAA,EACAC,EAAAx9D,IAAA5hB,OAAAm/E,CAEA,oBAAAt8E,WAAAw8E,IAAAD,EAAA,CACA,KAAAA,EAAAD,GAAA,CACA,GAAAhS,GAAAgS,EAAAC,IAAA,EACA51E,EAAAoY,EAAAurD,IAEA+R,EAAAr8E,GAAA2G,EAAA3G,EAAA2G,GACA21E,EAAAhS,EAAA,EAEAiS,EAAAjS,EAGA,MAAAiS,GAEA,MAAAE,IAAA19D,EAAA/e,EAAAoD,GAAAi5E,GAiBA,QAAAI,IAAA19D,EAAA/e,EAAAuxE,EAAA8K,GACAr8E,EAAAuxE,EAAAvxE,EAOA,KALA,GAAAs8E,GAAA,EACAC,EAAAx9D,IAAA5hB,OAAA,EACAu/E,EAAA18E,MACA28E,EAAA,mBAAA38E,GAEAu8E,EAAAD,GAAA,CACA,GAAAhS,GAAAv7D,IAAAutE,EAAAC,GAAA,GACA51E,EAAA4qE,EAAAxyD,EAAAurD,IACAsS,EAAAj2E,KAEA,IAAA+1E,EACA,GAAAG,GAAAD,GAAAP,MAEAQ,GADSF,EACTC,IAAAP,GAAA,mBAAA11E,IAEA01E,EAAAr8E,GAAA2G,EAAA3G,EAAA2G,CAEAk2E,GACAP,EAAAhS,EAAA,EAEAiS,EAAAjS,EAGA,MAAAkJ,IAAA+I,EAAAO,IAaA,QAAAtG,IAAAtzE,EAAAo4B,EAAAg7C,GACA,qBAAApzE,GACA,MAAAE,GAEA,uBAAAk4B,GACA,MAAAp4B,EAEA,QAAAozE,GACA,uBAAAt2E,GACA,MAAAkD,GAAAnI,KAAAugC,EAAAt7B,GAEA,wBAAAA,EAAAhF,EAAA66E,GACA,MAAA3yE,GAAAnI,KAAAugC,EAAAt7B,EAAAhF,EAAA66E,GAEA,wBAAAZ,EAAAj1E,EAAAhF,EAAA66E,GACA,MAAA3yE,GAAAnI,KAAAugC,EAAA25C,EAAAj1E,EAAAhF,EAAA66E,GAEA,wBAAA71E,EAAA6S,EAAA9T,EAAAyV,EAAAtC,GACA,MAAAhP,GAAAnI,KAAAugC,EAAAt7B,EAAA6S,EAAA9T,EAAAyV,EAAAtC,IAGA,kBACA,MAAAhP,GAAA5H,MAAAggC,EAAAlhC,YAWA,QAAA2iF,IAAAh5B,GACA,MAAAi5B,IAAAjiF,KAAAgpD,EAAA,GAgCA,QAAAk5B,IAAA9iF,EAAA+iF,EAAAC,GAQA,IAPA,GAAAC,GAAAD,EAAAhgF,OACAkgF,EAAA,GACAC,EAAAC,GAAApjF,EAAAgD,OAAAigF,EAAA,GACAI,EAAA,GACAC,EAAAP,EAAA//E,OACAU,EAAAjD,GAAA0iF,EAAAG,KAEAD,EAAAC,GACA5/E,EAAA2/E,GAAAN,EAAAM,EAEA,QAAAH,EAAAD,GACAv/E,EAAAs/E,EAAAE,IAAAljF,EAAAkjF,EAEA,MAAAC,KACAz/E,EAAA2/E,KAAArjF,EAAAkjF,IAEA,OAAAx/E,GAaA,QAAA6/E,IAAAvjF,EAAA+iF,EAAAC,GASA,IARA,GAAAQ,GAAA,GACAP,EAAAD,EAAAhgF,OACAkgF,EAAA,GACAC,EAAAC,GAAApjF,EAAAgD,OAAAigF,EAAA,GACAQ,EAAA,GACAC,EAAAX,EAAA//E,OACAU,EAAAjD,GAAA0iF,EAAAO,KAEAR,EAAAC,GACAz/E,EAAAw/E,GAAAljF,EAAAkjF,EAGA,KADA,GAAApiB,GAAAoiB,IACAO,EAAAC,GACAhgF,EAAAo9D,EAAA2iB,GAAAV,EAAAU,EAEA,QAAAD,EAAAP,GACAv/E,EAAAo9D,EAAAkiB,EAAAQ,IAAAxjF,EAAAkjF,IAEA,OAAAx/E,GAaA,QAAAigF,IAAA77D,EAAAihD,GACA,gBAAA2S,EAAAtE,EAAAj2C,GACA,GAAAz9B,GAAAqlE,QAGA,IAFAqO,EAAAwM,GAAAxM,EAAAj2C,EAAA,GAEA/7B,GAAAs2E,GAIA,IAHA,GAAA76E,GAAA,GACAmC,EAAA04E,EAAA14E,SAEAnC,EAAAmC,GAAA,CACA,GAAA6C,GAAA61E,EAAA76E,EACAinB,GAAApkB,EAAAmC,EAAAuxE,EAAAvxE,EAAAhF,EAAA66E,UAGAsC,IAAAtC,EAAA,SAAA71E,EAAAjB,EAAA82E,GACA5zD,EAAApkB,EAAAmC,EAAAuxE,EAAAvxE,EAAAjB,EAAA82E,OAGA,OAAAh4E,IAYA,QAAAmgF,IAAAC,GACA,kBACA,GAAA9gF,GAAA/C,UAAA+C,OACAqX,EAAApa,UAAA,EAEA,MAAA+C,GAAA,MAAAqX,EACA,MAAAA,EAMA,IAJArX,EAAA,GAAA+gF,GAAA9jF,UAAA,GAAAA,UAAA,GAAAA,UAAA,MACA+C,EAAA,GAGAA,EAAA,qBAAA/C,WAAA+C,EAAA,GACA,GAAAu4E,GAAAc,GAAAp8E,YAAA+C,EAAA,GAAA/C,UAAA+C,KAAA,OACSA,GAAA,qBAAA/C,WAAA+C,EAAA,KACTu4E,EAAAt7E,YAAA+C,GAGA,KADA,GAAAnC,GAAA,IACAA,EAAAmC,GAAA,CACA,GAAA+U,GAAA9X,UAAAY,EACAkX,IACA+rE,EAAAzpE,EAAAtC,EAAAwjE,GAGA,MAAAlhE,IAaA,QAAA2pE,IAAAj7E,EAAAo4B,GAGA,QAAAhqB,KACA,OAAAjX,eAAAiX,GAAA7F,EAAAvI,GAAA5H,MAAAggC,EAAAlhC,WAHA,GAAAqR,GAAA2yE,GAAAl7E,EAKA,OAAAoO,GAsBA,QAAA+sE,IAAA55C,GACA,gBAAAqhB,GAMA,IALA,GAAA9qD,GAAA,GACA+jB,EAAAu/D,GAAAC,GAAAz4B,IACA3oD,EAAA4hB,EAAA5hB,OACAU,EAAA,KAEA7C,EAAAmC,GACAU,EAAA4mC,EAAA5mC,EAAAkhB,EAAA/jB,KAEA,OAAA6C,IAYA,QAAAugF,IAAA3yE,GACA,kBACA,GAAA+yE,GAAAC,GAAAhzE,EAAA5Q,WACAgD,EAAA4N,EAAAnQ,MAAAkjF,EAAApkF,UAIA,OAAA6d,IAAApa,KAAA2gF,GAaA,QAAAE,IAAAC,EAAAC,GACA,gBAAA/I,EAAAtE,EAAAj2C,GACAA,GAAA4iD,GAAArI,EAAAtE,EAAAj2C,KACAi2C,EAAA,KAEA,IAAAruE,GAAA66E,KACAc,EAAA,MAAAtN,CAMA,IAJAruE,IAAAmzE,IAAAwI,IACAA,GAAA,EACAtN,EAAAruE,EAAAquE,EAAAj2C,EAAA,IAEAujD,EAAA,CACA,GAAA/I,GAAAv2E,GAAAs2E,EACA,IAAAC,IAAAxoB,GAAAuoB,GAGA,MAAA8I,GAAA7I,EAAAD,EAAAiJ,GAAAjJ,GAFAtE,GAAA1B,EAKA,MAAAkP,IAAAlJ,EAAAtE,EAAAqN,IAqBA,QAAAI,IAAA97E,EAAA+7E,EAAA3jD,EAAA4hD,EAAAC,EAAA+B,EAAAC,EAAAC,EAAAC,EAAAv9E,GAWA,QAAAwP,KAOA,IAJA,GAAAnU,GAAA/C,UAAA+C,OACAnC,EAAAmC,EACAhD,EAAAS,GAAAuC,GAEAnC,KACAb,EAAAa,GAAAZ,UAAAY,EAQA,IANAkiF,IACA/iF,EAAA8iF,GAAA9iF,EAAA+iF,EAAAC,IAEA+B,IACA/kF,EAAAujF,GAAAvjF,EAAA+kF,EAAAC,IAEAG,GAAAC,EAAA,CACA,GAAApO,GAAA7/D,EAAA6/D,YACAqO,EAAAtO,EAAA/2E,EAAAg3E,EAGA,IADAh0E,GAAAqiF,EAAAriF,OACA2E,EAAA3E,EAAA,CACA,GAAAsiF,GAAAL,EAAArM,GAAAqM,GAAA,KACAM,EAAAnC,GAAAz7E,EAAA3E,EAAA,GACAwiF,EAAAL,EAAAE,EAAA,KACAI,EAAAN,EAAA,KAAAE,EACAK,EAAAP,EAAAnlF,EAAA,KACA2lF,EAAAR,EAAA,KAAAnlF,CAEA8kF,IAAAK,EAAAS,EAAAC,EACAf,KAAAK,EAAAU,EAAAD,GAEAE,IACAhB,KAAA7I,EAAA8J,GAEA,IAAAriF,GAAAmhF,GAAA97E,EAAA+7E,EAAA3jD,EAAAukD,EAAAF,EAAAG,EAAAF,EAAAH,EAAAJ,EAAAK,EAEA,OADA7hF,GAAAszE,cACAtzE,GAGA,GAAA2gF,GAAA2B,EAAA7kD,EAAAjhC,IAUA,OATA+lF,KACAl9E,EAAAs7E,EAAAz/E,IAEAqgF,IACAjlF,EAAAkmF,GAAAlmF,EAAAilF,IAEAkB,GAAAjB,EAAAllF,EAAAgD,SACAhD,EAAAgD,OAAAkiF,IAEAhlF,eAAAiX,GAAA7F,GAAA2yE,GAAAl7E,MAAA5H,MAAAkjF,EAAArkF,GA5DA,GAAAmmF,GAAArB,EAAAsB,EACAJ,EAAAlB,EAAA7I,EACAgK,EAAAnB,EAAAiB,EACAZ,EAAAL,EAAAuB,EACAP,EAAAhB,EAAAwB,EACAlB,EAAAN,EAAAyB,EAEAj1E,GAAA20E,GAAAhC,GAAAl7E,GACAnE,EAAAmE,CAsDA,OAAAoO,GAcA,QAAAqvE,IAAA76B,EAAA3oD,EAAA4yE,GACA,GAAA6Q,GAAA96B,EAAA3oD,MAGA,IAFAA,KAEAyjF,GAAAzjF,IAAA0jF,GAAA1jF,GACA,QAEA,IAAA2jF,GAAA3jF,EAAAyjF,CAEA,OADA7Q,GAAA,MAAAA,EAAA,IAAAA,EAAA,GACA/5D,GAAA+5D,EAAA/gE,GAAA8xE,EAAA/Q,EAAA5yE,SAAArC,MAAA,EAAAgmF,GAeA,QAAAC,IAAA79E,EAAA+7E,EAAA3jD,EAAA4hD,GAIA,QAAA5rE,KASA,IANA,GAAA+rE,GAAA,GACAC,EAAAljF,UAAA+C,OACAqgF,EAAA,GACAC,EAAAP,EAAA//E,OACAhD,EAAAS,GAAA0iF,EAAAG,KAEAD,EAAAC,GACAtjF,EAAAqjF,GAAAN,EAAAM,EAEA,MAAAF,KACAnjF,EAAAqjF,KAAApjF,YAAAijF,EAEA,QAAAhjF,eAAAiX,GAAA7F,EAAAvI,GAAA5H,MAAA6kF,EAAA7kD,EAAAjhC,KAAAF,GAlBA,GAAAgmF,GAAAlB,EAAA7I,EACA3qE,EAAA2yE,GAAAl7E,EAmBA,OAAAoO,GA4BA,QAAA6kE,IAAAjzE,EAAA+7E,EAAA3jD,EAAA4hD,EAAAC,EAAAiC,EAAAC,EAAAv9E,GACA,GAAAs+E,GAAAnB,EAAAiB,CACA,KAAAE,GAAA,kBAAAl9E,GACA,SAAA1C,IAAAm3E,EAEA,IAAAx6E,GAAA+/E,IAAA//E,OAAA,CAMA,IALAA,IACA8hF,KAAAc,EAAAC,GACA9C,EAAAC,EAAA,MAEAhgF,GAAAggF,IAAAhgF,OAAA,EACA8hF,EAAAe,EAAA,CACA,GAAAd,GAAAhC,EACAiC,EAAAhC,CAEAD,GAAAC,EAAA,KAEA,GAAApjE,IAAAqmE,GAAAzZ,GAAAzjE,GACA89E,GAAA99E,EAAA+7E,EAAA3jD,EAAA4hD,EAAAC,EAAA+B,EAAAC,EAAAC,EAAAC,EAAAv9E,EAWA,IATAiY,QAAA,IACAknE,GAAAD,EAAAjnE,GACAklE,EAAA+B,EAAA,GACAl/E,EAAAk/E,EAAA,IAEAA,EAAA,SAAAl/E,EACAs+E,EAAA,EAAAl9E,EAAA/F,OACAogF,GAAAz7E,EAAA3E,EAAA,MAEA8hF,GAAA7I,EACA,GAAAv4E,GAAAsgF,GAAA6C,EAAA,GAAAA,EAAA,QAIAnjF,GAHOohF,GAAAc,GAAAd,IAAA7I,EAAA2J,IAAAiB,EAAA,GAAA7jF,OAGP6hF,GAAA1jF,MAAA+J,EAAA27E,GAFAD,GAAAzlF,MAAA+J,EAAA27E,EAIA,IAAA/+D,GAAAlI,EAAAmnE,GAAAC,EACA,OAAAl/D,GAAApkB,EAAAmjF,GAiBA,QAAAvG,IAAA17D,EAAAlM,EAAA+mE,EAAAlE,EAAA8D,EAAAznE,EAAAC,GACA,GAAAhX,GAAA,GACAomF,EAAAriE,EAAA5hB,OACAkkF,EAAAxuE,EAAA1V,OACAU,GAAA,CAEA,IAAAujF,GAAAC,KAAA7H,GAAA6H,EAAAD,GACA,QAGA,MAAAvjF,KAAA7C,EAAAomF,GAAA,CACA,GAAAE,GAAAviE,EAAA/jB,GACAumF,EAAA1uE,EAAA7X,EAQA,IANA6C,EAAAwH,EACAqwE,IACA73E,EAAA27E,EACA9D,EAAA6L,EAAAD,EAAAtmF,GACA06E,EAAA4L,EAAAC,EAAAvmF,IAEA,mBAAA6C,GAEA,GAAA27E,EAEA,IADA,GAAAgI,GAAAH,EACAG,MACAD,EAAA1uE,EAAA2uE,KACA3jF,EAAAyjF,OAAAC,GAAA3H,EAAA0H,EAAAC,EAAA7L,EAAA8D,EAAAznE,EAAAC,WAMAnU,GAAAyjF,OAAAC,GAAA3H,EAAA0H,EAAAC,EAAA7L,EAAA8D,EAAAznE,EAAAC,GAIA,QAAAnU,EAgBA,QAAAy8E,IAAA9lE,EAAA3B,EAAAkK,GACA,OAAAA,GACA,IAAA0kE,GACA,IAAAC,GAGA,OAAAltE,IAAA3B,CAEA,KAAA8uE,GACA,MAAAntE,GAAAtT,MAAA2R,EAAA3R,MAAAsT,EAAAioB,SAAA5pB,EAAA4pB,OAEA,KAAAmlD,GAEA,MAAAptE,OACA3B,MAEA,GAAA2B,EAAA,EAAAA,GAAA,EAAA3B,EAAA2B,IAAA3B,CAEA,KAAAgvE,IACA,IAAAC,IAGA,MAAAttE,IAAA3B,EAAA,GAEA,SAiBA,QAAA6nE,IAAAlmE,EAAA3B,EAAA+mE,EAAAlE,EAAA8D,EAAAznE,EAAAC,GACA,GAAA+vE,GAAAn2E,GAAA4I,GACAwtE,EAAAD,EAAA5kF,OACA8kF,EAAAr2E,GAAAiH,GACAwuE,EAAAY,EAAA9kF,MAEA,IAAA6kF,GAAAX,IAAA7H,EACA,QAKA,KAHA,GAAA0I,GACAlnF,EAAA,KAEAA,EAAAgnF,GAAA,CACA,GAAAjjF,GAAAgjF,EAAA/mF,GACA6C,EAAA2F,GAAAzI,KAAA8X,EAAA9T,EAEA,IAAAlB,EAAA,CACA,GAAAi9E,GAAAtmE,EAAAzV,GACAwiF,EAAA1uE,EAAA9T,EAEAlB,GAAAwH,EACAqwE,IACA73E,EAAA27E,EACA9D,EAAA6L,EAAAzG,EAAA/7E,GACA22E,EAAAoF,EAAAyG,EAAAxiF,IAEA,mBAAAlB,KAEAA,EAAAi9E,OAAAyG,GAAA3H,EAAAkB,EAAAyG,EAAA7L,EAAA8D,EAAAznE,EAAAC,IAGA,IAAAnU,EACA,QAEAqkF,OAAA,eAAAnjF,GAEA,IAAAmjF,EAAA,CACA,GAAAC,GAAA3tE,EAAA9I,YACA02E,EAAAvvE,EAAAnH,WAGA,IAAAy2E,GAAAC,GAAA,eAAA5tE,IAAA,eAAA3B,MACA,kBAAAsvE,oBAAA,kBAAAC,oBACA,SAGA,SAeA,QAAArD,IAAAlJ,EAAAtE,EAAAqN,GACA,GAAAyD,GAAAzD,EAAAlM,GAAAoC,GACAnuE,EAAA07E,EACAxkF,EAAA8I,CASA,OAPAwxE,IAAAtC,EAAA,SAAA71E,EAAAhF,EAAA66E,GACA,GAAApiE,GAAA89D,EAAAvxE,EAAAhF,EAAA66E,KACA+I,EAAAj4E,EAAA8M,IAAA9M,IAAA8M,IAAA4uE,GAAA5uE,IAAA5V,KACA8I,EAAA8M,EACA5V,EAAAmC,KAGAnC,EAYA,QAAAkgF,IAAA76E,EAAAo4B,EAAAg7C,GACA,GAAAz4E,GAAAg0E,EAAAptC,YAEA,OADA5mC,OAAA4mC,GAAA4xC,GAAAx4E,EACAy4E,EAAAz4E,EAAAqF,EAAAo4B,EAAAg7C,GAAAz4E,EAuBA,QAAAi6E,IAAAjC,EAAA5qE,EAAAukE,GACA,GAAA3xE,GAAAg0E,EAAA7mE,WAEA,OADAnN,OAAAmN,GAAAukE,EAAA1xE,EACAg4E,EAAAh4E,EAAAg4E,EAAA5qE,EAAAukE,GAAA3xE,EAaA,QAAAw1E,IAAAjkE,EAAAge,EAAAk1D,GAIA,IAHA,GAAAtnF,GAAA,GACAmC,EAAAmlF,IAAAnlF,OAAA,IAEAnC,EAAAmC,GAAA,CACA,GAAA4c,GAAAuoE,EAAAtnF,GACA2+C,EAAA5/B,EAAA4/B,IAEA,QAAA5/B,EAAA3U,MACA,WAAAgK,GAAAuqC,CAA0C,MAC1C,iBAAAvsB,GAAAusB,CAAwC,MACxC,YAAAvsB,EAAAomD,GAAApmD,EAAAhe,EAAAuqC,EAA+D,MAC/D,iBAAAvqC,EAAAmuE,GAAAnuE,EAAAge,EAAAusB,IAGA,OAAcvqC,QAAAge,OAUd,QAAA0pD,IAAA/3D,GACA,GAAA5hB,GAAA4hB,EAAA5hB,OACAU,EAAA,GAAAkhB,GAAArT,YAAAvO,EAOA,OAJAA,IAAA,gBAAA4hB,GAAA,IAAAvb,GAAAzI,KAAAgkB,EAAA,WACAlhB,EAAA7C,MAAA+jB,EAAA/jB,MACA6C,EAAAs3D,MAAAp2C,EAAAo2C,OAEAt3D,EAUA,QAAAy5E,IAAA9iE,GACA,GAAA/I,GAAA+I,EAAA9I,WAIA,OAHA,kBAAAD,qBACAA,EAAAhM,IAEA,GAAAgM,GAgBA,QAAA4rE,IAAA7iE,EAAAuI,EAAA85D,GACA,GAAAprE,GAAA+I,EAAA9I,WACA,QAAAqR,GACA,IAAAwlE,IACA,MAAAxF,IAAAvoE,EAEA,KAAAitE,GACA,IAAAC,GACA,UAAAj2E,IAAA+I,EAEA,KAAAguE,IAAA,IAAAC,IACA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IACA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IACA,GAAAj/B,GAAAvvC,EAAAuvC,MACA,WAAAt4C,GAAAorE,EAAAkG,GAAAh5B,KAAAvvC,EAAAyuE,WAAAzuE,EAAArX,OAEA,KAAAykF,GACA,IAAAE,IACA,UAAAr2E,GAAA+I,EAEA,KAAAqtE,IACA,GAAAhkF,GAAA,GAAA4N,GAAA+I,EAAAtC,OAAAgxE,GAAA/hC,KAAA3sC,GACA3W,GAAAolC,UAAAzuB,EAAAyuB,UAEA,MAAAplC,GAUA,QAAA04E,IAAArzE,GACA,GAAAigF,GAAAtR,EAAAsR,QACAtlF,IAAAslF,EAAAC,UAAAlgF,EAAAhC,KAAAiiF,EAAAE,WAEA,KAAAxlF,EAAA,CACA,GAAAqU,GAAAoxE,GAAAvoF,KAAAmI,EACAigF,GAAAC,YACAvlF,GAAA0lF,GAAAh8E,KAAA2K,IAEArU,IAEAA,EAAA2lF,GAAAj8E,KAAA2K,IAAAuQ,GAAAvf,GACAg+E,GAAAh+E,EAAArF,IAGA,MAAAA,GAWA,QAAAy/B,IAAAt9B,EAAA7C,GAGA,MAFA6C,MACA7C,EAAA,MAAAA,EAAAkjB,GAAAljB,EACA6C,EAAA,IAAAA,EAAA,MAAA7C,EAAA6C;CAYA,QAAAk+E,IAAAl+E,EAAAhF,EAAAwZ,GACA,IAAAyD,GAAAzD,GACA,QAEA,IAAApP,SAAApK,EACA,cAAAoK,EACA,GAAAjI,GAAAqX,EAAArX,OACAsmF,EAAA1N,GAAA54E,IAAAmgC,GAAAtiC,EAAAmC,OAEAsmF,GAAA,UAAAr+E,GAAApK,IAAAwZ,EAEA,OAAAivE,IAAAjvE,EAAAxZ,KAAAgF,EAcA,QAAA+1E,IAAA/1E,GACA,sBAAAA,MAAA,IAAAA,EAAA,MAAAqgB,IAAArgB,EAWA,QAAAi7E,IAAAj7E,GACA,MAAAA,SAAA,IAAAA,EAAA,EAAAA,EAAA,GAAAiY,GAAAjY,IAkBA,QAAAihF,IAAAlnE,EAAA7H,GACA,GAAA+sE,GAAAllE,EAAA,GACA2pE,EAAAxxE,EAAA,GACAyxE,EAAA1E,EAAAyE,EAEAE,EAAArD,EAAAsD,EACAC,EAAA1N,EAAA8J,EACA6D,EAAAH,EAAAE,EAAArD,EAAAC,EAEAJ,EAAArB,EAAAsB,KAAAmD,EAAAnD,GACAyD,EAAA/E,EAAA4E,KAAAH,EAAAG,GACAzE,GAAA4E,EAAAjqE,EAAA7H,GAAA,GACAmtE,GAAAiB,EAAAvmE,EAAA7H,GAAA,GAEA6lE,IAAAkH,GAAA4E,GAAAH,EAAAI,GACA7E,EAAA6E,GAAAJ,GAAAG,GAEAI,EAAAN,GAAAC,GAAAG,GAAAJ,IACAE,EAAA5E,IAAA+E,GAAA1D,IAAAlB,EAAAjiF,QAAAkiF,EAGA,KAAAtH,IAAAkM,EACA,MAAAlqE,EAGA2pE,GAAAtN,IACAr8D,EAAA,GAAA7H,EAAA,GAEAyxE,GAAA1E,EAAA7I,EAAA,EAAAqK,EAGA,IAAAzgF,GAAAkS,EAAA,EACA,IAAAlS,EAAA,CACA,GAAAk9E,GAAAnjE,EAAA,EACAA,GAAA,GAAAmjE,EAAAD,GAAAC,EAAAl9E,EAAAkS,EAAA,IAAA6gE,GAAA/yE,GACA+Z,EAAA,GAAAmjE,EAAAhM,EAAAn3D,EAAA,GAAAs3D,GAAA0B,GAAA7gE,EAAA,IA0BA,MAvBAlS,GAAAkS,EAAA,GACAlS,IACAk9E,EAAAnjE,EAAA,GACAA,EAAA,GAAAmjE,EAAAQ,GAAAR,EAAAl9E,EAAAkS,EAAA,IAAA6gE,GAAA/yE,GACA+Z,EAAA,GAAAmjE,EAAAhM,EAAAn3D,EAAA,GAAAs3D,GAAA0B,GAAA7gE,EAAA,KAGAlS,EAAAkS,EAAA,GACAlS,IACA+Z,EAAA,GAAAg5D,GAAA/yE,IAGA0jF,EAAAnD,IACAxmE,EAAA,SAAAA,EAAA,GAAA7H,EAAA,GAAAshE,GAAAz5D,EAAA,GAAA7H,EAAA,KAGA,MAAA6H,EAAA,KACAA,EAAA,GAAA7H,EAAA,IAGA6H,EAAA,GAAA7H,EAAA,GACA6H,EAAA,GAAA4pE,EAEA5pE,EAYA,QAAAmqE,IAAA1vE,EAAAhN,GACAgN,EAAA4J,GAAA5J,EAMA,KAJA,GAAAxZ,GAAA,GACAmC,EAAAqK,EAAArK,OACAU,OAEA7C,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACA+D,KAAAyV,KACA3W,EAAAkB,GAAAyV,EAAAzV,IAGA,MAAAlB,GAYA,QAAAsmF,IAAA3vE,EAAAtB,GACA,GAAArV,KAMA,OALAu7E,IAAA5kE,EAAA,SAAAxU,EAAAjB,EAAAyV,GACAtB,EAAAlT,EAAAjB,EAAAyV,KACA3W,EAAAkB,GAAAiB,KAGAnC,EAaA,QAAAwiF,IAAAthE,EAAA08D,GAKA,IAJA,GAAA2F,GAAAriE,EAAA5hB,OACAA,EAAAq2E,GAAAiI,EAAAt+E,OAAAikF,GACAgD,EAAArR,GAAAh0D,GAEA5hB,KAAA,CACA,GAAAnC,GAAAygF,EAAAt+E,EACA4hB,GAAA5hB,GAAAmgC,GAAAtiC,EAAAomF,GAAAgD,EAAAppF,GAAAqK,EAEA,MAAA0Z,GA6CA,QAAAslE,IAAArkF,GACA,IAAAyL,EACAomE,GAAAsR,QAGA,IAAApS,EAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAAk3E,KACA1zE,GAAAzI,KAAAiF,EAAA,iBACAyL,EAAAzL,EAAA0L,YAAA,kBAAAD,uBACA,QAKA,IAAA5N,EAOA,OAHAu7E,IAAAp5E,EAAA,SAAAw3E,EAAAz4E,GACAlB,EAAAkB,IAEA,mBAAAlB,IAAA2F,GAAAzI,KAAAiF,EAAAnC,GAWA,QAAAymF,IAAA9vE,GAYA,IAXA,GAAAhN,GAAA5D,GAAA4Q,GACAwhE,EAAAxuE,EAAArK,OACAA,EAAA64E,GAAAxhE,EAAArX,OACAgmF,EAAAtR,EAAAsR,QAEAoB,EAAApnF,GAAA44E,GAAA54E,KACAoC,GAAAiV,IAAA2uE,EAAAqB,aAAA1L,GAAAtkE,IAEAxZ,EAAA,GACA6C,OAEA7C,EAAAg7E,GAAA,CACA,GAAAj3E,GAAAyI,EAAAxM,IACAupF,GAAAjnD,GAAAv+B,EAAA5B,IAAAqG,GAAAzI,KAAAyZ,EAAAzV,KACAlB,EAAAgQ,KAAA9O,GAGA,MAAAlB,GAUA,QAAAihF,IAAA9+E,GACA,aAAAA,KAGA+1E,GAAA/1E,EAAA7C,QAGA8a,GAAAjY,KAAAP,GAAAO,GAFAkR,GAAAlR,GAYA,QAAAoe,IAAApe,GACA,MAAAiY,IAAAjY,KAAAP,GAAAO,GAUA,QAAAgyE,IAAA1gE,GACA,MAAAA,aAAAwgE,GACAxgE,EAAAnJ,QACA,GAAA4pE,GAAAzgE,EAAA4gE,YAAA5gE,EAAA8gE,UAAAW,GAAAzhE,EAAA6gE,cAyBA,QAAAsS,IAAA1lE,EAAA46B,EAAA+qC,GAEA/qC,GADA+qC,EAAAxG,GAAAn/D,EAAA46B,EAAA+qC,GAAA,MAAA/qC,GACA,EAEA4jC,IAAA5jC,GAAA,IAOA,KALA,GAAA3+C,GAAA,EACAmC,EAAA4hB,IAAA5hB,OAAA,EACAi0E,EAAA,GACAvzE,EAAAjD,GAAAoU,GAAA7R,EAAAw8C,IAEAx8C,EAAAnC,GACA6C,IAAAuzE,GAAAwG,GAAA74D,EAAA/jB,KAAA2+C,EAEA,OAAA97C,GAiBA,QAAA8mF,IAAA5lE,GAMA,IALA,GAAA/jB,GAAA,GACAmC,EAAA4hB,IAAA5hB,OAAA,EACAi0E,EAAA,GACAvzE,OAEA7C,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EACAgF,KACAnC,IAAAuzE,GAAApxE,GAGA,MAAAnC,GAuBA,QAAA8K,MAIA,IAHA,GAAA3N,GAAA,GACAmC,EAAA/C,UAAA+C,SAEAnC,EAAAmC,GAAA,CACA,GAAA6C,GAAA5F,UAAAY,EACA,IAAAuE,GAAAS,IAAA84E,GAAA94E,GACA,MAGA,MAAA63E,IAAA73E,EAAA44E,GAAAx+E,WAAA,OAAAY,IA2BA,QAAAiO,IAAA8V,EAAAjf,EAAA4kF,GACA,GAAAvnF,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,KAGAunF,EAAAxG,GAAAn/D,EAAAjf,EAAA4kF,GAAA,MAAA5kF,KACAA,EAAA,GAEA83E,GAAA74D,EAAA,EAAAjf,EAAA,EAAAA,OA2BA,QAAA8kF,IAAA7lE,EAAAjf,EAAA4kF,GACA,GAAAvnF,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,KAGAunF,EAAAxG,GAAAn/D,EAAAjf,EAAA4kF,GAAA,MAAA5kF,KACAA,EAAA,GAEAA,EAAA3C,IAAA2C,GAAA,GACA83E,GAAA74D,EAAA,IAAAjf,EAAA,EAAAA,OAkDA,QAAA+kF,IAAA9lE,EAAA7L,EAAAooB,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAGA,KADA+V,EAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAn+B,KAAA+V,EAAA6L,EAAA5hB,KAAA4hB,KACA,MAAA64D,IAAA74D,EAAA,EAAA5hB,EAAA,GAkDA,QAAA+L,IAAA6V,EAAA7L,EAAAooB,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAEA,IAAAnC,GAAA,EAEA,KADAkY,EAAA6qE,GAAA7qE,EAAAooB,EAAA,KACAtgC,EAAAmC,GAAA+V,EAAA6L,EAAA/jB,KAAA+jB,KACA,MAAA64D,IAAA74D,EAAA/jB,GAgBA,QAAA4yB,IAAA7O,EAAA/e,EAAAoP,EAAAge,GACA,GAAAjwB,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,IAGAiS,GAAA,gBAAAA,IAAA8uE,GAAAn/D,EAAA/e,EAAAoP,KACAA,EAAA,EACAge,EAAAjwB,GAEAo7E,GAAAx5D,EAAA/e,EAAAoP,EAAAge,OAkDA,QAAAzjB,IAAAoV,EAAA7L,EAAAooB,GACA,GAAAtgC,GAAA,GACAmC,EAAA4hB,IAAA5hB,OAAA,CAGA,KADA+V,EAAA6qE,GAAA7qE,EAAAooB,EAAA,KACAtgC,EAAAmC,GACA,GAAA+V,EAAA6L,EAAA/jB,KAAA+jB,GACA,MAAA/jB,EAGA,UAkDA,QAAA6O,IAAAkV,EAAA7L,EAAAooB,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CAEA,KADA+V,EAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAn+B,KACA,GAAA+V,EAAA6L,EAAA5hB,KAAA4hB,GACA,MAAA5hB,EAGA,UAoBA,QAAAyL,IAAAmW,GACA,MAAAA,KAAA,GAAA1Z,EAuBA,QAAAyE,IAAAiV,EAAA83D,EAAA6N,GACA,GAAAvnF,GAAA4hB,IAAA5hB,OAAA,CAIA,OAHAunF,IAAAxG,GAAAn/D,EAAA83D,EAAA6N,KACA7N,GAAA,GAEA15E,EAAAy7E,GAAA75D,EAAA83D,MAgBA,QAAAiO,IAAA/lE,GACA,GAAA5hB,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,GAAAy7E,GAAA75D,GAAA,MAmCA,QAAA/T,IAAA+T,EAAA/e,EAAAwvE,GACA,GAAAryE,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAEA,oBAAAqyE,GACAA,EAAA,EAAAA,EAAA+N,GAAApgF,EAAAqyE,EAAA,GAAAA,GAAA,MACO,IAAAA,EAAA,CACP,GAAAx0E,GAAAohF,GAAAr9D,EAAA/e,GACA6S,EAAAkM,EAAA/jB,EAEA,QAAAgF,UAAA6S,SAAA7X,EAAA,GAEA,MAAAu0E,GAAAxwD,EAAA/e,EAAAwvE,GAgBA,QAAAuV,IAAAhmE,GACA,MAAA6lE,IAAA7lE,EAAA,GAsBA,QAAA/J,MAQA,IAPA,GAAA7a,MACAkjF,EAAA,GACAC,EAAAljF,UAAA+C,OACA6nF,KACAh6E,EAAA8sE,KACAC,EAAA/sE,GAAAukE,IAEA8N,EAAAC,GAAA,CACA,GAAAt9E,GAAA5F,UAAAijF,IACA99E,GAAAS,IAAA84E,GAAA94E,MACA7F,EAAA0T,KAAA7N,GACAglF,EAAAn3E,KAAAkqE,GAAA/3E,EAAA7C,QAAA,KAAA66E,GAAAqF,GAAAr9E,KAGAs9E,EAAAnjF,EAAAgD,MACA,IAAA4hB,GAAA5kB,EAAA,GACAa,EAAA,GACAmC,EAAA4hB,IAAA5hB,OAAA,EACAU,KACAk7D,EAAAisB,EAAA,EAEAtR,GACA,OAAA14E,EAAAmC,GAEA,GADA6C,EAAA+e,EAAA/jB,IACA+9D,EAAAub,GAAAvb,EAAA/4D,GAAAgL,EAAAnN,EAAAmC,IAAA,GAEA,IADAq9E,EAAAC,IACAD,GAAA,CACA,GAAAr5E,GAAAghF,EAAA3H,EACA,KAAAr5E,EAAAswE,GAAAtwE,EAAAhE,GAAAgL,EAAA7Q,EAAAkjF,GAAAr9E,IAAA,EACA,QAAA0zE,GAGA3a,GACAA,EAAAlrD,KAAA7N,GAEAnC,EAAAgQ,KAAA7N,GAGA,MAAAnC,GAgBA,QAAA0X,IAAAwJ,GACA,GAAA5hB,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,GAAA4hB,EAAA5hB,EAAA,GAAAkI,EA4BA,QAAA6G,IAAA6S,EAAA/e,EAAAwvE,GACA,GAAAryE,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAEA,IAAAnC,GAAAmC,CACA,oBAAAqyE,GACAx0E,GAAA,EAAAw0E,EAAA+N,GAAApgF,EAAAqyE,EAAA,GAAAgE,GAAAhE,GAAA,EAAAryE,EAAA,UACO,IAAAqyE,EAAA,CACPx0E,EAAAohF,GAAAr9D,EAAA/e,GAAA,IACA,IAAA6S,GAAAkM,EAAA/jB,EACA,QAAAgF,UAAA6S,SAAA7X,EAAA,GAEA,GAAAgF,MACA,MAAAyvE,GAAA1wD,EAAA/jB,GAAA,EAEA,MAAAA,KACA,GAAA+jB,EAAA/jB,KAAAgF,EACA,MAAAhF,EAGA,UA0BA,QAAAiqF,MACA,GAAAlmE,GAAA3kB,UAAA,EACA,KAAA2kB,MAAA5hB,OACA,MAAA4hB,EAMA,KAJA,GAAA/jB,GAAA,EACAgQ,EAAA8sE,KACA36E,EAAA/C,UAAA+C,SAEAnC,EAAAmC,GAIA,IAHA,GAAAqyE,GAAA,EACAxvE,EAAA5F,UAAAY,IAEAw0E,EAAAxkE,EAAA+T,EAAA/e,EAAAwvE,IAAA,IACAr0E,GAAAJ,KAAAgkB,EAAAywD,EAAA,EAGA,OAAAzwD,GA4BA,QAAAmmE,IAAAnmE,GACA,MAAAy8D,IAAAz8D,MAAA65D,GAAAx+E,WAAA,SAyCA,QAAA+U,IAAA4P,EAAA7L,EAAAooB,GACA,GAAAtgC,GAAA,GACAmC,EAAA4hB,IAAA5hB,OAAA,EACAU,IAGA,KADAqV,EAAA6qE,GAAA7qE,EAAAooB,EAAA,KACAtgC,EAAAmC,GAAA,CACA,GAAA6C,GAAA+e,EAAA/jB,EACAkY,GAAAlT,EAAAhF,EAAA+jB,KACAlhB,EAAAgQ,KAAA7N,GACA7E,GAAAJ,KAAAgkB,EAAA/jB,IAAA,GACAmC,KAGA,MAAAU,GAiBA,QAAA2xD,IAAAzwC,GACA,MAAA9V,IAAA8V,EAAA,GAiBA,QAAAjkB,IAAAikB,EAAA3P,EAAAge,GACA,GAAAjwB,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,IAGAiwB,GAAA,gBAAAA,IAAA8wD,GAAAn/D,EAAA3P,EAAAge,KACAhe,EAAA,EACAge,EAAAjwB,GAEAy6E,GAAA74D,EAAA3P,EAAAge,OAoDA,QAAA+3D,IAAApmE,EAAA/e,EAAAuxE,EAAAj2C,GACA,GAAAp4B,GAAA66E,GAAAxM,EACA,OAAAruE,KAAAmzE,IAAA,MAAA9E,EACA6K,GAAAr9D,EAAA/e,GACAy8E,GAAA19D,EAAA/e,EAAAkD,EAAAquE,EAAAj2C,EAAA,IAwBA,QAAA8pD,IAAArmE,EAAA/e,EAAAuxE,EAAAj2C,GACA,GAAAp4B,GAAA66E,GAAAxM,EACA,OAAAruE,KAAAmzE,IAAA,MAAA9E,EACA6K,GAAAr9D,EAAA/e,GAAA,GACAy8E,GAAA19D,EAAA/e,EAAAkD,EAAAquE,EAAAj2C,EAAA,OA2BA,QAAAjrB,IAAA0O,EAAAjf,EAAA4kF,GACA,GAAAvnF,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,KAGAunF,EAAAxG,GAAAn/D,EAAAjf,EAAA4kF,GAAA,MAAA5kF,KACAA,EAAA,GAEA83E,GAAA74D,EAAA,IAAAjf,EAAA,EAAAA,OA2BA,QAAAulF,IAAAtmE,EAAAjf,EAAA4kF,GACA,GAAAvnF,GAAA4hB,IAAA5hB,OAAA,CACA,OAAAA,KAGAunF,EAAAxG,GAAAn/D,EAAAjf,EAAA4kF,GAAA,MAAA5kF,KACAA,EAAA,GAEAA,EAAA3C,IAAA2C,GAAA,GACA83E,GAAA74D,EAAA,EAAAjf,EAAA,EAAAA,OAkDA,QAAAwlF,IAAAvmE,EAAA7L,EAAAooB,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAGA,KADA+V,EAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAn+B,KAAA+V,EAAA6L,EAAA5hB,KAAA4hB,KACA,MAAA64D,IAAA74D,EAAA5hB,EAAA,GAkDA,QAAAmT,IAAAyO,EAAA7L,EAAAooB,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAEA,IAAAnC,GAAA,EAEA,KADAkY,EAAA6qE,GAAA7qE,EAAAooB,EAAA,KACAtgC,EAAAmC,GAAA+V,EAAA6L,EAAA/jB,KAAA+jB,KACA,MAAA64D,IAAA74D,EAAA,EAAA/jB,GAsBA,QAAAib,MACA,MAAA+lE,IAAApD,GAAAx+E,WAAA,OAuDA,QAAA2W,IAAAgO,EAAAwmE,EAAAhU,EAAAj2C,GACA,GAAAn+B,GAAA4hB,IAAA5hB,OAAA,CACA,KAAAA,EACA,QAGA,kBAAAooF,IAAA,MAAAA,IACAjqD,EAAAi2C,EACAA,EAAA2M,GAAAn/D,EAAAwmE,EAAAjqD,GAAA,KAAAiqD,EACAA,GAAA,EAEA,IAAAriF,GAAA66E,IAIA,QAHA76E,IAAAmzE,IAAA,MAAA9E,KACAA,EAAAruE,EAAAquE,EAAAj2C,EAAA,IAEAiqD,GAAAzN,MAAAvI,EACA+B,EAAAvyD,EAAAwyD,GACAyK,GAAAj9D,EAAAwyD,GAqBA,QAAAiU,IAAAzmE,GAKA,IAJA,GAAA/jB,GAAA,GACAmC,GAAA4hB,KAAA5hB,QAAA03E,GAAAD,GAAA71D,EAAA0mE,QAAA,EACA5nF,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GACAU,EAAA7C,GAAA45E,GAAA71D,EAAA23D,GAAA17E,GAEA,OAAA6C,GAuBA,QAAA6nF,IAAA3mE,GACA,MAAA84D,IAAA94D,EAAA64D,GAAAx9E,UAAA,IAqBA,QAAAurF,MAIA,IAHA,GAAA3qF,GAAA,GACAmC,EAAA/C,UAAA+C,SAEAnC,EAAAmC,GAAA,CACA,GAAA4hB,GAAA3kB,UAAAY,EACA,IAAAuE,GAAAwf,IAAA+5D,GAAA/5D,GACA,GAAAlhB,KACAg6E,GAAAh6E,EAAAkhB,GAAApkB,OAAAk9E,GAAA94D,EAAAlhB,IACAkhB,EAGA,MAAAlhB,GAAAm+E,GAAAn+E,MAkBA,QAAA2T,MAIA,IAHA,GAAArU,GAAA/C,UAAA+C,OACA4hB,EAAAnkB,GAAAuC,GAEAA,KACA4hB,EAAA5hB,GAAA/C,UAAA+C,EAEA,OAAAqoF,IAAAzmE,GAoBA,QAAA6mE,IAAAp+E,EAAA0J,GACA,GAAAlW,GAAA,GACAmC,EAAAqK,IAAArK,OAAA,EACAU,IAKA,MAHAV,GAAA+T,GAAA3R,GAAAiI,EAAA,MACA0J,QAEAlW,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACAkW,GACArT,EAAAkB,GAAAmS,EAAAlW,GACS+D,IACTlB,EAAAkB,EAAA,IAAAA,EAAA,IAGA,MAAAlB,GA6BA,QAAA6V,IAAA1T,GACA,GAAAnC,GAAAg0E,EAAA7xE,EAEA,OADAnC,GAAAu0E,WAAA,EACAv0E,EAwBA,QAAA0S,IAAAvQ,EAAA6lF,EAAAvqD,GAEA,MADAuqD,GAAA9qF,KAAAugC,EAAAt7B,GACAA,EAqBA,QAAA8lF,IAAA9lF,EAAA6lF,EAAAvqD,GACA,MAAAuqD,GAAA9qF,KAAAugC,EAAAt7B,GA4BA,QAAA+lF,MACA,MAAAryE,IAAArZ,MA4BA,QAAA2rF,MACA,UAAAjU,GAAA13E,KAAA2F,QAAA3F,KAAA+3E,WAwBA,QAAA6T,IAAAjmF,GAIA,IAHA,GAAAnC,GACAkgC,EAAA1jC,KAEA0jC,YAAAg0C,IAAA,CACA,GAAA5pE,GAAA6pE,GAAAj0C,EACAlgC,GACA69E,EAAAxJ,YAAA/pE,EAEAtK,EAAAsK,CAEA,IAAAuzE,GAAAvzE,CACA41B,KAAAm0C,YAGA,MADAwJ,GAAAxJ,YAAAlyE,EACAnC,EAuBA,QAAAqoF,MACA,GAAAlmF,GAAA3F,KAAA63E,WACA,OAAAlyE,aAAA8xE,IACAz3E,KAAA83E,YAAAh1E,SACA6C,EAAA,GAAA8xE,GAAAz3E,OAEA,GAAA03E,GAAA/xE,EAAA2E,UAAAtK,KAAA+3E,YAEA/3E,KAAAyrF,KAAA,SAAA9lF,GACA,MAAAA,GAAA2E,YAgBA,QAAAwhF,MACA,MAAA9rF,MAAA2F,QAAA,GAgBA,QAAAomF,MACA,MAAAlT,IAAA74E,KAAA63E,YAAA73E,KAAA83E,aAyBA,QAAArkD,IAAA+nD,GACA,GAAA14E,GAAA04E,IAAA14E,OAAA,CAIA,OAHA44E,IAAA54E,KACA04E,EAAAiJ,GAAAjJ,IAEAD,GAAAC,EAAA+C,GAAAx+E,WAAA,SAmCA,QAAAizB,IAAAwoD,EAAA5qE,EAAAukE,GACA,GAAAryE,GAAA04E,IAAA14E,OAAA,CAKA,OAJA44E,IAAA54E,KACA04E,EAAA3kE,GAAA2kE,GACA14E,EAAA04E,EAAA14E,QAEAA,GAIAqyE,EADA,gBAAAA,GACA,EAAAA,EAAA+N,GAAApgF,EAAAqyE,EAAA,GAAAA,GAAA,EAEA,EAEA,gBAAAqG,KAAAt2E,GAAAs2E,IAAAvoB,GAAAuoB,GACA14E,EAAAqyE,GAAAqG,EAAA7qE,QAAAC,EAAAukE,GAAA,GACAsI,GAAAjC,EAAA5qE,EAAAukE,GAAA,KATA,EAuGA,QAAA6W,IAAAxQ,EAAA3iE,EAAAooB,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAnB,GAAA4D,EAIA,QAHA,kBAAAplE,IAAA,mBAAAooB,MACApoB,EAAA6qE,GAAA7qE,EAAAooB,EAAA,IAEAp4B,EAAA2yE,EAAA3iE,GAmDA,QAAA1J,IAAAqsE,EAAA3iE,EAAAooB,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAlB,GAAA6D,EAEA,OADAtlE,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAp4B,EAAA2yE,EAAA3iE,GAoDA,QAAAxJ,IAAAmsE,EAAA3iE,EAAAooB,GACA,GAAA/7B,GAAAs2E,GAAA,CACA,GAAA76E,GAAA2O,GAAAksE,EAAA3iE,EAAAooB,EACA,OAAAtgC,GAAA,GAAA66E,EAAA76E,GAAAqK,EAGA,MADA6N,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAm9C,GAAA5C,EAAA3iE,EAAAilE,IAqBA,QAAAvuE,IAAAisE,EAAA3iE,EAAAooB,GAEA,MADApoB,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAm9C,GAAA5C,EAAA3iE,EAAAklE,IAgCA,QAAAkO,IAAAzQ,EAAA3jE,GACA,MAAAxI,IAAAmsE,EAAAY,GAAAvkE,IA6BA,QAAA/H,IAAA0rE,EAAAtE,EAAAj2C,GACA,wBAAAi2C,IAAA,mBAAAj2C,IAAA/7B,GAAAs2E,GACArB,GAAAqB,EAAAtE,GACA4G,GAAAtC,EAAAW,GAAAjF,EAAAj2C,EAAA,IAoBA,QAAAirD,IAAA1Q,EAAAtE,EAAAj2C,GACA,wBAAAi2C,IAAA,mBAAAj2C,IAAA/7B,GAAAs2E,GACApB,GAAAoB,EAAAtE,GACA6G,GAAAvC,EAAAW,GAAAjF,EAAAj2C,EAAA,IAuHA,QAAAxd,IAAA+3D,EAAA7uE,GACA,MAAAsyE,IAAAzD,EAAA7uE,EAAA4wE,GAAAx9E,UAAA,IAuDA,QAAAmS,IAAAspE,EAAAtE,EAAAj2C,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAjB,GAAAoG,EAEA,OADAzJ,GAAAwM,GAAAxM,EAAAj2C,EAAA,GACAp4B,EAAA2yE,EAAAtE,GAsLA,QAAAhjE,IAAAsnE,EAAA92E,GACA,MAAAwN,IAAAspE,EAAAa,GAAA33E,IAqCA,QAAAupC,IAAAutC,EAAAtE,EAAA0D,EAAA35C,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAb,GAAA6G,EACA,OAAA34E,GAAA2yE,EAAAkI,GAAAxM,EAAAj2C,EAAA,GAAA25C,EAAA76E,UAAA+C,OAAA,EAAAg7E,IAsBA,QAAAqO,IAAA3Q,EAAAtE,EAAA0D,EAAA35C,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAV,GAAA0G,EACA,OAAA34E,GAAA2yE,EAAAkI,GAAAxM,EAAAj2C,EAAA,GAAA25C,EAAA76E,UAAA+C,OAAA,EAAAi7E,IAiDA,QAAAnpE,IAAA4mE,EAAA3iE,EAAAooB,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAlB,GAAA6D,EAEA,OADAtlE,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAp4B,EAAA2yE,EAAA,SAAA71E,EAAAhF,EAAA66E,GACA,OAAA3iE,EAAAlT,EAAAhF,EAAA66E,KAsBA,QAAAjzB,IAAAizB,EAAA/1E,EAAA4kF,GACA,GAAAA,EAAAxG,GAAArI,EAAA/1E,EAAA4kF,GAAA,MAAA5kF,EAAA,CACA+1E,EAAAiJ,GAAAjJ,EACA,IAAA14E,GAAA04E,EAAA14E,MACA,OAAAA,GAAA,EAAA04E,EAAA8F,GAAA,EAAAx+E,EAAA,IAAAkI,EAEA,GAAAxH,GAAA4oF,GAAA5Q,EAEA,OADAh4E,GAAAV,OAAAq2E,GAAA,EAAA1zE,EAAA,GAAAA,GAAA,EAAAjC,EAAAV,QACAU,EAkBA,QAAA4oF,IAAA5Q,GACAA,EAAAiJ,GAAAjJ,EAMA,KAJA,GAAA76E,GAAA,GACAmC,EAAA04E,EAAA14E,OACAU,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GAAA,CACA,GAAAupF,GAAA/K,GAAA,EAAA3gF,EACAA,IAAA0rF,IACA7oF,EAAA7C,GAAA6C,EAAA6oF,IAEA7oF,EAAA6oF,GAAA7Q,EAAA76E,GAEA,MAAA6C,GAuBA,QAAA87C,IAAAk8B,GACA,GAAA14E,GAAA04E,IAAA14E,OAAA,CACA,OAAA44E,IAAA54E,KAAAyO,GAAAiqE,GAAA14E,OAqDA,QAAA++C,IAAA25B,EAAA3iE,EAAAooB,GACA,GAAAp4B,GAAA3D,GAAAs2E,GAAAT,GAAA2G,EAIA,QAHA,kBAAA7oE,IAAA,mBAAAooB,MACApoB,EAAA6qE,GAAA7qE,EAAAooB,EAAA,IAEAp4B,EAAA2yE,EAAA3iE,GAgDA,QAAAxD,IAAAmmE,EAAAtE,EAAAj2C,GACA,GAAAtgC,GAAA,GACAmC,EAAA04E,IAAA14E,OAAA,EACAU,EAAAk4E,GAAA54E,GAAAvC,GAAAuC,KASA,OAPAm+B,IAAA4iD,GAAArI,EAAAtE,EAAAj2C,KACAi2C,EAAA,MAEAA,EAAAwM,GAAAxM,EAAAj2C,EAAA,GACA68C,GAAAtC,EAAA,SAAA71E,EAAAjB,EAAA82E,GACAh4E,IAAA7C,IAA2Bk1E,SAAAqB,EAAAvxE,EAAAjB,EAAA82E,GAAA76E,QAAAgF,WAE3B0vE,EAAA7xE,EAAAoyE,GA0BA,QAAA0W,IAAA9Q,GACA,GAAA17E,GAAAC,SACAD,GAAAgD,OAAA,GAAA+gF,GAAA/jF,EAAA,GAAAA,EAAA,GAAAA,EAAA,MACAA,GAAA07E,EAAA17E,EAAA,IAEA,IAAAa,GAAA,GACAmC,EAAA04E,IAAA14E,OAAA,EACAqK,EAAAoxE,GAAAz+E,GAAA,QACA0D,EAAAk4E,GAAA54E,GAAAvC,GAAAuC,KAWA,OATAg7E,IAAAtC,EAAA,SAAA71E,GAIA,IAHA,GAAA7C,GAAAqK,EAAArK,OACA+yE,EAAAt1E,GAAAuC,GAEAA,KACA+yE,EAAA/yE,GAAA,MAAA6C,EAAAqF,EAAArF,EAAAwH,EAAArK,GAEAU,KAAA7C,IAA2Bk1E,WAAAl1E,QAAAgF,WAE3B0vE,EAAA7xE,EAAAsyE,GAgCA,QAAA/+D,IAAAykE,EAAA3jE,GACA,MAAA1I,IAAAqsE,EAAAY,GAAAvkE,IA8CA,QAAArP,IAAA/C,EAAAoD,GACA,qBAAAA,GAAA,CACA,qBAAApD,GAKA,SAAAU,IAAAm3E,EAJA,IAAA5kB,GAAAjzD,CACAA,GAAAoD,EACAA,EAAA6vD,EAMA,MADAjzD,GAAA+gF,GAAA/gF,QAAA,EACA,WACA,QAAAA,EAAA,EACAoD,EAAA5H,MAAAjB,KAAAD,WADA,QAsBA,QAAAilF,IAAAn8E,EAAApD,EAAA4kF,GAKA,MAJAA,IAAAxG,GAAAh7E,EAAApD,EAAA4kF,KACA5kF,EAAA,MAEAA,EAAAoD,GAAA,MAAApD,EAAAoD,EAAA/F,OAAAogF,IAAAz9E,GAAA,KACAq2E,GAAAjzE,EAAAq9E,EAAA,oBAAAzgF,GAmBA,QAAA8mF,IAAA9mF,EAAAoD,GACA,GAAArF,EACA,sBAAAqF,GAAA,CACA,qBAAApD,GAKA,SAAAU,IAAAm3E,EAJA,IAAA5kB,GAAAjzD,CACAA,GAAAoD,EACAA,EAAA6vD,EAKA,kBAMA,QALAjzD,EAAA,EACAjC,EAAAqF,EAAA5H,MAAAjB,KAAAD,WAEA8I,EAAA,KAEArF,GAuCA,QAAAoK,IAAA/E,EAAAo4B,GACA,GAAA2jD,GAAA7I,CACA,IAAAh8E,UAAA+C,OAAA,GACA,GAAA+/E,GAAAtF,GAAAx9E,UAAA,GACA+iF,EAAAjM,EAAAgM,EAAAj1E,GAAAkpE,YAEA8N,IAAAc,EAEA,MAAA5J,IAAAjzE,EAAA+7E,EAAA3jD,EAAA4hD,EAAAC,GA6BA,QAAA0J,IAAAryE,GACA,MAAAyhE,IAAAzhE,EACApa,UAAA+C,OAAA,EACAy7E,GAAAx+E,WAAA,QACAqa,GAAAD,IAgDA,QAAAsyE,IAAAtyE,EAAAzV,GACA,GAAAkgF,GAAA7I,EAAA8J,CACA,IAAA9lF,UAAA+C,OAAA,GACA,GAAA+/E,GAAAtF,GAAAx9E,UAAA,GACA+iF,EAAAjM,EAAAgM,EAAA4J,GAAA3V,YAEA8N,IAAAc,EAEA,MAAA5J,IAAAp3E,EAAAkgF,EAAAzqE,EAAA0oE,EAAAC,GA2CA,QAAAhpE,IAAAjR,EAAApB,EAAA4iF,GACAA,GAAAxG,GAAAh7E,EAAApB,EAAA4iF,KACA5iF,EAAA,KAEA,IAAAjE,GAAAs4E,GAAAjzE,EAAAs9E,EAAA,yBAAA1+E,EAEA,OADAjE,GAAAszE,YAAAh9D,GAAAg9D,YACAtzE,EAwCA,QAAAkpF,IAAA7jF,EAAApB,EAAA4iF,GACAA,GAAAxG,GAAAh7E,EAAApB,EAAA4iF,KACA5iF,EAAA,KAEA,IAAAjE,GAAAs4E,GAAAjzE,EAAAw9E,EAAA,yBAAA5+E,EAEA,OADAjE,GAAAszE,YAAA4V,GAAA5V,YACAtzE,EAiEA,QAAAmpF,IAAA9jF,EAAAw0E,EAAAttC,GAyBA,QAAAhM,KACA6oD,GACA1pC,GAAA0pC,GAEAC,GACA3pC,GAAA2pC,GAEAA,EAAAD,EAAAE,EAAA9hF,EAGA,QAAA+hF,KACA,GAAA92D,GAAAonD,GAAA2P,KAAAC,EACA,OAAAh3D,KAAAonD,EAAA,CACAwP,GACA3pC,GAAA2pC,EAEA,IAAAK,GAAAJ,CACAD,GAAAD,EAAAE,EAAA9hF,EACAkiF,IACAC,EAAAH,KACAxpF,EAAAqF,EAAA5H,MAAAggC,EAAAnhC,GACA8sF,GAAAC,IACA/sF,EAAAmhC,EAAA,WAIA2rD,GAAA/sE,GAAAktE,EAAA92D,GAIA,QAAAm3D,KACAR,GACA1pC,GAAA0pC,GAEAC,EAAAD,EAAAE,EAAA9hF,GACAqiF,GAAAC,IAAAjQ,KACA8P,EAAAH,KACAxpF,EAAAqF,EAAA5H,MAAAggC,EAAAnhC,GACA8sF,GAAAC,IACA/sF,EAAAmhC,EAAA,OAKA,QAAAssD,KAMA,GALAztF,EAAAC,UACAktF,EAAAD,KACA/rD,EAAAjhC,KACA8sF,EAAAO,IAAAT,IAAAY,GAEAF,KAAA,EACA,GAAAG,GAAAD,IAAAZ,MACS,CACTC,GAAAW,IACAL,EAAAF,EAEA,IAAAh3D,GAAAq3D,GAAAL,EAAAE,GACAD,EAAA,GAAAj3D,KAAAq3D,CAEAJ,IACAL,IACAA,EAAA3pC,GAAA2pC,IAEAM,EAAAF,EACAzpF,EAAAqF,EAAA5H,MAAAggC,EAAAnhC,IAEA+sF,IACAA,EAAAhtE,GAAAutE,EAAAn3D,IAgBA,MAbAi3D,IAAAN,EACAA,EAAA1pC,GAAA0pC,GAEAA,GAAAvP,IAAAiQ,IACAV,EAAA/sE,GAAAktE,EAAA1P,IAEAoQ,IACAP,GAAA,EACA1pF,EAAAqF,EAAA5H,MAAAggC,EAAAnhC,KAEAotF,GAAAN,GAAAC,IACA/sF,EAAAmhC,EAAA,MAEAz9B,EA3GA,GAAA1D,GACA+sF,EACArpF,EACAypF,EACAhsD,EACA2rD,EACAE,EACAK,EAAA,EACAG,GAAA,EACAD,GAAA,CAEA,sBAAAxkF,GACA,SAAA1C,IAAAm3E,EAGA,IADAD,EAAA,EAAAA,EAAA,EAAAA,EACAttC,KAAA,GACA,GAAAy9C,IAAA,CACAH,IAAA,MACOzvE,IAAAmyB,KACPy9C,EAAAz9C,EAAAy9C,QACAF,EAAA,WAAAv9C,IAAAmzC,IAAAnzC,EAAAu9C,SAAA,EAAAjQ,GACAgQ,EAAA,YAAAt9C,KAAAs9C,WAyFA,OADAE,GAAAxpD,SACAwpD,EAkBA,QAAAzvE,IAAAjV,GACA,MAAAu0E,IAAAv0E,EAAA,EAAA9I,UAAA,GAmBA,QAAAujD,IAAAz6C,EAAAw0E,GACA,MAAAD,IAAAv0E,EAAAw0E,EAAAt9E,UAAA,GA2BA,QAAA2tF,MACA,GAAAC,GAAA5tF,UACA+C,EAAA6qF,EAAA7qF,MAEA,KAAAA,EACA,kBAA2B,MAAA/C,WAAA,GAE3B,KAAAs6E,GAAAsT,EAAAnrE,IACA,SAAArc,IAAAm3E,EAEA,mBAIA,IAHA,GAAA38E,GAAA,EACA6C,EAAAmqF,EAAAhtF,GAAAM,MAAAjB,KAAAD,aAEAY,EAAAmC,GACAU,EAAAmqF,EAAAhtF,GAAAD,KAAAV,KAAAwD,EAEA,OAAAA,IA4BA,QAAAoqF,MACA,GAAAD,GAAA5tF,UACAo1E,EAAAwY,EAAA7qF,OAAA,CAEA,MAAAqyE,EACA,kBAA2B,MAAAp1E,WAAA,GAE3B,KAAAs6E,GAAAsT,EAAAnrE,IACA,SAAArc,IAAAm3E,EAEA,mBAIA,IAHA,GAAA38E,GAAAw0E,EACA3xE,EAAAmqF,EAAAhtF,GAAAM,MAAAjB,KAAAD,WAEAY,KACA6C,EAAAmqF,EAAAhtF,GAAAD,KAAAV,KAAAwD,EAEA,OAAAA,IAyDA,QAAAkG,IAAAb,EAAAqsC,GACA,qBAAArsC,IAAAqsC,GAAA,kBAAAA,GACA,SAAA/uC,IAAAm3E,EAEA,IAAAuQ,GAAA,WACA,GAAAlkF,GAAAkkF,EAAAlkF,MACAjF,EAAAwwC,IAAAj0C,MAAAjB,KAAAD,qBAAA,EAEA,IAAA4J,EAAAyG,IAAA1L,GACA,MAAAiF,GAAAsG,IAAAvL,EAEA,IAAAlB,GAAAqF,EAAA5H,MAAAjB,KAAAD,UAEA,OADA4J,GAAAqI,IAAAtN,EAAAlB,GACAA,EAGA,OADAqqF,GAAAlkF,MAAA,GAAAD,IAAAokF,MACAD,EAsBA,QAAAh7E,IAAAgG,GACA,qBAAAA,GACA,SAAA1S,IAAAm3E,EAEA,mBACA,OAAAzkE,EAAA5X,MAAAjB,KAAAD,YAqBA,QAAAkK,IAAApB,GACA,MAAA0jF,IAAA1jF,EAAA,GAmCA,QAAAklF,IAAAllF,GACA,GAAAg6E,GAAAtF,GAAAx9E,UAAA,GACA+iF,EAAAjM,EAAAgM,EAAAkL,GAAAjX,YAEA,OAAAgF,IAAAjzE,EAAA68E,EAAA,KAAA7C,EAAAC,GAkCA,QAAAkL,IAAAnlF,GACA,GAAAg6E,GAAAtF,GAAAx9E,UAAA,GACA+iF,EAAAjM,EAAAgM,EAAAmL,GAAAlX,YAEA,OAAAgF,IAAAjzE,EAAA88E,EAAA,KAAA9C,EAAAC,GA6BA,QAAAmL,IAAAplF,GACA,GAAAu4E,GAAA7C,GAAAx+E,WAAA,OACA,OAAA+7E,IAAAjzE,EAAA2gF,EAAA,eAAApI,GAmCA,QAAA/uC,IAAAxpC,GACA,qBAAAA,GACA,SAAA1C,IAAAm3E,EAEA,iBAAA54D,GACA,MAAA7b,GAAA5H,MAAAjB,KAAA0kB,IA0CA,QAAAwpE,IAAArlF,EAAAw0E,EAAAttC,GACA,GAAAy9C,IAAA,EACAH,GAAA,CAEA,sBAAAxkF,GACA,SAAA1C,IAAAm3E,EAWA,OATAvtC,MAAA,EACAy9C,GAAA,EACO5vE,GAAAmyB,KACPy9C,EAAA,WAAAz9C,OAAAy9C,UACAH,EAAA,YAAAt9C,OAAAs9C,YAEAc,GAAAX,UACAW,GAAAb,SAAAjQ,EACA8Q,GAAAd,WACAV,GAAA9jF,EAAAw0E,EAAA8Q,IAwBA,QAAAn3E,IAAArR,EAAAsR,GAEA,MADAA,GAAA,MAAAA,EAAAlO,GAAAkO,EACA6kE,GAAA7kE,EAAAyuE,EAAA,MAAA//E,OAsDA,QAAAmI,IAAAnI,EAAA62E,EAAAnB,EAAAp6C,GAQA,MANA,iBAAAu7C,IAAA,MAAAA,IACAv7C,EAAAo6C,EACAA,EAAAwI,GAAAl+E,EAAA62E,EAAAv7C,GAAA,KAAAu7C,EACAA,GAAA,GAEAnB,EAAA,kBAAAA,IAAAc,GAAAd,EAAAp6C,EAAA,GACAs7C,GAAA52E,EAAA62E,EAAAnB,GA8CA,QAAA+S,IAAAzoF,EAAA01E,EAAAp6C,GAEA,MADAo6C,GAAA,kBAAAA,IAAAc,GAAAd,EAAAp6C,EAAA,GACAs7C,GAAA52E,GAAA,EAAA01E,GAmBA,QAAAoD,IAAA94E,GACA,GAAA7C,GAAA4zE,EAAA/wE,KAAA7C,OAAAkI,CACA,OAAA0wE,IAAA54E,IAAA45E,GAAAh8E,KAAAiF,IAAAm3E,IAAA,EAuCA,QAAAhe,IAAAn5D,GACA,MAAAA,MAAA,GAAAA,KAAA,GAAA+wE,EAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAAyhF,IAAA,EAmBA,QAAAtnB,IAAAn6D,GACA,MAAA+wE,GAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAA0hF,IAAA,EAmBA,QAAAgH,IAAA1oF,GACA,MAAAA,IAAA,IAAAA,EAAAuD,UAAAwtE,EAAA/wE,IACA+2E,GAAAh8E,KAAAiF,GAAAgL,QAAA,kBAoCA,QAAAvH,IAAAzD,GACA,SAAAA,EACA,QAEA,IAAA7C,GAAA6C,EAAA7C,MACA,OAAA44E,IAAA54E,KAAAoC,GAAAS,IAAAstD,GAAAttD,IAAA84E,GAAA94E,IACA+wE,EAAA/wE,IAAA6c,GAAA7c,EAAA7E,UACAgC,GAEAyO,GAAA5L,GAAA7C,OA4CA,QAAAwrF,IAAA3oF,EAAA6S,EAAA6iE,EAAAp6C,GAEA,GADAo6C,EAAA,kBAAAA,IAAAc,GAAAd,EAAAp6C,EAAA,IACAo6C,GAAAuF,GAAAj7E,IAAAi7E,GAAApoE,GACA,MAAA7S,KAAA6S,CAEA,IAAAhV,GAAA63E,IAAA11E,EAAA6S,GAAAxN,CACA,0BAAAxH,GAAA07E,GAAAv5E,EAAA6S,EAAA6iE,KAAA73E,EAoBA,QAAAm8D,IAAAh6D,GACA,MAAA+wE,GAAA/wE,IAAA,gBAAAA,GAAAy8B,SAAAs6C,GAAAh8E,KAAAiF,IAAA2hF,IAAA,EAoDA,QAAA9kE,IAAA7c,GAGA,wBAAAA,KAAA,EAkCA,QAAAiY,IAAAjY,GAGA,GAAAoF,SAAApF,EACA,mBAAAoF,GAAApF,GAAA,UAAAoF,IAAA,EA0CA,QAAAwjF,IAAAp0E,EAAAtC,EAAAwjE,EAAAp6C,GACA,GAAA9zB,GAAAoE,GAAAsG,GACA/U,EAAAqK,EAAArK,MAGA,IADAu4E,EAAA,kBAAAA,IAAAc,GAAAd,EAAAp6C,EAAA,IACAo6C,GAAA,GAAAv4E,EAAA,CACA,GAAA4B,GAAAyI,EAAA,GACAxH,EAAAkS,EAAAnT,EAEA,IAAAk8E,GAAAj7E,GACA,aAAAwU,GAAAxU,IAAAwU,EAAAzV,IAAAyE,GAAAzI,KAAAyZ,EAAAzV,GAMA,IAHA,GAAAmS,GAAAtW,GAAAuC,GACAy9E,EAAAhgF,GAAAuC,GAEAA,KACA6C,EAAAkR,EAAA/T,GAAA+U,EAAA1K,EAAArK,IACAy9E,EAAAz9E,GAAA89E,GAAAj7E,EAEA,OAAA26E,IAAAnmE,EAAAhN,EAAA0J,EAAA0pE,EAAAlF,GA6BA,QAAAv1D,IAAAngB,GAGA,MAAA06D,IAAA16D,UAmBA,QAAAyiB,IAAAziB,GACA,aAAAA,GACA,EAEA+2E,GAAAh8E,KAAAiF,IAAAi3E,EACA4R,GAAAthF,KAAA+7E,GAAAvoF,KAAAiF,IAEA+wE,EAAA/wE,IAAA8oF,GAAAvhF,KAAAvH,KAAA,EAmBA,QAAA2tD,IAAA3tD,GACA,cAAAA,EAyBA,QAAA06D,IAAA16D,GACA,sBAAAA,IAAA+wE,EAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAA4hF,IAAA,EA6DA,QAAA1nB,IAAAl6D,GACA,MAAA+wE,GAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAA6hF,KAAA,EAmBA,QAAAv0B,IAAAttD,GACA,sBAAAA,IAAA+wE,EAAA/wE,IAAA+2E,GAAAh8E,KAAAiF,IAAA8hF,KAAA,EAmBA,QAAA5H,IAAAl6E,GACA,MAAA+wE,GAAA/wE,IAAA+1E,GAAA/1E,EAAA7C,SAAA4rF,GAAAhS,GAAAh8E,KAAAiF,MAAA,EAmBA,QAAAq5D,IAAAr5D,GACA,yBAAAA,GAgBA,QAAAgpF,IAAAhpF,GACA,GAAA7C,GAAA6C,IAAA7C,OAAA,CACA,OAAA44E,IAAA54E,GAGAA,EAGA41E,GAAA/yE,MALAkR,GAAAlR,GA+BA,QAAAu7E,IAAAv7E,GACA,MAAA21E,IAAA31E,EAAA4D,GAAA5D,IAoEA,QAAAke,IAAArjB,EAAAouF,EAAAvE,GACA,GAAA7mF,GAAA4gF,GAAA5jF,EAIA,OAHA6pF,IAAAxG,GAAArjF,EAAAouF,EAAAvE,KACAuE,EAAA,MAEAA,EAAAtT,GAAAsT,EAAAprF,EAAA+N,GAAAq9E,IAAAprF,EAmBA,QAAAqrF,IAAA10E,GACA,SAAAA,EACA,MAAAA,EAEA,IAAAra,GAAA44E,GAAA34E,UAEA,OADAD,GAAA0T,KAAAwnE,IACAptD,GAAA3sB,MAAA+J,EAAAlL,GAkDA,QAAAgvF,IAAA30E,EAAAtB,EAAAooB,GAEA,MADApoB,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAm9C,GAAAjkE,EAAAtB,EAAAqkE,IAAA,GAkDA,QAAA6R,IAAA50E,EAAAtB,EAAAooB,GAEA,MADApoB,GAAA6qE,GAAA7qE,EAAAooB,EAAA,GACAm9C,GAAAjkE,EAAAtB,EAAAmlE,IAAA,GA8BA,QAAAgR,IAAA70E,EAAA+8D,EAAAj2C,GAIA,OAHA,kBAAAi2C,IAAA,mBAAAj2C,MACAi2C,EAAAiF,GAAAjF,EAAAj2C,EAAA,IAEA29C,GAAAzkE,EAAA+8D,EAAA3tE,IA4BA,QAAA0lF,IAAA90E,EAAA+8D,EAAAj2C,GAEA,MADAi2C,GAAAiF,GAAAjF,EAAAj2C,EAAA,GACA69C,GAAA3kE,EAAA+8D,EAAA3tE,IAuBA,QAAA2lF,IAAA/0E,EAAA+8D,EAAAj2C,GAIA,OAHA,kBAAAi2C,IAAA,mBAAAj2C,MACAi2C,EAAAiF,GAAAjF,EAAAj2C,EAAA,IAEAi8C,GAAA/iE,EAAA+8D,GAqBA,QAAAiY,IAAAh1E,EAAA+8D,EAAAj2C,GAEA,MADAi2C,GAAAiF,GAAAjF,EAAAj2C,EAAA,GACA69C,GAAA3kE,EAAA+8D,EAAA3lE,IAkBA,QAAA6I,IAAAD,GACA,MAAA6kE,IAAA7kE,EAAA5Q,GAAA4Q,IAkBA,QAAA/J,IAAA+J,EAAAzV,GACA,MAAAyV,GAAAhR,GAAAzI,KAAAyZ,EAAAzV,IAAA,EA4BA,QAAAsW,IAAAb,EAAAi1E,EAAA/E,GACAA,GAAAxG,GAAA1pE,EAAAi1E,EAAA/E,KACA+E,EAAA,KAOA,KALA,GAAAzuF,GAAA,GACAwM,EAAAoE,GAAA4I,GACArX,EAAAqK,EAAArK,OACAU,OAEA7C,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,GACAgF,EAAAwU,EAAAzV,EAEA0qF,GACAjmF,GAAAzI,KAAA8C,EAAAmC,GACAnC,EAAAmC,GAAA6N,KAAA9O,GAEAlB,EAAAmC,IAAAjB,GAIAlB,EAAAmC,GAAAjB,EAGA,MAAAlB,GAgEA,QAAA+F,IAAA4Q,GACA,SAAAA,EACA,QAEAyD,IAAAzD,KACAA,EAAA/U,GAAA+U,GAEA,IAAArX,GAAAqX,EAAArX,MACAA,MAAA44E,GAAA54E,KACAoC,GAAAiV,IAAA2uE,GAAAqB,aAAA1L,GAAAtkE,KAAArX,GAAA,CAQA,KANA,GAAAsO,GAAA+I,EAAA9I,YACA1Q,EAAA,GACA0uF,EAAA,kBAAAj+E,MAAA5Q,YAAA2Z,EACA3W,EAAAjD,GAAAuC,GACAwsF,EAAAxsF,EAAA,IAEAnC,EAAAmC,GACAU,EAAA7C,KAAA,EAEA,QAAA+D,KAAAyV,GACAm1E,GAAArsD,GAAAv+B,EAAA5B,IACA,eAAA4B,IAAA2qF,IAAAlmF,GAAAzI,KAAAyZ,EAAAzV,KACAlB,EAAAgQ,KAAA9O,EAGA,OAAAlB,GA2CA,QAAA+rF,IAAAp1E,EAAA+8D,EAAAj2C,GACA,GAAAz9B,KAMA,OALA0zE,GAAAwM,GAAAxM,EAAAj2C,EAAA,GAEAi8C,GAAA/iE,EAAA,SAAAxU,EAAAjB,EAAAyV,GACA3W,EAAAkB,GAAAwyE,EAAAvxE,EAAAjB,EAAAyV,KAEA3W,EA+EA,QAAAyP,IAAAkH,EAAAtB,EAAAooB,GACA,SAAA9mB,EACA,QAEA,sBAAAtB,GAAA,CACA,GAAA1L,GAAAotE,GAAAgE,GAAAx+E,WAAA,QAAAkJ,GACA,OAAA4gF,IAAA1vE,EAAAqjE,GAAAj0E,GAAA4Q,GAAAhN,IAGA,MADA0L,GAAAsjE,GAAAtjE,EAAAooB,EAAA,GACA6oD,GAAA3vE,EAAA,SAAAxU,EAAAjB,EAAAyV,GACA,OAAAtB,EAAAlT,EAAAjB,EAAAyV,KAkBA,QAAA7R,IAAA6R,GAMA,IALA,GAAAxZ,GAAA,GACAwM,EAAAoE,GAAA4I,GACArX,EAAAqK,EAAArK,OACAU,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GAAA,CACA,GAAA4B,GAAAyI,EAAAxM,EACA6C,GAAA7C,IAAA+D,EAAAyV,EAAAzV,IAEA,MAAAlB,GA6BA,QAAAsQ,IAAAqG,EAAAtB,EAAAooB,GACA,aAAA9mB,KAGA,kBAAAtB,GACAixE,GAAA3vE,EAAAgiE,GAAAtjE,EAAAooB,EAAA,IACA4oD,GAAA1vE,EAAAokE,GAAAx+E,WAAA,SAiCA,QAAAyD,IAAA2W,EAAAzV,EAAA8gD,GACA,GAAA7/C,GAAA,MAAAwU,EAAAnP,EAAAmP,EAAAzV,EAIA,OAHA,mBAAAiB,KACAA,EAAA6/C,GAEAhjC,GAAA7c,KAAAjF,KAAAyZ,GAAAxU,EAkCA,QAAA6pF,IAAAr1E,EAAA+8D,EAAA0D,EAAA35C,GACA,GAAAw6C,GAAAv2E,GAAAiV,IAAA0lE,GAAA1lE,EAGA,IAFA+8D,EAAAwM,GAAAxM,EAAAj2C,EAAA,GAEA,MAAA25C,EACA,GAAAa,GAAA79D,GAAAzD,GAAA,CACA,GAAA/I,GAAA+I,EAAA9I,WAEAupE,GADAa,EACAv2E,GAAAiV,GAAA,GAAA/I,MAEAgzE,GAAA5hE,GAAApR,MAAA5Q,eAGAo6E,KAMA,QAHAa,EAAAtB,GAAA+C,IAAA/iE,EAAA,SAAAxU,EAAAhF,EAAAwZ,GACA,MAAA+8D,GAAA0D,EAAAj1E,EAAAhF,EAAAwZ,KAEAygE,EA4BA,QAAA/jE,IAAAsD,GACA,MAAA2nE,IAAA3nE,EAAA5I,GAAA4I,IA0BA,QAAAhP,IAAAgP,GACA,MAAA2nE,IAAA3nE,EAAA5Q,GAAA4Q,IAgCA,QAAAsN,IAAA3hB,EAAAd,EAAAyqF,GACAA,GAAA5L,GAAA/9E,EAAAd,EAAAyqF,KACAzqF,EAAAyqF,EAAA,KAEA,IAAAC,GAAA,MAAA5pF,EACA6pF,EAAA,MAAA3qF,CAuBA,IArBA,MAAAyqF,IACAE,GAAA,iBAAA7pF,IACA2pF,EAAA3pF,EACAA,EAAA,GAEA,iBAAAd,KACAyqF,EAAAzqF,EACA2qF,GAAA,IAGAD,GAAAC,IACA3qF,EAAA,EACA2qF,GAAA,GAEA7pF,MAAA,EACA6pF,GACA3qF,EAAAc,EACAA,EAAA,GAEAd,MAAA,EAEAyqF,GAAA3pF,EAAA,GAAAd,EAAA,GACA,GAAAqnF,GAAA9K,IACA,OAAApI,IAAArzE,EAAAumF,GAAArnF,EAAAc,EAAA0qB,WAAA,QAAA67D,EAAA,IAAAvpF,OAAA,KAAAkC,GAEA,MAAAs8E,IAAAx7E,EAAAd,GA2CA,QAAA4qF,IAAAnkC,GAEA,MADAA,GAAA8pB,EAAA9pB,GACAA,KAAAnyC,OAAA,GAAAyoD,cAAAtW,EAAAhrD,MAAA,GAkBA,QAAAyjF,IAAAz4B,GAEA,MADAA,GAAA8pB,EAAA9pB,GACAA,KAAA5qD,QAAAgvF,GAAA5Z,GAwBA,QAAArjD,IAAA64B,EAAA76C,EAAAhH,GACA6hD,EAAA8pB,EAAA9pB,GACA76C,GAAA,EAEA,IAAA9N,GAAA2oD,EAAA3oD,MAEA,OADA8G,IAAA,mBAAAA,GAAA9G,EAAAq2E,GAAA,EAAAvvE,EAAA,GAAAA,GAAA,EAAA9G,IAAA8N,EAAA9N,OACA8G,GAAA,GAAA6hD,EAAA96C,QAAAC,EAAAhH,MAmCA,QAAAmvB,IAAA0yB,GAGA,MADAA,GAAA8pB,EAAA9pB,GACAA,GAAAqkC,GAAA5iF,KAAAu+C,GACAA,EAAA5qD,QAAAkvF,GAAA3Z,GACA3qB,EAiBA,QAAAukC,IAAAvkC,GAEA,MADAA,GAAA8pB,EAAA9pB,GACAA,GAAAwkC,GAAA/iF,KAAAu+C,GACAA,EAAA5qD,QAAAqvF,GAAA,QACAzkC,EAmDA,QAAAmV,IAAAnV,EAAA3oD,EAAA4yE,GACAjqB,EAAA8pB,EAAA9pB,GACA3oD,IAEA,IAAAyjF,GAAA96B,EAAA3oD,MACA,IAAAyjF,GAAAzjF,IAAA0jF,GAAA1jF,GACA,MAAA2oD,EAEA,IAAAwkB,IAAAntE,EAAAyjF,GAAA,EACAnD,EAAA1uE,GAAAu7D,GACAuT,EAAA7uE,GAAAs7D,EAGA,OADAyF,GAAA4Q,GAAA,GAAA9C,EAAA9N,GACAA,EAAAj1E,MAAA,EAAA2iF,GAAA33B,EAAAiqB,EA0BA,QAAAya,IAAA1kC,EAAA3oD,EAAA4yE,GAEA,MADAjqB,GAAA8pB,EAAA9pB,GACAA,GAAA66B,GAAA76B,EAAA3oD,EAAA4yE,GAAAjqB,EA0BA,QAAA2kC,IAAA3kC,EAAA3oD,EAAA4yE,GAEA,MADAjqB,GAAA8pB,EAAA9pB,GACAA,KAAA66B,GAAA76B,EAAA3oD,EAAA4yE,GA0BA,QAAAh2E,IAAA+rD,EAAA4kC,EAAAhG,GAIA,MAHAA,IAAAxG,GAAAp4B,EAAA4kC,EAAAhG,KACAgG,EAAA,GAEAC,GAAA7kC,EAAA4kC,GAsCA,QAAA10E,IAAA8vC,EAAAhmD,GACA,GAAAjC,GAAA,EAGA,IAFAioD,EAAA8pB,EAAA9pB,GACAhmD,KACA,EAAAA,IAAAgmD,IAAA+6B,GAAA/gF,GACA,MAAAjC,EAIA,GACAiC,GAAA,IACAjC,GAAAioD,GAEAhmD,EAAAiP,GAAAjP,EAAA,GACAgmD,WACOhmD,EAEP,OAAAjC,GAyEA,QAAAyvB,IAAAw4B,EAAA76C,EAAAhH,GAGA,MAFA6hD,GAAA8pB,EAAA9pB,GACA7hD,EAAA,MAAAA,EAAA,EAAAuvE,GAAA,EAAAvvE,EAAA,GAAAA,GAAA,EAAA6hD,EAAA3oD,QACA2oD,EAAA55C,YAAAjB,EAAAhH,MAmGA,QAAA4jE,IAAA/hB,EAAA1b,EAAAwgD,GAGA,GAAAC,GAAAhZ,EAAAiZ,gBAEAF,IAAA1M,GAAAp4B,EAAA1b,EAAAwgD,KACAxgD,EAAAwgD,EAAA,MAEA9kC,EAAA8pB,EAAA9pB,GACA1b,EAAAqrC,SAAwCmV,GAAAxgD,GAAAygD,EAAArV,GAExC,IAIAuV,GACAC,EALAC,EAAAxV,SAA4CrrC,EAAA6gD,SAAAJ,EAAAI,QAAAzV,IAC5C0V,EAAAt/E,GAAAq/E,GACAE,EAAAhP,GAAA8O,EAAAC,GAIAlwF,EAAA,EACAowF,EAAAhhD,EAAAghD,aAAAC,GACAn5E,EAAA,WAGAo5E,EAAAtxF,IACAowC,EAAAhX,QAAAi4D,IAAAn5E,OAAA,IACAk5E,EAAAl5E,OAAA,KACAk5E,IAAAG,GAAAC,GAAAH,IAAAn5E,OAAA,KACAk4B,EAAAqhD,UAAAJ,IAAAn5E,OAAA,KACA,KAGAw5E,EAAA,kBACA,aAAAthD,GACAA,EAAAshD,UACA,6BAAAC,GAAA,KACA,IAEA7lC,GAAA5qD,QAAAowF,EAAA,SAAAxxF,EAAA8xF,EAAAC,EAAAC,EAAAC,EAAAhmC,GAsBA,MArBA8lC,OAAAC,GAGA55E,GAAA4zC,EAAAhrD,MAAAE,EAAA+qD,GAAA7qD,QAAA8wF,GAAApb,GAGAgb,IACAb,GAAA,EACA74E,GAAA,YAAA05E,EAAA,UAEAG,IACAf,GAAA,EACA94E,GAAA,OAAuB65E,EAAA,eAEvBF,IACA35E,GAAA,iBAAA25E,EAAA,+BAEA7wF,EAAA+qD,EAAAjsD,EAAAqD,OAIArD,IAGAoY,GAAA,MAIA,IAAA+5E,GAAA7hD,EAAA6hD,QACAA,KACA/5E,EAAA,iBAA8BA,EAAA,SAG9BA,GAAA84E,EAAA94E,EAAAhX,QAAAgxF,GAAA,IAAAh6E,GACAhX,QAAAixF,GAAA,MACAjxF,QAAAkxF,GAAA,OAGAl6E,EAAA,aAAA+5E,GAAA,gBACAA,EACA,GACA,wBAEA,qBACAlB,EACA,mBACA,KAEAC,EACA,uFAEA,OAEA94E,EACA,eAEA,IAAArU,GAAAuwC,GAAA,WACA,MAAA/yC,IAAA6vF,EAAAQ,EAAA,UAAAx5E,GAAA5W,MAAA+J,EAAA8lF,IAMA,IADAttF,EAAAqU,SACA8nD,GAAAn8D,GACA,KAAAA,EAEA,OAAAA,GAwBA,QAAAgH,IAAAihD,EAAAiqB,EAAA2U,GACA,GAAA1kF,GAAA8lD,CAEA,QADAA,EAAA8pB,EAAA9pB,KAIA4+B,EAAAxG,GAAAl+E,EAAA+vE,EAAA2U,GAAA,MAAA3U,GACAjqB,EAAAhrD,MAAA02E,EAAA1rB,GAAA2rB,EAAA3rB,GAAA,IAEAiqB,GAAA,GACAjqB,EAAAhrD,MAAAg1E,EAAAhqB,EAAAiqB,GAAAC,EAAAlqB,EAAAiqB,GAAA,IANAjqB,EA2BA,QAAAumC,IAAAvmC,EAAAiqB,EAAA2U,GACA,GAAA1kF,GAAA8lD,CAEA,OADAA,GAAA8pB,EAAA9pB,GACAA,EAIAA,EAAAhrD,OADA4pF,EAAAxG,GAAAl+E,EAAA+vE,EAAA2U,GAAA,MAAA3U,GACAyB,EAAA1rB,GAEAgqB,EAAAhqB,EAAAiqB,EAAA,KALAjqB,EA0BA,QAAAwmC,IAAAxmC,EAAAiqB,EAAA2U,GACA,GAAA1kF,GAAA8lD,CAEA,OADAA,GAAA8pB,EAAA9pB,GACAA,GAGA4+B,EAAAxG,GAAAl+E,EAAA+vE,EAAA2U,GAAA,MAAA3U,GACAjqB,EAAAhrD,MAAA,EAAA22E,EAAA3rB,GAAA,GAEAA,EAAAhrD,MAAA,EAAAk1E,EAAAlqB,EAAAiqB,EAAA,OALAjqB,EAwCA,QAAA1lC,IAAA0lC,EAAA1b,EAAAs6C,GACAA,GAAAxG,GAAAp4B,EAAA1b,EAAAs6C,KACAt6C,EAAA,KAEA,IAAAjtC,GAAAovF,EACAC,EAAAC,CAEA,UAAAriD,EACA,GAAAnyB,GAAAmyB,GAAA,CACA,GAAAsiD,GAAA,aAAAtiD,KAAAsiD,WACAvvF,GAAA,UAAAitC,MAAAjtC,QAAA,EAAAA,EACAqvF,EAAA,YAAApiD,GAAAwlC,EAAAxlC,EAAAoiD,gBAEArvF,IAAAitC,GAAA,CAIA,IADA0b,EAAA8pB,EAAA9pB,GACA3oD,GAAA2oD,EAAA3oD,OACA,MAAA2oD,EAEA,IAAA14B,GAAAjwB,EAAAqvF,EAAArvF,MACA,MAAAiwB,EACA,MAAAo/D,EAEA,IAAA3uF,GAAAioD,EAAAhrD,MAAA,EAAAsyB,EACA,UAAAs/D,EACA,MAAA7uF,GAAA2uF,CAEA,IAAAtyB,GAAAwyB,IACA,GAAA5mC,EAAAhrD,MAAAsyB,GAAA0/B,OAAA4/B,GAAA,CACA,GAAA5yF,GACA6yF,EACA58E,EAAA+1C,EAAAhrD,MAAA,EAAAsyB,EAMA,KAJAs/D,EAAAv6E,SACAu6E,EAAA1yF,GAAA0yF,EAAAx6E,QAAAgxE,GAAA/hC,KAAAurC,IAAA,UAEAA,EAAAzpD,UAAA,EACAnpC,EAAA4yF,EAAAvrC,KAAApxC,IACA48E,EAAA7yF,EAAAkB,KAEA6C,KAAA/C,MAAA,QAAA6xF,EAAAv/D,EAAAu/D,QAEO,IAAA7mC,EAAA96C,QAAA0hF,EAAAt/D,MAAA,CACP,GAAApyB,GAAA6C,EAAAqO,YAAAwgF,EACA1xF,GAAA,KACA6C,IAAA/C,MAAA,EAAAE,IAGA,MAAA6C,GAAA2uF,EAqBA,QAAAI,IAAA9mC,GAEA,MADAA,GAAA8pB,EAAA9pB,GACAA,GAAA+mC,GAAAtlF,KAAAu+C,GACAA,EAAA5qD,QAAA4xF,GAAApb,GACA5rB,EAqBA,QAAAw4B,IAAAx4B,EAAAz3B,EAAAq2D,GAKA,MAJAA,IAAAxG,GAAAp4B,EAAAz3B,EAAAq2D,KACAr2D,EAAA,MAEAy3B,EAAA8pB,EAAA9pB,GACAA,EAAAhsD,MAAAu0B,GAAA0+D,QAyBA,QAAA3+C,IAAAlrC,GACA,IACA,MAAAA,GAAA5H,MAAA+J,EAAAuyE,GAAAx9E,UAAA,IACO,MAAAwB,GACP,MAAAo+D,IAAAp+D,KAAA,GAAA6G,IAAA7G,IAwCA,QAAA6oC,IAAAvhC,EAAAo4B,EAAAopD,GAIA,MAHAA,IAAAxG,GAAAh7E,EAAAo4B,EAAAopD,KACAppD,EAAA,MAEAy1C,EAAA7tE,GACA09B,GAAA19B,GACAmzE,GAAAnzE,EAAAo4B,GAkBA,QAAA0xD,IAAAhtF,GACA,kBACA,MAAAA,IAkBA,QAAAoD,IAAApD,GACA,MAAAA,GA4BA,QAAA4gC,IAAA1uB,GACA,MAAAukE,IAAAG,GAAA1kE,GAAA,IA8BA,QAAA+6E,IAAAluF,EAAAiB,GACA,MAAA22E,IAAA53E,EAAA,GAAA63E,GAAA52E,GAAA,IAuCA,QAAA8V,IAAAtB,EAAAtC,EAAAk4B,GACA,SAAAA,EAAA,CACA,GAAA8iD,GAAAj1E,GAAA/F,GACA1K,EAAA0lF,GAAAthF,GAAAsG,GACAgkE,EAAA1uE,KAAArK,QAAAk8E,GAAAnnE,EAAA1K,IAEA0uE,IAAA/4E,OAAA+vF,KACAhX,GAAA,EACA9rC,EAAAl4B,EACAA,EAAAsC,EACAA,EAAAna,MAGA67E,IACAA,EAAAmD,GAAAnnE,EAAAtG,GAAAsG,IAEA,IAAAwB,IAAA,EACA1Y,EAAA,GACAg8E,EAAAn6D,GAAArI,GACArX,EAAA+4E,EAAA/4E,MAEAitC,MAAA,EACA12B,GAAA,EACOuE,GAAAmyB,IAAA,SAAAA,KACP12B,EAAA02B,EAAA12B,MAEA,QAAA1Y,EAAAmC,GAAA,CACA,GAAA6J,GAAAkvE,EAAAl7E,GACAkI,EAAAgP,EAAAlL,EAEAwN,GAAAxN,GAAA9D,EACA8zE,IACAxiE,EAAA3Z,UAAAmM,GAAA,SAAA9D,GACA,kBACA,GAAA+uE,GAAA53E,KAAA+3E,SACA,IAAA1+D,GAAAu+D,EAAA,CACA,GAAAp0E,GAAA2W,EAAAna,KAAA63E,YAGA,QAFAr0E,EAAAs0E,YAAAY,GAAA14E,KAAA83E,cAAAtkE,MAAyE3K,OAAA/I,KAAAC,UAAAkhC,QAAA9mB,IACzE3W,EAAAu0E,UAAAH,EACAp0E,EAEA,GAAA1D,IAAAE,KAAA2F,QAEA,OADA6N,IAAAvS,MAAAnB,EAAAC,WACA8I,EAAA5H,MAAAkZ,EAAAra,KAEW+I,IAGX,MAAAsR,GAeA,QAAAsU,MAEA,MADAnoB,GAAA8c,EAAA0vE,GACA9yF,KAeA,QAAAue,OA2BA,QAAAw0E,IAAAruF,GACA,MAAA23E,IAAA33E,EAAA,IAsBA,QAAAsuF,IAAA74E,GACA,gBAAAzV,GACA,aAAAyV,EAAAnP,EAAAmP,EAAAzV,IAoCA,QAAA+P,IAAAM,EAAAge,EAAAtI,GACAA,GAAAo5D,GAAA9uE,EAAAge,EAAAtI,KACAsI,EAAAtI,EAAA,MAEA1V,MAAA,EACA0V,EAAA,MAAAA,EAAA,GAAAA,GAAA,EAEA,MAAAsI,GACAA,EAAAhe,EACAA,EAAA,GAEAge,MAAA,CAQA,KAJA,GAAApyB,GAAA,GACAmC,EAAAogF,GAAAvuE,IAAAoe,EAAAhe,IAAA0V,GAAA,OACAjnB,EAAAjD,GAAAuC,KAEAnC,EAAAmC,GACAU,EAAA7C,GAAAoU,EACAA,GAAA0V,CAEA,OAAAjnB,GA0BA,QAAA2S,IAAA1Q,EAAAyxE,EAAAj2C,GAKA,GAJAx7B,KAIA,EAAAA,IAAA+gF,GAAA/gF,GACA,QAEA,IAAA9E,GAAA,GACA6C,EAAAjD,GAAA44E,GAAA1zE,EAAAwtF,IAGA,KADA/b,EAAAiF,GAAAjF,EAAAj2C,EAAA,KACAtgC,EAAA8E,GACAwtF,GAAAtyF,EACA6C,EAAA7C,GAAAu2E,EAAAv2E,GAEAu2E,EAAAv2E,EAGA,OAAA6C,GAmBA,QAAA0vF,IAAAvtC,GACA,GAAAvxB,KAAA++D,EACA,OAAA5d,GAAA5vB,GAAAvxB,EAp2TA9tB,IAAA8c,GAAAyrE,SAAAp1B,GAAAr0D,SAAAkB,EAAA8c,GAAAtP,KAAA2lD,GAAA25B,KAAA35B,EAGA,IAAAl5D,IAAA+F,EAAA/F,MACAsL,GAAAvF,EAAAuF,KACAzD,GAAA9B,EAAA8B,MACApH,GAAAsF,EAAAtF,SACA+D,GAAAuB,EAAAvB,KACAQ,GAAAe,EAAAf,OACAH,GAAAkB,EAAAlB,OACAzF,GAAA2G,EAAA3G,OACAsJ,GAAA3C,EAAA2C,OACA9C,GAAAG,EAAAH,UAGAktF,GAAA9yF,GAAAC,UACA8yF,GAAAluF,GAAA5E,UAGA1B,OAAAwH,EAAArH,SAAAH,YAGAmqF,GAAAjoF,GAAAR,UAAA6E,SAGA+lF,GAAA/O,GAAA,UAGAlzE,GAAAmqF,GAAAnqF,eAGAgqF,GAAA,EAOAzW,GAAA4W,GAAAjuF,SAGAytF,GAAAxsF,EAAA8c,EAGAorE,GAAA7uF,GAAA,IACAqwF,GAAAtT,IACA77E,QAAA,iEAIAooD,GAAA7gC,GAAA6gC,GAAA3iD,EAAA2iD,iBACA05B,GAAAv6D,GAAAu6D,GAAA15B,IAAA,GAAAA,IAAA,GAAAxoD,QAAAkiF,GACAhuE,GAAA5P,GAAA4P,KACAuuC,GAAA58C,EAAA48C,aACAxuC,GAAA3P,GAAA2P,MACAuU,GAAAb,GAAAa,GAAA7jB,GAAA6jB,oBACAzV,GAAA6/E,GAAA7/E,KACA/B,GAAA6hF,GAAA7hF,qBACAkb,GAAAvE,GAAAuE,GAAArmB,EAAAqmB,SACA9M,GAAAvZ,EAAAuZ,WACA/e,GAAAuyF,GAAAvyF,OACAoqD,GAAA9iC,GAAA8iC,GAAA5kD,EAAA4kD,gBACAt+B,GAAAxE,GAAAwE,GAAAtmB,EAAAsmB,aAGA2mE,GAAA,WAIA,IACA,GAAA1qF,GAAAuf,GAAAvf,EAAAvC,EAAAitF,eAAA1qF,EACArF,EAAA,GAAAqF,GAAA,GAAAogD,IAAA,UAAApgD,EACO,MAAAtH,IACP,MAAAiC,MAIAgwF,GAAAprE,GAAAorE,GAAAjzF,GAAA2E,UAAAsuF,GACAxZ,GAAA5xD,GAAA4xD,GAAA50E,GAAAye,SAAAm2D,GACAwM,GAAAlgF,EAAA0mB,SACAymE,GAAArrE,GAAAqrE,GAAAruF,GAAAmM,OAAAkiF,GACAvQ,GAAAn+E,GAAAC,IACAm0E,GAAAp0E,GAAAe,IACA4tF,GAAAtrE,GAAAsrE,GAAA7nF,GAAAmhF,MAAA0G,GACAC,GAAAvrE,GAAAurE,GAAApuF,GAAAynB,WAAA2mE,GACArD,GAAAhqF,EAAA5G,SACA6hF,GAAAx8E,GAAA0iB,OAGAgzD,GAAAl1E,GAAAk1E,kBACApC,GAAA9yE,GAAA8yE,kBAGA4a,GAAAluF,GAAAgpB,IAAA,QACA00D,GAAAwQ,GAAA,EACA9Q,GAAA8Q,KAAA,EAGAW,GAAAL,MAAAM,kBAAA,EAOA7tE,GAAAjhB,GAAAgpB,IAAA,QAGA+lE,GAAAlnE,IAAA,GAAAA,IAyHAk8D,GAAAtR,EAAAsR,YAEA,WAUAA,GAAAE,YAAA5gE,GAAA9hB,EAAAytF,aAAA5K,GAAAj8E,KAAAqqE,GAQAuR,GAAAC,UAAA,gBAAA/nF,IAAA6F,IAQA,KACAiiF,GAAAkL,IAAA,KAAAl1F,GAAAm1F,yBAAA/qF,SACO,MAAA3H,GACPunF,GAAAkL,KAAA,EAeA,IACAlL,GAAAqB,aAAA14E,GAAA/Q,KAAAX,UAAA,GACO,MAAAwB,GACPunF,GAAAqB,aAAA,IAEK,KAWL3S,EAAAiZ,kBAQA13D,OAAAm7D,GAQA9C,SAAA+C,GAQApD,YAAAG,GAQAU,SAAA,GAQAhB,SAQAxtE,EAAAo0D,GAotBA,IAAA4M,IAAA,WACA,QAAAh/E,MACA,gBAAA5E,GACA,GAAAod,GAAApd,GAAA,CACA4E,EAAA5E,WACA,IAAAgD,GAAA,GAAA4B,EACAA,GAAA5E,UAAA,KAEA,MAAAgD,IAAA8C,EAAAlB,aAmxBAyhF,GAAAiN,GAAA,SAAAjrF,EAAA6W,GAEA,MADAo0E,IAAA9hF,IAAAnJ,EAAA6W,GACA7W,GAFAE,EAsRA45E,MAEAD,GAAAz5B,IAAAiC,GAAA,SAAAxB,GACA,GAAAmB,GAAAnB,EAAAmB,WACAupC,EAAAb,GAAA7+E,GAAAm2C,EAAA+oC,IAAA,EACAloC,EAAA0oC,EAAAR,GACApwF,EAAA,GAAAylD,IAAA4B,EAEA,IAAAupC,EAAA,CACA,GAAA3nB,GAAA,GAAA8mB,IAAA/vF,EAAA,EAAA4wF,EACA3nB,GAAAz6D,IAAA,GAAAuhF,IAAA7pC,EAAA,EAAA0qC,IAMA,MAJAvpC,IAAAa,IACA+gB,EAAA,GAAAvhB,IAAA1nD,EAAAkoD,GACA+gB,EAAAz6D,IAAA,GAAAk5C,IAAAxB,EAAAgC,KAEAloD,GAdAmvF,GAAA,MA6KA,IAAAhV,IAAA3D,IAAArtD,GAAA,SAAA9V,GACA,UAAAkjE,IAAAljE,IADA87E,GAAA,MA0eArmB,GAAAwnB,GAAA,SAAAjrF,GACA,MAAAirF,IAAA7jF,IAAApH,IADA0V,GAgXAuoE,GAAA,WACA,GAAA9xE,GAAA,EACAm4E,EAAA,CAEA,iBAAAzoF,EAAAiB,GACA,GAAAsnF,GAAAD,KACA/2D,EAAAo+D,GAAApH,EAAAE,EAGA,IADAA,EAAAF,EACAh3D,EAAA,GACA,KAAAjhB,GAAAs/E,EACA,MAAA5vF,OAGAsQ,GAAA,CAEA,OAAA6xE,IAAAniF,EAAAiB,OAizDAiU,GAAA6pE,GAAA,SAAAjgF,EAAAmC,EAAAjB,GACAyE,GAAAzI,KAAA8C,EAAAkB,KAAAlB,EAAAkB,GAAAlB,EAAAkB,GAAA,IAkUAwL,GAAAuzE,GAAA,SAAAjgF,EAAAmC,EAAAjB,GACAyE,GAAAzI,KAAA8C,EAAAkB,GACAlB,EAAAkB,GAAA8O,KAAA7N,GAEAnC,EAAAkB,IAAAiB,KA+CA4uF,GAAA9Q,GAAA,SAAAjgF,EAAAmC,EAAAjB,GACAlB,EAAAkB,GAAAiB,IAsIAX,GAAAq/E,GAAA7J,IAiDA10E,GAAAu+E,GAAA3J,IAAA,GAwDAnnE,GAAAkwE,GAAA,SAAAjgF,EAAAmC,EAAAjB,GACAlB,EAAAkB,EAAA,KAAA8O,KAAA7N,IACK,WAAc,gBA0bnBqnF,GAAA0G,IAAA,WACA,UAAA7nF,KAAAsM,WAsnCAjT,GAAAsuF,IAAA,SAAA7tF,GACA,MAAA+wE,GAAA/wE,IAAA+1E,GAAA/1E,EAAA7C,SAAA45E,GAAAh8E,KAAAiF,IAAAg6E,IAAA,EAgEAmJ,IAAAkL,MACA3F,GAAA,SAAA1oF,GACA,MAAAA,IAAA,IAAAA,EAAAuD,UAAAwtE,EAAA/wE,KAAAs7E,GAAAt7E,KAAA,GA+IA,IAAAqnB,IAAA2mE,IAAA,SAAAhuF,GACA,sBAAAA,IAAA6gF,GAAA7gF,KAyBA6c,GAAA,MAAA0oC,KAAA1oC,GAAA0oC,OACA1oC,GAAA,SAAA7c,GAIA,MAAA+2E,IAAAh8E,KAAAiF,IAAAi3E,GAqOA,IAAAqE,IAAAh4D,GAAA,SAAAtjB,GACA,IAAAA,GAAA+2E,GAAAh8E,KAAAiF,IAAAk3E,GACA,QAEA,IAAAzsD,GAAAzqB,EAAAyqB,QACAokE,EAAApsE,GAAAgI,KAAAokE,EAAAvrE,GAAAmH,KAAAnH,GAAAurE,EAEA,OAAAA,GACA7uF,GAAA6uF,GAAAvrE,GAAAtjB,IAAA6uF,EACAxK,GAAArkF,IATAqkF,GA8KAp8D,GAAA+1D,GAAAvI,IAkZA7pE,GAAAkiF,GAAA,SAAAt5E,GACA,GAAAA,EACA,GAAA/I,GAAA+I,EAAA9I,YACAvO,EAAAqX,EAAArX,MAEA,yBAAAsO,MAAA5Q,YAAA2Z,GACA,kBAAAA,IAAArX,GAAA44E,GAAA54E,GACAmnF,GAAA9vE,GAEAyD,GAAAzD,GAAAs5E,GAAAt5E,OATA8vE,GA+JAwK,GAAA9Q,GAAA9C,IAmVA6T,GAAA1Q,GAAA,SAAAxgF,EAAAmxF,EAAAh0F,GAEA,MADAg0F,KAAAn1F,cACAgE,GAAA7C,EAAAg0F,EAAAr7E,OAAA,GAAAyoD,cAAA4yB,EAAAl0F,MAAA,GAAAk0F,KAyJAC,GAAA5Q,GAAA,SAAAxgF,EAAAmxF,EAAAh0F,GACA,MAAA6C,IAAA7C,EAAA,QAAAg0F,EAAAn1F,eAgIA,IAAA8wF,GAAAuE,GAAA,QACAn1F,GAAA,SAAA+rD,EAAA4kC,EAAAhG,GAUA,OANAA,EAAAxG,GAAAp4B,EAAA4kC,EAAAhG,GAAA,MAAAgG,GACAA,EAAA,EACSA,IACTA,MAEA5kC,EAAAjhD,GAAAihD,GACA6kC,GAAA7kC,EAAA4kC,IAAAyE,GAAA5nF,KAAAu+C,GAAA,SAgEA,IAAAspC,IAAA/Q,GAAA,SAAAxgF,EAAAmxF,EAAAh0F,GACA,MAAA6C,IAAA7C,EAAA,QAAAg0F,EAAAn1F,gBAwBAw1F,GAAAhR,GAAA,SAAAxgF,EAAAmxF,EAAAh0F,GACA,MAAA6C,IAAA7C,EAAA,SAAAg0F,EAAAr7E,OAAA,GAAAyoD,cAAA4yB,EAAAl0F,MAAA,KAo2CA,OA9bAi3E,GAAAl3E,UAAA4jF,GAAA5M,EAAAh3E,WAGAi3E,EAAAj3E,UAAA4jF,GAAA1M,EAAAl3E,WACAi3E,EAAAj3E,UAAA6Q,YAAAomE,EAGAgC,GAAAj5E,UAAA,UAAAm5E,GACAF,GAAAj5E,UAAAyP,IAAA2pE,GACAH,GAAAj5E,UAAA4P,IAAAypE,GACAJ,GAAAj5E,UAAAwR,IAAA8nE,GAGAC,GAAAv5E,UAAAgT,KAAA0mE,GAGAxwE,GAAAokF,MAAArU,GAGAjC,EAAAhvE,SACAgvE,EAAAwN,OACAxN,EAAA5pD,UACA4pD,EAAA/jD,MACA+jD,EAAA+U,UACA/U,EAAA5pE,QACA4pE,EAAAgV,WACAhV,EAAAiV,WACAjV,EAAAptC,YACAotC,EAAAn+D,SACAm+D,EAAA4S,SACA5S,EAAA8S,WACA9S,EAAAmb,YACAnb,EAAA59D,WACA49D,EAAA3zD,UACA2zD,EAAA19D,SACA09D,EAAAkV,cACAlV,EAAAmV,YACAnV,EAAAqX,YACArX,EAAA15D,SACA05D,EAAAl0B,SACAk0B,EAAAlpE,cACAkpE,EAAA5oE,QACA4oE,EAAA+S,aACA/S,EAAAgT,kBACAhT,EAAA3oE,aACA2oE,EAAAjkD,QACAikD,EAAAroE,UACAqoE,EAAA/nE,WACA+nE,EAAAiT,eACAjT,EAAAkW,QACAlW,EAAAoW,aACApW,EAAA1nE,WACA0nE,EAAA0U,gBACA1U,EAAAwX,SACAxX,EAAAyX,cACAzX,EAAA0X,UACA1X,EAAA2X,eACA3X,EAAAp9D,aACAo9D,EAAAtnE,WACAsnE,EAAA+c,WACA/c,EAAAkT,WACAlT,EAAA78D,gBACA68D,EAAAx8D,UACAw8D,EAAA/zD,UACA+zD,EAAAjmE,QACAimE,EAAAjuE,UACAiuE,EAAAtlE,OACAslE,EAAA+X,aACA/X,EAAAjxC,WACAixC,EAAAob,mBACApb,EAAA9tE,WACA8tE,EAAAid,SACAjd,EAAA/7D,SACA+7D,EAAA3kE,UACA2kE,EAAAvkE,QACAukE,EAAAvtE,QACAutE,EAAAlvE,SACAkvE,EAAAuW,WACAvW,EAAAwW,gBACAxW,EAAAjkE,aACAikE,EAAA1jE,QACA0jE,EAAAtjE,SACAsjE,EAAAub,YACAvb,EAAAwb,cACAxb,EAAAoT,QACApT,EAAAqT,UACArT,EAAA/iE,SACA+iE,EAAAyW,SACAzW,EAAA5iE,UACA4iE,EAAA1iE,UACA0iE,EAAAriB,QACAqiB,EAAA4U,WACA5U,EAAA/2E,SACA+2E,EAAAniE,UACAmiE,EAAA8U,aACA9U,EAAAnlC,UACAmlC,EAAAxhE,QACAwhE,EAAAwT,aACAxT,EAAAyT,kBACAzT,EAAAvhE,aACAuhE,EAAAthE,OACAshE,EAAA0W,YACA1W,EAAAiU,QACAjU,EAAArhE,SACAqhE,EAAAmX,WACAnX,EAAA0J,iBACA1J,EAAAgY,aACAhY,EAAA57D,SACA47D,EAAA9gE,QACA8gE,EAAA2T,SACA3T,EAAA3gE,UACA2gE,EAAArsE,YACAqsE,EAAAzgE,SACAygE,EAAA6T,WACA7T,EAAAxgE,QACAwgE,EAAA8T,OACA9T,EAAArgE,OACAqgE,EAAA+T,aAGA/T,EAAAyd,SAAArH,GACApW,EAAA0d,QAAAhjF,GACAslE,EAAAzpE,QAAA6/E,GACApW,EAAAtpC,KAAAp+B,GACA0nE,EAAA2d,UAAAjJ,GACA1U,EAAA4d,OAAAxnE,GACA4pD,EAAAN,SAAA9sC,GACAotC,EAAAphD,QAAAhc,GACAo9D,EAAAr9D,OAAAoxE,GACA/T,EAAA6d,OAAAlmF,GACAqoE,EAAAzhE,KAAAo/C,GACAqiB,EAAA8d,OAAA5+E,GAGA+E,GAAA+7D,KAKAA,EAAAzjC,WACAyjC,EAAAkd,aACAld,EAAAoY,cACApY,EAAA1pE,SACA0pE,EAAA4W,aACA5W,EAAA0M,UACA1M,EAAA5kD,YACA4kD,EAAAz+C,UACAy+C,EAAAwY,gBACAxY,EAAAwU,SACAxU,EAAAnoE,QACAmoE,EAAAloE,aACAkoE,EAAAsX,WACAtX,EAAAjoE,YACAioE,EAAAhoE,iBACAgoE,EAAAuX,eACAvX,EAAAyU,aACAzU,EAAAjpE,SACAipE,EAAApnE,OACAonE,EAAAzuE,YACAyuE,EAAAxkD,YACAwkD,EAAA7mE,WACA6mE,EAAAiH,eACAjH,EAAAtyE,WACAsyE,EAAA1Y,aACA0Y,EAAA1X,UACA0X,EAAA6W,aACA7W,EAAApuE,WACAouE,EAAA8W,WACA9W,EAAA7X,WACA6X,EAAAxqD,YACAwqD,EAAAh1D,cACAg1D,EAAA+W,WACA/W,EAAA1xD,SACA0xD,EAAApvD,YACAovD,EAAAlkB,UACAkkB,EAAAnX,YACAmX,EAAA55D,YACA45D,EAAAyJ,iBACAzJ,EAAA3X,YACA2X,EAAAvkB,YACAukB,EAAAqI,gBACArI,EAAAxY,eACAwY,EAAAod,aACApd,EAAAt8D,QACAs8D,EAAA3lE,eACA2lE,EAAAxyE,OACAwyE,EAAA1xE,OACA0xE,EAAA/oD,cACA+oD,EAAAj5D,QACAi5D,EAAAwV,OACAxV,EAAA5W,OACA4W,EAAA2Y,WACA3Y,EAAA4Y,YACA5Y,EAAA93E,YACA83E,EAAA/vD,UACA+vD,EAAAvpC,UACAupC,EAAA2U,eACA3U,EAAA77D,UACA67D,EAAAh0E,UACAg0E,EAAAD,eACAC,EAAAl4B,QACAk4B,EAAAud,aACAvd,EAAA31B,QACA21B,EAAAsT,eACAtT,EAAAuT,mBACAvT,EAAAwd,aACAxd,EAAAvkD,cACAukD,EAAAhK,YACAgK,EAAAhtE,QACAgtE,EAAAwa,YACAxa,EAAAya,aACAza,EAAAzxD,SACAyxD,EAAA+a,YACA/a,EAAA0b,YACA1b,EAAAyM,SAGAzM,EAAAlqE,IAAA0+E,GACAxU,EAAAhqE,IAAAq0C,GACA21B,EAAA79D,SAAAqZ,GACAwkD,EAAAnJ,OAAAh/D,GACAmoE,EAAA9nE,MAAAu+B,GACAupC,EAAA5nE,MAAAu8E,GACA3U,EAAAj9D,KAAAhM,GACAipE,EAAA+d,QAAAviE,GACAwkD,EAAAge,OAAAvnD,GAEAxyB,GAAA+7D,EAAA,WACA,GAAA3/D,KAMA,OALAqlE,IAAA1F,EAAA,SAAA3uE,EAAA8D,GACA6qE,EAAAh3E,UAAAmM,KACAkL,EAAAlL,GAAA9D,KAGAgP,MACK,GAKL2/D,EAAAjvB,UAEAivB,EAAAh3E,UAAA+nD,OAAA,SAAA9iD,GACA,MAAAzF,MAAA+3E,WAAA,MAAAtyE,EAGAzF,KAAAyrF,KAAA,SAAA9lF,GACA,MAAA4iD,IAAA5iD,EAAAF,KAHA8iD,GAAAvoD,KAAA2F,UAgBA6xE,EAAAie,UAGAtb,IAAA,yEAAAxtE,GACA6qE,EAAA7qE,GAAAmqE,YAAAU,IAIA2C,IAAA,qCAAAxtE,EAAAhM,GACA,GAAAkkB,GAAAlkB,GAAA64E,EACAkc,EAAA/0F,GAAAg1F,CAEAle,GAAAj3E,UAAAmM,GAAA,SAAAuqE,EAAAj2C,GACA,GAAAz9B,GAAAxD,KAAA8N,QACA8nF,EAAApyF,EAAA00E,aACAM,EAAAh1E,EAAA20E,gBAAA30E,EAAA20E,iBAIA,OAFA30E,GAAA00E,aAAA0d,GAAA/wE,GAAA6wE,GAAAlyF,EAAAw0E,QAAA,EACAQ,EAAAhlE,MAAwB0jE,SAAAwM,GAAAxM,EAAAj2C,EAAA,GAAAl2B,KAAApK,IACxB6C,KAKA22E,IAAA,wBAAAxtE,EAAAhM,GACA,GAAAk1F,GAAA,KAAAlpF,EAAA,UACAmpF,EAAAnpF,EAAA,OAEA8qE,GAAAj3E,UAAAmM,GAAA,SAAAlH,GACAA,EAAA,MAAAA,EAAA,EAAAy9E,GAAAxuE,GAAAjP,IAAA,IAEA,IAAAjC,GAAAxD,KAAA8N,OACA,IAAAtK,EAAA00E,aAAA,CACA,GAAAvyE,GAAAnC,EAAAqyF,EACAryF,GAAAqyF,GAAAl1F,EAAAw4E,GAAAxzE,EAAAF,GAAAE,EAAAF,MACS,CACT,GAAAgzE,GAAAj1E,EAAA80E,YAAA90E,EAAA80E,aACAG,GAAAjlE,MAAsB8rC,KAAA75C,EAAAsF,KAAA4B,GAAAnJ,EAAAw0E,QAAA,gBAEtB,MAAAx0E,IAGAi0E,EAAAj3E,UAAAmM,EAAA,kBAAAlH,GACA,MAAAzF,MAAAsK,UAAAqC,GAAAlH,GAAA6E,WAGAmtE,EAAAj3E,UAAAmM,EAAA,uBAAAkM,EAAAooB,GACA,MAAAjhC,MAAAsK,UAAAwrF,GAAAj9E,EAAAooB,GAAA32B,aAKA6vE,IAAA,yBAAAxtE,EAAAhM,GACA,GAAAo1F,GAAA,QAAAp1F,EAAA,WAEA82E,GAAAj3E,UAAAmM,GAAA,WACA,MAAA3M,MAAA+1F,GAAA,GAAApwF,QAAA,MAKAw0E,IAAA,2BAAAxtE,EAAAhM,GACA,GAAAq1F,GAAA,QAAAr1F,EAAA,WAEA82E,GAAAj3E,UAAAmM,GAAA,WACA,MAAA3M,MAAAg2F,GAAA,MAKA7b,IAAA,0BAAAxtE,EAAAhM,GACA,GAAAs1F,GAAAt1F,EAAA,eACAu1F,EAAAv1F,EAAAy7E,GAAAC,EAEA5E,GAAAj3E,UAAAmM,GAAA,SAAAhH,GACA,MAAA3F,MAAAi2F,GAAAC,EAAAvwF,OAIA8xE,EAAAj3E,UAAA8pF,QAAA,WACA,MAAAtqF,MAAAmP,OAAApG,KAGA0uE,EAAAj3E,UAAAqO,UAAA,SAAAqoE,EAAAj2C,GACA,GAAA5jB,EAEA,OADA65D,GAAAwM,GAAAxM,EAAAj2C,EAAA,GACAjhC,KAAAmP,OAAA,SAAAxJ,EAAAhF,EAAA+jB,GACA,MAAArH,QAAA65D,EAAAvxE,EAAAhF,EAAA+jB,OAIA+yD,EAAAj3E,UAAAoU,OAAA,SAAAsiE,EAAAj2C,GAEA,MADAi2C,GAAAwM,GAAAxM,EAAAj2C,EAAA,GACAjhC,KAAAmP,OAAA,SAAAxJ,EAAAhF,EAAA+jB,GACA,OAAAwyD,EAAAvxE,EAAAhF,EAAA+jB,MAIA+yD,EAAAj3E,UAAAC,MAAA,SAAAsU,EAAAge,GACAhe,EAAA,MAAAA,EAAA,GAAAA,GAAA,CACA,IAAAvR,GAAA,EAAAuR,EAAA/U,KAAAgrF,WAAAj2E,GAAA/U,KAAA4O,KAAAmG,EAMA,OAJA,mBAAAge,KACAA,MAAA,EACAvvB,EAAA,EAAAuvB,EAAAvvB,EAAA+mF,WAAAx3D,GAAAvvB,EAAAwS,KAAA+c,EAAAhe,IAEAvR,GAGAi0E,EAAAj3E,UAAAmuF,QAAA,WACA,MAAA3uF,MAAA4O,KAAA,IAIAsuE,GAAAzF,EAAAj3E,UAAA,SAAAqI,EAAA8D,GACA,GAAAwpF,GAAA3e,EAAA7qE,GACAypF,EAAA,mBAAAlpF,KAAAP,EAEA6qE,GAAAh3E,UAAAmM,GAAA,WACA,GAAAhH,GAAA3F,KAAA63E,YACA/3E,EAAAC,UACA63E,EAAA53E,KAAA+3E,UACAse,IAAAr2F,KAAA83E,YAAAh1E,OACAwzF,EAAA3wF,YAAA8xE,GACA8e,EAAAD,IAAAD,CAEA,IAAAD,IAAAxe,EACA,MAAA2e,GACA1tF,EAAAnI,KAAAiF,GACAwwF,EAAAz1F,KAAA82E,EAAAx3E,KAAA2F,QAEA,IAAA6lF,GAAA,SAAA7lF,GACA,GAAA6wF,IAAA7wF,EAEA,OADA6N,IAAAvS,MAAAu1F,EAAA12F,GACAq2F,EAAAl1F,MAAAu2E,EAAAgf,GAEA,IAAAF,GAAApxF,GAAAS,GAAA,CACA,GAAAsR,GAAAs/E,EAAA5wF,EAAA,GAAA8xE,GAAAz3E,MACAwD,EAAAqF,EAAA5H,MAAAgW,EAAAnX,EAEA,KAAAs2F,IAAAC,GAAA7yF,EAAAs0E,aAAA,CACA,GAAA1P,GAAA5kE,EAAAs0E,cAAAt0E,EAAAs0E,eACA1P,GAAA50D,MAA0B3K,KAAA4iF,GAAA3rF,MAAA0rF,GAAAvqD,QAAAu2C,IAE1B,UAAAE,GAAAl0E,EAAAo0E,GAEA,MAAA53E,MAAAyrF,KAAAD,MAKArR,IAAA,yEAAAxtE,GACA,GAAA9D,GAAAwqF,GAAA1mF,GACA8pF,EAAA,0BAAAvpF,KAAAP,GAAA,aACAypF,EAAA,uBAAAlpF,KAAAP,EAEA6qE,GAAAh3E,UAAAmM,GAAA,WACA,GAAA7M,GAAAC,SACA,OAAAq2F,KAAAp2F,KAAA+3E,UACAlvE,EAAA5H,MAAAjB,KAAA2F,QAAA7F,GAEAE,KAAAy2F,GAAA,SAAA9wF,GACA,MAAAkD,GAAA5H,MAAA0E,EAAA7F,QAMA23E,EAAAj3E,UAAAsN,MAAAyqE,EACAd,EAAAj3E,UAAA8J,QAAAquE,EACAlB,EAAAj3E,UAAAmF,MAAAizE,EAGApB,EAAAh3E,UAAA6Y,MAAAqyE,GACAlU,EAAAh3E,UAAAk2F,OAAA/K,GACAnU,EAAAh3E,UAAAm2F,MAAA/K,GACApU,EAAAh3E,UAAA8J,QAAAuhF,GACArU,EAAAh3E,UAAA6E,SAAAymF,GACAtU,EAAAh3E,UAAA2zB,IAAAqjD,EAAAh3E,UAAA01C,OAAAshC,EAAAh3E,UAAA4vB,QAAAonD,EAAAh3E,UAAAmF,MAAAomF,GAGAvU,EAAAh3E,UAAA00F,QAAA1d,EAAAh3E,UAAA0R,IACAslE,EAAAh3E,UAAA+Z,KAAAi9D,EAAAh3E,UAAA+N,MACAipE,EAAAh3E,UAAA60F,OAAA7d,EAAAh3E,UAAA2O,OACAqoE,EAAAh3E,UAAAuV,KAAAyhE,EAAAh3E,UAAA20D,KAEAqiB,EAx7VA,GAAAxsE,GAGAyqF,EAAA,QAGA1Z,EAAA,EACA8J,EAAA,EACAO,EAAA,EACAD,EAAA,EACAE,EAAA,GACAX,EAAA,GACAC,EAAA,GACA6D,EAAA,IACAtD,EAAA,IAGAgM,EAAA,GACAE,EAAA,MAGAkC,EAAA,IACAD,EAAA,GAGA7a,EAAA,EACAD,EAAA,EACAoc,EAAA,EAGArY,EAAA,sBAGAtG,EAAA,yBAGA8F,EAAA,qBACA6C,EAAA,iBACAyH,EAAA,mBACAC,EAAA,gBACAC,EAAA,iBACA1K,EAAA,oBACAga,EAAA,eACArP,EAAA,kBACA1K,GAAA,kBACA2K,GAAA,kBACAqP,GAAA,eACApP,GAAA,kBACAqP,GAAA,mBAEA5O,GAAA,uBACAC,GAAA,wBACAC,GAAA,wBACAC,GAAA,qBACAC,GAAA,sBACAC,GAAA,sBACAC,GAAA,sBACAC,GAAA,6BACAC,GAAA,uBACAC,GAAA,uBAGAkJ,GAAA,iBACAC,GAAA,qBACAC,GAAA,gCAGAU,GAAA,gCACA1C,GAAA,YACAyC,GAAA7yF,OAAA8yF,GAAA56E,QACAi4E,GAAAnwF,OAAAowF,GAAAl4E,QAGAq8E,GAAA,mBACAC,GAAA,kBACAjD,GAAA,mBAOAC,GAAA,kCAGAtI,GAAA,OAGAK,GAAA,2BAGA4L,GAAA,SAGArG,GAAA,8BAGAoB,GAAA,0CAGAmB,GAAA,OAOAd,GAAA,wBACAD,GAAAtwF,OAAAuwF,GAAAr4E,QAGAsxE,GAAA,WAGAwI,GAAA,yBAGAe,GAAA,WACA,GAAAqE,GAAA,8BACAC,EAAA,8BAEA,OAAAr3F,QAAAo3F,EAAA,UAA+BA,EAAAC,EAAA,KAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,mBAI/BlC,GAAA,0CAYAzB,IACA,mEACA,iEACA,+DACA,4DACA,0DACA,uBAIA9B,GAAA,GAGA5C,KACAA,IAAAvG,IAAAuG,GAAAtG,IACAsG,GAAArG,IAAAqG,GAAApG,IACAoG,GAAAnG,IAAAmG,GAAAlG,IACAkG,GAAAjG,IAAAiG,GAAAhG,IACAgG,GAAA/F,KAAA,EACA+F,GAAA5R,GAAA4R,GAAA/O,GACA+O,GAAAxG,IAAAwG,GAAAtH,GACAsH,GAAArH,GAAAqH,GAAApH,GACAoH,GAAA9R,GAAA8R,GAAAkI,GACAlI,GAAAnH,GAAAmH,GAAA7R,IACA6R,GAAAlH,IAAAkH,GAAAmI,IACAnI,GAAAjH,IAAAiH,GAAAoI,KAAA,CAGA,IAAA/Z,MACAA,IAAAD,GAAAC,GAAA4C,GACA5C,GAAAmL,IAAAnL,GAAAqK,GACArK,GAAAsK,GAAAtK,GAAAoL,IACApL,GAAAqL,IAAArL,GAAAsL,IACAtL,GAAAuL,IAAAvL,GAAAwL,IACAxL,GAAAwK,GAAAxK,GAAAF,IACAE,GAAAyK,IAAAzK,GAAA0K,IACA1K,GAAAyL,IAAAzL,GAAA0L,IACA1L,GAAA2L,IAAA3L,GAAA4L,KAAA,EACA5L,GAAAuK,GAAAvK,GAAAH,GACAG,GAAA6Z,GAAA7Z,GAAA8Z,IACA9Z,GAAA+Z,KAAA,CAGA,IAAA3I,KACAX,SAAA,EACAF,QAAA,EACAD,UAAA,GAIAlX,IACA8gB,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,MAIAxkB,IACAykB,IAAA,QACAC,IAAA,OACAC,IAAA,OACAC,IAAA,SACAC,IAAA,QACAC,IAAA,SAIA9jB,IACA+jB,QAAU,IACVC,OAAS,IACTC,OAAS,IACTC,SAAW,IACXC,QAAU,IACVC,QAAU,KAIVC,IACAC,YAAA,EACAzhF,QAAA,GAIAq8D,IACAqlB,KAAA,KACAV,IAAA,IACAW,KAAA,IACAC,KAAA,IACAC,SAAA,QACAC,SAAA,SASAxiC,GAAAkiC,SAAA18F,oBAAAe,WAAAf,eAAAe,KAGAk8F,GAAAP,SAAAh9F,WAAAuK,UAAAvK,EAGAw9F,GAAAR,SAAAj9F,WAAAwK,UAAAxK,EAGA09D,GAAA8/B,IAAAC,IAAA,gBAAArkF,OACAskD,OAAAtkD,SAAAskD,OAAAn9D,SAAAm9D,OAAAj3C,OAAAi3C,KACA3C,GAAA2C,GAIA,IAsrVAh5C,KAtrVA+4E,OAAAx9F,UAAAu9F,OAsrVA3kB,IAQA9d;GAAAr2C,KAIAo2C,EAAA,WACA,MAAAp2C,KACK1iB,KAAA/B,EAAAC,EAAAD,EAAAD,KAAA86D,IAAAxuD,IAAAtM,EAAAC,QAAA66D,MAiBJ94D,KAAAV,Q1Do1pB6BU,KAAK/B,EAASC,EAAoB,IAAIF,GAAU,WAAa,MAAOsB,WAI5Fo8F,IACA,SAAS19F,EAAQC,EAASC,G2Dj0/BhC,GAAAy9F,GAAAz9F,EAAA,IAEAD,GAAAqxD,KAAA,WACA,SAAA5nD,OAAA,6CAGAzJ,EAAA4rE,UAAA,SAAA7gB,EAAAtf,GACA,GAAAkyD,GAAAD,EAAAhuB,OAAA3kB,GACAjoC,EAAA,GAAAC,WACAD,GAAAE,OAAA,WACAyoB,EAAA,KAAA3oB,EAAAje,SAEAie,EAAAG,QAAA,WACAwoB,EAAA,GAAAhiC,OAAA,oBAEAqZ,EAAAK,WAAA,GAAAy6E,OAAA7yC,IAAA4yC,K3D20/BME,IACA,SAAS99F,EAAQC,EAASC,G4Dx1/BhC,QAAA+uE,KACA3tE,KAAA8f,MAAA,WACA9f,KAAAspE,OAAA,YACAtpE,KAAAupE,MAAA,WACAvpE,KAAAqpE,aACArpE,KAAAwpE,cACAxpE,KAAAy8F,WAAA,EACAz8F,KAAA+uC,MAAA,EAVA,GAAAtvC,GAAAb,EAAA,IACAF,GAAAC,QAAAgvE,EAYAA,EAAA5G,aAAA,SAAAf,GACA,GAAAxrC,GAAA,GAAAmzC,GACA7tD,EAAAkmD,EAAArJ,QAAA1sD,IAAA,SACAq5D,EAAAtD,EAAArJ,QAAA1sD,IAAA,UACAs5D,EAAAvD,EAAArJ,QAAA1sD,IAAA,SACAwsF,GAAAz2B,EAAArJ,QAAA1sD,IAAA,cACA8+B,GAAAi3B,EAAArJ,QAAA1sD,IAAA,aACAo5D,EAAArD,EAAArJ,QAAAW,OAAA,YACAkM,EAAAxD,EAAArJ,QAAAW,OAAA,YACA,oBAAAx9C,KAAAupD,EAAA,CACA,GAAAqzB,GAAA,SAAAlhF,GACAsE,EAAAtE,EAAA,GACA6tD,GAAA7tD,EAAA,IAEA/b,GAAAqgB,GACAw+C,KAAA,qBAAAo+B,GACAp+B,KAAA,qBAAAo+B,GACAp+B,KAAA,uBAAAo+B,GACAp+B,KAAA,uBAAAo+B,GACAp+B,KAAA,qBAAAo+B,GASA,MAPA58E,KAAA0a,EAAA1a,SACAwpD,IAAA9uC,EAAA8uC,UACAC,IAAA/uC,EAAA+uC,SACAF,IAAA7uC,EAAA6uC,aACAG,IAAAhvC,EAAAgvC,cACAizB,IAAAjiE,EAAAiiE,cACA1tD,IAAAvU,EAAAuU,SACAvU,I5Dq2/BMmiE,IACA,SAASj+F,G6D/2/Bf,QAAAk+F,GAAAn6F,GACA,GAAAo6F,GAAA,aAAAC,EAAA,MAAAlqB,EAAA,MAAAmqB,EAAA,KAAA/uE,EAAAjpB,KAAAipB,IAAAvrB,EACA,OAAAurB,IAAA6uE,EAAA93F,KAAAkiD,MAAAxkD,EAAAo6F,EAAA,cACA7uE,GAAA8uE,EAAA/3F,KAAAkiD,MAAAxkD,EAAAq6F,EAAA,cACA9uE,GAAA4kD,EAAA7tE,KAAAkiD,MAAAxkD,EAAAmwE,EAAA,cACA5kD,GAAA+uE,EAAAh4F,KAAAkiD,MAAAxkD,EAAAs6F,EAAA,cACAt6F,EAAA,IA9BA/D,EAAAC,QAAA,SAAA2gD,GACA,mBAAAA,GAAA,MAAAs9C,GAAAt9C,EACA,IAAAnmC,GAAAmmC,EAAA7/C,MAAA,oCACAgG,EAAA+qB,WAAArX,EAAA,IACApO,EAAAoO,EAAA,GAEAjH,GACA6qF,GAAA,KACAnqB,GAAA,MACAkqB,GAAA,MACAD,GAAA,aAGA,OAAA3qF,GAAAnH,GAAAtF,I7Dy6/BMu3F,IACA,SAASt+F,EAAQC,EAASC,G8Dh8/BhCD,EAAAD,EAAAC,QAAAC,EAAA,MACAD,EAAA6U,MAAA9U,EAAA01B,GAAA,iGAAyGx1B,EAAA,umGAA4oG,M9Ds8/B/uGq+F,IACA,SAASv+F,EAAQC,EAASC,G+Dx8/BhCF,EAAAC,QAAAC,EAAAwL,EAAA,wC/D88/BM8yF,IACA,SAASx+F,GgE/8/BfA,EAAAC,SAAgBqD,EAAA,EAAAq8B,IAAYA,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,iBAAwBl6F,IAAOo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,uBAA8Bl6F,IAAOo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,2BAAkCl6F,IAAOo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,kCAAyCl6F,IAAOo7B,EAAA,EAAA58B,EAAA,iBAA2B48B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,kCAAyCl6F,IAAOo7B,EAAA,EAAA58B,EAAA,iBAA2B48B,EAAA,EAAA58B,EAAA,iBAAAwB,IAAiCo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,qCAA4Cl6F,IAAOo7B,EAAA,EAAA58B,EAAA,UAAoB48B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,mCAA0Cl6F,IAAOo7B,EAAA,EAAA58B,EAAA,kBAA4B48B,EAAA,EAAA58B,EAAA,kBAAAwB,IAAkCo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,sCAA6Cl6F,IAAOo7B,EAAA,EAAA58B,EAAA,cAAwB48B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,0BAAiCl6F,IAAOo7B,EAAA,EAAA58B,EAAA,QAAAwB,IAAwBo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,gCAAuCl6F,IAAOo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,8BAAqCl6F,IAAOo7B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqBxD,OAAA,UAAmBq/B,EAAA,EAAA58B,EAAA,UAAkB07F,QAAA,uCAAiD9+D,EAAA,EAAA58B,EAAA,SAAmB48B,EAAA,EAAA98B,EAAA,OAAAiB,GAAsB26F,QAAA,wCAA+Cl6F,IAAOo7B,EAAA,EAAA58B,EAAA,qBAA+B48B,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,0BAAkC9+D,EAAA,EAAA98B,EAAA,MAAAiB,GAAqB26F,QAAA,8BhEq9/BlvCC,IACA,SAAS1+F,EAAQC,EAASC,GiEt9/BhC,GAAA46D,IAUA,SAAA1hD,GAEA,YAEA,IAAA2W,GAAA3W,EAAA21D,QAGA19B,EAAA,WAEA,GAAAstD,IAEAt2F,GAAA,OACA0G,QAAA,EAEA+/D,UACAxrE,EAAA,EACAq8B,MAEAi/D,QAAA,KAEAC,oBAAA,EACAC,UAAA,EACAC,eAAA,EAEA/9E,QACApT,YACAi4D,OAAA,EACAm5B,cAAA,EACApjC,SACAqjC,UAAA,EACAC,QAAA,EACA94B,MAAA,EAEA+4B,SAAA,EACAC,oBAAA,EACAzgE,SAAA,OAEA0gE,gBAAA,EAEAz8F,OAAA,EAEA,OAAA+7F,MAIAW,GACAC,OAAA,SAAA33E,GACA,MAAAA,IAEA43E,OAAA,SAAA53E,GACA,MAAAvhB,MAAAgpB,IAAAzH,EAAA,IAEA63E,QAAA,SAAA73E,GACA,MAAAvhB,MAAAgpB,IAAAzH,EAAA,QAEA83E,UAAA,SAAA93E,GACA,OAAAA,GAAA,MACA,GAAAvhB,KAAAgpB,IAAAzH,EAAA,GAEA,IAAAvhB,KAAAgpB,IAAAzH,EAAA,UAKA+3E,KAGAviE,EAAA12B,OAAA5E,UAAA2I,eAGAjE,EAAA,WAEA,GAAAG,GAAAD,OAAA5E,UAAA6E,QAEA,iBAAAi5F,GACA,yBAAAj5F,EAAA3E,KAAA49F,OAKA1gF,EAAA,WAEA,GAAAvY,GAAAD,OAAA5E,UAAA6E,QACA,iBAAAi5F,GACA,MAAAA,IAAA,oBAAAj5F,EAAA3E,KAAA49F,OAKAC,EAAA,SAAAD,GACA,OAAAx4E,MAAA0K,WAAA8tE,KAAAtxE,SAAAsxE,IAIAE,EAAA,SAAAH,EAAAl1F,EAAAjE,EAAA0Y,EAAA2gF,GAEA,GAAAC,GAAAzN,EAAA0N,CAoFA,OAnFAJ,GAAA7qF,KAAA,WACAu9E,EAAAsN,EAAAtN,cAEA0N,EAAA,2DACAD,GACA54E,OAAA,SAAA9gB,EAAAyC,GACA,GAAAgzD,EACA,OAAAgkC,GAAAz5F,IAAAy5F,EAAAh3F,IAGAzC,KACAyC,KACAgzD,EAAAhzD,EAAAzC,EACAy1D,EAKA,SAAAl8B,GACA,MAAAv5B,GAAAu5B,EAAAk8B,GALA,WACA,MAAAz1D,KAPA,MAcA4f,MAAA,SAAA5f,EAAAyC,GACA,GAAAm3F,GAAAF,EAAA56F,EAAAqa,CACA,KAAA/Y,EAAAJ,KAAAI,EAAAqC,GACA,WAKA,KAHAm3F,KACAF,KACAvgF,EAAAra,EAAAmB,KAAAe,IAAAhB,EAAAhC,OAAAyE,EAAAzE,QACAmb,KACAugF,EAAAvgF,GAAA8yE,EAAAjsF,EAAAmZ,GAAA1W,EAAA0W,GAGA,KAAAA,EAAAra,EAAkBqa,EAAAnZ,EAAAhC,OAAiBmb,GAAA,EACnCygF,EAAAzgF,GAAAnZ,EAAAmZ,EAEA,KAAAA,EAAAra,EAAkBqa,EAAA1W,EAAAzE,OAAemb,GAAA,EACjCygF,EAAAzgF,GAAA1W,EAAA0W,EAEA,iBAAAogB,GAEA,IADA,GAAApgB,GAAAra,EACAqa,KACAygF,EAAAzgF,GAAAugF,EAAAvgF,GAAAogB,EAEA,OAAAqgE,KAGAvkF,OAAA,SAAArV,EAAAyC,GACA,GAAAqnF,GAAAhrF,EAAA46F,EAAAE,EAAAl1F,CACA,KAAAoU,EAAA9Y,KAAA8Y,EAAArW,GACA,WAEAqnF,MACA8P,KACAF,IACA,KAAAh1F,IAAA1E,GACAqE,EAAAzI,KAAAoE,EAAA0E,KACAL,EAAAzI,KAAA6G,EAAAiC,IACAolF,EAAAp7E,KAAAhK,GACAg1F,EAAAh1F,GAAAunF,EAAAjsF,EAAA0E,GAAAjC,EAAAiC,KAEAk1F,EAAAl1F,GAAA1E,EAAA0E,GAIA,KAAAA,IAAAjC,GACA4B,EAAAzI,KAAA6G,EAAAiC,KAAAL,EAAAzI,KAAAoE,EAAA0E,KACAk1F,EAAAl1F,GAAAjC,EAAAiC,GAIA,OADA5F,GAAAgrF,EAAA9rF,OACA,SAAAu7B,GAGA,IAFA,GACA70B,GADAyU,EAAAra,EAEAqa,KACAzU,EAAAolF,EAAA3wE,GACAygF,EAAAl1F,GAAAg1F,EAAAh1F,GAAA60B,EAEA,OAAAqgE,OAKEL,EAAAviE,EAAA52B,EAAA0Y,EAAA2gF,GAGFI,EAAA,WAEA,GAAAA,EAMA,OAJAA,GADA,mBAAA7/F,WACA,EAEAA,mBAAA8/F,eAAAC,WAAA,8DAMAn4D,EAAA,WAGA,GAAAA,GAAA66B,IAcA,OAZA76B,GADA,mBAAAxnC,UAAA,kBAAAA,SAAAwnC,MAAA,kBAAAxnC,SAAAwnC,KAAAzlC,MACA,SAAAmhC,EAAA08D,GACA,IAAAA,EAAA,CACA,GAAAv9B,EAAAn/B,GACA,MAEAm/B,GAAAn/B,IAAA,EAEAljC,QAAAwnC,KAAA,mBAAAtE,EAAA,4BAA0E,4BAG1E,gBAMAiB,GACA07D,cAAA,6GACAC,oBAAA,wEACAC,0BAAA,yFACAC,qBAAA,+CACAC,iBAAA,+DACAC,gBAAA,2CACAC,aAAA,8EACAC,kBAAA,mCACAC,cAAA,+HACAC,qBAAA,oGACAC,yBAAA,mFACAC,mBAAA,+EACAC,6BAAA,+FACAC,iBAAA,kMAIA7+F,EAAA,SAAA8+F,EAAAx8D,GAiCA,QAAAy8D,GAAA/vD,GACA,GAAA3N,GAAAiB,EAAA0M,EAAA3N,UAAA2N,EAAA3N,SAAA,EACA,OAAA2uD,GAAA3uD,EAAA2N,EAAAjwC,MAIA,QAAAixF,GAAA3uD,EAAAtiC,GACA,MAAAsiC,GAAAvhC,QAAA,cAAsC,SAAA2B,EAAAC,GACtC,MAAA3C,GAAA2C,KAvCA,GAAA1B,IACA2lC,KAAA,SAAAqJ,EAAAgwD,IACAhwD,EAAAzuC,OAAAy+F,IAGA//F,KAAAggG,WAAAjwD,IAEAiwD,WAAA,SAAAjwD,GACA/vC,KAAAigG,OAAAH,EAAA/vD,KAAA+uD,kBAEA/4D,MAAA,SAAAgK,GACA/vC,KAAAkgG,UAAAnwD,GACAA,EAAAzuC,OACAtB,KAAA0mC,KAAAqJ,GAAA,IAGAmwD,UAAA,SAAAnwD,GACAA,EAAAzuC,OACAtB,KAAAmgG,SAAApwD,IAGAowD,SAAA,SAAApwD,GACA,GAAA3yB,GAAA2yB,EAAA3yB,KAAA,GAAAhV,OAAA03F,EAAA/vD,GACA/vC,MAAA2tC,QAAAvwB,IAEA6iF,OAAAJ,EACAlyD,QAAA,SAAAvwB,GACA,KAAAA,IAeA,OAAArc,IACE2lC,EAAArD,GAGF+8D,EAAA,SAAAr/F,GAiBA,QAAAs/F,GAAA/rE,GACAt0B,KAAAs0B,QACAt0B,KAAAiR,OAAA,KAAAqjB,EACAt0B,KAAAm3D,UAAAmpC,EAAAhsE,GAlBA,GAAAgsE,IACA7jF,WACA6kD,WAAA,aACApsD,YAAA,eAEAqrF,QACAj/B,WAAA,OACAl/B,QAAA,6WAEA/E,UACAikC,WAAA,WACApsD,YAAA,cA0BA,OAjBAmrF,GAAA7/F,UAAAggG,KAAA,SAAAC,EAAA52F,GACA,QAAAnJ,GAAAuQ,GACA,MAAAwvF,GAAAxvF,IACApH,EAAA42F,EAAAxvF,GAAApH,GAAA42F,EAAAxvF,MACA,GAFA,OAKAvQ,EAAAV,KAAAiR,SACAwvF,EAAAzgG,KAAAiR,SAAAjR,KAAAm3D,WAAAz2D,EAAAV,KAAAm3D,UAAAmK,aACAvgE,EAAAi/F,YACA1+F,MAAAm/F,EAAAn/F,MACA8gC,QAAApiC,KAAAm3D,UAAA/0B,SAAA,mBACAtiC,KAAAE,KAAAm3D,YAGAttD,EAAA42F,EAAAD,KAAAxgG,KAAAs0B,MAAAzqB,GAAA42F,EAAAD,KAAAxgG,KAAAs0B,QAEA+rE,GACEt/F,GAGF2/F,EAAA,SAAAh8E,EAAAi8E,GACA,GAAAhgG,GAAA+jB,EAAA/T,QAAAgwF,EACA,MAAAhgG,GACA+jB,EAAA5jB,OAAAH,EAAA,IAKAmc,EAAA,WA2GA,QAAAugE,GAAAjzC,GACAvqB,WAAAuqB,EAAA,GAGA,QAAAw2D,GAAAC,EAAAr9F,GACA,kBAEA,IADA,GAAAgtC,GACAA,EAAAqwD,EAAAjhF,SACA4wB,EAAAhtC,IAKA,QAAAuZ,GAAAgB,EAAApa,EAAAm9F,EAAAlsF,GAEA,GAAAhP,EAEA,IAAAjC,IAAAoa,EACA,SAAA5X,WAAA,iEAGA,IAAAxC,YAAAo9F,GACAp9F,EAAAiC,KAAAk7F,EAAAlsF,OACI,KAAAjR,GAAA,gBAAAA,IAAA,kBAAAA,GAwCJm9F,EAAAn9F,OAxCI,CACJ,IACAiC,EAAAjC,EAAAiC,KACK,MAAArE,GAGL,WAFAqT,GAAArT,GAKA,qBAAAqE,GAAA,CACA,GAAAsE,GAAA82F,EAAAC,CACAD,GAAA,SAAAtxE,GACAxlB,IAGAA,GAAA,EACA6S,EAAAgB,EAAA2R,EAAAoxE,EAAAlsF,KAEAqsF,EAAA,SAAAx/F,GACAyI,IAGAA,GAAA,EACA0K,EAAAnT,IAEA,KACAmE,EAAAlF,KAAAiD,EAAAq9F,EAAAC,GACM,MAAA1/F,GACN,IAAA2I,EAKA,MAHA0K,GAAArT,QAEA2I,GAAA,QAKA42F,GAAAn9F,IArKA,GAAAu9F,GACAH,EAAA/tD,KACAmuD,KACAC,IAwKA,OAvKA,kBAAAtkF,GAEAikF,EAAAjkF,GAEAikF,EAAA,SAAA32D,GACA,GAGA5mC,GAAA69F,EAAAC,EAAAR,EAAAlsF,EAAAmJ,EAHAwjF,KACAC,KACAhsE,EAAAwd,CAEAsuD,GAAA,SAAAG,GACA,gBAAA97F,GACA6vB,IAAAwd,IAGAxvC,EAAAmC,EACA6vB,EAAAisE,EACAJ,EAAAT,EAAAprE,IAAA2rE,EAAAI,EAAAC,EAAAh+F,GAEA65E,EAAAgkB,MAGAP,EAAAQ,EAAAH,GACAvsF,EAAA0sF,EAAAF,EACA,KACAh3D,EAAA02D,EAAAlsF,GACK,MAAAwI,GACLxI,EAAAwI,GAsCA,MApCAW,IAEAnY,KAAA,SAAAoX,EAAAG,GACA,GAAAukF,GAAA,GAAAX,GAAA,SAAAD,EAAAlsF,GACA,GAAA+sF,GAAA,SAAAnxD,EAAAqwD,EAAAe,GAGAf,EAAArtF,KADA,kBAAAg9B,GACA,SAAAqxD,GACA,GAAAl+F,EACA,KACAA,EAAA6sC,EAAAqxD,GACA9kF,EAAA2kF,EAAA/9F,EAAAm9F,EAAAlsF,GACW,MAAAwI,GACXxI,EAAAwI,KAMAwkF,GAIAD,GAAA3kF,EAAAukF,EAAAT,GACAa,EAAAxkF,EAAAqkF,EAAA5sF,GACA4gB,IAAAwd,GAEAqqC,EAAAgkB,IAGA,OAAAK,KAGA3jF,EAAA,kBAAAZ,GACA,MAAAnd,MAAA4F,KAAA,KAAAuX,IAEAY,GAEAgjF,EAAAzzF,IAAA,SAAA0Q,GACA,UAAA+iF,GAAA,SAAAD,EAAAlsF,GACA,GACA2hC,GAAAt4B,EAAA6jF,EADAt+F,IAEA,KAAAwa,EAAAlb,OAEA,WADAg+F,GAAAt9F,EAYA,KATAs+F,EAAA,SAAA7jF,GACAD,EAAAC,GAAArY,KAAA,SAAAD,GACAnC,EAAAya,GAAAtY,IACA4wC,GACAuqD,EAAAt9F,IAEOoR,IAEP2hC,EAAAt4B,EAAAD,EAAAlb,OACAmb,KACA6jF,EAAA7jF,MAIA8iF,EAAAhkF,QAAA,SAAApX,GACA,UAAAo7F,GAAA,SAAAD,GACAA,EAAAn7F,MAGAo7F,EAAAnsF,OAAA,SAAA4uB,GACA,UAAAu9D,GAAA,SAAAD,EAAAlsF,GACAA,EAAA4uB,OAIA09D,EAAAH,KAwEAgB,EAAA,WAEA,GAAA9sF,GAAA,mCACA,iBAAAowD,GACA,OAAAA,GAAA,IAAAxkE,QAAAoU,EAAA,WAKA+sF,EAAA,SAAAC,GACA,EACA,IAAAj3F,SAAAi3F,EAAA37F,QACA,MAAA27F,GAAA37F,cAEG27F,IAAAv+D,OACH,WAIA4qD,EAAA,SAAA9rF,EAAAC,GACA,cAAAD,GAAA,OAAAC,GACA,EAEA,gBAAAD,IAAA,gBAAAC,IACA,EAEAD,IAAAC,GAIAy/F,EAAA,SAAA7D,EAAA/P,GA0FA,QAAA6T,GAAAC,EAAAC,GACA,GAAA/1F,GAAA81F,EAAAE,aAAAD,EACA,QAAA/1F,KAAAsb,OA1FA,GAAA26E,EACAlE,GAAA7qF,KAAA,WACA,MAAA+uF,GAAAlE,EAAAkE,SAEA,IAAAC,GAAA,SAAA/B,EAAA4B,EAAAI,EAAAC,GACA,GAAAC,GAAA3iG,IACAA,MAAAy5D,KAAAgnC,EACAzgG,KAAAqiG,UACAriG,KAAAyiG,gBACAziG,KAAA0iG,eACA1iG,KAAA4iG,KAAA,WACA,MAAAD,GAAAE,UAAA,GAEA7iG,KAAA8iG,OAAA,WACA,MAAAH,GAAAE,UAAA,GAEA7iG,KAAA4N,OACA5N,KAAA2F,MAAA3F,KAAAy5D,KAAA2oC,UAAAnyF,IAAAjQ,KAAAqiG,SA2EA,OAzEAG,GAAAhiG,WACAuiG,SAAA,WACA,MAAA/iG,MAAA6iG,UAAA7iG,KAAAgjG,aAAAhjG,KAAAgjG,YAAAH,UAEAzW,QAAA,SAAA6W,EAAAt9F,GACA3F,KAAAkjG,gBAAAv9F,EAAAs9F,IAEAE,SAAA,SAAAx9F,GACA3F,KAAAkjG,gBAAAv9F,IAEAu9F,gBAAA,SAAAv9F,EAAAs9F,GACA,GAAAzqF,EAEA,OAAAxY,MAAA+iG,gBACA/iG,KAAA2F,cAGA2oF,EAAA3oF,EAAA3F,KAAA2F,SACA3F,KAAA4iG,OAIAL,EAAAa,aAAA5qF,EAAAxY,KAAAyiG,cAAAL,YAAApiG,KAAAgjG,YAAAr9F,WACA48F,EAAAc,aAAA,WACA,MAAAd,GAAAa,aAAA5qF,KAGAyqF,EACAzqF,EAAA8qF,YAAAtjG,KAAA0iG,aAAA/8F,EAAAs9F,GAEAd,EAAA3pF,EAAAxY,KAAA0iG,eACAlqF,EAAAxG,IAAAhS,KAAA0iG,aAAA/8F,GAGA3F,KAAA2F,QAGA48F,EAAAc,aAAArjG,KAAA8iG,WAGAS,YAAA,SAAAC,GACA,GACAhrF,GADAmqF,EAAA3iG,IAEAA,MAAA+iG,aAGA/iG,KAAA4iG,OACAL,EAAAa,aAAA5qF,EAAAxY,KAAAyiG,cAAAL,WACAoB,EAAAtxF,IAAA,SAAAmwF,GACA,MAAAM,GAAAD,aAAAL,EAAAh8D,OAAAs8D,EAAAN,QAAAv/F,UACKgN,QAAA,SAAAuyF,GACL,MAAA7pF,GAAA6jB,KAAAgmE,KAEAE,EAAAc,aAAArjG,KAAA8iG,UAEAl1F,KAAA,WACA5N,KAAAy5D,KAAA2oC,UAAAqB,SAAAzjG,KAAAqiG,QAAAriG,OAEA0jG,OAAA,SAAAC,GACA3jG,KAAA4jG,SACA5jG,KAAAqiG,QAAAsB,EACA3jG,KAAAgjG,YAAAN,aAAAiB,EACA3jG,KAAA4N,QAEAg2F,OAAA,WACA5jG,KAAAy5D,KAAA2oC,UAAAyB,WAAA7jG,KAAAqiG,QAAAriG,QAQA,SAAA8jG,EAAAC,EAAAC,EAAAC,GACA,GAAAzxC,GAAA0xC,EAAAC,EAAAC,EAAAC,CACA7xC,GAAAwxC,EAAA,IAAAC,EACAE,EAAAL,EAAAK,SACAA,EAAA3xC,KAIA0xC,EAAAJ,EAAAlgF,SACAwgF,EAAA,GAAA5B,GAAAuB,EAAAC,EAAAE,EAAAD,GACAE,EAAA3wF,KAAA4wF,GACAF,EAAAtG,SACAyG,EAAA,GAAA7B,GAAA0B,EAAAD,EAAAF,EAAAC,GACAG,EAAA3wF,KAAA6wF,GACAD,EAAApB,YAAAqB,EACAA,EAAArB,YAAAoB,GAEAD,EAAA3xC,GAAA4xC,KAEE/F,EAAA/P,GAGFgW,EAAA,SAAAvC,EAAAC,EAAAE,GAmFA,QAAAqC,GAAAC,EAAAn/B,GACA,GAAAo/B,EAEA,UAAAp/B,EACA,MAAAm/B,EAGA,IAFAC,EAAAD,IAAA7wF,MAAA,QAEA,QAAA0xD,EAAAh/B,OAAA,MACA,aAAAg/B,EAAAh/B,OAAA,OACA,IAAAo+D,EAAA3hG,OACA,SAAAsF,OAAAs8F,EAEAD,GAAApsF,MACAgtD,IAAA3vD,UAAA,GAGA,MADA+uF,GAAAjxF,KAAA6xD,GACAo/B,EAAAnzF,KAAA,KAGA,MAAAkzF,GAGAA,EAAAn/B,EAAAxkE,QAAA,aAFAwkE,EAAAxkE,QAAA,aArGA,GAAAqgG,GACAwD,EAAAC,CAwGA,OAvGAD,GAAA,wDACAC,GACAC,iBAAA,GAEA1D,EAAA,QAAAoD,GAAA7D,EAAAp7B,EAAA48B,EAAA4C,GACA,GAAAv+F,GAAA5B,EAAA/D,EAAA0hG,EAAAyC,EAAAC,EAAAC,EAAAC,EAAAjB,EAAAC,CAGA,IAFA5+B,EAAA08B,EAAA18B,GAEA,OAAAA,EAAAh/B,OAAA,KACA,MAAAg/B,GAAA3vD,UAAA,EAIA,UAAA2vD,EAAA/rD,OAAA,GACA,MAAAirF,GAAAvC,EAAAC,GAAA58B,EAGA3gE,GAAA2gE,EAAA1xD,MAAA,QAEAsuF,OACA,GAEA,IADA37F,EAAA27F,EAAA37F,QACAA,IAGAy+F,GAAA,EACAD,EAAArE,EAAA2B,UAAAnyF,IAAA3J,EAAAq+F,GACAG,IAAA,gBAAAA,IAAA,kBAAAA,KAAApgG,IAAAogG,IACA,MAAAx+F,GAAA,IAAA++D,QAEI48B,IAAAv+D,OAEJ,IAAAh/B,IAAA+7F,GAAA/gF,MAAAhb,IAAA+7F,GAAA2B,UAAAE,aACA,MAAAj9B,EAIA,IAAAo7B,EAAA77D,UAAA67D,EAAA9C,SAAA,CAIA,GAHAoH,GAAA,EACA9C,EAAAxB,EAAAqD,UAAAoB,eAEAjD,EAAAkD,WAAAn6F,UAAArK,EAAAshG,EAAAkD,UAAA9/B,IAKA,MAFAo7B,GAAAqD,UAAAsB,iBAAA//B,SACAo7B,GAAA2B,UAAApwF,IAAAqzD,EAAA1kE,GAAA,EAIA,IADA0hG,EAAAiC,EAAA7D,EAAA77D,QAAAygC,EAAA48B,GAAA,GACA,CAMA,IAFA+C,EAAA3C,EAAA1uF,MAAA,KACAsxF,EAAA5/B,EAAA1xD,MAAA,KACAqxF,EAAAliG,OAAA,GAAAmiG,EAAAniG,OAAA,GAAAkiG,IAAAliG,OAAA,KAAAmiG,IAAAniG,OAAA,IACAkiG,EAAA3sF,MACA4sF,EAAA5sF,KAMA,OAJA2rF,GAAAgB,EAAA1zF,KAAA,KACA2yF,EAAAgB,EAAA3zF,KAAA,KACAmvF,EAAA2B,UAAApwF,IAAAiyF,EAAAxD,EAAA77D,QAAAw9D,UAAAnyF,IAAA+zF,IAAA,GACA9B,EAAAzB,EAAAqD,UAAArD,EAAA77D,QAAAo/D,EAAAC,GACA5+B,GAKA,MAAAw/B,IAAAE,EAMA/5F,SAAAy1F,EAAA2B,UAAAnyF,IAAAo1D,GACAA,EADA,QAHAo7B,EAAA2B,UAAApwF,IAAAqzD,EAAAr6D,QACAq6D,KAgCE08B,EAAAC,EAAAE,GAGFmD,EAAA,SAAA3E,GAgDA,QAAA5zB,GAAAC,GACAA,EAAAD,SAGA,QAAAw4B,GAAAC,GACAA,EAAAD,cAGA,QAAAE,GAAAD,IACAA,EAAAE,OAAAF,EAAAG,OAAA5iG,QAAAyiG,EAAAI,gBAKAJ,EAAAK,iBACAL,EAAA7hE,OACA6hE,EAAA7hE,OAAAmiE,gBAAAN,GAEAA,EAAAD,cAEAC,EAAAK,gBAAA,GAIAL,EAAAO,OAAAhjG,QAAAyiG,EAAAQ,gBACA,kBAAAR,GAAAn7D,UACAm7D,EAAAn7D,WAEAm7D,EAAA7hE,QACA6hE,EAAA7hE,OAAAsiE,mBA3EA,GAAAX,GAAA,SAAAj7D,EAAA1G,GACA1jC,KAAAoqC,WACApqC,KAAA0jC,SACA1jC,KAAA8lG,UACA9lG,KAAA0lG,UACA1lG,KAAAo3D,YACAp3D,KAAA+lG,cAAA/lG,KAAA2lG,cAAA,EACA3lG,KAAAimG,eACAjmG,KAAA4lG,gBAAA,EACAliE,GACAA,EAAAwiE,SAAAlmG,MAqEA,OAlEAqlG,GAAA7kG,WACA0lG,SAAA,SAAA7+C,GACArnD,KAAAo3D,SAAA5jD,KAAA6zC,GACArnD,KAAA+lG,eAAA,EACA/lG,KAAA2lG,eAAA,GAEAE,gBAAA,WACA7lG,KAAA2lG,eAAA,EACAH,EAAAxlG,OAEAgmG,eAAA,WACAhmG,KAAA+lG,eAAA,EACAP,EAAAxlG,OAEAqN,IAAA,SAAA84F,GACA,GAAAvjG,GAAAujG,EAAAC,QAAApmG,KAAA8lG,OAAA9lG,KAAA0lG,MACA9iG,GAAA4Q,KAAA2yF,IAEArxF,OAAA,SAAAqxF,GACA,GAAAvjG,GAAAujG,EAAAC,QAAApmG,KAAA8lG,OAAA9lG,KAAA0lG,MACAhF,GAAA99F,EAAAujG,GACAX,EAAAxlG,OAEAwa,KAAA,WACAxa,KAAAylG,OAAA,EACAD,EAAAxlG,OAEAslG,YAAA,WACAtlG,KAAAimG,YAAAn2F,QAAAg9D,GACA9sE,KAAAo3D,SAAAtnD,QAAAw1F,KAqCAD,GACE3E,GAGF6B,EAAA,SAAAlE,EAAAgC,EAAAK,EAAA5jF,EAAAwnF,EAAAe,GAkFA,QAAAgB,KACA,GAAApoF,GAAAqgF,EAAAgI,CACA,KAAAroF,EAAA,EAAeA,EAAAsoF,EAAAC,WAAA1jG,OAA6Bmb,GAAA,EAC5CqgF,EAAAiI,EAAAC,WAAAvoF,GACAqoF,EAAAhI,EAAAmI,eACAH,GACAI,EAAAlG,KAAAlC,EAAAmC,QAAA6F,EAOA,KAJAC,EAAAC,WAAA1jG,OAAA,EACA6jG,IAGA1oF,EAAA,EAAeA,EAAAsoF,EAAA9tB,MAAA31E,OAAwBmb,GAAA,EACvCsoF,EAAA9tB,MAAAx6D,GAAA2oF,QAGA,KADAL,EAAA9tB,MAAA31E,OAAA,EACAmb,EAAA,EAAeA,EAAAsoF,EAAAt7B,MAAAnoE,OAAwBmb,GAAA,EACvCsoF,EAAAt7B,MAAAhtD,IAMA,OAJAsoF,GAAAt7B,MAAAnoE,OAAA,EAIAyjG,EAAAC,WAAA1jG,OACAujG,IADA,OAIA,QAAAM,KACA,GAAA1oF,GAAApZ,EAAAw9F,EAAAwE,CAGA,KAFA5oF,EAAA6oF,EAAAhkG,OAEAmb,KACApZ,EAAAiiG,EAAA7oF,GACApZ,EAAAw9F,SAGAyE,EAAAhmG,OAAAmd,EAAA,IAEAokF,EAAAiC,EAAAz/F,EAAA40D,KAAA50D,EAAAwgE,IAAAxgE,EAAAqgG,oBACA2B,WAAArzF,MACA3O,OACAw9F,YAEAyE,EAAAhmG,OAAAmd,EAAA,GAGA4oF,IACAA,EAAA/2F,QAAAiN,GAIA,QAAAA,GAAA8pF,GACAA,EAAAhiG,KAAAkY,QAAA8pF,EAAAxE,SArIA,GAAAnB,GACAqF,EAAAhE,EAAAuE,KACAJ,EAAA,GAAArG,GAAA,SAqIA,OApIAkC,IACAxtF,MAAA,SAAA6O,EAAAmjF,GACA,GAAAhpF,GAAAipF,CAiBA,OAhBAD,KACAhpF,EAAA,GAAAjB,GAAA,SAAA7Z,GACA,MAAA+jG,GAAA/jG,KAGAsjG,GACAU,cAAAV,EACAW,kBAAA,GAAA7B,GAAA2B,EAAAT,KAAAW,mBACAzuB,SACAxN,SACAu7B,cACA5iF,YAEAA,GACA2iF,EAAAC,WAAAhzF,KAAAoQ,EAAAw+E,WAEArkF,GAEAgV,IAAA,WACAszE,IACAE,EAAAW,kBAAA1sF,QACA+rF,EAAAU,eAAAV,EAAA3iF,WACA2iF,EAAA3iF,SAAAw+E,UAAA+E,YACAZ,IAAAU,eAEA7D,aAAA,SAAAhB,GACA,MAAAmE,GACA,KAAAA,EAAAC,WAAA71F,QAAAyxF,IACAmE,EAAAC,WAAAhzF,KAAA4uF,IACA,IAEA,GAGAA,EAAAqE,gBACA,IAGAW,mBAAA,SAAAjB,GACAA,EAAAkB,SAAAd,EAAAW,kBACAX,EAAAW,kBAAA75F,IAAA84F,IAEAmB,QAAA,SAAA76B,GACA85B,EAAA9tB,MAAAjlE,KAAAi5D,IAEA86B,cAAA,SAAAjJ,GACAwI,EAAAtzF,KAAA8qF,IAEAkJ,iBAAA,SAAAlJ,GACAoC,EAAAoG,EAAAxI,IAGAmJ,gBAAA,SAAAnJ,GACAiI,EAAAW,kBAAAjB,YAAAzyF,KAAA8qF,IAEA+E,aAAA,SAAAl3B,EAAAu7B,GACA,GAAAC,EACA,IAAApB,EAEK,CAEL,IADAoB,EAAApB,EACAmB,GAAAC,EAAAV,eAIAU,IAAAV,aAEAU,GAAA18B,MAAAz3D,KAAA24D,OATAA,OAaAkyB,EAAAkE,UACArB,EAAAqB,GA0DElE,EAAA+B,EAAAM,EAAA5jF,EAAAwnF,EAAAe,GAGFuC,EAAA,WAEA,GAAAC,GAAA,gBACA,iBAAAnjG,GACA,MAAAmjG,GAAA36F,KAAAxI,aAKAojG,EAAA,SAAAvF,EAAAqF,EAAA1iG,GAsHA,QAAA6iG,GAAAC,EAAAriG,EAAA6nE,GA4BA,QAAAy6B,GAAAhxF,GACA,GAAAorF,GAAA5B,CACAxpF,GAAAtR,QACAsR,EAAA4rF,WAGApC,EAAAxpF,EAAAwpF,QACA4B,EAAAprF,EAAAorF,QACAprF,EAAA4rF,UAAA,EACAN,EAAAxtF,MAAA0rF,GACAA,EAAA2B,UAAA/lE,KAAAgmE,GACAE,EAAAxvE,MACA9b,EAAA4rF,UAAA,GAvCA,GAAA1oF,GAAA44E,EAAAmV,EAAAC,EAAAl4F,EAAA+B,CAIA,IAHAmI,EAAA6tF,EAAAvjG,IACAsuF,EAAAiV,EAAAx+F,KAEAgkE,MAAAvmD,aAAA,CAEA,cAAA8rE,EACA,MAEA,UAAA3qF,OAAA,wCAAA2qF,EAAA,kCAGAvlB,IACA06B,EAAA16B,EAAAv9D,IACAk4F,EAAA36B,EAAAx7D,KAEA/B,EAAAi4F,GAAA,WACA,MAAAviG,IAEAqM,EAAA,SAAAhQ,GACAmmG,GACAA,EAAAnmG,GAEA2D,EAAAuiG,MAAAlmG,EACAgQ,EAAAo2F,iBAAAt4F,QAAAm4F,IAmBAj2F,EAAAo2F,kBAAAJ,GACA5iG,OAAAgc,eAAAjH,EAAA44E,GACA9iF,MACA+B,MACAgV,YAAA,EACAC,cAAA,IArKA,GAAAi6E,GACAmH,EAAAC,CACA,KACAljG,OAAAgc,kBAA4B,QAC5Bzb,MAAA,IAEA0iG,GACAl5F,OAAA,SAAAgL,EAAAkoF,EAAA5B,GACA,GAAAlvF,GAAA7M,EAAAs/F,EAAAuE,EAAAzD,CACA,OAAAzC,IAGA9wF,EAAA8wF,EAAA1uF,MAAA,KACAjP,EAAA6M,EAAA8G,MACA2rF,EAAAzyF,EAAAD,KAAA,MAGAi3F,EAAA9H,EAAA2B,UAAAhmD,QAAA4nD,MAAAuE,EAAAhkC,OACA,GAEAugC,EAAArE,EAAAxwF,IAAA+zF,GAGA9+F,EAAA4/F,IAAA,WAAA53F,KAAAxI,IACA,EAEAogG,IAAA,gBAAAA,IAAA,kBAAAA,OAhBA,GAkBA9tF,KAAA,SAAAypF,EAAA1N,EAAAsP,GACA,UAAAiG,GAAA7H,EAAA1N,EAAAsP,KAGAiG,EAAA,SAAA7H,EAAA96F,EAAA08F,GACA,GAAA9wF,GAAAi3F,EAAAh7B,EAAAi7B,CAWA,OAVAzoG,MAAAukE,OAAA,EACAvkE,KAAAygG,UACAzgG,KAAAqiG,UACAriG,KAAA2F,QACA4L,EAAA8wF,EAAA1uF,MAAA,KACA3T,KAAAwJ,KAAA+H,EAAA8G,MACAmwF,EAAAj3F,EAAAD,KAAA,KACAtR,KAAAyE,IAAA+jG,EAAA/H,EAAAxwF,IAAAu4F,GAAA/H,EAAA/gF,KACA8tD,EAAAxtE,KAAA0oG,mBAAAtjG,OAAAooB,yBAAAxtB,KAAAyE,IAAAzE,KAAAwJ,MAEAgkE,KAAAx7D,MAAAy2F,EAAAj7B,EAAAx7D,IAAAo2F,uBAEA,KAAAK,EAAA93F,QAAA3Q,OACAyoG,EAAAj1F,KAAAxT,WAKA+nG,GAAA/nG,KAAA2F,EAAA6nE,IAEA86B,EAAA9nG,WACAyP,IAAA,WACA,MAAAjQ,MAAA2F,OAEAg2B,MAAA,SAAAh2B,GACA3F,KAAA6iG,WAGA7iG,KAAA6iG,UAAA,EACA7iG,KAAAyE,IAAAzE,KAAAwJ,MAAA7D,EAEA48F,EAAAa,aAAApjG,KAAAygG,QAAA2B,WACApiG,KAAAygG,QAAA2B,UAAA/lE,KAAAr8B,KAAAqiG,SACAriG,KAAA6iG,UAAA,IAEA7wF,IAAA,SAAAtN,EAAAiB,GACA3F,KAAA6iG,WAGA7iG,KAAAyE,IAAAzE,KAAAwJ,QACAxJ,KAAA6iG,UAAA,EACA7iG,KAAAyE,IAAAzE,KAAAwJ,MAAAo+F,EAAAljG,GACA1E,KAAA6iG,UAAA,GAEA7iG,KAAAyE,IAAAzE,KAAAwJ,MAAA9E,GAAAiB,IAEAgjG,SAAA,WACA,GAAAn7B,GAAAx7D,EAAArM,EAAAijG,EAAAjoG,CAIA,OAAAX,MAAA6iG,UACA,GAEAr1B,EAAApoE,OAAAooB,yBAAAxtB,KAAAyE,IAAAzE,KAAAwJ,MACAwI,EAAAw7D,KAAAx7D,SACAA,IAIA42F,EAAA52F,EAAAo2F,iBACAznG,EAAAioG,EAAAj4F,QAAA3Q,MACA,KAAAW,GACAioG,EAAA9nG,OAAAH,EAAA,GAGAioG,EAAA9lG,SACA6C,EAAA3F,KAAAyE,IAAAzE,KAAAwJ,MACApE,OAAAgc,eAAAphB,KAAAyE,IAAAzE,KAAAwJ,KAAAxJ,KAAA0oG,qBACAxhF,UAAA,EACAF,YAAA,EACAC,cAAA,IAEAjnB,KAAAyE,IAAAzE,KAAAwJ,MAAA7D,QAIG,MAAAyX,GACHirF,GAAA,EAwDA,MAtDAnH,GAAAmH,GAuDE9F,EAAAqF,EAAA1iG,GAGFq/D,EAAA,SAAA8jC,GAEA,QAAAA,GACEP,GAGF3mG,GACA8rB,KAAA,+BACA47E,OAAA,qCACAlK,IAAA,6BACAmK,MAAA,+BACAC,IAAA,uCACAC,MAAA,iCAIA7pF,EAAA,SAAAw/E,EAAAx9F,GAEA,GAAAge,EAiBA,OAPAA,GARAw/E,EAQA,SAAA5zF,EAAAk+F,GACA,MAAAA,QAAA9nG,EAAA8rB,KAGAnuB,SAAAoqG,gBAAAD,EAAAl+F,GAFAjM,SAAAqgB,cAAApU,IATA,SAAAA,EAAAk+F,GACA,GAAAA,OAAA9nG,EAAA8rB,KACA,sQAEA,OAAAnuB,UAAAqgB,cAAApU,KAWE4zF,EAAAx9F,GAGFgoG,EAAA,WAEA,GAAAA,GAAA,gBAAArqG,SACA,OAAAqqG,MAIA/nF,EAAA,SAAA+nF,GAEA,GAAA/nF,EACA,KACAhc,OAAAgc,kBAA4B,QAC5Bzb,MAAA,IAEAwjG,GACA/jG,OAAAgc,eAAAtiB,SAAAqgB,cAAA,eACAxZ,MAAA,IAGAyb,EAAAhc,OAAAgc,eACG,MAAAhE,GAGHgE,EAAA,SAAA3c,EAAA+E,EAAA0uB,GACAzzB,EAAA+E,GAAA0uB,EAAAvyB,OAGA,MAAAyb,IACE+nF,GAGF57E,EAAA,SAAApO,EAAAiC,EAAA+nF,GAEA,GAAA57E,EACA,KACA,IACAnoB,OAAAmoB,qBACArgB,MACAvH,MAAA,KAGI,MAAAyX,GAEJ,KAAAA,GAEA+rF,GACA/jG,OAAAmoB,iBAAApO,EAAA,QACAjS,MACAvH,MAAA,KAIA4nB,EAAAnoB,OAAAmoB,iBACG,MAAAnQ,GACHmQ,EAAA,SAAA9oB,EAAA0I,GACA,GAAA3D,EACA,KAAAA,IAAA2D,GACAA,EAAAhE,eAAAK,IACA4X,EAAA3c,EAAA+E,EAAA2D,EAAA3D,KAKA,MAAA+jB,IACEpO,EAAAiC,EAAA+nF,GAGFC,EAAA,SAAA7K,GAEA,gBAAA9kC,EAAA4oC,EAAAv9C,GACA,GAAAn/C,EACA,oBAAA08F,KAAA9D,EAAAz5C,GACA,SAAA18C,OAAA,gBAGA,IADAzC,GAAA8zD,EAAAxpD,IAAAoyF,IAAA,GACA9D,EAAA54F,GACA,SAAAyC,OAAA,oCAEA,OAAAqxD,GAAAznD,IAAAqwF,EAAA18F,EAAAm/C,KAEEy5C,GAGF8K,EAAA,SAAAh8F,GAEA,gBAAAg1F,EAAAv9C,GACA,MAAAz3C,GAAArN,KAAAqiG,EAAAr3F,SAAA85C,EAAA,GAAAA,KAEEskD,GAGFE,EAAA,SAAAvH,GAEA,GAAAwH,GAAA,MACA,iBAAAlH,GACA,MAAAN,GAAAM,GAAAxhG,QAAA0oG,EAAA,MAEExH,GAGFyH,GACA,IACA,KACA,MACA,UAIAC,EAAA,SAAAD,GAEA,GAAAC,EA8BA,OA5BA,mBAAAxqG,QACAwqG,EAAA,OAGA,SAAAD,EAAAE,EAAAzqG,GACA,GAAA0E,GAAAkc,CACA,KAAA5gB,EAAAwqG,sBAAA,CAGA,IAAA9lG,EAAA,EAAgBA,EAAA6lG,EAAA1mG,SAAA7D,EAAAwqG,wBAAqD9lG,EACrE1E,EAAAwqG,sBAAAxqG,EAAAuqG,EAAA7lG,GAAA,wBAEA1E,GAAAwqG,wBACA5pF,EAAA5gB,EAAA4gB,WACA5gB,EAAAwqG,sBAAA,SAAAr/D,GACA,GAAAu/D,GAAAC,EAAAx1E,CAOA,OANAu1E,GAAA99F,KAAAmhF,MACA4c,EAAA7kG,KAAAC,IAAA,MAAA2kG,EAAAD,IACAt1E,EAAAvU,EAAA,WACAuqB,EAAAu/D,EAAAC,IACOA,GACPF,EAAAC,EAAAC,EACAx1E,MAGIo1E,EAAA,EAAAvqG,QACJwqG,EAAAxqG,OAAAwqG,uBAEAA,GACED,GAGFrxF,EAAA,WAEA,GAAAA,EAUA,OARAA,GADA,mBAAAlZ,gBAAA4qG,aAAA,kBAAA5qG,QAAA4qG,YAAA7c,IACA,WACA,MAAA/tF,QAAA4qG,YAAA7c,OAGA,WACA,MAAAnhF,MAAAmhF,UAOA8c,EAAA,SAAAC,EAAA5xF,EAAAoqF,GAEA,GAAAtjF,MACA6qF,GACAE,KAAA,WACA,GAAA/rF,GAAAgsF,EAAAjd,CAGA,KAFAA,EAAA70E,IACAoqF,EAAAxtF,QACAkJ,EAAA,EAAgBA,EAAAgB,EAAAnc,OAAkBmb,GAAA,EAClCgsF,EAAAhrF,EAAAhB,GACAgsF,EAAAD,KAAAhd,IAEA/tE,EAAAne,OAAAmd,IAAA,EAGAskF,GAAAxvE,MACA9T,EAAAnc,OACAinG,EAAAD,EAAAE,MAEAF,EAAAI,SAAA,GAGA78F,IAAA,SAAA48F,GACAhrF,EAAAzL,KAAAy2F,GACAH,EAAAI,UACAJ,EAAAI,SAAA,EACAH,EAAAD,EAAAE,QAIAG,MAAA,SAAA9H,EAAA5oC,GAGA,IAFA,GACAwwC,GADAhsF,EAAAgB,EAAAnc,OAEAmb,KACAgsF,EAAAhrF,EAAAhB,GACAgsF,EAAAxwC,UAAAwwC,EAAA5H,aACA4H,EAAAttE,QAKA,OAAAmtE,IACEL,EAAAtxF,EAAAoqF,GAGF/S,EAAA,WAoDA,QAAAhlF,GAAAI,GACA,MAAAA,GAAAJ,KACAI,EAAAJ,OAEAI,EAAA/J,QAAA,WAAAA,QAAA,WAGA,QAAAupG,GAAAC,GACA,MAAAA,GAAAz/F,IA1DA,GAAAs2F,GACAoJ,EAAA,+BACAC,EAAA,eACAC,EAAA,+EACAC,EAAA,UACAC,EAAA,+BAuDA,OAtDAxJ,GAAA,SAAAyJ,EAAAC,GACA,GAAAC,GAAAC,CAwCA,OAvCAA,GAAA,SAAAC,GACA,GAAAC,GAAAvrG,EAAA4qG,EAAAY,EAAA/yD,EAAAgzD,EAAAC,EAAAltF,EAAA4sF,IAEA,KADAG,KACAvrG,EAAA+qG,EAAA1jD,KAAAikD,IACAC,EAAAx3F,MACA5I,IAAAnL,EAAA,GACAy4C,KAAAz4C,EAAA,GACA2rG,UAAA3rG,EAAA,IAQA,KAHAwrG,EAAA,kBAAAL,EAAA,KACA1yD,EAAA8yD,EAAA94F,IAAAk4F,GACAnsF,EAAA+sF,EAAAloG,OACAmb,KACAktF,EAAAjzD,EAAAz3C,QAEA4pG,EAAAW,EAAA/sF,GACAktF,EAAAltF,GAAAosF,EAAAnyD,KAAA+yD,EAAAZ,EAAAe,WAAA,GACAF,EAAAhzD,EAAAz3C,QACAyqG,EAAAjtF,GAAAgtF,EAAA,IAAAC,EAAAjtF,GACA4sF,EAAAr3F,KAAA23F,EAAA75F,KAAA,KAAA45F,EAAA55F,KAAA,KAEA,OAAAu5F,GAAAv5F,KAAA,OAGAu5F,EADAH,EAAAx9F,KAAAy9F,GACAA,EAAA9pG,QAAA6pG,EAAA,kBAAAE,EAAA,MAEAD,EAAA9pG,QAAA0pG,EAAA,IAAA1pG,QAAAypG,EAAA,SAAA7qG,EAAAG,GACA,GAAAyrG,GAAAR,CAEA,OAAAJ,GAAAv9F,KAAAtN,GACAH,GACA4rG,EAAAzrG,EAAA+T,MAAA,KAAAzB,IAAA1H,GACAqgG,EAAAQ,EAAAn5F,IAAA44F,GAAAx5F,KAAA,UACA7R,EAAAoB,QAAAjB,EAAAirG,UAoBAF,EAAA,SAAAW,GAQA,QAAAlW,GAAAtvC,EAAA5nC,EAAA6xB,GACA,GACA46D,GADAC,EAAA1sF,EAAA7M,YAAAk6F,OAEAZ,EAAAa,EAAAz7D,EAAA46D,IAAA56D,EAAA66D,IAAAY,EAAA1lD,EAAA6kD,IAAA7kD,EAAA8kD,MACA1sF,EAAA7M,YAAAs5F,OAIA,QAAAa,GAAAb,EAAA/5F,EAAAg6F,GACA,MAAAD,GAGA/5F,EAAAmtF,eAAA4M,EAAAW,EAAAX,EAAAC,GAHA,OAfA,GAAAa,IACA5kG,KAAA,MACAuuF,SACA56E,KAAA,aAiBA,OAAAixF,IACEjc,GAGFkc,EAAA,WAqBA,QAAAC,GAAA16F,EAAA26F,GACA,wBAAAA,IAAA,SAAA1+F,KAAA+D,GApBA,GAAAiwF,EAsBA,OArBAA,GAAA,SAAAjwF,EAAA26F,EAAAC,GACA,MAAAA,IAAAF,EAAA16F,EAAA26F,GACA,WACA,GAEApoG,GAFAsoG,EAAA,UAAA9rG,MACA+rG,EAAA/rG,KAAA+rG,MAOA,OALA/rG,MAAA+rG,OAAAH,EACApoG,EAAAyN,EAAAhQ,MAAAjB,KAAAD,WACA+rG,IACA9rG,KAAA+rG,UAEAvoG,GAGAyN,MAWAyO,EAAA,SAAA1I,GAWA,QAAAg1F,GAAAlmD,EAAAl1C,EAAAm/B,GACA,GAAApqC,GAAAoqC,EAAArwB,SACAolF,EAAAmH,EAAAnmD,EAAAtlD,UAAAkf,KACA,oBAAA/Z,IAAA,kBAAAA,GACA,SAAAQ,WAAA,iDAAAR,EAAA,iBAEA,OAAAumG,GAAApH,EAAAn/F,GAGA,QAAAyvF,GAAAtvC,EAAA5nC,EAAA6xB,GACA7xB,EAAAwB,KAAAssF,EAAAlmD,EAAA5nC,EAAA6xB,GAGA,QAAAv1B,GAAAsrC,EAAA26C,EAAA1wD,GACA,GAAApqC,GAAAoqC,EAAArwB,KACAlc,EAAAwoG,EAAAlmD,EAAA26C,EAAA1wD,EAIA,OAHA,kBAAAvsC,KACAA,IAAA9C,KAAA+/F,EAAA96F,OAEA86F,EAAA/gF,KAAAlc,MAGA,QAAAm4B,GAAA8kE,GACA,GAAAj9F,GAAAxD,KAAAwa,KAAAimF,EAAApvF,YAAAovF,IACA,OAAAj9F,IACAi9F,EAAA/gF,KAAAlc,GACA,GAFA,OAMA,QAAAyoG,GAAAvoE,GAEA,qBAAAA,KAAAt+B,OAAAmM,KAAAmyB,GAAA5gC,OACA,MAAA4gC,EAIA,IAAAg1B,KAGA,OAFA9xD,GAAA88B,EAAAg1B,GAEAwzC,EAAAxoE,EAAAg1B,GAGA,QAAAwzC,GAAAxoE,EAAA2jB,GACA,wBAAAA,GACA8kD,EAAA9kD,EAAA3jB,GACI,kBAAAA,GACJ0oE,EAAA/kD,EAAA3jB,GAEA2oE,EAAAhlD,EAAA3jB,GAIA,QAAA98B,GAAA9B,EAAAyC,EAAA+kG,GACA,OAAA5nG,KAAAI,GACAwnG,GAAA5nG,IAAA6C,KAGAA,EAAA7C,GAAAI,EAAAJ,IAIA,QAAA2nG,GAAAhlD,EAAA3jB,GAEA,MADA2jB,SACA3jB,GAGA98B,EAAA88B,EAAA2jB,GAAA,GACAA,GAHAA,EAMA,QAAA+kD,GAAA/kD,EAAAklD,GACA,gBAAA7sF,GACA,GAAAnO,EACA,IAAA81C,EAAA,CAIA91C,IACA,QAAA7M,KAAA2iD,GACA3nC,GAAAhb,IAAAgb,IACAnO,EAAAiC,KAAA9O,GAeA,MAVAgb,GAAA6sF,EAAA7rG,KAAAV,KAAA0f,MAIAnO,KAAAzO,SACA4c,QACAnO,EAAAzB,QAAA,SAAApL,GACAgb,EAAAhb,GAAA2iD,EAAA3iD,MAGAgb,GAIA,QAAAysF,GAAAK,EAAA9oE,GACA,GAAA6oE,EAeA,OAZAA,GAFA,kBAAA7oE,GAEA,SAAAhkB,GACA2sF,EAAA3sF,EAAAgkB,IAGA,SAAAhkB,GAKA,MADAgkB,GAAA1sB,EAAA0sB,EAAA,cAAyC,GACzCA,EAAAhjC,KAAAV,KAAA0f,OAGA1I,EAAAw1F,EAAAD,GA7HA,GAAArL,GACAuL,GACA5lG,KAAA,OACAuuF,SACA56E,OACAmhB,QA0HA,OAxHAulE,GAAAuL,GAyHEf,GAGFgB,GACAC,KAAA,EACAC,aAAA,EACAC,OAAA,EACAC,QAAA,EACAC,SAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,YAAA,GACAC,SAAA,GACA3+E,IAAA,GACA4+E,UAAA,GACAC,YAAA,GACAC,UAAA,GACAC,eAAA,GACAC,eAAA,GACAC,cAAA,GACAC,eAAA,GACAC,gBAAA,GACA/iF,OAAA,GACAgjF,eAAA,GACA90E,UAAA,GACA+0E,WAAA,GACAC,OAAA,GACAC,gBAAA,GACAC,UAAA,GACAC,YAAA,GACAC,eAAA,GACAC,WAAA,GACAC,WAAA,GACAC,eAAA,GACAC,aAAA,GACAC,aAAA,GACAC,gBAAA,IAIA7qF,EAAA,WAEA,GAAAA,EACA,KACAze,OAAAye,OAAA,MACAA,EAAAze,OAAAye,OACG,MAAAzG,GAEHyG,EAAA,WACA,GAAAxY,GAAA,YACA,iBAAA6S,EAAA/Q,GACA,GAAA1I,EACA,eAAAyZ,MAGA7S,EAAA7K,UAAA0d,EACAzZ,EAAA,GAAA4G,GACA8B,GACA/H,OAAAmoB,iBAAA9oB,EAAA0I,GAEA1I,OAIA,MAAAof,MAIA8qF,GACAC,mBAAA,mCACAC,cAAA,0BAIAC,EAAA,SAAApC,GAEA,GAAAqC,GAAA,6FACA,iBAAAz7B,GACA,GAAA9vE,EACA,QAAAA,EAAA8vE,EAAA07B,aAAAD,KAEA1wE,EAAAquE,EAAAe,eACAzrG,EAAAwB,GAGA,OAEEkpG,GAGFuC,EAAA,SAAAvC,GAEA,gBAAAp5B,GACA,GAAAr9C,GAAAq9C,EAAAr9C,WACA,gBAAAA,EAAAoQ,OAAA,MACAitC,EAAAhtD,KAAA,GAEA+X,EAAAquE,EAAAmB,gBACA7rG,EAAA,SAGA,UAAAi0B,EAAAoQ,OAAA,MACAitC,EAAAhtD,KAAA,GAEA+X,EAAAquE,EAAAmB,gBACA7rG,EAAA,UAGA,OAEE0qG,GAGFwC,EAAA,WAEA,GAAAC,GAAAC,EAAAC,CASA,OANAF,GAAA,sCAEAC,EAAA,8EAEAC,EAAA,yCAEA,SAAAC,GACA,gBAAAh8B,GACA,GAAAv+D,GAAAw6F,EAAAlyF,EAAAH,CAIA,KAHAnI,EAAAu+D,EAAAhtD,IACAipF,EAAA,IACAlyF,GAAA,GACAA,GACAH,EAAAo2D,EAAA07B,aAAAG,IAAA77B,EAAA07B,aAAAI,IAAA97B,EAAAk8B,YAAAF,GACApyF,EAEAqyF,GADA,MAAAryF,EACA,MACO,QAAAA,EACP,IAEAA,GAGAA,EAAAo2D,EAAA07B,aAAAK,GACAnyF,EAEAqyF,GAAA,aAAAryF,EAAA3D,WAAA,GAAAlU,SAAA,KAAA5E,MAAA,IAEA4c,GAAA,EAMA,OAFAkyF,IAAA,IAEAttG,KAAA4kD,MAAA0oD,QAMAE,EAAA,SAAAP,GAEA,MAAAA,GAAA,MACEA,GAGFQ,GAAA,SAAAR,GAEA,MAAAA,GAAA,MACEA,GAGFS,GAAA,SAAAjD,EAAAkD,EAAAC,GAEA,gBAAAv8B,GACA,GAAAv+D,GAAA02C,CAEA,OADA12C,GAAAu+D,EAAAhtD,IACAgtD,EAAAk8B,YAAA,MACA/jD,EAAAokD,EAAAv8B,GACAA,EAAAk8B,YAAA,MAKAnxE,EAAAquE,EAAAgB,eACA1rG,EAAAypD,IALA6nB,EAAAhtD,IAAAvR,EACA,OAOAu+D,EAAAk8B,YAAA,MACA/jD,EAAAmkD,EAAAt8B,GACAA,EAAAk8B,YAAA,MAKAnxE,EAAAquE,EAAAgB,eACA1rG,EAAAypD,IALA6nB,EAAAhtD,IAAAvR,EACA,OAOA,OAEE23F,EAAA+C,EAAAC,IAGFI,IACAjpG,KAAA,6BAIAnC,GAAA,SAAAqrG,EAAAC,EAAAF,GAEA,GAAAG,GAAA,4BAGA,iBAAA38B,GACA,GAAA48B,EACA,QAAAA,EAAAH,EAAAz8B,IACA28B,EAAA/iG,KAAAgjG,EAAAluG,GAAAkuG,EAAAluG,EAAA,IAAAkuG,EAAAluG,EAAAnB,QAAA,iBAEAqvG,EAAAF,EAAA18B,IACA48B,EAAAluG,GAEAkuG,EAAA58B,EAAA07B,aAAAc,EAAAjpG,OACAqpG,EADA,SAIEP,GAAAb,EAAAgB,IAGFK,GAAA,SAAAzD,EAAA0D,GAEA,gBAAA98B,GACA,GAAAv+D,GAAArQ,EAAAiB,CAKA,OAJAoP,GAAAu+D,EAAAhtD,IAEAgtD,EAAA+8B,kBACA3rG,EAAA0rG,EAAA98B,GACA,OAAA5uE,GACA4uE,EAAAhtD,IAAAvR,EACA,OAGAu+D,EAAA+8B,kBAEA/8B,EAAAk8B,YAAA,MAKAl8B,EAAA+8B,kBAEA1qG,EAAA2tE,EAAAg9B,iBACA,OAAA3qG,GACA2tE,EAAAhtD,IAAAvR,EACA,OAGAspB,EAAAquE,EAAAoB,eACAn6E,EAAAjvB,EACA1C,EAAA2D,KAdA2tE,EAAAhtD,IAAAvR,EACA,SAgBE23F,EAAAhoG,IAGF6rG,GAAA,SAAAC,GAEA,eAAAC,GAAAn9B,GACA,GAAAv+D,GAAAzM,EAAAmO,EAAA85F,CAGA,OAFAx7F,GAAAu+D,EAAAhtD,IACA7P,EAAA+5F,EAAAl9B,GACA,OAAA78D,EACA,MAEAnO,GAAAmO,GACA68D,EAAAk8B,YAAA,MACAe,EAAAE,EAAAn9B,GACAi9B,EAIAjoG,EAAAhI,OAAAiwG,IAHAj9B,EAAAhtD,IAAAvR,EACA,OAIAzM,KAEE6nG,IAGFO,GAAA,SAAAhE,EAAA+D,GAEA,gBAAAn9B,GACA,GAAAv+D,GAAAw7F,CAIA,OAHAx7F,GAAAu+D,EAAAhtD,IAEAgtD,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MAIAe,EAAAE,EAAAn9B,GAEAA,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MAKAnxE,EAAAquE,EAAAkB,eACApyF,EAAA+0F,IALAj9B,EAAAhtD,IAAAvR,EACA,QARAu+D,EAAAhtD,IAAAvR,EACA,QAcE23F,EAAA6D,IAGFI,GAAA,SAAAttE,GAEA,eAAAutE,GAAAt9B,GAmBA,QAAA7lE,GAAAojG,GACAC,EAAAt9F,KAAAq9F,GAnBA,GAAA97F,GAAA+7F,EAAAC,EAAA7zF,CAIA,OAHAnI,GAAAu+D,EAAAhtD,IACAgtD,EAAA+8B,kBACAU,EAAAz9B,EAAAg9B,iBACA,OAAAS,EACA,MAEAD,GAAAC,GAEAz9B,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,OACAtyF,EAAA0zF,EAAAt9B,GACA,OAAAp2D,GACAo2D,EAAAvtC,MAAA1C,EAAAurE,oBAEA1xF,EAAApN,QAAArC,IAMAqjG,KAEEnC,GAGFqC,GAAA,SAAAtE,EAAAkE,GAEA,gBAAAt9B,GACA,GAAAv+D,GAAA47F,CAIA,OAHA57F,GAAAu+D,EAAAhtD,IAEAgtD,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MAIAmB,EAAAC,EAAAt9B,GACAA,EAAAk8B,YAAA,MAKAnxE,EAAAquE,EAAAiB,cACAnyF,EAAAm1F,IALAr9B,EAAAhtD,IAAAvR,EACA,QANAu+D,EAAAhtD,IAAAvR,EACA,QAYE23F,EAAAiE,IAGFpB,GAAA,SAAAS,EAAAiB,EAAAlB,EAAAmB,EAAAC,GAEA,gBAAA79B,GACA,GAAAi8B,GAAAS,EAAA18B,IAAA29B,EAAA39B,IAAAy8B,EAAAz8B,IAAA49B,EAAA59B,IAAA69B,EAAA79B,EACA,OAAAi8B,KAEET,EAAAG,EAAAU,GAAAe,GAAAM,IAGFI,GAAA,SAAA1E,EAAAoD,GAEA,GAAAuB,GAAAC,EAAAC,EAAAC,EAAAC,CAcA,OAbAJ,GAAA,oBACAE,EAAA,SAAAj+B,GACA,GAAA9a,GAAA8a,EAAA07B,aAAAsC,EACA,OAAA94C,GACA,IAAAA,EAEA,MAEA84C,EAAA,uBAEAE,EAAA,4JAEAC,EAAA,+JACA,SAAAn+B,GACA,GAAAo+B,GAAAC,EAAA9qG,EAAA+qG,EAAAC,EAAAC,EAAAC,CAGA,IAFAL,EAAAp+B,EAAAhtD,IAEAgtD,EAAAk8B,YAAA,MACAmC,EAAA,SAIA,KADAA,EAAA,GACAr+B,EAAAk8B,YAAA,QACAmC,GAAA,KASA,IANAA,IAEAC,EAAAt+B,EAAAk8B,YAAA,OAAAl8B,EAAAk8B,YAAA,UAEA3oG,EAAAysE,EAAA07B,aAAA,4BAAA17B,EAAA07B,aAAAc,EAAAjpG,OAAA,GAEA4qG,EAAAvkG,KAAArG,GAEA,MADAysE,GAAAhtD,IAAAorF,EACA,IAGA,KAAAC,IAAAC,GAAAJ,EAAAtkG,KAAArG,GACA,OACAw3B,EAAAquE,EAAA5hF,OACA9oB,EAAA6E,EAIA,IADAgrG,GAAAF,GAAAC,GAAA/qG,GACAgrG,EACA,WAEA,MAAAC,EAAAx+B,EAAA07B,aAAAqC,IAAAE,EAAAj+B,IACAu+B,GAAAC,CAcA,OAZAx+B,GAAAk8B,YAAA,OAIAuC,EAAAF,EAAAhgG,YAAA,KACA,KAAAkgG,GACAF,IAAAxrE,OAAA,EAAA0rE,GACAz+B,EAAAhtD,IAAAorF,EAAAG,EAAA/uG,QAEAwwE,EAAAhtD,KAAA,IAIA+X,EAAAquE,EAAA1zE,UACAvzB,EAAAosG,EAAAhxG,QAAA,gBAAAA,QAAA,iBAGE6rG,EAAAoD,IAGFkC,GAAA,SAAAtF,EAAArpE,GAEA,gBAAAiwC,GACA,GAAAv+D,GAAAg8F,CAEA,OADAh8F,GAAAu+D,EAAAhtD,IACAgtD,EAAAk8B,YAAA,MAGAl8B,EAAA+8B,kBACAU,EAAAz9B,EAAAg9B,iBACAS,GACAz9B,EAAAvtC,MAAA1C,EAAAurE,oBAEAt7B,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MACAl8B,EAAAvtC,MAAA1C,EAAAwrE,gBAGAxwE,EAAAquE,EAAAwB,UACAvqG,EAAAotG,IAbA,OAgBErE,EAAAiC,GAGFsD,GAAA,SAAAC,EAAAC,EAAAC,GAEA,gBAAA9+B,GACA,MAAA4+B,GAAA5+B,IAAA6+B,EAAA7+B,IAAA8+B,EAAA9+B,KAEEi8B,GAAA6B,GAAAY,IAGFF,GAAA,SAAApF,EAAArpE,EAAAysE,GAEA,gBAAAx8B,GACA,GAAAv+D,GAAAlO,EAAAkqG,CAIA,IAHAh8F,EAAAu+D,EAAAhtD,IACAgtD,EAAA+8B,kBAEA/8B,EAAAk8B,YAAA,MAEA,GADAl8B,EAAA+8B,kBACAxpG,EAAAysE,EAAA07B,aAAAc,EAAAjpG,MACA,OACAw3B,EAAAquE,EAAAqB,WACAtoG,EAAAoB,EAGAysE,GAAAvtC,MAAA,4BAGA,MAAAutC,GAAAk8B,YAAA,MACAl8B,EAAA+8B,kBACAU,EAAAz9B,EAAAg9B,iBACAS,GACAz9B,EAAAvtC,MAAA1C,EAAAurE,oBAEAt7B,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MACAl8B,EAAAvtC,MAAA,iBAGA1H,EAAAquE,EAAAqB,WACApqG,EAAAotG,IAGA,OAEErE,EAAAiC,EAAAmB,IAGFuC,GAAA,SAAA3F,EAAA4F,EAAA1B,EAAA2B,EAAAlvE,GAEA,gBAAAiwC,GACA,GAAAl6D,GAAAy3F,EAAAiB,EAAAnB,CAEA,IADAE,EAAAyB,EAAAh/B,IACAu9B,EACA,WAEA,MAAAA,GAEA,GADAz3F,EAAAk6D,EAAAhtD,IACAwrF,EAAAS,EAAAj/B,GACAu9B,GACAxyE,EAAAquE,EAAAsB,OACArqG,EAAAktG,EACApvG,EAAAqwG,OAEK,KAAAx+B,EAAAk8B,YAAA,KAeL,KAdAl8B,GAAA+8B,kBACAM,EAAAC,EAAAt9B,GACAA,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MACAl8B,EAAAvtC,MAAA1C,EAAAwrE,eAEAgC,GACAxyE,EAAAquE,EAAA2B,WACA1qG,EAAAktG,GAEAF,IACAE,EAAA9gF,EAAA4gF,GAMA,MAAAE,KAEEnE,EAAAuF,GAAAtB,GAAAmB,GAAAnD,GAGF6D,GAAA,SAAA9F,EAAArpE,EAAAovE,GAEA,GAAAC,GAAAC,CAoCA,OAnCAA,GAAA,SAAAC,EAAAC,GACA,gBAAAv/B,GACA,GAAAu9B,EACA,QAAAA,EAAAgC,EAAAv/B,IACAu9B,EAEAv9B,EAAAk8B,YAAAoD,IAGAt/B,EAAA+8B,kBACAQ,EAAAv9B,EAAAg9B,iBACAO,GACAv9B,EAAAvtC,MAAA1C,EAAAurE,qBAGAroF,EAAAqsF,EACA7iF,EAAA8gF,EACAxyE,EAAAquE,EAAAuB,kBAVA,OAeA,WACA,GAAAhwF,GAAAra,EAAAkvG,EAAAC,EAAAF,CAGA,KAFAE,EAAA,iBAAAp/F,MAAA,KACAk/F,EAAAJ,EACAx0F,EAAA,EAAAra,EAAAmvG,EAAAjwG,OAA6Cc,EAAAqa,EAASA,GAAA,EACtD60F,EAAAH,EAAAI,EAAA90F,GAAA40F,GACAA,EAAAC,CAKAJ,GAAAG,KAEAH,GACEhG,EAAAiC,EAAA0D,IAGFW,GAAA,SAAAtG,EAAAgG,GAEA,GAAAO,GAAAC,CA0DA,OAzDAA,GAAA,SAAAN,EAAAC,GACA,gBAAAv/B,GACA,GAAAv+D,GAAAg7D,EAAAC,CAEA,IADAD,EAAA8iC,EAAAv/B,IACAvD,EACA,WAKA,SAGA,GAFAh7D,EAAAu+D,EAAAhtD,IACAgtD,EAAA+8B,mBACA/8B,EAAAk8B,YAAAoD,GAEA,MADAt/B,GAAAhtD,IAAAvR,EACAg7D,CAGA,WAAA6iC,GAAA,gBAAA1lG,KAAAomE,EAAAr9C,YAAA3c,OAAA,IAEA,MADAg6D,GAAAhtD,IAAAvR,EACAg7D,CAKA,IAHAuD,EAAA+8B,kBAEArgC,EAAA6iC,EAAAv/B,IACAtD,EAEA,MADAsD,GAAAhtD,IAAAvR,EACAg7D,CAEAA,IACA1xC,EAAAquE,EAAA0B,eACA7nF,EAAAqsF,EACA7iF,GACAggD,EACAC,OAOA,WACA,GAAA/xD,GAAAra,EAAAkvG,EAAAK,EAAAN,CAQA,KAHAM,EAAA,wEAAAx/F,MAAA,KAEAk/F,EAAAH,EACAz0F,EAAA,EAAAra,EAAAuvG,EAAArwG,OAA4Cc,EAAAqa,EAASA,GAAA,EACrD60F,EAAAI,EAAAC,EAAAl1F,GAAA40F,GACAA,EAAAC,CAGAG,GAAAJ,KAEAI,GACEvG,EAAA8F,IAGFY,GAAA,SAAA1G,EAAAuG,EAAA5vE,GAEA,gBAAAiwC,GACA,GAAAv+D,GAAA87F,EAAAwC,EAAAC,CAEA,QADAzC,EAAAoC,EAAA3/B,KAIAv+D,EAAAu+D,EAAAhtD,IACAgtD,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MAIAl8B,EAAA+8B,kBACAgD,EAAA//B,EAAAg9B,iBACA+C,GACA//B,EAAAvtC,MAAA1C,EAAAurE,oBAEAt7B,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MACAl8B,EAAAvtC,MAAA,gBAEAutC,EAAA+8B,kBACAiD,EAAAhgC,EAAAg9B,iBACAgD,GACAhgC,EAAAvtC,MAAA1C,EAAAurE,qBAGAvwE,EAAAquE,EAAAyB,YACAp+E,GACA8gF,EACAwC,EACAC,MAtBAhgC,EAAAhtD,IAAAvR,EACA87F,IANA;GA+BEnE,EAAAsG,GAAArE,GAGF4E,GAAA,SAAA7G,EAAA9uF,GAcA,QAAA41F,GAAA5oG,GACA,MAAA3I,MAAAC,UAAA+G,OAAA2B,IAGA,QAAA6oG,GAAAzsE,EAAAi+B,GACA,GAAAhnD,GAAArb,CAOA,IANAokC,EAAA3I,IAAAquE,EAAA1zE,WACA,KAAAisC,EAAAt0D,QAAAq2B,EAAAvhC,IACAw/D,EAAAn3C,QAAAkZ,EAAAvhC,GAGA7C,EAAAokC,EAAAjX,GAAAiX,EAAAxrB,EAEA,GAAAoC,EAAAhb,GACA6wG,EAAA7wG,EAAAqiE,OAGA,KADAhnD,EAAArb,EAAAE,OACAmb,KACAw1F,EAAA7wG,EAAAqb,GAAAgnD,EAIAj+B,GAAArjC,GACA8vG,EAAAzsE,EAAArjC,EAAAshE,GAEAj+B,EAAAvlC,GACAgyG,EAAAzsE,EAAAvlC,EAAAwjE,GAEAj+B,EAAAhlC,GACAyxG,EAAAzsE,EAAAhlC,EAAAijE,GAIA,QAAA/iE,GAAAoxE,EAAAtsC,EAAAi+B,GACA,GAAAyuC,GAAA,SAAA7uG,GACA,MAAA3C,GAAAoxE,EAAAzuE,EAAAogE,GAEA,QAAAj+B,EAAA3I,GACA,IAAAquE,GAAAmB,gBACA,IAAAnB,GAAA5hF,OACA,IAAA4hF,GAAAe,eACA,MAAAzmE,GAAAhlC,CACA,KAAA0qG,GAAAgB,eACA,MAAA8F,GAAAxsE,EAAAhlC,EACA,KAAA0qG,GAAAiB,cACA,WAAA3mE,EAAAxrB,EAAAwrB,EAAAxrB,EAAAtJ,IAAAwhG,GAAApiG,KAAA,YACA,KAAAo7F,GAAAkB,eACA,WAAc5mE,EAAAxrB,EAAAwrB,EAAAxrB,EAAAtJ,IAAAwhG,GAAApiG,KAAA,YACd,KAAAo7F,GAAAoB,eACA,MAAA9mE,GAAArT,EAAA,IAAAzxB,EAAAoxE,EAAAtsC,EAAAhlC,EAAAijE,EACA,KAAAynC,GAAAuB,gBACA,kBAAAjnE,EAAAzgB,EAAA,UAAAygB,EAAAzgB,GAAArkB,EAAAoxE,EAAAtsC,EAAAjX,EAAAk1C,EACA,KAAAynC,GAAA0B,eACA,MAAAlsG,GAAAoxE,EAAAtsC,EAAAjX,EAAA,GAAAk1C,IAAA,OAAAj+B,EAAAzgB,EAAA8f,OAAA,SAAAW,EAAAzgB,EAAA,IAAAygB,EAAAzgB,GAAArkB,EAAAoxE,EAAAtsC,EAAAjX,EAAA,GAAAk1C,EACA,KAAAynC,GAAA2B,WACA,MAAAnsG,GAAAoxE,EAAAtsC,EAAArjC,EAAAshE,GAAA,KAAAj+B,EAAAjX,EAAAiX,EAAAjX,EAAA7d,IAAAwhG,GAAApiG,KAAA,YACA,KAAAo7F,GAAAwB,UACA,UAAAhsG,EAAAoxE,EAAAtsC,EAAArjC,EAAAshE,GAAA,GACA,KAAAynC,GAAAsB,OACA,MAAA9rG,GAAAoxE,EAAAtsC,EAAArjC,EAAAshE,GAAA/iE,EAAAoxE,EAAAtsC,EAAAvlC,EAAAwjE,EACA,KAAAynC,GAAAqB,WACA,MAAA/mE,GAAAvhC,EAAA,IAAAuhC,EAAAvhC,EAAA,IAAAvD,EAAAoxE,EAAAtsC,EAAArjC,EAAAshE,GAAA,GACA,KAAAynC,GAAAyB,YACA,MAAAjsG,GAAAoxE,EAAAtsC,EAAAjX,EAAA,GAAAk1C,GAAA,IAAA/iE,EAAAoxE,EAAAtsC,EAAAjX,EAAA,GAAAk1C,GAAA,IAAA/iE,EAAAoxE,EAAAtsC,EAAAjX,EAAA,GAAAk1C,EACA,KAAAynC,GAAA1zE,UACA,UAAAisC,EAAAt0D,QAAAq2B,EAAAvhC,EACA,SACA6tE,EAAAvtC,MAAA,8BA/EA,GAAAm7D,EAkFA,OAjFAA,GAAA,SAAA2P,GACA,GACA8C,GADA1uC,IAOA,OALAwuC,GAAA5C,EAAA5rC,GACA0uC,GACAlyG,EAAAwjE,EACA1+C,EAAArkB,EAAAlC,KAAA6wG,EAAA5rC,MA4EEynC,EAAA9uF,GAGFg2F,GAAA,SAAAvV,EAAAx6E,EAAA1a,EAAA0qG,EAAAN,GAEA,GAAAK,GAAAE,EAAAC,EAAA,MA8HA,OA7HAD,GAAA,SAAA1xE,GACApiC,KAAA6G,KAAA,aACA7G,KAAAoiC,SACA,KACA,SAAAh6B,OAAAg6B,GACI,MAAA7gC,GACJvB,KAAAwlC,MAAAjkC,EAAAikC,QAGAsuE,EAAAtzG,UAAA4H,MAAA5H,UACAozG,EAAA,SAAAhpG,EAAAmlC,GACA,GAAAg2B,GAAAlhE,EAAAmvG,EAAA,CAeA,KAdAh0G,KAAA4K,MACA5K,KAAA+vC,cACA/vC,KAAAsmB,IAAA,EACAtmB,KAAAivC,MAAAjvC,KAAA4K,IAAA+I,MAAA,MACA3T,KAAAi0G,SAAAj0G,KAAAivC,MAAA/8B,IAAA,SAAAozB,GACA,GAAA4uE,GAAAF,EAAA1uE,EAAAxiC,OAAA,CAGA,OADAkxG,GAAAE,EACAA,GACI,GAEJl0G,KAAAwa,MACAxa,KAAAwa,KAAA5P,EAAAmlC,GACAg2B,KACA/lE,KAAAsmB,IAAAtmB,KAAA4K,IAAA9H,SAAA+B,EAAA7E,KAAAgwD,SACA+V,EAAAvyD,KAAA3O,EAEA7E,MAAAm0G,SAAAn0G,KAAAi2B,YACAj2B,KAAAwD,OAAAxD,KAAAo0G,YAAAp0G,KAAAo0G,YAAAruC,EAAAh2B,GAAAg2B,GAEA6tC,EAAApzG,WACAwvD,KAAA,SAAAqkD,GACA,GAAA/tF,GAAArI,EAAAra,EAAAiB,CAKA,KAJAwvG,IACAA,EAAAr0G,KAAAq0G,YACA/tF,EAAAtmB,KAAAsmB,IACA1iB,EAAAywG,EAAAvxG,OACAmb,EAAA,EAAgBra,EAAAqa,EAASA,GAAA,EAGzB,GAFAje,KAAAsmB,MAEAzhB,EAAAwvG,EAAAp2F,GAAAje,MACA,MAAA6E,EAGA,cAEAyrG,eAAA,WAOA,MAAAuD,GAAA7zG,OAEAuzG,oBACAe,WAAA,SAAAC,GAIA,IAHA,GAEAC,GAFAC,EAAA,EACAT,EAAA,EAEAO,GAAAv0G,KAAAi0G,SAAAQ,IACAT,EAAAh0G,KAAAi0G,SAAAQ,GACAA,GAAA,CAGA,OADAD,GAAAD,EAAAP,GAEAS,EAAA,EACAD,EAAA,EACAD,IAGAxuE,MAAA,SAAA3D,GACA,GAAA9b,GAAAmuF,EAAAD,EAAAlvE,EAAAovE,EAAA3uE,CAUA,MATAzf,GAAAtmB,KAAAs0G,WAAAt0G,KAAAsmB,KACAmuF,EAAAnuF,EAAA,GACAkuF,EAAAluF,EAAA,GACAgf,EAAAtlC,KAAAivC,MAAA3oB,EAAA,MACAouF,EAAApvE,EAAA,QAAA/kC,OAAA+lB,EAAA,IAAAhV,KAAA,aACAy0B,EAAA,GAAA+tE,GAAA1xE,EAAA,YAAAqyE,EAAA,cAAAD,EAAA,MAAAE,GACA3uE,EAAAT,KAAAhf,EAAA,GACAyf,EAAA4uE,UAAAruF,EAAA,GACAyf,EAAA6uE,aAAAxyE,EACA2D,GAEAypE,YAAA,SAAA/jD,GACA,MAAAzrD,MAAA4K,IAAAy7B,OAAArmC,KAAAsmB,IAAAmlC,EAAA3oD,UAAA2oD,GACAzrD,KAAAsmB,KAAAmlC,EAAA3oD,OACA2oD,GAFA,QAKAujD,aAAA,SAAAh7E,GACA,GAAAv0B,EACA,QAAAA,EAAAu0B,EAAA8yB,KAAA9mD,KAAAi2B,eACAj2B,KAAAsmB,KAAA7mB,EAAA,GAAAqD,OACArD,EAAA,IAAAA,EAAA,IAFA,QAKA4wG,gBAAA,WACArwG,KAAAgvG,aAAA+E,IAEA99E,UAAA,WACA,MAAAj2B,MAAA4K,IAAA8K,UAAA1V,KAAAsmB,MAEA2qD,SAAA,WACA,MAAAjxE,MAAA4K,IAAA0O,OAAAtZ,KAAAsmB,OAGAstF,EAAAxe,OAAA,SAAAl3E,GACA,GACA2nC,GAAAnhD,EADAohD,EAAA9lD,IAEA6lD,GAAA,SAAAj7C,EAAAmlC,GACA6jE,EAAAlzG,KAAAV,KAAA4K,EAAAmlC,IAEA8V,EAAArlD,UAAAqjB,EAAAiiC,EAAAtlD,UACA,KAAAkE,IAAAwZ,GACA/U,EAAAzI,KAAAwd,EAAAxZ,KACAmhD,EAAArlD,UAAAkE,GAAAwZ,EAAAxZ,GAIA,OADAmhD,GAAAuvC,OAAAwe,EAAAxe,OACAvvC,GAEAw4C,EAAAuV,SACAA,GACEvV,EAAAx6E,EAAAiY,EAAAs3E,GAAAG,IAGFsB,GAAA,WAEA,GAAAC,GAAA,WACAC,EAAA,MACA,iBAAAzhC,GACA,GAAAv+D,GAAAigG,EAAAC,CACA,OAAA3hC,GAAAk8B,YAAA,MAGAz6F,EAAAu+D,EAAAhtD,IAEAgtD,EAAA+8B,mBACA2E,EAAA1hC,EAAA07B,aAAA8F,IAMAxhC,EAAA07B,aAAA+F,IAGAE,EAAA3hC,EAAA07B,aAAA8F,KAMAxhC,EAAA+8B,kBACA/8B,EAAAk8B,YAAA,MAKAwF,EACAC,IALA3hC,EAAAhtD,IAAAvR,EACA,QAPAu+D,EAAAhtD,IAAAvR,EACA,MALA,MALAu+D,EAAAhtD,IAAAvR,EACA,OARA,SAiCAmgG,KACAC,WAAA,aACAC,UAAA,EACAjvF,UAAA,IAEAgvF,WAAA,mBACAC,UAAA,EACAjvF,UAAA,IAEAgvF,WAAA,mBACAC,UAAA,EACAjvF,UAAA,IAEAgvF,WAAA,yBACAC,UAAA,EACAjvF,UAAA,IAIApb,GAAA,SAAA2hG,GAEA,GAAA2I,IACAC,IAAA5I,EAAAI,QACAyI,IAAA7I,EAAAK,SACAyI,IAAA9I,EAAAM,QACA/R,IAAAyR,EAAAQ,QACAuI,IAAA/I,EAAAS,QACApS,IAAA2R,EAAAG,OAEA,iBAAAv5B,GACA,GAAAvoE,GAAAsqG,EAAA/hC,EAAA1oE,IAAA0O,OAAAg6D,EAAAhtD,KACA,OAAAvb,IAGAuoE,EAAAhtD,KAAA,EACAvb,GAHA,OAKE2hG,GAGFgJ,GAAA,SAAAhJ,GAEA,OACAx+D,KAAAw+D,EAAA8B,aACAmH,KAAAjJ,EAAA4B,WACAsH,UAAAlJ,EAAAgC,gBACAmH,OAAAnJ,EAAA+B,aACAqH,OAAApJ,EAAA6B,iBAEE7B,GAGFqJ,GAAA,KAGAC,GAAA,SAAAtJ,EAAAuJ,EAAAP,GAwHA,QAAAQ,GAAA5iC,EAAAu9B,EAAAsF,GACA,GAAAC,EACA,IAAAvF,EAAA,CACA,KAAAA,EAAAxyE,IAAAquE,EAAAwB,WAAA2C,EAAAltG,GACAktG,IAAAltG,CAeA,OAXAktG,GAAAxyE,IAAAquE,EAAA1zE,UACAm9E,EAAA10G,EAAAovG,EAAAprG,EAEAorG,EAAAxyE,IAAAquE,EAAAe,gBAAA6D,EAAApkG,KAAA2jG,EAAA7uG,GACAm0G,EAAA10G,EAAAovG,EAAA7uG,GACMo0G,EAAAC,EAAA/iC,EAAAu9B,IACNsF,EAAAG,GAAAF,EAEAD,EAAAxyG,EAAA2vE,EAAAigC,kBAAA1C,GAGAsF,GAIA,QAAAE,GAAA/iC,EAAAu9B,GAGA,IAFA,GACAiB,GADAyE,KAEA1F,EAAAxyE,IAAAquE,EAAAsB,QAAA6C,EAAApvG,EAAA48B,IAAAquE,EAAAqB,YACA+D,EAAAjB,EAAApvG,EAGA80G,EAAAzoF,QAFAgkF,EAAAnuG,EACAmuG,EAAAnuG,EAAA06B,IAAAquE,EAAA1zE,UACA84E,EAAAnuG,EAEA2vE,EAAAigC,kBAAAzB,EAAAnuG,GAGAmuG,EAAArsG,GAEAorG,IAAAltG,CAEA,OAAAktG,GAAAxyE,IAAAquE,EAAA1zE,UACA,MAGAv3B,EAAAovG,EAAAprG,EACA+V,EAAA+6F,GAlKA,GAAArV,GAIAsV,EAHAC,EAAA,qCACAnF,EAAA,gBACAoF,EAAA,GAAA/2G,QAAA,KAAAyF,OAAAmM,KAAAmkG,GAAApkG,KAAA,YAkKA,OAhKAklG,GAAA,+DACAtV,EAAA,SAAA5tB,EAAAqjC,GACA,GAAA5hG,GAAAuR,EAAA6vF,EAAAprG,EAAA6rG,EAAA/F,EAAA5yF,EAAAgY,EAAAt1B,EAAAw0G,CAQA,IAPApgG,EAAAu+D,EAAAhtD,IACA6vF,KACAhB,EAAA7hC,EAAAqjC,EAAAxB,YACAwB,EAAAxwF,WACAgwF,EAAA5vF,GAAA,GAGAowF,EAAAvB,SACAe,EAAA93E,EAAAquE,EAAAG,WACI,CAGJ,SAAAv5B,EAAAr9C,YAAA,IACA,IACA46E,EAAAv9B,EAAAg9B,iBAEAh9B,EAAA+8B,kBACA/8B,EAAAr9C,YAAAtlB,QAAAwkG,EAAA,IACAtE,EAAA,KAEAsF,EAAA93E,EAAAquE,EAAAE,aAEM,MAAAxvF,IACN,IAAAyzF,EAOA,MANAlwG,GAAA2yE,EAAAr9C,YAAAtlB,QAAAwkG,EAAA,KACAx0G,EACA2yE,EAAAhtD,KAAA3lB,EAEA2yE,EAAAvtC,MAAA,gCAAAovE,EAAA,UAGA92E,EAAAquE,EAAAS,SAIA,IAAA0D,EAKA,GAJA9lG,EAAAkrG,EAAA3iC,GACA6iC,EAAA93E,EAAAtzB,GAAA2hG,EAAAE,aAGA7hG,IAAA2hG,EAAAI,SACA8J,EAAAtjC,EAAA07B,aAAA0H,MACAP,EAAA1wG,EAAAmxG,GAEAtjC,EAAA+8B,sBACM,KAAAtlG,IAAA2hG,EAAAS,SAAApiG,IAAA2hG,EAAAM,WACN/2E,EAAAq9C,EAAAr9C,YACAt1B,EAAAs1B,EAAAtlB,QAAAwkG,EAAA,IACA,KAAAx0G,GAGA,MAFAw1G,GAAA10G,EAAAw0B,EAAAoQ,OAAA,EAAA1lC,GAAAgT,MAAA,QACA2/D,EAAAhtD,KAAA3lB,EACAw1G,EAKA,IAAAtF,EAAA,CAEAv9B,EAAA+8B,kBAEAQ,EAAAv9B,EAAAg9B,gBAMA,IAAA53C,EAaA,IAZAy9C,EAAA93E,IAAAquE,EAAAQ,SAAA2D,IAAAn4C,EAAA4a,EAAAg9B,oBACA6F,GACAU,yBAAAhG,GAEAA,EAAAn4C,GAOAziC,EAAAq9C,EAAAr9C,YACAA,EAAAoQ,OAAA,EAAA8uE,EAAA,GAAAryG,UAAAqyG,EAAA,UAAAl/E,EAAA3c,OAAA,IAKA,GAJAgN,EAAAgtD,EAAAhtD,IACAgtD,EAAAhtD,IAAAvR,EACAkhB,EAAAq9C,EAAAr9C,YACAt1B,EAAAs1B,EAAAtlB,QAAAwkG,EAAA,IACA,KAAAx0G,EAOA,MANAw1G,GAAA10G,EAAAw0B,EAAAoQ,OAAA,EAAA1lC,GAAA6J,OAEAgsG,EAAAtpG,KAAAipG,EAAA10G,IACA6xE,EAAAvtC,MAAA,uCAEAutC,EAAAhtD,KAAA3lB,EACAw1G,CAEA7iC,GAAAhtD,OAcA,MAXA4vF,GAAA5iC,EAAAu9B,EAAAsF,GAEAA,EAAAU,2BACAV,EAAAU,0BAAAX,EAAA5iC,EAAA6iC,EAAAU,0BACAx4E,EAAAquE,EAAAQ,aAIAjvF,EAAAq1D,EAAA07B,aAAAyH,MACAN,EAAAl4F,KAEAk4F,IAmDEzJ,EAAA3hG,GAAA2qG,GAAAK,IAGFI,GAAA,SAAAzJ,EAAAmI,EAAAK,EAAA4B,EAAApB,GASA,QAAAqB,GAAAzjC,GACA,GAAAo5B,EAGA,OAAAp5B,GAAAyd,YAAAzd,EAAA0jC,WAAA,EACA,MAEAtK,EAAAwI,EAAAz0G,QAAA2U,KAAA,SAAA5S,EAAAC,GAGA,MAAA6wE,GAAA7wE,EAAA0yG,YAAA,GAAAryG,OAAAwwE,EAAA9wE,EAAA2yG,YAAA,GAAAryG,SAEA,QAAArB,GAAAsJ,GACA,MAAAA,GAGAksG,EAAA3jC,EAAAvoE,IAAAtJ,EAAAirG,EAAA9sF,SAFA,MAII8sF,EAAA9sF,UAGJ,QAAAq3F,GAAA3jC,EAAAqjC,GACA,GAAA5hG,GAAAohG,EAAAhB,EAAA/9C,EAAA8/C,EAAAC,EAAAC,EAAA/vD,CAGA,IAFAtyC,EAAAu+D,EAAAhtD,IACA6uF,EAAA7hC,EAAAqjC,EAAAxB,aACA7hC,EAAAk8B,YAAA2F,EAAA,IACA,WAGA,IAAAgB,EAAAtB,EAAAvhC,GAEA,MAAAA,GAAAk8B,YAAA2F,EAAA,KAIA7hC,EAAAqjC,EAAAxB,YAAAgB,EACAkB,GAJA,IAQA,IAFA/jC,EAAA+8B,kBACA8F,EAAAW,EAAAxjC,EAAAqjC,GACA,OAAAR,EAEA,MADA7iC,GAAAhtD,IAAAvR,EACA,IAkBA,IAfAu+D,EAAA+8B,kBACA/8B,EAAAk8B,YAAA2F,EAAA,KACA7hC,EAAAvtC,MAAA,+BAAAovE,EAAA,wBAEAgB,EAAA93E,IAAAquE,EAAAS,UACAgJ,EAAAmB,SAAA,GAEAnB,EAAA93E,IAAAquE,EAAAM,UACA15B,EAAAikC,cAAA,EACAjkC,EAAAikC,aAAA,IACAjkC,EAAAhtD,IAAAvR,EACAu+D,EAAAvtC,MAAA,mDAIAowE,EAAAU,yBACAV,EAAAlzG,EAAAkzG,EAAAU,yBACAV,EAAA93E,EAAAquE,EAAAI,QACAqJ,EAAA1wG,EAAA,aACA0wG,GAAAU,6BACI,IAAAW,EAAArB,GAAA,CAKJ,IAJA7iC,EAAAikC,cAAA,EACAngD,KACAggD,EAAAhgD,EACA8/C,EAAAf,EAAA1wG,EACA4hD,EAAAisB,EAAAtjB,QAAA,CACA,GAAA3I,EAAAhpB,IAAAquE,EAAAM,QAAA,CACAkK,GAAA7vD,EAAA5lD,IAAAy1G,GACA5jC,EAAAvtC,MAAA,eAAiCmxE,EAAA,KAEjC,OAGA,GAAA7vD,EAAAhpB,IAAAquE,EAAAE,cAAA,SAAAvlD,EAAA5lD,EAAA,CAEA,cAAA00G,EAAA1wG,EAEO,CACP2xG,EAAAD,IACA,UAHA7jC,EAAAvtC,MAAA,uCAMAqxE,EAAA5jG,KAAA6zC,GAEA+P,EAAAt0D,SACAqzG,EAAAlzG,EAAAm0D,GAEA+/C,KAAAr0G,SACAqzG,EAAA3vF,EAAA2wF,EACA,SAAAhB,EAAA1wG,IACA0wG,EAAA1wG,EAAA,YAcA,MAVA6tE,GAAAmkC,uBACAtB,EAAA/rG,EAAAkpE,EAAAghC,WAAAv/F,IAGAohG,EAAA1wG,EACA0wG,EAAA1wG,EAAAiwG,EAAAS,EAAA1wG,GACI0wG,EAAA93E,IAAAquE,EAAAK,WACJoJ,EAAA93E,EAAAquE,EAAAI,QACAqJ,EAAA1wG,EAAAinG,EAAA6B,gBAEA4H,EAGA,QAAAqB,GAAArB,GACA,MAAAA,GAAA93E,IAAAquE,EAAAI,SAAAqJ,EAAA93E,IAAAquE,EAAAK,SAxHA,GAAA7L,GACAmW,GACAh5E,EAAAquE,EAAAU,YACAkK,SAAA,EAuHA,OArHApW,GAAA6V,GAsHErK,EAAAmI,GAAAK,GAAAc,GAAAN,IAGFgC,GAAA,SAAAhL,GAEA,GAAAiL,GAAA,OACAC,EAAA,KACA,iBAAAtkC,GACA,GAAAv+D,GAAAihG,EAAA//E,EAAA4hF,EAAAH,CAEA,OADA3iG,GAAAu+D,EAAAhtD,IACAgtD,EAAAk8B,YAAAmI,IAGA1hF,EAAAq9C,EAAAr9C,YACA4hF,EAAA5hF,EAAAtlB,QAAAinG,GACA,KAAAC,GACAvkC,EAAAvtC,MAAA,4DAEAiwE,EAAA//E,EAAAoQ,OAAA,EAAAwxE,GACAvkC,EAAAhtD,KAAAuxF,EAAA,EACAH,GACAr5E,EAAAquE,EAAAS,QACA/sG,EAAA41G,GAEA1iC,EAAAmkC,uBACAC,EAAAttG,EAAAkpE,EAAAghC,WAAAv/F,IAEA2iG,GAhBA,OAkBEhL,GAGFoL,GAAA,WAEA,GAAAA,GAAA,oGACA,OAAAA,MAIAC,GAAA,SAAAC,EAAAC,GACA,GAAAh6F,GAAAtd,EAAAu3G,CAEA,KADAj6F,EAAAg6F,EAAAn1G,OACAmb,KAAA,CAGA,GAFAtd,EAAAq3G,EAAArnG,QAAAsnG,EAAAh6F,KAEAtd,EACA,QAEA,MAAAA,KAGAu3G,KAAAv3G,KACAu3G,EAAAv3G,GAGA,MAAAu3G,IAAA,IAIAC,GAAA,WA4TA,QAAAC,GAAA7lF,GACA,MAAAA,GAIA,KAAAA,EACA,GAGA,IAAAA,EACAA,EAIA,KAAAA,EACA8lF,EAAA9lF,EAAA,KAGA,MAAAA,EACAA,EAGA,OAAAA,EACA,MAGA,OAAAA,EACAA,EAEA,MA3BA,MA5TA,GAAA2uE,GACAoX,EAAAD,EAAAE,CAwVA,OAvVAD,IACAE,KAAA,GACAC,IAAA,GACAC,KAAA,GACAr9F,GAAA,GACAhB,GAAA,GACAs+F,KAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,IAAA,IACAC,OAAA,IACAC,KAAA,IACAC,IAAA,IACAvyG,KAAA,IACAwyG,KAAA,IACAC,MAAA,IACAtvG,IAAA,IACAuvG,IAAA,IACAC,IAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACA5lG,MAAA,IACA6lG,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACA/jG,OAAA,IACAgkG,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,QAAA,IACAC,KAAA,IACAC,IAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,QAAA,IACAC,GAAA,IACAC,IAAA,IACAC,MAAA,IACAC,IAAA,IACAC,QAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAlmD,MAAA,IACAmmD,QAAA,IACAC,KAAA,IACAC,IAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,QAAA,IACAC,GAAA,IACAC,IAAA,IACAC,OAAA,IACAC,MAAA,IACAC,IAAA,IACAC,QAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,MAAA,IACAC,SAAA,IACAC,MAAA,IACAC,IAAA,IACAC,KAAA,KACAC,KAAA,KACAC,OAAA,KACAC,KAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,OAAA,KACAC,OAAA,KACAC,KAAA,KACAC,OAAA,KACAC,OAAA,KACAC,MAAA,KACAC,MAAA,KACAC,OAAA,KACAC,OAAA,KACAC,MAAA,KACAC,MAAA,KACAC,KAAA,KACAC,MAAA,KACAC,OAAA,KACAC,KAAA,KACAC,MAAA,KACAC,QAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,MAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,OAAA,KACA3hG,KAAA,KACA4hG,MAAA,KACAh2G,MAAA,KACAi2G,MAAA,KACAC,KAAA,KACAC,MAAA,KACAC,GAAA,KACAC,KAAA,KACArvG,IAAA,KACAsvG,MAAA,KACAC,OAAA,KACAC,MAAA,KACA97G,KAAA,KACA+7G,MAAA,KACAC,IAAA,KACAj4G,IAAA,KACA6F,GAAA,KACAqyG,IAAA,KACAC,IAAA,KACAC,MAAA,KACAC,OAAA,KACAC,IAAA,KACAC,KAAA,KACAC,MAAA,KACAC,GAAA,KACAC,MAAA,KACAC,GAAA,KACAC,GAAA,KACAC,IAAA,KACAC,IAAA,KACAC,KAAA,KACAC,KAAA,KACAC,KAAA,KACAC,MAAA,KACAC,OAAA,KACAC,KAAA,KACAC,KAAA,KACAC,MAAA,KACAC,MAAA,KACAC,OAAA,KACAC,OAAA,KACAvvD,KAAA,KACAwvD,KAAA,KACAC,IAAA,KACAC,OAAA,KACAC,MAAA,KACAC,OAAA,KACAC,MAAA,MAEAjP,GACA,KACA,IACA,KACA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","file":"gameMode-7e758bd1f3a7c694c3b8.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(26);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\t\n\t/**\n\t * Use chrome.storage.local if we are in an app\n\t */\n\t\n\tvar storage;\n\t\n\tif (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')\n\t  storage = chrome.storage.local;\n\telse\n\t  storage = window.localStorage;\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      storage.removeItem('debug');\n\t    } else {\n\t      storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\n\n/***/ },\n\n/***/ 10:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//  Ramda v0.9.1\n\t//  https://github.com/ramda/ramda\n\t//  (c) 2013-2015 Scott Sauyet and Michael Hurley\n\t//  Ramda may be freely distributed under the MIT license.\n\t\n\t;(function() {\n\t\n\t    'use strict';\n\t\n\t    var __ = { ramda: 'placeholder' };\n\t\n\t    var _add = function _add(a, b) {\n\t        return a + b;\n\t    };\n\t\n\t    var _all = function _all(fn, list) {\n\t        var idx = -1;\n\t        while (++idx < list.length) {\n\t            if (!fn(list[idx])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    var _any = function _any(fn, list) {\n\t        var idx = -1;\n\t        while (++idx < list.length) {\n\t            if (fn(list[idx])) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    /**\n\t     * Basic, right-associative composition function. Accepts two functions and returns the\n\t     * composite function; this composite function represents the operation `var h = f(g(x))`,\n\t     * where `f` is the first argument, `g` is the second argument, and `x` is whatever\n\t     * argument(s) are passed to `h`.\n\t     *\n\t     * This function's main use is to build the more general `compose` function, which accepts\n\t     * any number of functions.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} f A function.\n\t     * @param {Function} g A function.\n\t     * @return {Function} A new function that is the equivalent of `f(g(x))`.\n\t     * @example\n\t     *\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var square = function(x) { return x * x; };\n\t     *      var squareThenDouble = _compose(double, square);\n\t     *\n\t     *      squareThenDouble(5); //≅ double(square(5)) => 50\n\t     */\n\t    var _compose = function _compose(f, g) {\n\t        return function () {\n\t            return f.call(this, g.apply(this, arguments));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Private `concat` function to merge two array-like objects.\n\t     *\n\t     * @private\n\t     * @param {Array|Arguments} [set1=[]] An array-like object.\n\t     * @param {Array|Arguments} [set2=[]] An array-like object.\n\t     * @return {Array} A new, merged array.\n\t     * @example\n\t     *\n\t     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n\t     */\n\t    var _concat = function _concat(set1, set2) {\n\t        set1 = set1 || [];\n\t        set2 = set2 || [];\n\t        var idx;\n\t        var len1 = set1.length;\n\t        var len2 = set2.length;\n\t        var result = new Array(len1 + len2);\n\t        idx = -1;\n\t        while (++idx < len1) {\n\t            result[idx] = set1[idx];\n\t        }\n\t        idx = -1;\n\t        while (++idx < len2) {\n\t            result[len1 + idx] = set2[idx];\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _containsWith = function _containsWith(pred, x, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len) {\n\t            if (pred(x, list[idx])) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    /**\n\t     * Create a function which takes a comparator function and a list\n\t     * and determines the winning value by a compatator. Used internally\n\t     * by `R.maxBy` and `R.minBy`\n\t     *\n\t     * @private\n\t     * @param {Function} compatator a function to compare two items\n\t     * @category Math\n\t     * @return {Function}\n\t     */\n\t    var _createMaxMinBy = function _createMaxMinBy(comparator) {\n\t        return function (valueComputer, list) {\n\t            if (!(list && list.length > 0)) {\n\t                return;\n\t            }\n\t            var idx = 0, winner = list[idx], computedWinner = valueComputer(winner), computedCurrent;\n\t            while (++idx < list.length) {\n\t                computedCurrent = valueComputer(list[idx]);\n\t                if (comparator(computedCurrent, computedWinner)) {\n\t                    computedWinner = computedCurrent;\n\t                    winner = list[idx];\n\t                }\n\t            }\n\t            return winner;\n\t        };\n\t    };\n\t\n\t    var _filter = function _filter(fn, list) {\n\t        var idx = -1, len = list.length, result = [];\n\t        while (++idx < len) {\n\t            if (fn(list[idx])) {\n\t                result[result.length] = list[idx];\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _filterIndexed = function _filterIndexed(fn, list) {\n\t        var idx = -1, len = list.length, result = [];\n\t        while (++idx < len) {\n\t            if (fn(list[idx], idx, list)) {\n\t                result[result.length] = list[idx];\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _foldl = function _foldl(fn, acc, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len) {\n\t            acc = fn(acc, list[idx]);\n\t        }\n\t        return acc;\n\t    };\n\t\n\t    // i can't bear not to return *something*\n\t    var _forEach = function _forEach(fn, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len) {\n\t            fn(list[idx]);\n\t        }\n\t        // i can't bear not to return *something*\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * @param {Function} fn The strategy for extracting function names from an object\n\t     * @return {Function} A function that takes an object and returns an array of function names.\n\t     *\n\t     */\n\t    var _functionsWith = function _functionsWith(fn) {\n\t        return function (obj) {\n\t            return _filter(function (key) {\n\t                return typeof obj[key] === 'function';\n\t            }, fn(obj));\n\t        };\n\t    };\n\t\n\t    var _gt = function _gt(a, b) {\n\t        return a > b;\n\t    };\n\t\n\t    /**\n\t     * Internal implementation of `indexOf`.\n\t     * Returns the position of the first occurrence of an item in an array\n\t     * (by strict equality),\n\t     * or -1 if the item is not included in the array.\n\t     *\n\t     * @private\n\t     * @param {Array} list The array to search\n\t     * @param {*} item the item to find in the Array\n\t     * @param {Number} from (optional) the index to start searching the Array\n\t     * @return {Number} The index of the found item, or -1.\n\t     *\n\t     */\n\t    var _indexOf = function _indexOf(list, item, from) {\n\t        var idx = 0, len = list.length;\n\t        if (typeof from == 'number') {\n\t            idx = from < 0 ? Math.max(0, len + from) : from;\n\t        }\n\t        while (idx < len) {\n\t            if (list[idx] === item) {\n\t                return idx;\n\t            }\n\t            ++idx;\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Tests whether or not an object is an array.\n\t     *\n\t     * @private\n\t     * @param {*} val The object to test.\n\t     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n\t     * @example\n\t     *\n\t     *      _isArray([]); //=> true\n\t     *      _isArray(null); //=> false\n\t     *      _isArray({}); //=> false\n\t     */\n\t    var _isArray = Array.isArray || function _isArray(val) {\n\t        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n\t    };\n\t\n\t    /**\n\t     * Determine if the passed argument is an integer.\n\t     *\n\t     * @private\n\t     * @param {*} n\n\t     * @category Type\n\t     * @return {Boolean}\n\t     */\n\t    var _isInteger = Number.isInteger || function _isInteger(n) {\n\t        return n << 0 === n;\n\t    };\n\t\n\t    /**\n\t     * Tests if a value is a thenable (promise).\n\t     */\n\t    var _isThenable = function _isThenable(value) {\n\t        return value != null && value === Object(value) && typeof value.then === 'function';\n\t    };\n\t\n\t    /**\n\t     * Internal implementation of `lastIndexOf`.\n\t     * Returns the position of the last occurrence of an item in an array\n\t     * (by strict equality),\n\t     * or -1 if the item is not included in the array.\n\t     *\n\t     * @private\n\t     * @param {Array} list The array to search\n\t     * @param {*} item the item to find in the Array\n\t     * @param {Number} from (optional) the index to start searching the Array\n\t     * @return {Number} The index of the found item, or -1.\n\t     *\n\t     */\n\t    var _lastIndexOf = function _lastIndexOf(list, item, from) {\n\t        var idx = list.length;\n\t        if (typeof from == 'number') {\n\t            idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n\t        }\n\t        while (--idx >= 0) {\n\t            if (list[idx] === item) {\n\t                return idx;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    var _lt = function _lt(a, b) {\n\t        return a < b;\n\t    };\n\t\n\t    var _map = function _map(fn, list) {\n\t        var idx = -1, len = list.length, result = new Array(len);\n\t        while (++idx < len) {\n\t            result[idx] = fn(list[idx]);\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _multiply = function _multiply(a, b) {\n\t        return a * b;\n\t    };\n\t\n\t    /**\n\t     * Creates an exception about calling a function with no arguments.\n\t     *\n\t     * @private\n\t     * @return {TypeError} A no arguments exception.\n\t     */\n\t    var _noArgsException = function _noArgsException() {\n\t        return new TypeError('Function called with no arguments');\n\t    };\n\t\n\t    var _nth = function _nth(n, list) {\n\t        return n < 0 ? list[list.length + n] : list[n];\n\t    };\n\t\n\t    /**\n\t     * A right-associative two-argument composition function like `_compose`\n\t     * but with automatic handling of promises (or, more precisely,\n\t     * \"thenables\"). This function is used to construct a more general\n\t     * `pCompose` function, which accepts any number of arguments.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} f A function.\n\t     * @param {Function} g A function.\n\t     * @return {Function} A new function that is the equivalent of `f(g(x))`.\n\t     * @example\n\t     *\n\t     *      var Q = require('q');\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var squareAsync = function(x) { return Q.when(x * x); };\n\t     *      var squareAsyncThenDouble = _pCompose(double, squareAsync);\n\t     *\n\t     *      squareAsyncThenDouble(5)\n\t     *          .then(function(result) {\n\t     *            // the result is now 50.\n\t     *          });\n\t     */\n\t    var _pCompose = function _pCompose(f, g) {\n\t        return function () {\n\t            var context = this;\n\t            var value = g.apply(this, arguments);\n\t            if (_isThenable(value)) {\n\t                return value.then(function (result) {\n\t                    return f.call(context, result);\n\t                });\n\t            } else {\n\t                return f.call(this, value);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * @param {Function} fn The strategy for extracting keys from an object\n\t     * @return {Function} A function that takes an object and returns an array of\n\t     *         key-value arrays.\n\t     */\n\t    var _pairWith = function _pairWith(fn) {\n\t        return function (obj) {\n\t            return _map(function (key) {\n\t                return [\n\t                    key,\n\t                    obj[key]\n\t                ];\n\t            }, fn(obj));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * internal path function\n\t     * Takes an array, paths, indicating the deep set of keys\n\t     * to find.\n\t     *\n\t     * @private\n\t     * @memberOf R\n\t     * @category Object\n\t     * @param {Array} paths An array of strings to map to object properties\n\t     * @param {Object} obj The object to find the path in\n\t     * @return {Array} The value at the end of the path or `undefined`.\n\t     * @example\n\t     *\n\t     *      _path(['a', 'b'], {a: {b: 2}}); //=> 2\n\t     */\n\t    var _path = function _path(paths, obj) {\n\t        var idx = -1, length = paths.length, val;\n\t        if (obj == null) {\n\t            return;\n\t        }\n\t        val = obj;\n\t        while (val != null && ++idx < length) {\n\t            val = val[paths[idx]];\n\t        }\n\t        return val;\n\t    };\n\t\n\t    /**\n\t     * Internal implementation of `pickAll`\n\t     *\n\t     * @private\n\t     * @see R.pickAll\n\t     */\n\t    var _pickAll = function _pickAll(names, obj) {\n\t        var copy = {};\n\t        _forEach(function (name) {\n\t            copy[name] = obj[name];\n\t        }, names);\n\t        return copy;\n\t    };\n\t\n\t    var _prepend = function _prepend(el, list) {\n\t        return _concat([el], list);\n\t    };\n\t\n\t    /**\n\t     * internal helper for `where`\n\t     *\n\t     * @private\n\t     * @see R.where\n\t     */\n\t    var _satisfiesSpec = function _satisfiesSpec(spec, parsedSpec, testObj) {\n\t        if (spec === testObj) {\n\t            return true;\n\t        }\n\t        if (testObj == null) {\n\t            return false;\n\t        }\n\t        parsedSpec.fn = parsedSpec.fn || [];\n\t        parsedSpec.obj = parsedSpec.obj || [];\n\t        var key, val, idx = -1, fnLen = parsedSpec.fn.length, j = -1, objLen = parsedSpec.obj.length;\n\t        while (++idx < fnLen) {\n\t            key = parsedSpec.fn[idx];\n\t            val = spec[key];\n\t            if (!(key in testObj)) {\n\t                return false;\n\t            }\n\t            if (!val(testObj[key], testObj)) {\n\t                return false;\n\t            }\n\t        }\n\t        while (++j < objLen) {\n\t            key = parsedSpec.obj[j];\n\t            if (spec[key] !== testObj[key]) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * An optimized, private array `slice` implementation.\n\t     *\n\t     * @private\n\t     * @param {Arguments|Array} args The array or arguments object to consider.\n\t     * @param {Number} [from=0] The array index to slice from, inclusive.\n\t     * @param {Number} [to=args.length] The array index to slice to, exclusive.\n\t     * @return {Array} A new, sliced array.\n\t     * @example\n\t     *\n\t     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n\t     *\n\t     *      var firstThreeArgs = function(a, b, c, d) {\n\t     *        return _slice(arguments, 0, 3);\n\t     *      };\n\t     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n\t     */\n\t    var _slice = function _slice(args, from, to) {\n\t        switch (arguments.length) {\n\t        case 0:\n\t            throw _noArgsException();\n\t        case 1:\n\t            return _slice(args, 0, args.length);\n\t        case 2:\n\t            return _slice(args, from, args.length);\n\t        default:\n\t            var length = Math.max(0, to - from), list = new Array(length), idx = -1;\n\t            while (++idx < length) {\n\t                list[idx] = args[from + idx];\n\t            }\n\t            return list;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Returns a function that always returns the given value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig a -> (* -> a)\n\t     * @param {*} val The value to wrap in a function\n\t     * @return {Function} A Function :: * -> val.\n\t     * @example\n\t     *\n\t     *      var t = R.always('Tee');\n\t     *      t(); //=> 'Tee'\n\t     */\n\t    var always = function always(val) {\n\t        return function () {\n\t            return val;\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`\n\t     * parameters. Unlike `nAry`, which passes only `n` arguments to the wrapped function,\n\t     * functions produced by `arity` will pass all provided arguments to the wrapped function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @sig (Number, (* -> *)) -> (* -> *)\n\t     * @category Function\n\t     * @param {Number} n The desired arity of the returned function.\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is\n\t     *         guaranteed to be of arity `n`.\n\t     * @example\n\t     *\n\t     *      var takesTwoArgs = function(a, b) {\n\t     *        return [a, b];\n\t     *      };\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      takesTwoArgs(1, 2); //=> [1, 2]\n\t     *\n\t     *      var takesOneArg = R.arity(1, takesTwoArgs);\n\t     *      takesOneArg.length; //=> 1\n\t     *      // All arguments are passed through to the wrapped function\n\t     *      takesOneArg(1, 2); //=> [1, 2]\n\t     */\n\t    var arity = function (n, fn) {\n\t        switch (n) {\n\t        case 0:\n\t            return function () {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 1:\n\t            return function (a0) {\n\t                void a0;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 2:\n\t            return function (a0, a1) {\n\t                void a1;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 3:\n\t            return function (a0, a1, a2) {\n\t                void a2;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 4:\n\t            return function (a0, a1, a2, a3) {\n\t                void a3;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 5:\n\t            return function (a0, a1, a2, a3, a4) {\n\t                void a4;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 6:\n\t            return function (a0, a1, a2, a3, a4, a5) {\n\t                void a5;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 7:\n\t            return function (a0, a1, a2, a3, a4, a5, a6) {\n\t                void a6;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 8:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n\t                void a7;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 9:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n\t                void a8;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 10:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n\t                void a9;\n\t                return fn.apply(this, arguments);\n\t            };\n\t        default:\n\t            throw new Error('First argument to arity must be a non-negative integer no greater than ten');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Returns the result of calling its first argument with the remaining\n\t     * arguments. This is occasionally useful as a converging function for\n\t     * `R.converge`: the left branch can produce a function while the right\n\t     * branch produces a value to be passed to that function as an argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (*... -> a),*... -> a\n\t     * @param {Function} fn The function to apply to the remaining arguments.\n\t     * @param {...*} args Any number of positional arguments.\n\t     * @return {*}\n\t     * @example\n\t     *\n\t     *      var indentN = R.pipe(R.times(R.always(' ')),\n\t     *                           R.join(''),\n\t     *                           R.replace(/^(?!$)/gm));\n\t     *\n\t     *      var format = R.converge(R.call,\n\t     *                              R.pipe(R.prop('indent'), indentN),\n\t     *                              R.prop('value'));\n\t     *\n\t     *      format({indent: 2, value: 'foo\\nbar\\nbaz\\n'}); //=> '  foo\\n  bar\\n  baz\\n'\n\t     */\n\t    var call = function call(fn) {\n\t        return fn.apply(this, _slice(arguments, 1));\n\t    };\n\t\n\t    /**\n\t     * Makes a comparator function out of a function that reports whether the first element is less than the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a, b -> Boolean) -> (a, b -> Number)\n\t     * @param {Function} pred A predicate function of arity two.\n\t     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.\n\t     * @example\n\t     *\n\t     *      var cmp = R.comparator(function(a, b) {\n\t     *        return a.age < b.age;\n\t     *      });\n\t     *      var people = [\n\t     *        // ...\n\t     *      ];\n\t     *      R.sort(cmp, people);\n\t     */\n\t    var comparator = function comparator(pred) {\n\t        return function (a, b) {\n\t            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Returns a function, `fn`, which encapsulates if/else-if/else logic.\n\t     * Each argument to `R.cond` is a [predicate, transform] pair. All of\n\t     * the arguments to `fn` are applied to each of the predicates in turn\n\t     * until one returns a \"truthy\" value, at which point `fn` returns the\n\t     * result of applying its arguments to the corresponding transformer.\n\t     * If none of the predicates matches, `fn` returns undefined.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig [(*... -> Boolean),(*... -> *)]... -> (*... -> *)\n\t     * @param {...Function} functions\n\t     * @return {Function}\n\t     * @example\n\t     *\n\t     *      var fn = R.cond(\n\t     *          [R.eq(0),   R.always('water freezes at 0°C')],\n\t     *          [R.eq(100), R.always('water boils at 100°C')],\n\t     *          [R.T,       function(temp) { return 'nothing special happens at ' + temp + '°C'; }]\n\t     *      );\n\t     *      fn(0); //=> 'water freezes at 0°C'\n\t     *      fn(50); //=> 'nothing special happens at 50°C'\n\t     *      fn(100); //=> 'water boils at 100°C'\n\t     */\n\t    var cond = function cond() {\n\t        var pairs = arguments;\n\t        return function () {\n\t            var idx = -1;\n\t            while (++idx < pairs.length) {\n\t                if (pairs[idx][0].apply(this, arguments)) {\n\t                    return pairs[idx][1].apply(this, arguments);\n\t                }\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Accepts at least three functions and returns a new function. When invoked, this new\n\t     * function will invoke the first function, `after`, passing as its arguments the\n\t     * results of invoking the subsequent functions with whatever arguments are passed to\n\t     * the new function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((*... -> c) -> (((* -> a), (* -> b), ...) -> c)\n\t     * @param {Function} after A function. `after` will be invoked with the return values of\n\t     *        `fn1` and `fn2` as its arguments.\n\t     * @param {...Function} functions A variable number of functions.\n\t     * @return {Function} A new function.\n\t     * @example\n\t     *\n\t     *      var add = function(a, b) { return a + b; };\n\t     *      var multiply = function(a, b) { return a * b; };\n\t     *      var subtract = function(a, b) { return a - b; };\n\t     *\n\t     *      //≅ multiply( add(1, 2), subtract(1, 2) );\n\t     *      R.converge(multiply, add, subtract)(1, 2); //=> -3\n\t     *\n\t     *      var add3 = function(a, b, c) { return a + b + c; };\n\t     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4\n\t     */\n\t    var converge = function (after) {\n\t        var fns = _slice(arguments, 1);\n\t        return function () {\n\t            var args = arguments;\n\t            return after.apply(this, _map(function (fn) {\n\t                return fn.apply(this, args);\n\t            }, fns));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Returns a new function much like the supplied one, except that the first two arguments'\n\t     * order is reversed.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n\t     * @param {Function} fn The function to invoke with its first two parameters reversed.\n\t     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n\t     * @example\n\t     *\n\t     *      var mergeThree = function(a, b, c) {\n\t     *        return ([]).concat(a, b, c);\n\t     *      };\n\t     *\n\t     *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n\t     *\n\t     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n\t     */\n\t    var flip = function flip(fn) {\n\t        return function (a, b) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                throw _noArgsException();\n\t            case 1:\n\t                return function (b) {\n\t                    return fn.apply(this, [\n\t                        b,\n\t                        a\n\t                    ].concat(_slice(arguments, 1)));\n\t                };\n\t            default:\n\t                return fn.apply(this, _concat([\n\t                    b,\n\t                    a\n\t                ], _slice(arguments, 2)));\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Creates a new object out of a list key-value pairs.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [[k,v]] -> {k: v}\n\t     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.\n\t     * @return {Object} The object made by pairing up `keys` and `values`.\n\t     * @example\n\t     *\n\t     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}\n\t     */\n\t    var fromPairs = function fromPairs(pairs) {\n\t        var idx = -1, len = pairs.length, out = {};\n\t        while (++idx < len) {\n\t            if (_isArray(pairs[idx]) && pairs[idx].length) {\n\t                out[pairs[idx][0]] = pairs[idx][1];\n\t            }\n\t        }\n\t        return out;\n\t    };\n\t\n\t    /**\n\t     * Calls the specified function on the supplied object. Any additional arguments\n\t     * after `fn` and `obj` are passed in to `fn`. If no additional arguments are passed to `func`,\n\t     * `fn` is invoked with no arguments.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig k -> {k : v} -> v(*)\n\t     * @param {String} funcName The name of the property mapped to the function to invoke\n\t     * @param {Object} obj The object\n\t     * @return {*} The value of invoking `obj.fn`.\n\t     * @example\n\t     *\n\t     *      R.func('add', R, 1, 2); //=> 3\n\t     *\n\t     *      var obj = { f: function() { return 'f called'; } };\n\t     *      R.func('f', obj); //=> 'f called'\n\t     */\n\t    var func = function func(funcName, obj) {\n\t        switch (arguments.length) {\n\t        case 0:\n\t            throw _noArgsException();\n\t        case 1:\n\t            return function (obj) {\n\t                return obj[funcName].apply(obj, _slice(arguments, 1));\n\t            };\n\t        default:\n\t            return obj[funcName].apply(obj, _slice(arguments, 2));\n\t        }\n\t    };\n\t\n\t    /**\n\t     * A function that does nothing but return the parameter supplied to it. Good as a default\n\t     * or placeholder function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig a -> a\n\t     * @param {*} x The value to return.\n\t     * @return {*} The input value, `x`.\n\t     * @example\n\t     *\n\t     *      R.identity(1); //=> 1\n\t     *\n\t     *      var obj = {};\n\t     *      R.identity(obj) === obj; //=> true\n\t     */\n\t    var identity = function identity(x) {\n\t        return x;\n\t    };\n\t\n\t    /**\n\t     * Tests whether or not an object is similar to an array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Type\n\t     * @category List\n\t     * @param {*} x The object to test.\n\t     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n\t     * @example\n\t     *\n\t     *      R.isArrayLike([]); //=> true\n\t     *      R.isArrayLike(true); //=> false\n\t     *      R.isArrayLike({}); //=> false\n\t     *      R.isArrayLike({length: 10}); //=> false\n\t     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n\t     */\n\t    var isArrayLike = function isArrayLike(x) {\n\t        if (_isArray(x)) {\n\t            return true;\n\t        }\n\t        if (!x) {\n\t            return false;\n\t        }\n\t        if (typeof x !== 'object') {\n\t            return false;\n\t        }\n\t        if (x instanceof String) {\n\t            return false;\n\t        }\n\t        if (x.nodeType === 1) {\n\t            return !!x.length;\n\t        }\n\t        if (x.length === 0) {\n\t            return true;\n\t        }\n\t        if (x.length > 0) {\n\t            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n\t        }\n\t        return false;\n\t    };\n\t\n\t    /**\n\t     * Reports whether the list has zero elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig [a] -> Boolean\n\t     * @param {Array} list\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      R.isEmpty([1, 2, 3]); //=> false\n\t     *      R.isEmpty([]); //=> true\n\t     *      R.isEmpty(''); //=> true\n\t     *      R.isEmpty(null); //=> false\n\t     */\n\t    var isEmpty = function isEmpty(list) {\n\t        return Object(list).length === 0;\n\t    };\n\t\n\t    /**\n\t     * Checks if the input value is `null` or `undefined`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Type\n\t     * @sig * -> Boolean\n\t     * @param {*} x The value to test.\n\t     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n\t     * @example\n\t     *\n\t     *     R.isNil(null); //=> true\n\t     *     R.isNil(undefined); //=> true\n\t     *     R.isNil(0); //=> false\n\t     *     R.isNil([]); //=> false\n\t     */\n\t    var isNil = function isNil(x) {\n\t        return x == null;\n\t    };\n\t\n\t    /**\n\t     * Returns `true` if all elements are unique, otherwise `false`.\n\t     * Uniqueness is determined using strict equality (`===`).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> Boolean\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if all elements are unique, else `false`.\n\t     * @example\n\t     *\n\t     *      R.isSet(['1', 1]); //=> true\n\t     *      R.isSet([1, 1]);   //=> false\n\t     *      R.isSet([{}, {}]); //=> true\n\t     */\n\t    var isSet = function isSet(list) {\n\t        var len = list.length;\n\t        var idx = -1;\n\t        while (++idx < len) {\n\t            if (_indexOf(list, list[idx], idx + 1) >= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Returns a list containing the names of all the\n\t     * properties of the supplied object, including prototype properties.\n\t     * Note that the order of the output array is not guaranteed to be\n\t     * consistent across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [k]\n\t     * @param {Object} obj The object to extract properties from\n\t     * @return {Array} An array of the object's own and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.keysIn(f); //=> ['x', 'y']\n\t     */\n\t    var keysIn = function keysIn(obj) {\n\t        var prop, ks = [];\n\t        for (prop in obj) {\n\t            ks[ks.length] = prop;\n\t        }\n\t        return ks;\n\t    };\n\t\n\t    /**\n\t     * Creates a new function that, when invoked, caches the result of calling `fn` for a given\n\t     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same\n\t     * argument set will not result in an additional call to `fn`; instead, the cached result\n\t     * for that set of arguments will be returned.\n\t     *\n\t     * Note that this version of `memoize` effectively handles only string and number\n\t     * parameters.  Also note that it does not work on variadic functions.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a... -> b) -> (a... -> b)\n\t     * @param {Function} fn The function to be wrapped by `memoize`.\n\t     * @return {Function}  Returns a memoized version of `fn`.\n\t     * @example\n\t     *\n\t     *      var numberOfCalls = 0;\n\t     *      var trackedAdd = function(a, b) {\n\t     *        numberOfCalls += 1;\n\t     *        return a + b;\n\t     *      };\n\t     *      var memoTrackedAdd = R.memoize(trackedAdd);\n\t     *\n\t     *      memoTrackedAdd(1, 2); //=> 3\n\t     *      numberOfCalls; //=> 1\n\t     *      memoTrackedAdd(1, 2); //=> 3\n\t     *      numberOfCalls; //=> 1\n\t     *      memoTrackedAdd(2, 3); //=> 5\n\t     *      numberOfCalls; //=> 2\n\t     *\n\t     *      // Note that argument order matters\n\t     *      memoTrackedAdd(2, 1); //=> 3\n\t     *      numberOfCalls; //=> 3\n\t     */\n\t    var memoize = function memoize(fn) {\n\t        var cache = {};\n\t        return function () {\n\t            if (!arguments.length) {\n\t                return;\n\t            }\n\t            var position = _foldl(function (cache, arg) {\n\t                return cache[arg] || (cache[arg] = {});\n\t            }, cache, _slice(arguments, 0, arguments.length - 1));\n\t            var arg = arguments[arguments.length - 1];\n\t            return position[arg] || (position[arg] = fn.apply(this, arguments));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`\n\t     * parameters. Any extraneous parameters will not be passed to the supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig Number -> (* -> a) -> (* -> a)\n\t     * @param {Number} n The desired arity of the new function.\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity `n`.\n\t     * @example\n\t     *\n\t     *      var takesTwoArgs = function(a, b) {\n\t     *        return [a, b];\n\t     *      };\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      takesTwoArgs(1, 2); //=> [1, 2]\n\t     *\n\t     *      var takesOneArg = R.nAry(1, takesTwoArgs);\n\t     *      takesOneArg.length; //=> 1\n\t     *      // Only `n` arguments are passed to the wrapped function\n\t     *      takesOneArg(1, 2); //=> [1, undefined]\n\t     */\n\t    var nAry = function (n, fn) {\n\t        switch (n) {\n\t        case 0:\n\t            return function () {\n\t                return fn.call(this);\n\t            };\n\t        case 1:\n\t            return function (a0) {\n\t                return fn.call(this, a0);\n\t            };\n\t        case 2:\n\t            return function (a0, a1) {\n\t                return fn.call(this, a0, a1);\n\t            };\n\t        case 3:\n\t            return function (a0, a1, a2) {\n\t                return fn.call(this, a0, a1, a2);\n\t            };\n\t        case 4:\n\t            return function (a0, a1, a2, a3) {\n\t                return fn.call(this, a0, a1, a2, a3);\n\t            };\n\t        case 5:\n\t            return function (a0, a1, a2, a3, a4) {\n\t                return fn.call(this, a0, a1, a2, a3, a4);\n\t            };\n\t        case 6:\n\t            return function (a0, a1, a2, a3, a4, a5) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5);\n\t            };\n\t        case 7:\n\t            return function (a0, a1, a2, a3, a4, a5, a6) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);\n\t            };\n\t        case 8:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);\n\t            };\n\t        case 9:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);\n\t            };\n\t        case 10:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n\t            };\n\t        default:\n\t            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * A function wrapping a call to the given function in a `!` operation.  It will return `true` when the\n\t     * underlying function would return a false-y value, and `false` when it would return a truth-y one.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> Boolean)\n\t     * @param {Function} f a predicate\n\t     * @return {Function} a function that applies its arguments to `f` and logically inverts its output.\n\t     * @example\n\t     *\n\t     *      var gt10 = function(x) { return x > 10; };\n\t     *      var f = R.not(gt10);\n\t     *      f(11); //=> false\n\t     *      f(9); //=> true\n\t     */\n\t    var not = function not(f) {\n\t        return function () {\n\t            return !f.apply(this, arguments);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Returns a function which returns its nth argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig Number -> *... -> *\n\t     * @param {Number} n\n\t     * @return {Function}\n\t     * @example\n\t     *\n\t     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'\n\t     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'\n\t     */\n\t    var nthArg = function nthArg(n) {\n\t        return function () {\n\t            return _nth(n, arguments);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that\n\t     * `fn` can only ever be called once, no matter how many times the returned function is\n\t     * invoked.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a... -> b) -> (a... -> b)\n\t     * @param {Function} fn The function to wrap in a call-only-once wrapper.\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      var addOneOnce = R.once(function(x){ return x + 1; });\n\t     *      addOneOnce(10); //=> 11\n\t     *      addOneOnce(addOneOnce(50)); //=> 11\n\t     */\n\t    var once = function once(fn) {\n\t        var called = false, result;\n\t        return function () {\n\t            if (called) {\n\t                return result;\n\t            }\n\t            called = true;\n\t            result = fn.apply(this, arguments);\n\t            return result;\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Flipped version of R.prepend.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> a -> [a]\n\t     * @param {Array} list\n\t     * @param {*} el\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      R.prependTo(['fi', 'fo', 'fum'], 'fee'); //=> ['fee', 'fi', 'fo', 'fum']\n\t     */\n\t    var prependTo = flip(_prepend);\n\t\n\t    /**\n\t     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig s -> {s: a} -> a\n\t     * @param {String} p The property name\n\t     * @param {Object} obj The object to query\n\t     * @return {*} The value at `obj.p`.\n\t     * @example\n\t     *\n\t     *      R.prop('x', {x: 100}); //=> 100\n\t     *      R.prop('x', {}); //=> undefined\n\t     */\n\t    var prop = function prop(p, obj) {\n\t        switch (arguments.length) {\n\t        case 0:\n\t            throw _noArgsException();\n\t        case 1:\n\t            return function _prop(obj) {\n\t                return obj[p];\n\t            };\n\t        }\n\t        return obj[p];\n\t    };\n\t\n\t    /**\n\t     * Returns the value at the specified property.\n\t     * The only difference from `prop` is the parameter order.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @see R.prop\n\t     * @category Object\n\t     * @sig {k: v} -> k -> v\n\t     * @param {Object} obj The object to query\n\t     * @param {String} p The property name\n\t     * @return {*} The value at `obj.p`.\n\t     * @example\n\t     *\n\t     *      R.propOf({x: 100}, 'x'); //=> 100\n\t     */\n\t    var propOf = flip(prop);\n\t\n\t    /**\n\t     * Returns a new list with the same elements as the original list, just\n\t     * in the reverse order.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} list The list to reverse.\n\t     * @return {Array} A copy of the list in reverse order.\n\t     * @example\n\t     *\n\t     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n\t     *      R.reverse([1, 2]);     //=> [2, 1]\n\t     *      R.reverse([1]);        //=> [1]\n\t     *      R.reverse([]);         //=> []\n\t     */\n\t    var reverse = function reverse(list) {\n\t        return _slice(list).reverse();\n\t    };\n\t\n\t    /**\n\t     * Converts an object into an array of key, value arrays.\n\t     * The object's own properties and prototype properties are used.\n\t     * Note that the order of the output array is not guaranteed to be\n\t     * consistent across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [[k,v]]\n\t     * @param {Object} obj The object to extract from\n\t     * @return {Array} An array of key, value arrays from the object's own\n\t     *         and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n\t     */\n\t    var toPairsIn = _pairWith(keysIn);\n\t\n\t    /**\n\t     * Removes (strips) whitespace from both ends of the string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to trim.\n\t     * @return {String} Trimmed version of `str`.\n\t     * @example\n\t     *\n\t     *      R.trim('   xyz  '); //=> 'xyz'\n\t     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n\t     */\n\t    var trim = function () {\n\t        var ws = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\n\t        var zeroWidth = '\\u200B';\n\t        var hasProtoTrim = typeof String.prototype.trim === 'function';\n\t        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {\n\t            return function trim(str) {\n\t                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n\t                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n\t                return str.replace(beginRx, '').replace(endRx, '');\n\t            };\n\t        } else {\n\t            return function trim(str) {\n\t                return str.trim();\n\t            };\n\t        }\n\t    }();\n\t\n\t    /**\n\t     * Gives a single-word string description of the (native) type of a value, returning such\n\t     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user\n\t     * Object types any further, reporting them all as 'Object'.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Type\n\t     * @sig (* -> {*}) -> String\n\t     * @param {*} val The value to test\n\t     * @return {String}\n\t     * @example\n\t     *\n\t     *      R.type({}); //=> \"Object\"\n\t     *      R.type(1); //=> \"Number\"\n\t     *      R.type(false); //=> \"Boolean\"\n\t     *      R.type('s'); //=> \"String\"\n\t     *      R.type(null); //=> \"Null\"\n\t     *      R.type([]); //=> \"Array\"\n\t     *      R.type(/[A-z]/); //=> \"RegExp\"\n\t     */\n\t    var type = function type(val) {\n\t        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n\t    };\n\t\n\t    /**\n\t     * Takes a function `fn`, which takes a single array argument, and returns\n\t     * a function which:\n\t     *\n\t     *   - takes any number of positional arguments;\n\t     *   - passes these arguments to `fn` as an array; and\n\t     *   - returns the result.\n\t     *\n\t     * In other words, R.unapply derives a variadic function from a function\n\t     * which takes an array. R.unapply is the inverse of R.apply.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ([*...] -> a) -> (*... -> a)\n\t     * @param {Function} fn\n\t     * @return {Function}\n\t     * @see R.apply\n\t     * @example\n\t     *\n\t     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n\t     */\n\t    var unapply = function unapply(fn) {\n\t        if (arguments.length === 0) {\n\t            throw _noArgsException();\n\t        }\n\t        return function () {\n\t            return fn(_slice(arguments));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1\n\t     * parameter. Any extraneous parameters will not be passed to the supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (* -> b) -> (a -> b)\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity 1.\n\t     * @example\n\t     *\n\t     *      var takesTwoArgs = function(a, b) {\n\t     *        return [a, b];\n\t     *      };\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      takesTwoArgs(1, 2); //=> [1, 2]\n\t     *\n\t     *      var takesOneArg = R.unary(takesTwoArgs);\n\t     *      takesOneArg.length; //=> 1\n\t     *      // Only 1 argument is passed to the wrapped function\n\t     *      takesOneArg(1, 2); //=> [1, undefined]\n\t     */\n\t    var unary = function unary(fn) {\n\t        return nAry(1, fn);\n\t    };\n\t\n\t    /**\n\t     * Returns a list of all the properties, including prototype properties,\n\t     * of the supplied object.\n\t     * Note that the order of the output array is not guaranteed to be\n\t     * consistent across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [v]\n\t     * @param {Object} obj The object to extract values from\n\t     * @return {Array} An array of the values of the object's own and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.valuesIn(f); //=> ['X', 'Y']\n\t     */\n\t    var valuesIn = function valuesIn(obj) {\n\t        var prop, vs = [];\n\t        for (prop in obj) {\n\t            vs[vs.length] = obj[prop];\n\t        }\n\t        return vs;\n\t    };\n\t\n\t    /**\n\t     * A function that always returns `false`. Any passed in parameters are ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig * -> false\n\t     * @see R.always\n\t     * @return {Boolean} false\n\t     * @example\n\t     *\n\t     *      R.F(); //=> false\n\t     */\n\t    var F = always(false);\n\t\n\t    /**\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @see R.identity\n\t     */\n\t    var I = identity;\n\t\n\t    /**\n\t     * A function that always returns `true`. Any passed in parameters are ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig * -> true\n\t     * @see R.always\n\t     * @return {Boolean} `true`.\n\t     * @example\n\t     *\n\t     *      R.T(); //=> true\n\t     */\n\t    var T = always(true);\n\t\n\t    var _append = function _append(el, list) {\n\t        return _concat(list, [el]);\n\t    };\n\t\n\t    /**\n\t     * Copies an object.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to be copied\n\t     * @param {Array} refFrom Array containing the source references\n\t     * @param {Array} refTo Array containing the copied source references\n\t     * @return {*} The copied value.\n\t     */\n\t    var _baseCopy = function _baseCopy(value, refFrom, refTo) {\n\t        var copy = function copy(copiedValue) {\n\t            var len = refFrom.length;\n\t            var idx = -1;\n\t            while (++idx < len) {\n\t                if (value === refFrom[idx]) {\n\t                    return refTo[idx];\n\t                }\n\t            }\n\t            refFrom[refFrom.length] = value;\n\t            refTo[refTo.length] = copiedValue;\n\t            for (var key in value) {\n\t                copiedValue[key] = _baseCopy(value[key], refFrom, refTo);\n\t            }\n\t            return copiedValue;\n\t        };\n\t        switch (type(value)) {\n\t        case 'Object':\n\t            return copy({});\n\t        case 'Array':\n\t            return copy([]);\n\t        case 'Date':\n\t            return new Date(value);\n\t        default:\n\t            return value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Similar to hasMethod, this checks whether a function has a [methodname]\n\t     * function. If it isn't an array it will execute that function otherwise it will\n\t     * default to the ramda implementation.\n\t     *\n\t     * @private\n\t     * @param {Function} fn ramda implemtation\n\t     * @param {String} methodname property to check for a custom implementation\n\t     * @return {Object} Whatever the return value of the method is.\n\t     */\n\t    var _checkForMethod = function _checkForMethod(methodname, fn) {\n\t        return function (a, b, c) {\n\t            var length = arguments.length;\n\t            var obj = arguments[length - 1], callBound = obj && !_isArray(obj) && typeof obj[methodname] === 'function';\n\t            switch (arguments.length) {\n\t            case 0:\n\t                return fn();\n\t            case 1:\n\t                return callBound ? obj[methodname]() : fn(a);\n\t            case 2:\n\t                return callBound ? obj[methodname](a) : fn(a, b);\n\t            case 3:\n\t                return callBound ? obj[methodname](a, b) : fn(a, b, c);\n\t            }\n\t        };\n\t    };\n\t\n\t    var _contains = function _contains(a, list) {\n\t        return _indexOf(list, a) >= 0;\n\t    };\n\t\n\t    /*\n\t     * Returns a function that makes a multi-argument version of compose from\n\t     * either _compose or _pCompose.\n\t     */\n\t    var _createComposer = function _createComposer(composeFunction) {\n\t        return function () {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                throw _noArgsException();\n\t            case 1:\n\t                return arguments[0];\n\t            default:\n\t                var idx = arguments.length - 1, fn = arguments[idx], length = fn.length;\n\t                while (idx--) {\n\t                    fn = composeFunction(arguments[idx], fn);\n\t                }\n\t                return arity(length, fn);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Create a function which takes a a list\n\t     * and determines the winning value by a compatator. Used internally\n\t     * by `R.max` and `R.min`\n\t     *\n\t     * @private\n\t     * @param {Function} compatator a function to compare two items\n\t     * @param {*} intialVal, default value if nothing else wins\n\t     * @category Math\n\t     * @return {Function}\n\t     */\n\t    var _createMaxMin = function _createMaxMin(comparator, initialVal) {\n\t        return function (list) {\n\t            if (arguments.length === 0) {\n\t                throw _noArgsException();\n\t            }\n\t            var idx = -1, winner = initialVal, computed;\n\t            while (++idx < list.length) {\n\t                computed = +list[idx];\n\t                if (comparator(computed, winner)) {\n\t                    winner = computed;\n\t                }\n\t            }\n\t            return winner;\n\t        };\n\t    };\n\t\n\t    var _createPartialApplicator = function _createPartialApplicator(concat) {\n\t        return function (fn) {\n\t            var args = _slice(arguments, 1);\n\t            return arity(Math.max(0, fn.length - args.length), function () {\n\t                return fn.apply(this, concat(args, arguments));\n\t            });\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Optimized internal two-arity curry function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     * @example\n\t     *\n\t     *      var addTwo = function(a, b) {\n\t     *        return a + b;\n\t     *      };\n\t     *\n\t     *      var curriedAddTwo = _curry2(addTwo);\n\t     */\n\t    var _curry2 = function _curry2(fn) {\n\t        return function (a, b) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                throw _noArgsException();\n\t            case 1:\n\t                return function (b) {\n\t                    return fn(a, b);\n\t                };\n\t            default:\n\t                return fn(a, b);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Optimized internal three-arity curry function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     * @example\n\t     *\n\t     *      var addThree = function(a, b, c) {\n\t     *        return a + b + c;\n\t     *      };\n\t     *\n\t     *      var curriedAddThree = _curry3(addThree);\n\t     */\n\t    var _curry3 = function _curry3(fn) {\n\t        return function (a, b, c) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                throw _noArgsException();\n\t            case 1:\n\t                return _curry2(function (b, c) {\n\t                    return fn(a, b, c);\n\t                });\n\t            case 2:\n\t                return function (c) {\n\t                    return fn(a, b, c);\n\t                };\n\t            default:\n\t                return fn(a, b, c);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Private function that determines whether or not a provided object has a given method.\n\t     * Does not ignore methods stored on the object's prototype chain. Used for dynamically\n\t     * dispatching Ramda methods to non-Array objects.\n\t     *\n\t     * @private\n\t     * @param {String} methodName The name of the method to check for.\n\t     * @param {Object} obj The object to test.\n\t     * @return {Boolean} `true` has a given method, `false` otherwise.\n\t     * @example\n\t     *\n\t     *      var person = { name: 'John' };\n\t     *      person.shout = function() { alert(this.name); };\n\t     *\n\t     *      _hasMethod('shout', person); //=> true\n\t     *      _hasMethod('foo', person); //=> false\n\t     */\n\t    var _hasMethod = function _hasMethod(methodName, obj) {\n\t        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';\n\t    };\n\t\n\t    /**\n\t     * `_makeFlat` is a helper function that returns a one-level or fully recursive function\n\t     * based on the flag passed in.\n\t     *\n\t     * @private\n\t     */\n\t    var _makeFlat = function _makeFlat(recursive) {\n\t        return function flatt(list) {\n\t            var value, result = [], idx = -1, j, ilen = list.length, jlen;\n\t            while (++idx < ilen) {\n\t                if (isArrayLike(list[idx])) {\n\t                    value = recursive ? flatt(list[idx]) : list[idx];\n\t                    j = -1;\n\t                    jlen = value.length;\n\t                    while (++j < jlen) {\n\t                        result[result.length] = value[j];\n\t                    }\n\t                } else {\n\t                    result[result.length] = list[idx];\n\t                }\n\t            }\n\t            return result;\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Internal helper function for making a partial copy of an object\n\t     *\n\t     * @private\n\t     *\n\t     */\n\t    var _pickBy = function _pickBy(test, obj) {\n\t        var copy = {};\n\t        var prop;\n\t        var props = keysIn(obj);\n\t        var len = props.length;\n\t        var idx = -1;\n\t        while (++idx < len) {\n\t            prop = props[idx];\n\t            if (test(obj[prop], prop, obj)) {\n\t                copy[prop] = obj[prop];\n\t            }\n\t        }\n\t        return copy;\n\t    };\n\t\n\t    var _pluck = function _pluck(p, list) {\n\t        return _map(prop(p), list);\n\t    };\n\t\n\t    /**\n\t     * Adds two numbers (or strings). Equivalent to `a + b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @sig String -> String -> String\n\t     * @param {Number|String} a The first value.\n\t     * @param {Number|String} b The second value.\n\t     * @return {Number|String} The result of `a + b`.\n\t     * @example\n\t     *\n\t     *      var increment = R.add(1);\n\t     *      increment(10);   //=> 11\n\t     *      R.add(2, 3);       //=>  5\n\t     *      R.add(7)(10);      //=> 17\n\t     */\n\t    var add = _curry2(_add);\n\t\n\t    /**\n\t     * Returns `true` if all elements of the list match the predicate, `false` if there are any\n\t     * that don't.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Boolean\n\t     * @param {Function} fn The predicate function.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`\n\t     *         otherwise.\n\t     * @example\n\t     *\n\t     *      var lessThan2 = R.flip(R.lt)(2);\n\t     *      var lessThan3 = R.flip(R.lt)(3);\n\t     *      var xs = R.range(1, 3);\n\t     *      xs; //=> [1, 2]\n\t     *      R.all(lessThan2)(xs); //=> false\n\t     *      R.all(lessThan3)(xs); //=> true\n\t     */\n\t    var all = _curry2(_all);\n\t\n\t    /**\n\t     *\n\t     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first\n\t     * function if it is false-y and the result of the second function otherwise.  Note that this is\n\t     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y\n\t     * value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n\t     * @param {Function} f a predicate\n\t     * @param {Function} g another predicate\n\t     * @return {Function} a function that applies its arguments to `f` and `g` and ANDs their outputs together.\n\t     * @example\n\t     *\n\t     *      var gt10 = function(x) { return x > 10; };\n\t     *      var even = function(x) { return x % 2 === 0 };\n\t     *      var f = R.and(gt10, even);\n\t     *      f(100); //=> true\n\t     *      f(101); //=> false\n\t     */\n\t    var and = _curry2(function and(f, g) {\n\t        return function _and() {\n\t            return f.apply(this, arguments) && g.apply(this, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if at least one of elements of the list match the predicate, `false`\n\t     * otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Boolean\n\t     * @param {Function} fn The predicate function.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`\n\t     *         otherwise.\n\t     * @example\n\t     *\n\t     *      var lessThan0 = R.flip(R.lt)(0);\n\t     *      var lessThan2 = R.flip(R.lt)(2);\n\t     *      var xs = R.range(1, 3);\n\t     *      xs; //=> [1, 2]\n\t     *      R.any(lessThan0)(xs); //=> false\n\t     *      R.any(lessThan2)(xs); //=> true\n\t     */\n\t    var any = _curry2(_any);\n\t\n\t    /**\n\t     * Returns a new list containing the contents of the given list, followed by the given\n\t     * element.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> [a] -> [a]\n\t     * @param {*} el The element to add to the end of the new list.\n\t     * @param {Array} list The list whose contents will be added to the beginning of the output\n\t     *        list.\n\t     * @return {Array} A new list containing the contents of the old list followed by `el`.\n\t     * @example\n\t     *\n\t     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\n\t     *      R.append('tests', []); //=> ['tests']\n\t     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]\n\t     */\n\t    var append = _curry2(_append);\n\t\n\t    /**\n\t     * Flipped version of R.append.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> a -> [a]\n\t     * @param {Array} list\n\t     * @param {*} el\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      R.appendTo([], 1); //=> [1]\n\t     *      R.appendTo([1, 2, 3], 4); //=> [1, 2, 3, 4]\n\t     *      R.appendTo([1, 2, 3], [4, 5, 6]); //=> [1, 2, 3, [4, 5, 6]]\n\t     */\n\t    var appendTo = flip(_append);\n\t\n\t    /**\n\t     * Applies function `fn` to the argument list `args`. This is useful for\n\t     * creating a fixed-arity function from a variadic function. `fn` should\n\t     * be a bound function if context is significant.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (*... -> a) -> [*] -> a\n\t     * @param {Function} fn\n\t     * @param {Array} args\n\t     * @return {*}\n\t     * @example\n\t     *\n\t     *      var nums = [1, 2, 3, -99, 42, 6, 7];\n\t     *      R.apply(Math.max, nums); //=> 42\n\t     */\n\t    var apply = _curry2(function apply(fn, args) {\n\t        return fn.apply(this, args);\n\t    });\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2\n\t     * parameters. Any extraneous parameters will not be passed to the supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (* -> c) -> (a, b -> c)\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity 2.\n\t     * @example\n\t     *\n\t     *      var takesThreeArgs = function(a, b, c) {\n\t     *        return [a, b, c];\n\t     *      };\n\t     *      takesThreeArgs.length; //=> 3\n\t     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n\t     *\n\t     *      var takesTwoArgs = R.binary(takesThreeArgs);\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      // Only 2 arguments are passed to the wrapped function\n\t     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]\n\t     */\n\t    var binary = function binary(fn) {\n\t        return nAry(2, fn);\n\t    };\n\t\n\t    /**\n\t     * Creates a function that is bound to a context.\n\t     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n\t     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @category Object\n\t     * @sig (* -> *) -> {*} -> (* -> *)\n\t     * @param {Function} fn The function to bind to context\n\t     * @param {Object} thisObj The context to bind `fn` to\n\t     * @return {Function} A function that will execute in the context of `thisObj`.\n\t     */\n\t    var bind = _curry2(function bind(fn, thisObj) {\n\t        return function () {\n\t            return fn.apply(thisObj, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Creates a deep copy of the value which may contain (nested) `Array`s and\n\t     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are\n\t     * not copied, but assigned by their reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {*} -> {*}\n\t     * @param {*} value The object or array to clone\n\t     * @return {*} A new object or array.\n\t     * @example\n\t     *\n\t     *      var objects = [{}, {}, {}];\n\t     *      var objectsClone = R.clone(objects);\n\t     *      objects[0] === objectsClone[0]; //=> false\n\t     *\n\t     */\n\t    var clone = function clone(value) {\n\t        return _baseCopy(value, [], []);\n\t    };\n\t\n\t    /**\n\t     * Creates a new function that runs each of the functions supplied as parameters in turn,\n\t     * passing the return value of each function invocation to the next function invocation,\n\t     * beginning with whatever arguments were passed to the initial invocation.\n\t     *\n\t     * Note that `compose` is a right-associative function, which means the functions provided\n\t     * will be invoked in order from right to left. In the example `var h = compose(f, g)`,\n\t     * the function `h` is equivalent to `f( g(x) )`, where `x` represents the arguments\n\t     * originally passed to `h`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((y -> z), (x -> y), ..., (b -> c), (a... -> b)) -> (a... -> z)\n\t     * @param {...Function} functions A variable number of functions.\n\t     * @return {Function} A new function which represents the result of calling each of the\n\t     *         input `functions`, passing the result of each function call to the next, from\n\t     *         right to left.\n\t     * @example\n\t     *\n\t     *      var triple = function(x) { return x * 3; };\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var square = function(x) { return x * x; };\n\t     *      var squareThenDoubleThenTriple = R.compose(triple, double, square);\n\t     *\n\t     *      //≅ triple(double(square(5)))\n\t     *      squareThenDoubleThenTriple(5); //=> 150\n\t     */\n\t    var compose = _createComposer(_compose);\n\t\n\t    /**\n\t     * Returns `true` if the `x` is found in the `list`, using `pred` as an\n\t     * equality predicate for `x`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {*} x The item to find\n\t     * @param {Array} list The list to iterate over\n\t     * @return {Boolean} `true` if `x` is in `list`, else `false`.\n\t     * @example\n\t     *\n\t     *     var xs = [{x: 12}, {x: 11}, {x: 10}];\n\t     *     R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true\n\t     *     R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false\n\t     */\n\t    var containsWith = _curry3(_containsWith);\n\t\n\t    /**\n\t     * Creates an object containing a single key:value pair.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig String -> a -> {String:a}\n\t     * @param {String} key\n\t     * @param {*} val\n\t     * @return {Object}\n\t     * @example\n\t     *\n\t     *      var matchPhrases = R.compose(\n\t     *          R.createMapEntry('must'),\n\t     *          R.map(R.createMapEntry('match_phrase'))\n\t     *      );\n\t     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n\t     */\n\t    var createMapEntry = _curry2(function (key, val) {\n\t        var obj = {};\n\t        obj[key] = val;\n\t        return obj;\n\t    });\n\t\n\t    /**\n\t     * Creates a new version of `fn` with given arity that, when invoked,\n\t     * will return either:\n\t     * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of\n\t     * `fn`'s expected arguments have not yet been provided\n\t     * - `fn`'s result if all of its expected arguments have been provided\n\t     *\n\t     * This function is useful in place of `curry`, when the arity of the\n\t     * function to curry cannot be determined from its signature, e.g. if it's\n\t     * a variadic function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig Number -> (* -> a) -> (* -> a)\n\t     * @param {Number} fnArity The arity for the returned function.\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} A new, curried function.\n\t     * @see R.curry\n\t     * @example\n\t     *\n\t     *      var addFourNumbers = function() {\n\t     *        return R.sum([].slice.call(arguments, 0, 4));\n\t     *      };\n\t     *\n\t     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);\n\t     *      var f = curriedAddFourNumbers(1, 2);\n\t     *      var g = f(3);\n\t     *      g(4);//=> 10\n\t     */\n\t    var curryN = _curry2(function curryN(length, fn) {\n\t        return function recurry(args) {\n\t            return arity(Math.max(length - (args && args.length || 0), 0), function () {\n\t                if (arguments.length === 0) {\n\t                    throw _noArgsException();\n\t                }\n\t                var newArgs = _concat(args, arguments);\n\t                if (newArgs.length >= length) {\n\t                    return fn.apply(this, newArgs);\n\t                } else {\n\t                    return recurry(newArgs);\n\t                }\n\t            });\n\t        }([]);\n\t    });\n\t\n\t    /**\n\t     * Decrements its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.dec(42); //=> 41\n\t     */\n\t    var dec = add(-1);\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig [a] -> [a] -> [a]\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The elements in `list1` that are not in `list2`.\n\t     * @see R.differenceWith\n\t     * @example\n\t     *\n\t     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]\n\t     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]\n\t     */\n\t    var difference = _curry2(function difference(first, second) {\n\t        var out = [];\n\t        var idx = -1;\n\t        var firstLen = first.length;\n\t        while (++idx < firstLen) {\n\t            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {\n\t                out[out.length] = first[idx];\n\t            }\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n\t     * Duplication is determined according to the value returned by applying the supplied predicate to two list\n\t     * elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @see R.difference\n\t     * @return {Array} The elements in `list1` that are not in `list2`.\n\t     * @example\n\t     *\n\t     *      function cmp(x, y) { return x.a === y.a; }\n\t     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      var l2 = [{a: 3}, {a: 4}];\n\t     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]\n\t     *\n\t     */\n\t    var differenceWith = _curry3(function differenceWith(pred, first, second) {\n\t        var out = [];\n\t        var idx = -1;\n\t        var firstLen = first.length;\n\t        var containsPred = containsWith(pred);\n\t        while (++idx < firstLen) {\n\t            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {\n\t                out[out.length] = first[idx];\n\t            }\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing all but the first `n` elements of the given `list`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @param {Number} n The number of elements of `list` to skip.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The last `n` elements of `list`.\n\t     * @example\n\t     *\n\t     *     R.drop(3, [1,2,3,4,5,6,7]); //=> [4,5,6,7]\n\t     */\n\t    var drop = _curry2(_checkForMethod('drop', function drop(n, list) {\n\t        return n < list.length ? _slice(list, n) : [];\n\t    }));\n\t\n\t    /**\n\t     * Returns a new list containing the last `n` elements of a given list, passing each value\n\t     * to the supplied predicate function, skipping elements while the predicate function returns\n\t     * `true`. The predicate function is passed one argument: *(value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @example\n\t     *\n\t     *      var lteTwo = function(x) {\n\t     *        return x <= 2;\n\t     *      };\n\t     *\n\t     *      R.dropWhile(lteTwo, [1, 2, 3, 4]); //=> [3, 4]\n\t     */\n\t    var dropWhile = _curry2(function dropWhile(pred, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len && pred(list[idx])) {\n\t        }\n\t        return _slice(list, idx);\n\t    });\n\t\n\t    /**\n\t     * `empty` wraps any object in an array. This implementation is compatible with the\n\t     * Fantasy-land Monoid spec, and will work with types that implement that spec.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig * -> []\n\t     * @return {Array} An empty array.\n\t     * @example\n\t     *\n\t     *      R.empty([1,2,3,4,5]); //=> []\n\t     */\n\t    var empty = function empty(x) {\n\t        return _hasMethod('empty', x) ? x.empty() : [];\n\t    };\n\t\n\t    /**\n\t     * Tests if two items are equal.  Equality is strict here, meaning reference equality for objects and\n\t     * non-coercing equality for primitives.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig a -> b -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      var o = {};\n\t     *      R.eq(o, o); //=> true\n\t     *      R.eq(o, {}); //=> false\n\t     *      R.eq(1, 1); //=> true\n\t     *      R.eq(1, '1'); //=> false\n\t     *      R.eq(0, -0); //=> false\n\t     *      R.eq(NaN, NaN); //=> true\n\t     */\n\t    var eq = _curry2(function eq(a, b) {\n\t        if (a === 0) {\n\t            return 1 / a === 1 / b;\n\t        } else {\n\t            return a === b || a !== a && b !== b;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Reports whether two objects have the same value for the specified property.  Useful as a curried predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig k -> {k: v} -> {k: v} -> Boolean\n\t     * @param {String} prop The name of the property to compare\n\t     * @param {Object} obj1\n\t     * @param {Object} obj2\n\t     * @return {Boolean}\n\t     *\n\t     * @example\n\t     *\n\t     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };\n\t     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };\n\t     *      R.eqProps('a', o1, o2); //=> false\n\t     *      R.eqProps('c', o1, o2); //=> true\n\t     */\n\t    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {\n\t        return obj1[prop] === obj2[prop];\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing only those items that match a given predicate function.\n\t     * The predicate function is passed one argument: *(value)*.\n\t     *\n\t     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native\n\t     * `Array.prototype.filter` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} The new filtered array.\n\t     * @example\n\t     *\n\t     *      var isEven = function(n) {\n\t     *        return n % 2 === 0;\n\t     *      };\n\t     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]\n\t     */\n\t    var filter = _curry2(_checkForMethod('filter', _filter));\n\t\n\t    /**\n\t     * Like `filter`, but passes additional parameters to the predicate function. The predicate\n\t     * function is passed three arguments: *(value, index, list)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a, i, [a] -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} The new filtered array.\n\t     * @example\n\t     *\n\t     *      var lastTwo = function(val, idx, list) {\n\t     *        return list.length - idx <= 2;\n\t     *      };\n\t     *      R.filterIndexed(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [0, 9]\n\t     */\n\t    var filterIndexed = _curry2(_filterIndexed);\n\t\n\t    /**\n\t     * Returns the first element of the list which matches the predicate, or `undefined` if no\n\t     * element matches.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> a | undefined\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     *        desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Object} The element found, or `undefined`.\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}\n\t     *      R.find(R.propEq('a', 4))(xs); //=> undefined\n\t     */\n\t    var find = _curry2(function find(fn, list) {\n\t        var idx = -1;\n\t        var len = list.length;\n\t        while (++idx < len) {\n\t            if (fn(list[idx])) {\n\t                return list[idx];\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Returns the index of the first element of the list which matches the predicate, or `-1`\n\t     * if no element matches.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Number\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Number} The index of the element found, or `-1`.\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1\n\t     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1\n\t     */\n\t    var findIndex = _curry2(function findIndex(fn, list) {\n\t        var idx = -1;\n\t        var len = list.length;\n\t        while (++idx < len) {\n\t            if (fn(list[idx])) {\n\t                return idx;\n\t            }\n\t        }\n\t        return -1;\n\t    });\n\t\n\t    /**\n\t     * Returns the last element of the list which matches the predicate, or `undefined` if no\n\t     * element matches.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> a | undefined\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Object} The element found, or `undefined`.\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n\t     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}\n\t     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined\n\t     */\n\t    var findLast = _curry2(function findLast(fn, list) {\n\t        var idx = list.length;\n\t        while (idx--) {\n\t            if (fn(list[idx])) {\n\t                return list[idx];\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Returns the index of the last element of the list which matches the predicate, or\n\t     * `-1` if no element matches.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Number\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Number} The index of the element found, or `-1`.\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n\t     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1\n\t     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1\n\t     */\n\t    var findLastIndex = _curry2(function findLastIndex(fn, list) {\n\t        var idx = list.length;\n\t        while (idx--) {\n\t            if (fn(list[idx])) {\n\t                return idx;\n\t            }\n\t        }\n\t        return -1;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting\n\t     * them in a new array, depth-first.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [b]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The flattened list.\n\t     * @example\n\t     *\n\t     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n\t     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\t     */\n\t    var flatten = _makeFlat(true);\n\t\n\t    /**\n\t     * Returns a single item by iterating through the list, successively calling the iterator\n\t     * function and passing it an accumulator value and the current value from the array, and\n\t     * then passing the result to the next call.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*\n\t     *\n\t     * Note: `R.foldl` does not skip deleted or unassigned indices (sparse arrays), unlike\n\t     * the native `Array.prototype.reduce` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b -> a) -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3];\n\t     *      var add = function(a, b) {\n\t     *        return a + b;\n\t     *      };\n\t     *\n\t     *      R.foldl(add, 10, numbers); //=> 16\n\t     */\n\t    var foldl = _curry3(_foldl);\n\t\n\t    /**\n\t     * Like `foldl`, but passes additional parameters to the predicate function.\n\t     *\n\t     * The iterator function receives four values: *(acc, value, index, list)*\n\t     *\n\t     * Note: `R.foldlIndexed` does not skip deleted or unassigned indices (sparse arrays),\n\t     * unlike the native `Array.prototype.reduce` method. For more details on this behavior,\n\t     * see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b,i,[b] -> a) -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives four values: the accumulator, the\n\t     *        current element from `list`, that element's index, and the entire `list` itself.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var letters = ['a', 'b', 'c'];\n\t     *      var objectify = function(accObject, elem, idx, list) {\n\t     *        accObject[elem] = idx;\n\t     *        return accObject;\n\t     *      };\n\t     *\n\t     *      R.foldlIndexed(objectify, {}, letters); //=> { 'a': 0, 'b': 1, 'c': 2 }\n\t     */\n\t    var foldlIndexed = _curry3(function foldlIndexed(fn, acc, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len) {\n\t            acc = fn(acc, list[idx], idx, list);\n\t        }\n\t        return acc;\n\t    });\n\t\n\t    /**\n\t     * Returns a single item by iterating through the list, successively calling the iterator\n\t     * function and passing it an accumulator value and the current value from the array, and\n\t     * then passing the result to the next call.\n\t     *\n\t     * Similar to `foldl`, except moves through the input list from the right to the left.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*\n\t     *\n\t     * Note: `R.foldr` does not skip deleted or unassigned indices (sparse arrays), unlike\n\t     * the native `Array.prototype.reduce` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b -> a) -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\n\t     *      var flattenPairs = function(acc, pair) {\n\t     *        return acc.concat(pair);\n\t     *      };\n\t     *\n\t     *      R.foldr(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]\n\t     */\n\t    var foldr = _curry3(function foldr(fn, acc, list) {\n\t        var idx = list.length;\n\t        while (idx--) {\n\t            acc = fn(acc, list[idx]);\n\t        }\n\t        return acc;\n\t    });\n\t\n\t    /**\n\t     * Like `foldr`, but passes additional parameters to the predicate function. Moves through\n\t     * the input list from the right to the left.\n\t     *\n\t     * The iterator function receives four values: *(acc, value, index, list)*.\n\t     *\n\t     * Note: `R.foldrIndexed` does not skip deleted or unassigned indices (sparse arrays),\n\t     * unlike the native `Array.prototype.reduce` method. For more details on this behavior,\n\t     * see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b,i,[b] -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives four values: the accumulator, the\n\t     *        current element from `list`, that element's index, and the entire `list` itself.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var letters = ['a', 'b', 'c'];\n\t     *      var objectify = function(accObject, elem, idx, list) {\n\t     *        accObject[elem] = idx;\n\t     *        return accObject;\n\t     *      };\n\t     *\n\t     *      R.foldrIndexed(objectify, {}, letters); //=> { 'c': 2, 'b': 1, 'a': 0 }\n\t     */\n\t    var foldrIndexed = _curry3(function foldrIndexed(fn, acc, list) {\n\t        var idx = list.length;\n\t        while (idx--) {\n\t            acc = fn(acc, list[idx], idx, list);\n\t        }\n\t        return acc;\n\t    });\n\t\n\t    /**\n\t     * Iterate over an input `list`, calling a provided function `fn` for each element in the\n\t     * list.\n\t     *\n\t     * `fn` receives one argument: *(value)*.\n\t     *\n\t     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike\n\t     * the native `Array.prototype.forEach` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n\t     *\n\t     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original\n\t     * array. In some libraries this function is named `each`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> *) -> [a] -> [a]\n\t     * @param {Function} fn The function to invoke. Receives one argument, `value`.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {Array} The original list.\n\t     * @example\n\t     *\n\t     *      var printXPlusFive = function(x) { console.log(x + 5); };\n\t     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]\n\t     *      //-> 6\n\t     *      //-> 7\n\t     *      //-> 8\n\t     */\n\t    var forEach = _curry2(_forEach);\n\t\n\t    /**\n\t     * Like `forEach`, but but passes additional parameters to the predicate function.\n\t     *\n\t     * `fn` receives three arguments: *(value, index, list)*.\n\t     *\n\t     * Note: `R.forEachIndexed` does not skip deleted or unassigned indices (sparse arrays),\n\t     * unlike the native `Array.prototype.forEach` method. For more details on this behavior,\n\t     * see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n\t     *\n\t     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original\n\t     * array. In some libraries this function is named `each`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a, i, [a] -> ) -> [a] -> [a]\n\t     * @param {Function} fn The function to invoke. Receives three arguments:\n\t     *        (`value`, `index`, `list`).\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {Array} The original list.\n\t     * @example\n\t     *\n\t     *      // Note that having access to the original `list` allows for\n\t     *      // mutation. While you *can* do this, it's very un-functional behavior:\n\t     *      var plusFive = function(num, idx, list) { list[idx] = num + 5 };\n\t     *      R.forEachIndexed(plusFive, [1, 2, 3]); //=> [6, 7, 8]\n\t     */\n\t    // i can't bear not to return *something*\n\t    var forEachIndexed = _curry2(function forEachIndexed(fn, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len) {\n\t            fn(list[idx], idx, list);\n\t        }\n\t        // i can't bear not to return *something*\n\t        return list;\n\t    });\n\t\n\t    /**\n\t     * Returns a list of function names of object's own and prototype functions\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {*} -> [String]\n\t     * @param {Object} obj The objects with functions in it\n\t     * @return {Array} A list of the object's own properties and prototype\n\t     *         properties that map to functions.\n\t     * @example\n\t     *\n\t     *      R.functionsIn(R); // returns list of ramda's own and prototype function names\n\t     *\n\t     *      var F = function() { this.x = function(){}; this.y = 1; }\n\t     *      F.prototype.z = function() {};\n\t     *      F.prototype.a = 100;\n\t     *      R.functionsIn(new F()); //=> [\"x\", \"z\"]\n\t     */\n\t    var functionsIn = _functionsWith(keysIn);\n\t\n\t    /**\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @see R.prop\n\t     */\n\t    var get = prop;\n\t\n\t    /**\n\t     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function\n\t     * on each element, and grouping the results according to values returned.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> s) -> [a] -> {s: a}\n\t     * @param {Function} fn Function :: a -> String\n\t     * @param {Array} list The array to group\n\t     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements\n\t     *         that produced that key when passed to `fn`.\n\t     * @example\n\t     *\n\t     *     var byGrade = R.groupBy(function(student) {\n\t     *       var score = student.score;\n\t     *       return (score < 65) ? 'F' : (score < 70) ? 'D' :\n\t     *              (score < 80) ? 'C' : (score < 90) ? 'B' : 'A';\n\t     *     });\n\t     *     var students = [{name: 'Abby', score: 84},\n\t     *                     {name: 'Eddy', score: 58},\n\t     *                     // ...\n\t     *                     {name: 'Jack', score: 69}];\n\t     *     byGrade(students);\n\t     *     // {\n\t     *     //   'A': [{name: 'Dianne', score: 99}],\n\t     *     //   'B': [{name: 'Abby', score: 84}]\n\t     *     //   // ...,\n\t     *     //   'F': [{name: 'Eddy', score: 58}]\n\t     *     // }\n\t     */\n\t    var groupBy = _curry2(function groupBy(fn, list) {\n\t        return _foldl(function (acc, elt) {\n\t            var key = fn(elt);\n\t            acc[key] = _append(elt, acc[key] || (acc[key] = []));\n\t            return acc;\n\t        }, {}, list);\n\t    });\n\t\n\t    /**\n\t     * Returns whether or not an object has an own property with\n\t     * the specified name\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig s -> {s: x} -> Boolean\n\t     * @param {String} prop The name of the property to check for.\n\t     * @param {Object} obj The object to query.\n\t     * @return {Boolean} Whether the property exists.\n\t     * @example\n\t     *\n\t     *      var obj = {\n\t     *        foo: 1,\n\t     *        bar: 2,\n\t     *      };\n\t     *      R.has('foo', obj);  //=> true\n\t     *\n\t     *      var list = [{foo: 1}, {foo: 2}, {bar: 3}];\n\t     *      R.filter(R.has('foo'), list);  //=> [{foo: 1}, {foo: 2}]\n\t     */\n\t    var has = _curry2(function (prop, obj) {\n\t        return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    });\n\t\n\t    /**\n\t     * Returns whether or not an object or its prototype chain has\n\t     * a property with the specified name\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig s -> {s: x} -> Boolean\n\t     * @param {String} prop The name of the property to check for.\n\t     * @param {Object} obj The object to query.\n\t     * @return {Boolean} Whether the property exists.\n\t     * @example\n\t     *\n\t     *      function Rectangle(width, height) {\n\t     *          this.width = width;\n\t     *          this.height = height;\n\t     *      }\n\t     *      Rectangle.prototype.area = function() {\n\t     *          return this.width * this.height;\n\t     *      };\n\t     *\n\t     *      var square = new Rectangle(2, 2);\n\t     *      R.hasIn('width', square);  //=> true\n\t     *      R.hasIn('area', square);  //=> true\n\t     */\n\t    var hasIn = _curry2(function (prop, obj) {\n\t        return prop in obj;\n\t    });\n\t\n\t    /**\n\t     * Creates a function that will process either the `onTrue` or the `onFalse` function depending\n\t     * upon the result of the `condition` predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)\n\t     * @param {Function} condition A predicate function\n\t     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.\n\t     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.\n\t     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`\n\t     *                    function depending upon the result of the `condition` predicate.\n\t     * @example\n\t     *\n\t     *      // Flatten all arrays in the list but leave other values alone.\n\t     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));\n\t     *\n\t     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]\n\t     *      flattenArrays([[[10], 123], [8, [10]], \"hello\"]); //=> [[10, 123], [8, 10], \"hello\"]\n\t     */\n\t    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {\n\t        return function _ifElse() {\n\t            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Increments its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.inc(42); //=> 43\n\t     */\n\t    var inc = add(1);\n\t\n\t    /**\n\t     * Returns the position of the first occurrence of an item in an array\n\t     * (by strict equality),\n\t     * or -1 if the item is not included in the array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> [a] -> Number\n\t     * @param {*} target The item to find.\n\t     * @param {Array} list The array to search in.\n\t     * @return {Number} the index of the target, or -1 if the target is not found.\n\t     *\n\t     * @example\n\t     *\n\t     *      R.indexOf(3, [1,2,3,4]); //=> 2\n\t     *      R.indexOf(10, [1,2,3,4]); //=> -1\n\t     */\n\t    var indexOf = _curry2(function indexOf(target, list) {\n\t        return _indexOf(list, target);\n\t    });\n\t\n\t    /**\n\t     * Inserts the supplied element into the list, at index `index`.  _Note\n\t     * that this is not destructive_: it returns a copy of the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> a -> [a] -> [a]\n\t     * @param {Number} index The position to insert the element\n\t     * @param {*} elt The element to insert into the Array\n\t     * @param {Array} list The list to insert into\n\t     * @return {Array} A new Array with `elt` inserted at `index`.\n\t     * @example\n\t     *\n\t     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]\n\t     */\n\t    var insert = _curry3(function insert(idx, elt, list) {\n\t        idx = idx < list.length && idx >= 0 ? idx : list.length;\n\t        return _concat(_append(elt, _slice(list, 0, idx)), _slice(list, idx));\n\t    });\n\t\n\t    /**\n\t     * Inserts the sub-list into the list, at index `index`.  _Note  that this\n\t     * is not destructive_: it returns a copy of the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> [a] -> [a] -> [a]\n\t     * @param {Number} index The position to insert the sub-list\n\t     * @param {Array} elts The sub-list to insert into the Array\n\t     * @param {Array} list The list to insert the sub-list into\n\t     * @return {Array} A new Array with `elts` inserted starting at `index`.\n\t     * @example\n\t     *\n\t     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]\n\t     */\n\t    var insertAll = _curry3(function insertAll(idx, elts, list) {\n\t        idx = idx < list.length && idx >= 0 ? idx : list.length;\n\t        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));\n\t    });\n\t\n\t    /**\n\t     * Turns a named method with a specified arity into a function\n\t     * that can be called directly supplied with arguments and a target object.\n\t     *\n\t     * The returned function is curried and accepts `len + 1` parameters where\n\t     * the final parameter is the target object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (Number, String) -> (a... -> c -> b)\n\t     * @param {Number} len Number of arguments the returned function should take\n\t     *        before the target object.\n\t     * @param {Function} method Name of the method to call.\n\t     * @return {Function} A new curried function.\n\t     * @example\n\t     *\n\t     *      var sliceFrom = R.invoker(1, 'slice');\n\t     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n\t     *      var sliceFrom6 = R.invoker(2, 'slice', 6);\n\t     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n\t     */\n\t    var invoker = function invoker(arity, method) {\n\t        var initialArgs = _slice(arguments, 2);\n\t        var len = arity - initialArgs.length;\n\t        return curryN(len + 1, function () {\n\t            var target = arguments[len];\n\t            var args = initialArgs.concat(_slice(arguments, 0, len));\n\t            return target[method].apply(target, args);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * See if an object (`val`) is an instance of the supplied constructor.\n\t     * This function will check up the inheritance chain, if any.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Type\n\t     * @sig (* -> {*}) -> a -> Boolean\n\t     * @param {Object} ctor A constructor\n\t     * @param {*} val The value to test\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      R.is(Object, {}); //=> true\n\t     *      R.is(Number, 1); //=> true\n\t     *      R.is(Object, 1); //=> false\n\t     *      R.is(String, 's'); //=> true\n\t     *      R.is(String, new String('')); //=> true\n\t     *      R.is(Object, new String('')); //=> true\n\t     *      R.is(Object, 's'); //=> false\n\t     *      R.is(Number, {}); //=> false\n\t     */\n\t    var is = _curry2(function is(Ctor, val) {\n\t        return val != null && val.constructor === Ctor || val instanceof Ctor;\n\t    });\n\t\n\t    /**\n\t     * Returns a string made by inserting the `separator` between each\n\t     * element and concatenating all the elements into a single string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig String -> [a] -> String\n\t     * @param {Number|String} separator The string used to separate the elements.\n\t     * @param {Array} xs The elements to join into a string.\n\t     * @return {String} str The string made by concatenating `xs` with `separator`.\n\t     * @example\n\t     *\n\t     *      var spacer = R.join(' ');\n\t     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'\n\t     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'\n\t     */\n\t    var join = invoker(1, 'join');\n\t\n\t    /**\n\t     * Returns a list containing the names of all the enumerable own\n\t     * properties of the supplied object.\n\t     * Note that the order of the output array is not guaranteed to be\n\t     * consistent across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [k]\n\t     * @param {Object} obj The object to extract properties from\n\t     * @return {Array} An array of the object's own properties.\n\t     * @example\n\t     *\n\t     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n\t     */\n\t    // cover IE < 9 keys issues\n\t    var keys = function () {\n\t        // cover IE < 9 keys issues\n\t        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n\t        var nonEnumerableProps = [\n\t            'constructor',\n\t            'valueOf',\n\t            'isPrototypeOf',\n\t            'toString',\n\t            'propertyIsEnumerable',\n\t            'hasOwnProperty',\n\t            'toLocaleString'\n\t        ];\n\t        return function keys(obj) {\n\t            if (Object(obj) !== obj) {\n\t                return [];\n\t            }\n\t            if (Object.keys) {\n\t                return Object.keys(obj);\n\t            }\n\t            var prop, ks = [], nIdx;\n\t            for (prop in obj) {\n\t                if (has(prop, obj)) {\n\t                    ks[ks.length] = prop;\n\t                }\n\t            }\n\t            if (hasEnumBug) {\n\t                nIdx = nonEnumerableProps.length;\n\t                while (nIdx--) {\n\t                    prop = nonEnumerableProps[nIdx];\n\t                    if (has(prop, obj) && !_contains(prop, ks)) {\n\t                        ks[ks.length] = prop;\n\t                    }\n\t                }\n\t            }\n\t            return ks;\n\t        };\n\t    }();\n\t\n\t    /**\n\t     * Accepts as its arguments a function and any number of values and returns a function that,\n\t     * when invoked, calls the original function with all of the values prepended to the\n\t     * original function's arguments list. In some libraries this function is named `applyLeft`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)\n\t     * @param {Function} fn The function to invoke.\n\t     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.\n\t     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`\n\t     *         with `args` prepended to `fn`'s arguments list.\n\t     * @example\n\t     *\n\t     *      var multiply = function(a, b) { return a * b; };\n\t     *      var double = R.lPartial(multiply, 2);\n\t     *      double(2); //=> 4\n\t     *\n\t     *      var greet = function(salutation, title, firstName, lastName) {\n\t     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n\t     *      };\n\t     *      var sayHello = R.lPartial(greet, 'Hello');\n\t     *      var sayHelloToMs = R.lPartial(sayHello, 'Ms.');\n\t     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'\n\t     */\n\t    var lPartial = _createPartialApplicator(_concat);\n\t\n\t    /**\n\t     * Returns the position of the last occurrence of an item (by strict equality) in\n\t     * an array, or -1 if the item is not included in the array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> [a] -> Number\n\t     * @param {*} target The item to find.\n\t     * @param {Array} list The array to search in.\n\t     * @return {Number} the index of the target, or -1 if the target is not found.\n\t     *\n\t     * @example\n\t     *\n\t     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6\n\t     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1\n\t     */\n\t    var lastIndexOf = _curry2(function lastIndexOf(target, list) {\n\t        return _lastIndexOf(list, target);\n\t    });\n\t\n\t    /**\n\t     * Returns the number of elements in the array by returning `list.length`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> Number\n\t     * @param {Array} list The array to inspect.\n\t     * @return {Number} The length of the array.\n\t     * @example\n\t     *\n\t     *      R.length([]); //=> 0\n\t     *      R.length([1, 2, 3]); //=> 3\n\t     */\n\t    var length = function length(list) {\n\t        return list != null && is(Number, list.length) ? list.length : NaN;\n\t    };\n\t\n\t    /**\n\t     * Creates a lens. Supply a function to `get` values from inside an object, and a `set`\n\t     * function to change values on an object. (n.b.: This can, and should, be done without\n\t     * mutating the original object!) The lens is a function wrapped around the input `get`\n\t     * function, with the `set` function attached as a property on the wrapper. A `map`\n\t     * function is also attached to the returned function that takes a function to operate\n\t     * on the specified (`get`) property, which is then `set` before returning. The attached\n\t     * `set` and `map` functions are curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig (k -> v) -> (v -> a -> *) -> (a -> b)\n\t     * @param {Function} get A function that gets a value by property name\n\t     * @param {Function} set A function that gets a value by property name\n\t     * @return {Function} the returned function has `set` and `map` properties that are\n\t     *         also curried functions.\n\t     * @example\n\t     *\n\t     *     var headLens = R.lens(\n\t     *         function get(arr) { return arr[0]; },\n\t     *         function set(val, arr) { return [val].concat(arr.slice(1)); }\n\t     *     );\n\t     *     headLens([10, 20, 30, 40]); //=> 10\n\t     *     headLens.set('mu', [10, 20, 30, 40]); //=> ['mu', 20, 30, 40]\n\t     *     headLens.map(function(x) { return x + 1; }, [10, 20, 30, 40]); //=> [11, 20, 30, 40]\n\t     *\n\t     *     var phraseLens = R.lens(\n\t     *         function get(obj) { return obj.phrase; },\n\t     *         function set(val, obj) {\n\t     *             var out = R.clone(obj);\n\t     *             out.phrase = val;\n\t     *             return out;\n\t     *         }\n\t     *     );\n\t     *     var obj1 = { phrase: 'Absolute filth . . . and I LOVED it!'};\n\t     *     var obj2 = { phrase: \"What's all this, then?\"};\n\t     *     phraseLens(obj1); // => 'Absolute filth . . . and I LOVED it!'\n\t     *     phraseLens(obj2); // => \"What's all this, then?\"\n\t     *     phraseLens.set('Ooh Betty', obj1); //=> { phrase: 'Ooh Betty'}\n\t     *     phraseLens.map(R.toUpper, obj2); //=> { phrase: \"WHAT'S ALL THIS, THEN?\"}\n\t     */\n\t    var lens = _curry2(function lens(get, set) {\n\t        var lns = function (a) {\n\t            return get(a);\n\t        };\n\t        lns.set = _curry2(set);\n\t        lns.map = _curry2(function (fn, a) {\n\t            return set(fn(get(a)), a);\n\t        });\n\t        return lns;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list, constructed by applying the supplied function to every element of the\n\t     * supplied list.\n\t     *\n\t     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the\n\t     * native `Array.prototype.map` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> b) -> [a] -> [b]\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {Array} list The list to be iterated over.\n\t     * @return {Array} The new list.\n\t     * @example\n\t     *\n\t     *      var double = function(x) {\n\t     *        return x * 2;\n\t     *      };\n\t     *\n\t     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n\t     */\n\t    var map = _curry2(_checkForMethod('map', _map));\n\t\n\t    /**\n\t     * The mapAccumL function behaves like a combination of map and foldl; it applies a\n\t     * function to each element of a list, passing an accumulating parameter from left to\n\t     * right, and returning a final value of this accumulator together with the new list.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var digits = ['1', '2', '3', '4'];\n\t     *      var append = function(a, b) {\n\t     *          return [a + b, a + b];\n\t     *      }\n\t     *\n\t     *      R.mapAccumL(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n\t     */\n\t    var mapAccumL = _curry3(function mapAccumL(fn, acc, list) {\n\t        var idx = -1, len = list.length, result = new Array(len), tuple = [acc];\n\t        while (++idx < len) {\n\t            tuple = fn(tuple[0], list[idx]);\n\t            result[idx] = tuple[1];\n\t        }\n\t        return [\n\t            tuple[0],\n\t            result\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * The mapAccumR function behaves like a combination of map and foldr; it applies a\n\t     * function to each element of a list, passing an accumulating parameter from right\n\t     * to left, and returning a final value of this accumulator together with the new list.\n\t     *\n\t     * Similar to `mapAccumL`, except moves through the input list from the right to the\n\t     * left.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var digits = ['1', '2', '3', '4'];\n\t     *      var append = function(a, b) {\n\t     *          return [a + b, a + b];\n\t     *      }\n\t     *\n\t     *      R.mapAccumR(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]\n\t     */\n\t    var mapAccumR = _curry3(function mapAccumR(fn, acc, list) {\n\t        var idx = list.length, len = list.length, result = new Array(len), tuple = [acc];\n\t        while (idx--) {\n\t            tuple = fn(tuple[0], list[idx]);\n\t            result[idx] = tuple[1];\n\t        }\n\t        return [\n\t            tuple[0],\n\t            result\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * Like `map`, but but passes additional parameters to the mapping function.\n\t     * `fn` receives three arguments: *(value, index, list)*.\n\t     *\n\t     * Note: `R.mapIndexed` does not skip deleted or unassigned indices (sparse arrays), unlike\n\t     * the native `Array.prototype.map` method. For more details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,i,[b] -> b) -> [a] -> [b]\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {Array} list The list to be iterated over.\n\t     * @return {Array} The new list.\n\t     * @example\n\t     *\n\t     *      var squareEnds = function(elt, idx, list) {\n\t     *        if (idx === 0 || idx === list.length - 1) {\n\t     *          return elt * elt;\n\t     *        }\n\t     *        return elt;\n\t     *      };\n\t     *\n\t     *      R.mapIndexed(squareEnds, [8, 5, 3, 0, 9]); //=> [64, 5, 3, 0, 81]\n\t     */\n\t    var mapIndexed = _curry2(function mapIndexed(fn, list) {\n\t        var idx = -1, len = list.length, result = new Array(len);\n\t        while (++idx < len) {\n\t            result[idx] = fn(list[idx], idx, list);\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Map, but for objects. Creates an object with the same keys as `obj` and values\n\t     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:\n\t     * *(value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (v -> v) -> {k: v} -> {k: v}\n\t     * @param {Function} fn A function called for each property in `obj`. Its return value will\n\t     * become a new property on the return object.\n\t     * @param {Object} obj The object to iterate over.\n\t     * @return {Object} A new object with the same keys as `obj` and values that are the result\n\t     *         of running each property through `fn`.\n\t     * @example\n\t     *\n\t     *      var values = { x: 1, y: 2, z: 3 };\n\t     *      var double = function(num) {\n\t     *        return num * 2;\n\t     *      };\n\t     *\n\t     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }\n\t     */\n\t    var mapObj = _curry2(function mapObject(fn, obj) {\n\t        return _foldl(function (acc, key) {\n\t            acc[key] = fn(obj[key]);\n\t            return acc;\n\t        }, {}, keys(obj));\n\t    });\n\t\n\t    /**\n\t     * Like `mapObj`, but but passes additional arguments to the predicate function. The\n\t     * predicate function is passed three arguments: *(value, key, obj)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}\n\t     * @param {Function} fn A function called for each property in `obj`. Its return value will\n\t     *        become a new property on the return object.\n\t     * @param {Object} obj The object to iterate over.\n\t     * @return {Object} A new object with the same keys as `obj` and values that are the result\n\t     *         of running each property through `fn`.\n\t     * @example\n\t     *\n\t     *      var values = { x: 1, y: 2, z: 3 };\n\t     *      var prependKeyAndDouble = function(num, key, obj) {\n\t     *        return key + (num * 2);\n\t     *      };\n\t     *\n\t     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }\n\t     */\n\t    var mapObjIndexed = _curry2(function mapObjectIndexed(fn, obj) {\n\t        return _foldl(function (acc, key) {\n\t            acc[key] = fn(obj[key], key, obj);\n\t            return acc;\n\t        }, {}, keys(obj));\n\t    });\n\t\n\t    /**\n\t     * Tests a regular expression against a String\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig RegExp -> String -> [String] | null\n\t     * @param {RegExp} rx A regular expression.\n\t     * @param {String} str The string to match against\n\t     * @return {Array} The list of matches, or null if no matches found.\n\t     * @see R.invoker\n\t     * @example\n\t     *\n\t     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']\n\t     */\n\t    var match = invoker(1, 'match');\n\t\n\t    /**\n\t     * Determines the largest of a list of numbers (or elements that can be cast to numbers)\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @see R.maxBy\n\t     * @param {Array} list A list of numbers\n\t     * @return {Number} The greatest number in the list.\n\t     * @example\n\t     *\n\t     *      R.max([7, 3, 9, 2, 4, 9, 3]); //=> 9\n\t     */\n\t    var max = _createMaxMin(_gt, -Infinity);\n\t\n\t    /**\n\t     * Determines the largest of a list of items as determined by pairwise comparisons from the supplied comparator\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig (a -> Number) -> [a] -> a\n\t     * @param {Function} keyFn A comparator function for elements in the list\n\t     * @param {Array} list A list of comparable elements\n\t     * @return {*} The greatest element in the list. `undefined` if the list is empty.\n\t     * @see R.max\n\t     * @example\n\t     *\n\t     *      function cmp(obj) { return obj.x; }\n\t     *      var a = {x: 1}, b = {x: 2}, c = {x: 3};\n\t     *      R.maxBy(cmp, [a, b, c]); //=> {x: 3}\n\t     */\n\t    var maxBy = _curry2(_createMaxMinBy(_gt));\n\t\n\t    /**\n\t     * Determines the smallest of a list of numbers (or elements that can be cast to numbers)\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list A list of numbers\n\t     * @return {Number} The greatest number in the list.\n\t     * @see R.minBy\n\t     * @example\n\t     *\n\t     *      R.min([7, 3, 9, 2, 4, 9, 3]); //=> 2\n\t     */\n\t    var min = _createMaxMin(_lt, Infinity);\n\t\n\t    /**\n\t     * Determines the smallest of a list of items as determined by pairwise comparisons from the supplied comparator\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig (a -> Number) -> [a] -> a\n\t     * @param {Function} keyFn A comparator function for elements in the list\n\t     * @param {Array} list A list of comparable elements\n\t     * @see R.min\n\t     * @return {*} The greatest element in the list. `undefined` if the list is empty.\n\t     * @example\n\t     *\n\t     *      function cmp(obj) { return obj.x; }\n\t     *      var a = {x: 1}, b = {x: 2}, c = {x: 3};\n\t     *      R.minBy(cmp, [a, b, c]); //=> {x: 1}\n\t     */\n\t    var minBy = _curry2(_createMaxMinBy(_lt));\n\t\n\t    /**\n\t     * Multiplies two numbers. Equivalent to `a * b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a * b`.\n\t     * @example\n\t     *\n\t     *      var double = R.multiply(2);\n\t     *      var triple = R.multiply(3);\n\t     *      double(3);       //=>  6\n\t     *      triple(4);       //=> 12\n\t     *      R.multiply(2, 5);  //=> 10\n\t     */\n\t    var multiply = _curry2(_multiply);\n\t\n\t    /**\n\t     * Negates its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.negate(42); //=> -42\n\t     */\n\t    var negate = multiply(-1);\n\t\n\t    /**\n\t     * Returns the nth element in a list.\n\t     * If n is negative the element at index length + n is returned.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> a\n\t     * @param {Number} idx\n\t     * @param {Array} list\n\t     * @return {*} The nth element of the list.\n\t     * @example\n\t     *\n\t     *      var list = ['foo', 'bar', 'baz', 'quux'];\n\t     *      R.nth(1, list); //=> 'bar'\n\t     *      R.nth(-1, list); //=> 'quux'\n\t     *      R.nth(-99, list); //=> undefined\n\t     */\n\t    var nth = _curry2(_nth);\n\t\n\t    /**\n\t     *\n\t     * `of` wraps any object in an Array. This implementation is compatible with the\n\t     * Fantasy-land Applicative spec, and will work with types that implement that spec.\n\t     * Note this `of` is different from the ES6 `of`; See\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig a -> [a]\n\t     * @param {*} x any value\n\t     * @return {Array} An array wrapping `x`.\n\t     * @example\n\t     *\n\t     *      R.of(1); //=> [1]\n\t     *      R.of([2]); //=> [[2]]\n\t     *      R.of({}); //=> [{}]\n\t     */\n\t    var of = function of(x, container) {\n\t        return _hasMethod('of', container) ? container.of(x) : [x];\n\t    };\n\t\n\t    /**\n\t     * Returns a partial copy of an object omitting the keys specified.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> {k: v}\n\t     * @param {Array} names an array of String property names to omit from the new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with properties from `names` not on it.\n\t     * @example\n\t     *\n\t     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n\t     */\n\t    var omit = _curry2(function omit(names, obj) {\n\t        return _pickBy(function (val, key) {\n\t            return !_contains(key, names);\n\t        }, obj);\n\t    });\n\t\n\t    /**\n\t     * Uses a placeholder to convert a binary function into something like an infix operation.\n\t     * When called with the `R.__` placeholder the second argument is applied to the\n\t     * second position, and it returns a function waiting for its first argument.\n\t     * This can allow for more natural processing of functions which are really binary operators.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @param {Function} fn The binary operation to adjust\n\t     * @return {Function} A new function that acts somewhat like an infix operator.\n\t     * @example\n\t     *\n\t     *      var div = R.op(function (a, b) {\n\t     *          return a / b;\n\t     *      });\n\t     *\n\t     *      div(6, 3); //=> 2\n\t     *      div(6)(3); //=> 2\n\t     *      div(R.__, 3)(6); //=> 2\n\t     *      div(R.__)(3, 6); //=> 2\n\t     *      div(R.__)(3)(6); //=> 2\n\t     */\n\t    var op = function op(fn) {\n\t        if (fn.length !== 2) {\n\t            throw new Error('Expected binary function.');\n\t        }\n\t        return function _op(a, b) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                throw _noArgsException();\n\t            case 1:\n\t                return a === __ ? flip(_op) : lPartial(fn, a);\n\t            default:\n\t                return a === __ ? flip(fn)(b) : fn(a, b);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first\n\t     * function if it is truth-y and the result of the second function otherwise.  Note that this is\n\t     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y\n\t     * value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n\t     * @param {Function} f a predicate\n\t     * @param {Function} g another predicate\n\t     * @return {Function} a function that applies its arguments to `f` and `g` and ORs their outputs together.\n\t     * @example\n\t     *\n\t     *      var gt10 = function(x) { return x > 10; };\n\t     *      var even = function(x) { return x % 2 === 0 };\n\t     *      var f = R.or(gt10, even);\n\t     *      f(101); //=> true\n\t     *      f(8); //=> true\n\t     */\n\t    var or = _curry2(function or(f, g) {\n\t        return function _or() {\n\t            return f.apply(this, arguments) || g.apply(this, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Similar to `compose` but with automatic handling of promises (or, more\n\t     * precisely, \"thenables\"). The behavior is identical  to that of\n\t     * compose() if all composed functions return something other than\n\t     * promises (i.e., objects with a .then() method). If one of the function\n\t     * returns a promise, however, then the next function in the composition\n\t     * is called asynchronously, in the success callback of the promise, using\n\t     * the resolved value as an input. Note that `pCompose` is a right-\n\t     * associative function, just like `compose`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((y -> z), (x -> y), ..., (b -> c), (a... -> b)) -> (a... -> z)\n\t     * @param {...Function} functions A variable number of functions.\n\t     * @return {Function} A new function which represents the result of calling each of the\n\t     *         input `functions`, passing either the returned result or the asynchronously\n\t     *         resolved value) of each function call to the next, from right to left.\n\t     * @example\n\t     *\n\t     *      var Q = require('q');\n\t     *      var triple = function(x) { return x * 3; };\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var squareAsync = function(x) { return Q.when(x * x); };\n\t     *      var squareAsyncThenDoubleThenTriple = R.pCompose(triple, double, squareAsync);\n\t     *\n\t     *      //≅ squareAsync(5).then(function(x) { return triple(double(x)) };\n\t     *      squareAsyncThenDoubleThenTriple(5)\n\t     *          .then(function(result) {\n\t     *              // result is 150\n\t     *          });\n\t     */\n\t    var pCompose = _createComposer(_pCompose);\n\t\n\t    /**\n\t     * Creates a new function that runs each of the functions supplied as parameters in turn,\n\t     * passing to the next function invocation either the value returned by the previous\n\t     * function or the resolved value if the returned value is a promise. In other words,\n\t     * if some of the functions in the sequence return promises, `pPipe` pipes the values\n\t     * asynchronously. If none of the functions return promises, the behavior is the same as\n\t     * that of `pipe`.\n\t     *\n\t     * `pPipe` is the mirror version of `pCompose`. `pPipe` is left-associative, which means that\n\t     * each of the functions provided is executed in order from left to right.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((a... -> b), (b -> c), ..., (x -> y), (y -> z)) -> (a... -> z)\n\t     * @param {...Function} functions A variable number of functions.\n\t     * @return {Function} A new function which represents the result of calling each of the\n\t     *         input `functions`, passing either the returned result or the asynchronously\n\t     *         resolved value) of each function call to the next, from left to right.\n\t     * @example\n\t     *\n\t     *      var Q = require('q');\n\t     *      var triple = function(x) { return x * 3; };\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var squareAsync = function(x) { return Q.when(x * x); };\n\t     *      var squareAsyncThenDoubleThenTriple = R.pPipe(squareAsync, double, triple);\n\t     *\n\t     *      //≅ squareAsync(5).then(function(x) { return triple(double(x)) };\n\t     *      squareAsyncThenDoubleThenTriple(5)\n\t     *          .then(function(result) {\n\t     *              // result is 150\n\t     *          });\n\t     */\n\t    var pPipe = function pPipe() {\n\t        return pCompose.apply(this, reverse(arguments));\n\t    };\n\t\n\t    /**\n\t     * Takes a predicate and a list and returns the pair of lists of\n\t     * elements which do and do not satisfy the predicate, respectively.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [[a],[a]]\n\t     * @param {Function} pred A predicate to determine which array the element belongs to.\n\t     * @param {Array} list The array to partition.\n\t     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,\n\t     *         and second an array of elements that did not satisfy.\n\t     * @example\n\t     *\n\t     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);\n\t     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]\n\t     */\n\t    var partition = _curry2(function partition(pred, list) {\n\t        return _foldl(function (acc, elt) {\n\t            acc[pred(elt) ? 0 : 1].push(elt);\n\t            return acc;\n\t        }, [\n\t            [],\n\t            []\n\t        ], list);\n\t    });\n\t\n\t    /**\n\t     * Determines whether a nested path on an object, seperated by periods,\n\t     * has a specific value according to strict equality ('==='). Most\n\t     * likely used to filter a list:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig String -> v -> {k: v} -> Boolean\n\t     * @param {String} path The path of the nested property to use\n\t     * @param {*} val The value to compare the nested property with\n\t     * @param {Object} obj The object to check the nested property in\n\t     * @return {Boolean} `true` if the value equals the nested object property,\n\t     *         `false` otherwise.\n\t     * @example\n\t     *\n\t     *     var user1 = { address: { zipCode: 90210 } };\n\t     *     var user2 = { address: { zipCode: 55555 } };\n\t     *     var user3 = { name: 'Bob' };\n\t     *     var users = [ user1, user2, user3 ]\n\t     *     var isFamous = R.pathEq('address.zipCode', 90210);\n\t     *     R.filter(isFamous, users); //=> [ user1 ]\n\t     */\n\t    var pathEq = _curry3(function (path, val, obj) {\n\t        return _path(path.split('.'), obj) === val;\n\t    });\n\t\n\t    /**\n\t     * Retrieve a nested path on an object separated by the specified\n\t     * separator value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig String -> String -> {*} -> *\n\t     * @param {String} sep The separator to use in `path`.\n\t     * @param {String} path The path to use.\n\t     * @return {*} The data at `path`.\n\t     * @example\n\t     *\n\t     *      R.pathOn('/', 'a/b/c', {a: {b: {c: 3}}}); //=> 3\n\t     */\n\t    var pathOn = _curry3(function pathOn(sep, str, obj) {\n\t        return _path(str.split(sep), obj);\n\t    });\n\t\n\t    /**\n\t     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the\n\t     * property is ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> {k: v}\n\t     * @param {Array} names an array of String property names to copy onto a new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties from `names` on it.\n\t     * @example\n\t     *\n\t     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n\t     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n\t     */\n\t    var pick = _curry2(function pick(names, obj) {\n\t        return _pickBy(function (val, key) {\n\t            return _contains(key, names);\n\t        }, obj);\n\t    });\n\t\n\t    /**\n\t     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> {k: v}\n\t     * @param {Array} names an array of String property names to copy onto a new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties from `names` on it.\n\t     * @see R.pick\n\t     * @example\n\t     *\n\t     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n\t     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n\t     */\n\t    var pickAll = _curry2(_pickAll);\n\t\n\t    /**\n\t     * Returns a partial copy of an object containing only the keys that\n\t     * satisfy the supplied predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}\n\t     * @param {Function} pred A predicate to determine whether or not a key\n\t     *        should be included on the output object.\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties that satisfy `pred`\n\t     *         on it.\n\t     * @see R.pick\n\t     * @example\n\t     *\n\t     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }\n\t     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n\t     */\n\t    var pickBy = _curry2(_pickBy);\n\t\n\t    /**\n\t     * Creates a new function that runs each of the functions supplied as parameters in turn,\n\t     * passing the return value of each function invocation to the next function invocation,\n\t     * beginning with whatever arguments were passed to the initial invocation.\n\t     *\n\t     * `pipe` is the mirror version of `compose`. `pipe` is left-associative, which means that\n\t     * each of the functions provided is executed in order from left to right.\n\t     *\n\t     * In some libraries this function is named `sequence`.\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((a... -> b), (b -> c), ..., (x -> y), (y -> z)) -> (a... -> z)\n\t     * @param {...Function} functions A variable number of functions.\n\t     * @return {Function} A new function which represents the result of calling each of the\n\t     *         input `functions`, passing the result of each function call to the next, from\n\t     *         left to right.\n\t     * @example\n\t     *\n\t     *      var triple = function(x) { return x * 3; };\n\t     *      var double = function(x) { return x * 2; };\n\t     *      var square = function(x) { return x * x; };\n\t     *      var squareThenDoubleThenTriple = R.pipe(square, double, triple);\n\t     *\n\t     *      //≅ triple(double(square(5)))\n\t     *      squareThenDoubleThenTriple(5); //=> 150\n\t     */\n\t    var pipe = function pipe() {\n\t        return compose.apply(this, reverse(arguments));\n\t    };\n\t\n\t    /**\n\t     * Returns a new list by plucking the same named property off all objects in the list supplied.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig String -> {*} -> [*]\n\t     * @param {Number|String} key The key name to pluck off of each object.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of values for the given key.\n\t     * @example\n\t     *\n\t     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n\t     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n\t     */\n\t    var pluck = _curry2(_pluck);\n\t\n\t    /**\n\t     * Returns a new list with the given element at the front, followed by the contents of the\n\t     * list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> [a] -> [a]\n\t     * @param {*} el The item to add to the head of the output list.\n\t     * @param {Array} list The array to add to the tail of the output list.\n\t     * @return {Array} A new array.\n\t     * @example\n\t     *\n\t     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']\n\t     */\n\t    var prepend = _curry2(_prepend);\n\t\n\t    /**\n\t     * Multiplies together all the elements of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list An array of numbers\n\t     * @return {Number} The product of all the numbers in the list.\n\t     * @see foldl\n\t     * @example\n\t     *\n\t     *      R.product([2,4,6,8,100,1]); //=> 38400\n\t     */\n\t    var product = foldl(_multiply, 1);\n\t\n\t    /**\n\t     * Determines whether the given property of an object has a specific\n\t     * value according to strict equality (`===`).  Most likely used to\n\t     * filter a list:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig k -> v -> {k: v} -> Boolean\n\t     * @param {Number|String} name The property name (or index) to use.\n\t     * @param {*} val The value to compare the property with.\n\t     * @return {Boolean} `true` if the properties are equal, `false` otherwise.\n\t     * @example\n\t     *\n\t     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};\n\t     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};\n\t     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};\n\t     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};\n\t     *      var kids = [abby, fred, rusty, alois];\n\t     *      var hasBrownHair = R.propEq('hair', 'brown');\n\t     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]\n\t     */\n\t    var propEq = _curry3(function propEq(name, val, obj) {\n\t        return obj[name] === val;\n\t    });\n\t\n\t    /**\n\t     * If the given, non-null object has an own property with the specified name,\n\t     * returns the value of that property.\n\t     * Otherwise returns the provided default value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig s -> v -> {s: x} -> x | v\n\t     * @param {String} p The name of the property to return.\n\t     * @param {*} val The default value.\n\t     * @param {Object} obj The object to query.\n\t     * @return {*} The value of given property or default value.\n\t     * @example\n\t     *\n\t     *      var alice = {\n\t     *        name: 'ALICE',\n\t     *        age: 101\n\t     *      };\n\t     *      var favorite = R.prop('favoriteLibrary');\n\t     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');\n\t     *\n\t     *      favorite(alice);  //=> undefined\n\t     *      favoriteWithDefault(alice);  //=> 'Ramda'\n\t     */\n\t    var propOr = _curry3(function propOr(val, p, obj) {\n\t        return has(p, obj) ? obj[p] : val;\n\t    });\n\t\n\t    /**\n\t     * Acts as multiple `get`: array of keys in, array of values out. Preserves order.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> [v]\n\t     * @param {Array} ps The property names to fetch\n\t     * @param {Object} obj The object to query\n\t     * @return {Array} The corresponding values or partially applied function.\n\t     * @example\n\t     *\n\t     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]\n\t     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]\n\t     *\n\t     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));\n\t     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'\n\t     */\n\t    var props = _curry2(function props(ps, obj) {\n\t        var len = ps.length, out = new Array(len), idx = -1;\n\t        while (++idx < len) {\n\t            out[idx] = obj[ps[idx]];\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Accepts as its arguments a function and any number of values and returns a function that,\n\t     * when invoked, calls the original function with all of the values appended to the original\n\t     * function's arguments list.\n\t     *\n\t     * Note that `rPartial` is the opposite of `lPartial`: `rPartial` fills `fn`'s arguments\n\t     * from the right to the left.  In some libraries this function is named `applyRight`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)\n\t     * @param {Function} fn The function to invoke.\n\t     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.\n\t     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with\n\t     *         `args` appended to `fn`'s arguments list.\n\t     * @example\n\t     *\n\t     *      var greet = function(salutation, title, firstName, lastName) {\n\t     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n\t     *      };\n\t     *      var greetMsJaneJones = R.rPartial(greet, 'Ms.', 'Jane', 'Jones');\n\t     *\n\t     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n\t     */\n\t    var rPartial = _createPartialApplicator(flip(_concat));\n\t\n\t    /**\n\t     * Returns a list of numbers from `from` (inclusive) to `to`\n\t     * (exclusive).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> Number -> [Number]\n\t     * @param {Number} from The first number in the list.\n\t     * @param {Number} to One more than the last number in the list.\n\t     * @return {Array} The list of numbers in tthe set `[a, b)`.\n\t     * @example\n\t     *\n\t     *      R.range(1, 5);    //=> [1, 2, 3, 4]\n\t     *      R.range(50, 53);  //=> [50, 51, 52]\n\t     */\n\t    var range = _curry2(function range(from, to) {\n\t        if (from >= to) {\n\t            return [];\n\t        }\n\t        var idx = 0, result = new Array(Math.floor(to) - Math.ceil(from));\n\t        while (from < to) {\n\t            result[idx++] = from++;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Similar to `filter`, except that it keeps only values for which the given predicate\n\t     * function returns falsy. The predicate function is passed one argument: *(value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} The new filtered array.\n\t     * @example\n\t     *\n\t     *      var isOdd = function(n) {\n\t     *        return n % 2 === 1;\n\t     *      };\n\t     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n\t     */\n\t    var reject = _curry2(function reject(fn, list) {\n\t        return _filter(not(fn), list);\n\t    });\n\t\n\t    /**\n\t     * Like `reject`, but passes additional parameters to the predicate function. The predicate\n\t     * function is passed three arguments: *(value, index, list)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a, i, [a] -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} The new filtered array.\n\t     * @example\n\t     *\n\t     *      var lastTwo = function(val, idx, list) {\n\t     *        return list.length - idx <= 2;\n\t     *      };\n\t     *\n\t     *      R.rejectIndexed(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [8, 6, 7, 5, 3]\n\t     */\n\t    var rejectIndexed = _curry2(function rejectIndexed(fn, list) {\n\t        return _filterIndexed(not(fn), list);\n\t    });\n\t\n\t    /**\n\t     * Removes the sub-list of `list` starting at index `start` and containing\n\t     * `count` elements.  _Note that this is not destructive_: it returns a\n\t     * copy of the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> Number -> [a] -> [a]\n\t     * @param {Number} start The position to start removing elements\n\t     * @param {Number} count The number of elements to remove\n\t     * @param {Array} list The list to remove from\n\t     * @return {Array} A new Array with `count` elements from `start` removed.\n\t     * @example\n\t     *\n\t     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n\t     */\n\t    var remove = _curry3(function remove(start, count, list) {\n\t        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n\t    });\n\t\n\t    /**\n\t     * Replace a substring or regex match in a string with a replacement.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig RegExp|String -> String -> String -> String\n\t     * @param {RegExp|String} pattern A regular expression or a substring to match.\n\t     * @param {String} replacement The string to replace the matches with.\n\t     * @param {String} str The String to do the search and replacement in.\n\t     * @return {String} A string with all the matches replaced.\n\t     * @example\n\t     *\n\t     *      R.replace(/\\d+/g, 'number', '1 2 three'); //=> 'number number three'\n\t     *\n\t     *      var replaceSemicolon = R.replace(';');\n\t     *      var removeSemicolon = replaceSemicolon('');\n\t     *      removeSemicolon('return 42;'); //=> 'return 42'\n\t     */\n\t    var replace = _curry3(function replace(regex, replacement, str) {\n\t        return str.replace(regex, replacement);\n\t    });\n\t\n\t    /**\n\t     * Scanl is similar to foldl, but returns a list of successively reduced values from the left\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b -> a) -> a -> [b] -> [a]\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {Array} A list of all intermediately reduced values.\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3, 4];\n\t     *      var factorials = R.scanl(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]\n\t     */\n\t    var scanl = _curry3(function scanl(fn, acc, list) {\n\t        var idx = 0, len = list.length + 1, result = new Array(len);\n\t        result[idx] = acc;\n\t        while (++idx < len) {\n\t            acc = fn(acc, list[idx - 1]);\n\t            result[idx] = acc;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns the elements from `xs` starting at `a` and ending at `b - 1`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> Number -> [a] -> [a]\n\t     * @param {Number} a The starting index.\n\t     * @param {Number} b One more than the ending index.\n\t     * @param {Array} xs The list to take elements from.\n\t     * @return {Array} The items from `a` to `b - 1` from `xs`.\n\t     * @example\n\t     *\n\t     *      var xs = R.range(0, 10);\n\t     *      R.slice(2, 5)(xs); //=> [2, 3, 4]\n\t     */\n\t    var slice = invoker(2, 'slice');\n\t\n\t    /**\n\t     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a\n\t     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero\n\t     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,a -> Number) -> [a] -> [a]\n\t     * @param {Function} comparator A sorting function :: a -> b -> Int\n\t     * @param {Array} list The list to sort\n\t     * @return {Array} a new array with its elements sorted by the comparator function.\n\t     * @example\n\t     *\n\t     *      var diff = function(a, b) { return a - b; };\n\t     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]\n\t     */\n\t    var sort = _curry2(function sort(comparator, list) {\n\t        return clone(list).sort(comparator);\n\t    });\n\t\n\t    /**\n\t     * Sorts the list according to a key generated by the supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig (a -> String) -> [a] -> [a]\n\t     * @param {Function} fn The function mapping `list` items to keys.\n\t     * @param {Array} list The list to sort.\n\t     * @return {Array} A new list sorted by the keys generated by `fn`.\n\t     * @example\n\t     *\n\t     *      var sortByFirstItem = R.sortBy(prop(0));\n\t     *      var sortByNameCaseInsensitive = R.sortBy(compose(R.toLower, prop('name')));\n\t     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];\n\t     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]\n\t     *      var alice = {\n\t     *         name: 'ALICE',\n\t     *         age: 101\n\t     *      };\n\t     *      var bob = {\n\t     *         name: 'Bob',\n\t     *        age: -10\n\t     *      };\n\t     *      var clara = {\n\t     *        name: 'clara',\n\t     *        age: 314.159\n\t     *      };\n\t     *      var people = [clara, bob, alice];\n\t     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]\n\t     */\n\t    var sortBy = _curry2(function sortBy(fn, list) {\n\t        return clone(list).sort(function (a, b) {\n\t            var aa = fn(a);\n\t            var bb = fn(b);\n\t            return aa < bb ? -1 : aa > bb ? 1 : 0;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Splits a string into an array of strings based on the given\n\t     * separator.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String -> [String]\n\t     * @param {String} sep The separator string.\n\t     * @param {String} str The string to separate into an array.\n\t     * @return {Array} The array of strings from `str` separated by `str`.\n\t     * @example\n\t     *\n\t     *      var pathComponents = R.split('/');\n\t     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n\t     *\n\t     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n\t     */\n\t    var split = invoker(1, 'split');\n\t\n\t    /**\n\t     * Finds the first index of a substring in a string, returning -1 if it's not present\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String -> Number\n\t     * @param {String} c A string to find.\n\t     * @param {String} str The string to search in\n\t     * @return {Number} The first index of `c` or -1 if not found.\n\t     * @example\n\t     *\n\t     *      R.strIndexOf('c', 'abcdefg'); //=> 2\n\t     */\n\t    var strIndexOf = _curry2(function strIndexOf(c, str) {\n\t        return str.indexOf(c);\n\t    });\n\t\n\t    /**\n\t     *\n\t     * Finds the last index of a substring in a string, returning -1 if it's not present\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String -> Number\n\t     * @param {String} c A string to find.\n\t     * @param {String} str The string to search in\n\t     * @return {Number} The last index of `c` or -1 if not found.\n\t     * @example\n\t     *\n\t     *      R.strLastIndexOf('a', 'banana split'); //=> 5\n\t     */\n\t    var strLastIndexOf = _curry2(function (c, str) {\n\t        return str.lastIndexOf(c);\n\t    });\n\t\n\t    /**\n\t     * returns a subset of a string between one index and another.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig Number -> Number -> String -> String\n\t     * @param {Number} indexA An integer between 0 and the length of the string.\n\t     * @param {Number} indexB An integer between 0 and the length of the string.\n\t     * @param {String} str The string to extract from\n\t     * @return {String} The extracted substring.\n\t     * @see R.invoker\n\t     * @example\n\t     *\n\t     *      R.substring(2, 5, 'abcdefghijklm'); //=> 'cde'\n\t     */\n\t    var substring = invoker(2, 'substring');\n\t\n\t    /**\n\t     * The trailing substring of a String starting with the nth character:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig Number -> String -> String\n\t     * @param {Number} indexA An integer between 0 and the length of the string.\n\t     * @param {String} str The string to extract from\n\t     * @return {String} The extracted substring.\n\t     * @example\n\t     *\n\t     *      R.substringFrom(8, 'abcdefghijklm'); //=> 'ijklm'\n\t     */\n\t    var substringFrom = flip(substring)(void 0);\n\t\n\t    /**\n\t     * The leading substring of a String ending before the nth character:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig Number -> String -> String\n\t     * @param {Number} indexA An integer between 0 and the length of the string.\n\t     * @param {String} str The string to extract from\n\t     * @return {String} The extracted substring.\n\t     * @example\n\t     *\n\t     *      R.substringTo(8, 'abcdefghijklm'); //=> 'abcdefgh'\n\t     */\n\t    var substringTo = substring(0);\n\t\n\t    /**\n\t     * Subtracts two numbers. Equivalent to `a - b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a - b`.\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `R.__` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.subtract(10, 8); //=> 2\n\t     *\n\t     *      var minus5 = R.subtract(R.__, 5);\n\t     *      minus5(17); //=> 12\n\t     *\n\t     *      var complementaryAngle = R.subtract(90);\n\t     *      complementaryAngle(30); //=> 60\n\t     *      complementaryAngle(72); //=> 18\n\t     */\n\t    var subtract = op(function subtract(a, b) {\n\t        return a - b;\n\t    });\n\t\n\t    /**\n\t     * Adds together all the elements of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list An array of numbers\n\t     * @return {Number} The sum of all the numbers in the list.\n\t     * @see foldl\n\t     * @example\n\t     *\n\t     *      R.sum([2,4,6,8,100,1]); //=> 121\n\t     */\n\t    var sum = foldl(_add, 0);\n\t\n\t    /**\n\t     * Returns all but the first element of a list. If the list provided has the `tail` method,\n\t     * it will instead return `list.tail()`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} [list=[]] The array to consider.\n\t     * @return {Array} A new array containing all but the first element of the input list, or an\n\t     *         empty list if the input list is empty.\n\t     * @example\n\t     *\n\t     *      R.tail(['fi', 'fo', 'fum']); //=> ['fo', 'fum']\n\t     */\n\t    var tail = _checkForMethod('tail', function (list) {\n\t        return _slice(list, 1);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing the first `n` elements of the given list.  If\n\t     * `n > * list.length`, returns a list of `list.length` elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @param {Number} n The number of elements to return.\n\t     * @param {Array} list The array to query.\n\t     * @return {Array} A new array containing the first elements of `list`.\n\t     */\n\t    var take = _curry2(_checkForMethod('take', function (n, list) {\n\t        return _slice(list, 0, Math.min(n, list.length));\n\t    }));\n\t\n\t    /**\n\t     * Returns a new list containing the first `n` elements of a given list, passing each value\n\t     * to the supplied predicate function, and terminating when the predicate function returns\n\t     * `false`. Excludes the element that caused the predicate function to fail. The predicate\n\t     * function is passed one argument: *(value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @example\n\t     *\n\t     *      var isNotFour = function(x) {\n\t     *        return !(x === 4);\n\t     *      };\n\t     *\n\t     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]\n\t     */\n\t    var takeWhile = _curry2(_checkForMethod('takeWhile', function (fn, list) {\n\t        var idx = -1, len = list.length;\n\t        while (++idx < len && fn(list[idx])) {\n\t        }\n\t        return _slice(list, 0, idx);\n\t    }));\n\t\n\t    /**\n\t     * Runs the given function with the supplied object, then returns the object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a -> *) -> a -> a\n\t     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n\t     * @param {*} x\n\t     * @return {*} `x`.\n\t     * @example\n\t     *\n\t     *      var sayX = function(x) { console.log('x is ' + x); };\n\t     *      R.tap(sayX, 100); //=> 100\n\t     *      //-> 'x is 100')\n\t     */\n\t    var tap = _curry2(function tap(fn, x) {\n\t        fn(x);\n\t        return x;\n\t    });\n\t\n\t    /**\n\t     * Calls an input function `n` times, returning an array containing the results of those\n\t     * function calls.\n\t     *\n\t     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is\n\t     * gradually incremented to `n - 1`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (i -> a) -> i -> [a]\n\t     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n\t     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n\t     * @return {Array} An array containing the return values of all calls to `fn`.\n\t     * @example\n\t     *\n\t     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n\t     */\n\t    var times = _curry2(function times(fn, n) {\n\t        var list = new Array(Number(n));\n\t        var len = list.length;\n\t        var idx = -1;\n\t        while (++idx < len) {\n\t            list[idx] = fn(idx);\n\t        }\n\t        return list;\n\t    });\n\t\n\t    /**\n\t     * The lower case version of a string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to lower case.\n\t     * @return {String} The lower case version of `str`.\n\t     * @example\n\t     *\n\t     *      R.toLower('XYZ'); //=> 'xyz'\n\t     */\n\t    var toLower = invoker(0, 'toLowerCase');\n\t\n\t    /**\n\t     * Converts an object into an array of key, value arrays.\n\t     * Only the object's own properties are used.\n\t     * Note that the order of the output array is not guaranteed to be\n\t     * consistent across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [[k,v]]\n\t     * @param {Object} obj The object to extract from\n\t     * @return {Array} An array of key, value arrays from the object's own properties.\n\t     * @example\n\t     *\n\t     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n\t     */\n\t    var toPairs = _pairWith(keys);\n\t\n\t    /**\n\t     * The upper case version of a string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to upper case.\n\t     * @return {String} The upper case version of `str`.\n\t     * @example\n\t     *\n\t     *      R.toUpper('abc'); //=> 'ABC'\n\t     */\n\t    var toUpper = invoker(0, 'toUpperCase');\n\t\n\t    /**\n\t     * Builds a list from a seed value. Accepts an iterator function, which returns either false\n\t     * to stop iteration or an array of length 2 containing the value to add to the resulting\n\t     * list and the seed to be used in the next call to the iterator function.\n\t     *\n\t     * The iterator function receives one argument: *(seed)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> [b]) -> * -> [b]\n\t     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n\t     *        either false to quit iteration or an array of length two to proceed. The element\n\t     *        at index 0 of this array will be added to the resulting array, and the element\n\t     *        at index 1 will be passed to the next call to `fn`.\n\t     * @param {*} seed The seed value.\n\t     * @return {Array} The final list.\n\t     * @example\n\t     *\n\t     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };\n\t     *      R.unfoldr(f, 10); //=> [-10, -20, -30, -40, -50]\n\t     */\n\t    var unfoldr = _curry2(function unfoldr(fn, seed) {\n\t        var pair = fn(seed);\n\t        var result = [];\n\t        while (pair && pair.length) {\n\t            result[result.length] = pair[0];\n\t            pair = fn(pair[1]);\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing only one copy of each element in the original list.\n\t     * Equality is strict here, meaning reference equality for objects and non-coercing equality\n\t     * for primitives.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of unique items.\n\t     * @example\n\t     *\n\t     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n\t     *      R.uniq([{}, {}]);     //=> [{}, {}]\n\t     *      R.uniq([1, '1']);     //=> [1, '1']\n\t     */\n\t    var uniq = function uniq(list) {\n\t        var idx = -1, len = list.length;\n\t        var result = [], item;\n\t        while (++idx < len) {\n\t            item = list[idx];\n\t            if (!_contains(item, result)) {\n\t                result[result.length] = item;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Returns a new list containing only one copy of each element in the original list, based\n\t     * upon the value returned by applying the supplied predicate to two list elements. Prefers\n\t     * the first item if two items compare equal based on the predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a, a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of unique items.\n\t     * @example\n\t     *\n\t     *      var strEq = function(a, b) { return String(a) === String(b); };\n\t     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n\t     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n\t     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n\t     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n\t     */\n\t    var uniqWith = _curry2(function uniqWith(pred, list) {\n\t        var idx = -1, len = list.length;\n\t        var result = [], item;\n\t        while (++idx < len) {\n\t            item = list[idx];\n\t            if (!_containsWith(pred, item, result)) {\n\t                result[result.length] = item;\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list by pulling every item at the first level of nesting out, and putting\n\t     * them in a new array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [b]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The flattened list.\n\t     * @example\n\t     *\n\t     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n\t     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n\t     */\n\t    var unnest = _makeFlat(false);\n\t\n\t    /**\n\t     * Returns a list of all the enumerable own properties of the supplied object.\n\t     * Note that the order of the output array is not guaranteed across\n\t     * different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> [v]\n\t     * @param {Object} obj The object to extract values from\n\t     * @return {Array} An array of the values of the object's own properties.\n\t     * @example\n\t     *\n\t     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n\t     */\n\t    var values = function values(obj) {\n\t        var props = keys(obj);\n\t        var len = props.length;\n\t        var vals = new Array(len);\n\t        var idx = -1;\n\t        while (++idx < len) {\n\t            vals[idx] = obj[props[idx]];\n\t        }\n\t        return vals;\n\t    };\n\t\n\t    /**\n\t     * Takes a spec object and a test object and returns true if the test satisfies the spec.\n\t     * Any property on the spec that is not a function is interpreted as an equality\n\t     * relation.\n\t     *\n\t     * If the spec has a property mapped to a function, then `where` evaluates the function, passing in\n\t     * the test object's value for the property in question, as well as the whole test object.\n\t     *\n\t     * `where` is well suited to declaratively expressing constraints for other functions, e.g.,\n\t     * `filter`, `find`, `pickBy`, etc.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> {k: v} -> Boolean\n\t     * @param {Object} spec\n\t     * @param {Object} testObj\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      var spec = {x: 2};\n\t     *      R.where(spec, {w: 10, x: 2, y: 300}); //=> true\n\t     *      R.where(spec, {x: 1, y: 'moo', z: true}); //=> false\n\t     *\n\t     *      var spec2 = {x: function(val, obj) { return  val + obj.y > 10; }};\n\t     *      R.where(spec2, {x: 2, y: 7}); //=> false\n\t     *      R.where(spec2, {x: 3, y: 8}); //=> true\n\t     *\n\t     *      var xs = [{x: 2, y: 1}, {x: 10, y: 2}, {x: 8, y: 3}, {x: 10, y: 4}];\n\t     *      R.filter(R.where({x: 10}), xs); // ==> [{x: 10, y: 2}, {x: 10, y: 4}]\n\t     */\n\t    var where = function where(spec, testObj) {\n\t        var parsedSpec = groupBy(function (key) {\n\t            return typeof spec[key] === 'function' ? 'fn' : 'obj';\n\t        }, keys(spec));\n\t        switch (arguments.length) {\n\t        case 0:\n\t            throw _noArgsException();\n\t        case 1:\n\t            return function (testObj) {\n\t                return _satisfiesSpec(spec, parsedSpec, testObj);\n\t            };\n\t        }\n\t        return _satisfiesSpec(spec, parsedSpec, testObj);\n\t    };\n\t\n\t    /**\n\t     * Wrap a function inside another to allow you to make adjustments to the parameters, or do\n\t     * other processing either before the internal function is called or with its results.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)\n\t     * @param {Function} fn The function to wrap.\n\t     * @param {Function} wrapper The wrapper function.\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      var greet = function(name) {return 'Hello ' + name;};\n\t     *\n\t     *      var shoutedGreet = R.wrap(greet, function(gr, name) {\n\t     *          return gr(name).toUpperCase();\n\t     *      });\n\t     *      shoutedGreet(\"Kathy\"); //=> \"HELLO KATHY\"\n\t     *\n\t     *      var shortenedGreet = R.wrap(greet, function(gr, name) {\n\t     *          return gr(name.substring(0, 3));\n\t     *      });\n\t     *      shortenedGreet(\"Robert\"); //=> \"Hello Rob\"\n\t     *\n\t     */\n\t    var wrap = function wrap(fn, wrapper) {\n\t        return curryN(fn.length, function () {\n\t            return wrapper.apply(this, _concat([fn], arguments));\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by creating each possible\n\t     * pair from the lists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [b] -> [[a,b]]\n\t     * @param {Array} as The first list.\n\t     * @param {Array} bs The second list.\n\t     * @return {Array} The list made by combining each possible pair from\n\t     *         `as` and `bs` into pairs (`[a, b]`).\n\t     * @example\n\t     *\n\t     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n\t     */\n\t    // = xprodWith(prepend); (takes about 3 times as long...)\n\t    // Better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n\t    var xprod = _curry2(function xprod(a, b) {\n\t        // = xprodWith(prepend); (takes about 3 times as long...)\n\t        var idx = -1;\n\t        var ilen = a.length;\n\t        var j;\n\t        var jlen = b.length;\n\t        // Better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n\t        var result = [];\n\t        while (++idx < ilen) {\n\t            j = -1;\n\t            while (++j < jlen) {\n\t                result[result.length] = [\n\t                    a[idx],\n\t                    b[j]\n\t                ];\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by pairing up\n\t     * equally-positioned items from both lists.  The returned list is\n\t     * truncated to the length of the shorter of the two input lists.\n\t     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> b -> [[a,b]]\n\t     * @param {Array} list1 The first array to consider.\n\t     * @param {Array} list2 The second array to consider.\n\t     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n\t     * @example\n\t     *\n\t     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n\t     */\n\t    var zip = _curry2(function zip(a, b) {\n\t        var rv = [];\n\t        var idx = -1;\n\t        var len = Math.min(a.length, b.length);\n\t        while (++idx < len) {\n\t            rv[idx] = [\n\t                a[idx],\n\t                b[idx]\n\t            ];\n\t        }\n\t        return rv;\n\t    });\n\t\n\t    /**\n\t     * Creates a new object out of a list of keys and a list of values.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig k -> v -> {k: v}\n\t     * @param {Array} keys The array that will be properties on the output object.\n\t     * @param {Array} values The list of values on the output object.\n\t     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n\t     * @example\n\t     *\n\t     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n\t     */\n\t    var zipObj = _curry2(function zipObj(keys, values) {\n\t        var idx = -1, len = keys.length, out = {};\n\t        while (++idx < len) {\n\t            out[keys[idx]] = values[idx];\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by applying the function to\n\t     * each equally-positioned pair in the lists. The returned list is\n\t     * truncated to the length of the shorter of the two input lists.\n\t     *\n\t     * @function\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a,b -> c) -> [a] -> [b] -> [c]\n\t     * @param {Function} fn The function used to combine the two elements into one value.\n\t     * @param {Array} list1 The first array to consider.\n\t     * @param {Array} list2 The second array to consider.\n\t     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n\t     *         using `fn`.\n\t     * @example\n\t     *\n\t     *      var f = function(x, y) {\n\t     *        // ...\n\t     *      };\n\t     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n\t     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n\t     */\n\t    var zipWith = _curry3(function zipWith(fn, a, b) {\n\t        var rv = [], idx = -1, len = Math.min(a.length, b.length);\n\t        while (++idx < len) {\n\t            rv[idx] = fn(a[idx], b[idx]);\n\t        }\n\t        return rv;\n\t    });\n\t\n\t    var _ap = function _ap(fns, vs) {\n\t        return _hasMethod('ap', fns) ? fns.ap(vs) : _foldl(function (acc, fn) {\n\t            return _concat(acc, _map(fn, vs));\n\t        }, [], fns);\n\t    };\n\t\n\t    // The algorithm used to handle cyclic structures is\n\t    // inspired by underscore's isEqual\n\t    // RegExp equality algorithm: http://stackoverflow.com/a/10776635\n\t    var _eqDeep = function _eqDeep(a, b, stackA, stackB) {\n\t        var typeA = type(a);\n\t        if (typeA !== type(b)) {\n\t            return false;\n\t        }\n\t        if (eq(a, b)) {\n\t            return true;\n\t        }\n\t        if (typeA == 'RegExp') {\n\t            // RegExp equality algorithm: http://stackoverflow.com/a/10776635\n\t            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;\n\t        }\n\t        if (Object(a) === a) {\n\t            if (typeA === 'Date' && a.getTime() != b.getTime()) {\n\t                return false;\n\t            }\n\t            var keysA = keys(a);\n\t            if (keysA.length !== keys(b).length) {\n\t                return false;\n\t            }\n\t            var idx = stackA.length;\n\t            while (idx--) {\n\t                if (stackA[idx] === a) {\n\t                    return stackB[idx] === b;\n\t                }\n\t            }\n\t            stackA.push(a);\n\t            stackB.push(b);\n\t            idx = keysA.length;\n\t            while (idx--) {\n\t                var key = keysA[idx];\n\t                if (!has(key, b) || !_eqDeep(b[key], a[key], stackA, stackB)) {\n\t                    return false;\n\t                }\n\t            }\n\t            stackA.pop();\n\t            stackB.pop();\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t\n\t    /**\n\t     * Assigns own enumerable properties of the other object to the destination\n\t     * object preferring items in other.\n\t     *\n\t     * @private\n\t     * @memberOf R\n\t     * @category Object\n\t     * @param {Object} destination The destination object.\n\t     * @param {Object} other The other object to merge with destination.\n\t     * @return {Object} The destination object.\n\t     * @example\n\t     *\n\t     *      _extend({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n\t     *      //=> { 'name': 'fred', 'age': 40 }\n\t     */\n\t    var _extend = function _extend(destination, other) {\n\t        var props = keys(other), idx = -1, length = props.length;\n\t        while (++idx < length) {\n\t            destination[props[idx]] = other[props[idx]];\n\t        }\n\t        return destination;\n\t    };\n\t\n\t    /**\n\t     * Create a predicate wrapper which will call a pick function (all/any) for each predicate\n\t     *\n\t     * @private\n\t     * @see R.all\n\t     * @see R.any\n\t     */\n\t    // Call function immediately if given arguments\n\t    // Return a function which will call the predicates with the provided arguments\n\t    var _predicateWrap = function _predicateWrap(predPicker) {\n\t        return function (preds) {\n\t            var predIterator = function () {\n\t                var args = arguments;\n\t                return predPicker(function (predicate) {\n\t                    return predicate.apply(null, args);\n\t                }, preds);\n\t            };\n\t            return arguments.length > 1 ? // Call function immediately if given arguments\n\t            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments\n\t            arity(max(_pluck('length', preds)), predIterator);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n\t     * @param {Array} list An array of predicate functions\n\t     * @param {*} optional Any arguments to pass into the predicates\n\t     * @return {Function} a function that applies its arguments to each of\n\t     *         the predicates, returning `true` if all are satisfied.\n\t     * @example\n\t     *\n\t     *      var gt10 = function(x) { return x > 10; };\n\t     *      var even = function(x) { return x % 2 === 0};\n\t     *      var f = R.allPass([gt10, even]);\n\t     *      f(11); //=> false\n\t     *      f(12); //=> true\n\t     */\n\t    var allPass = _predicateWrap(_all);\n\t\n\t    /**\n\t     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Logic\n\t     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n\t     * @param {Array} list An array of predicate functions\n\t     * @param {*} optional Any arguments to pass into the predicates\n\t     * @return {Function} A function that applies its arguments to each of the predicates, returning\n\t     *         `true` if all are satisfied.\n\t     * @example\n\t     *\n\t     *      var gt10 = function(x) { return x > 10; };\n\t     *      var even = function(x) { return x % 2 === 0};\n\t     *      var f = R.anyPass([gt10, even]);\n\t     *      f(11); //=> true\n\t     *      f(8); //=> true\n\t     *      f(9); //=> false\n\t     */\n\t    var anyPass = _predicateWrap(_any);\n\t\n\t    /**\n\t     * ap applies a list of functions to a list of values.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig [f] -> [a] -> [f a]\n\t     * @param {Array} fns An array of functions\n\t     * @param {Array} vs An array of values\n\t     * @return {Array} The value of applying each the function `fns` to each value in `vs`.\n\t     * @example\n\t     *\n\t     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n\t     */\n\t    var ap = _curry2(_ap);\n\t\n\t    /**\n\t     * Makes a shallow clone of an object, setting or overriding the specified\n\t     * property with the given value.  Note that this copies and flattens\n\t     * prototype properties onto the new object as well.  All non-primitive\n\t     * properties are copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig String -> a -> {k: v} -> {k: v}\n\t     * @param {String} prop the property name to set\n\t     * @param {*} val the new value\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object similar to the original except for the specified property.\n\t     * @example\n\t     *\n\t     *      var obj1 = {a: 1, b: {c: 2, d: 3}, e: 4, f: 5};\n\t     *      var obj2 = R.assoc('e', {x: 42}, obj1);\n\t     *      //=>  {a: 1, b: {c: 2, d: 3}, e: {x: 42}, f: 5}\n\t     *\n\t     *      // And moreover, obj2.b is a reference to obj1.b\n\t     *      // No unnecessary objects are created.\n\t     */\n\t    // rather than `clone` to get prototype props too, even though they're flattened\n\t    var assoc = _curry3(function (prop, val, obj) {\n\t        // rather than `clone` to get prototype props too, even though they're flattened\n\t        return _extend(fromPairs(_map(function (key) {\n\t            return [\n\t                key,\n\t                obj[key]\n\t            ];\n\t        }, keysIn(obj))), createMapEntry(prop, val));\n\t    });\n\t\n\t    /**\n\t     * Makes a shallow clone of an object, setting or overriding the nodes\n\t     * required to create the given path, and placing the specifiec value at the\n\t     * tail end of that path.  Note that this copies and flattens prototype\n\t     * properties onto the new object as well.  All non-primitive properties\n\t     * are copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig String -> a -> {k: v} -> {k: v}\n\t     * @param {String} path the dot-delimited path to set\n\t     * @param {*} val the new value\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object similar to the original except along the specified path.\n\t     * @example\n\t     *\n\t     *      var obj1 = {a: {b: 1, c: 2, d: {e: 3}}, f: {g: {h: 4, i: 5, j: {k: 6, l: 7}}}, m: 8};\n\t     *      var obj2 = R.assocPath('f.g.i', {x: 42}, obj1);\n\t     *      //=> {a: {b: 1, c: 2, d: {e: 3}}, f: {g: {h: 4, i: {x: 42}, j: {k: 6, l: 7}}}, m: 8}\n\t     */\n\t    var assocPath = function () {\n\t        var setParts = function (parts, val, obj) {\n\t            if (parts.length === 1) {\n\t                return assoc(parts[0], val, obj);\n\t            }\n\t            var current = obj[parts[0]];\n\t            return assoc(parts[0], setParts(_slice(parts, 1), val, is(Object, current) ? current : {}), obj);\n\t        };\n\t        return function (path, val, obj) {\n\t            var length = arguments.length;\n\t            if (length === 0) {\n\t                throw _noArgsException();\n\t            }\n\t            var parts = split('.', path);\n\t            var fn = _curry2(function (val, obj) {\n\t                return setParts(parts, val, obj);\n\t            });\n\t            switch (length) {\n\t            case 1:\n\t                return fn;\n\t            case 2:\n\t                return fn(val);\n\t            default:\n\t                return fn(val, obj);\n\t            }\n\t        };\n\t    }();\n\t\n\t    /**\n\t     * `chain` maps a function over a list and concatenates the results.\n\t     * This implementation is compatible with the\n\t     * Fantasy-land Chain spec, and will work with types that implement that spec.\n\t     * `chain` is also known as `flatMap` in some libraries\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig (a -> [b]) -> [a] -> [b]\n\t     * @param {Function} fn\n\t     * @param {Array} list\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      var duplicate = function(n) {\n\t     *        return [n, n];\n\t     *      };\n\t     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n\t     *\n\t     */\n\t    var chain = _curry2(_checkForMethod('chain', function chain(f, list) {\n\t        return unnest(_map(f, list));\n\t    }));\n\t\n\t    /**\n\t     * The character at the nth position in a String:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig Number -> String -> String\n\t     * @param {Number} index An integer between 0 and the length of the string.\n\t     * @param {String} str The string to extract a char from\n\t     * @return {String} The character at `index` of `str`.\n\t     * @see R.invoker\n\t     * @example\n\t     *\n\t     *      R.charAt(8, 'abcdefghijklm'); //=> 'i'\n\t     */\n\t    var charAt = invoker(1, 'charAt');\n\t\n\t    /**\n\t     * The ascii code of the character at the nth position in a String:\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category String\n\t     * @sig Number -> String -> Number\n\t     * @param {Number} index An integer between 0 and the length of the string.\n\t     * @param {String} str The string to extract a charCode from\n\t     * @return {Number} The code of the character at `index` of `str`.\n\t     * @see R.invoker\n\t     * @example\n\t     *\n\t     *      R.charCodeAt(8, 'abcdefghijklm'); //=> 105\n\t     *      // (... 'a' ~ 97, 'b' ~ 98, ... 'i' ~ 105)\n\t     */\n\t    var charCodeAt = invoker(1, 'charCodeAt');\n\t\n\t    /**\n\t     * Turns a list of Functors into a Functor of a list, applying\n\t     * a mapping function to the elements of the list along the way.\n\t     *\n\t     * Note: `commuteMap` may be more useful to convert a list of non-Array Functors (e.g.\n\t     * Maybe, Either, etc.) to Functor of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @see R.commute\n\t     * @sig (a -> (b -> c)) -> (x -> [x]) -> [[*]...]\n\t     * @param {Function} fn The transformation function\n\t     * @param {Function} of A function that returns the data type to return\n\t     * @param {Array} list An Array (or other Functor) of Arrays (or other Functors)\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *     var plus10map = R.map(function(x) { return x + 10; });\n\t     *     var as = [[1], [3, 4]];\n\t     *     R.commuteMap(R.map(function(x) { return x + 10; }), R.of, as); //=> [[11, 13], [11, 14]]\n\t     *\n\t     *     var bs = [[1, 2], [3]];\n\t     *     R.commuteMap(plus10map, R.of, bs); //=> [[11, 13], [12, 13]]\n\t     *\n\t     *     var cs = [[1, 2], [3, 4]];\n\t     *     R.commuteMap(plus10map, R.of, cs); //=> [[11, 13], [12, 13], [11, 14], [12, 14]]\n\t     *\n\t     */\n\t    var commuteMap = _curry3(function commuteMap(fn, of, list) {\n\t        function consF(acc, ftor) {\n\t            return _ap(_map(append, fn(ftor)), acc);\n\t        }\n\t        return _foldl(consF, of([]), list);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list consisting of the elements of the first list followed by the elements\n\t     * of the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [a] -> [a]\n\t     * @param {Array} list1 The first list to merge.\n\t     * @param {Array} list2 The second set to merge.\n\t     * @return {Array} A new array consisting of the contents of `list1` followed by the\n\t     *         contents of `list2`. If, instead of an Array for `list1`, you pass an\n\t     *         object with a `concat` method on it, `concat` will call `list1.concat`\n\t     *         and pass it the value of `list2`.\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *         be curried right by explicitly passing `R.__` for its first argument.\n\t     *\n\t     * @example\n\t     *\n\t     *      R.concat([], []); //=> []\n\t     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n\t     *      R.concat('ABC', 'DEF'); // 'ABCDEF'\n\t     *\n\t     *      // operator-style:\n\t     *      R.concat(R.__)([4, 5, 6], [1, 2, 3]); //=> [1, 2, 3, 4, 5, 6]\n\t     *\n\t     */\n\t    var concat = op(function (set1, set2) {\n\t        if (_isArray(set2)) {\n\t            return _concat(set1, set2);\n\t        } else if (_hasMethod('concat', set1)) {\n\t            return set1.concat(set2);\n\t        } else {\n\t            throw new TypeError('can\\'t concat ' + typeof set1);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the specified item is somewhere in the list, `false` otherwise.\n\t     * Equivalent to `indexOf(a)(list) > -1`. Uses strict (`===`) equality checking.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> [a] -> Boolean\n\t     * @param {Object} a The item to compare against.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the item is in the list, `false` otherwise.\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *       be curried right by explicitly passing `R.__` for its first argument.\n\t     *\n\t     * @example\n\t     *\n\t     *      R.contains(3)([1, 2, 3]); //=> true\n\t     *      R.contains(4)([1, 2, 3]); //=> false\n\t     *      R.contains({})([{}, {}]); //=> false\n\t     *      var obj = {};\n\t     *      R.contains(obj)([{}, obj, {}]); //=> true\n\t     *\n\t     *      // operator-style\n\t     *      R.contains(R.__)([1, 2, 3], 3) //=> true\n\t     *\n\t     */\n\t    var contains = op(_contains);\n\t\n\t    /**\n\t     * Counts the elements of a list according to how many match each value\n\t     * of a key generated by the supplied function. Returns an object\n\t     * mapping the keys produced by `fn` to the number of occurrences in\n\t     * the list. Note that all keys are coerced to strings because of how\n\t     * JavaScript objects work.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig (a -> String) -> [a] -> {*}\n\t     * @param {Function} fn The function used to map values to keys.\n\t     * @param {Array} list The list to count elements from.\n\t     * @return {Object} An object mapping keys to number of occurrences in the list.\n\t     * @example\n\t     *\n\t     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];\n\t     *      var letters = R.split('', 'abcABCaaaBBc');\n\t     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}\n\t     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}\n\t     */\n\t    var countBy = _curry2(function countBy(fn, list) {\n\t        var counts = {};\n\t        var len = list.length;\n\t        var idx = -1;\n\t        while (++idx < len) {\n\t            var key = fn(list[idx]);\n\t            counts[key] = (has(key, counts) ? counts[key] : 0) + 1;\n\t        }\n\t        return counts;\n\t    });\n\t\n\t    /**\n\t     * Creates a new version of `fn` that, when invoked, will return either:\n\t     * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of\n\t     * `fn`'s expected arguments have not yet been provided\n\t     * - `fn`'s result if all of its expected arguments have been provided\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (* -> a) -> (* -> a)\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} A new, curried function.\n\t     * @see R.curryN\n\t     * @example\n\t     *\n\t     *      var addFourNumbers = function(a, b, c, d) {\n\t     *        return a + b + c + d;\n\t     *      };\n\t     *\n\t     *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n\t     *      var f = curriedAddFourNumbers(1, 2);\n\t     *      var g = f(3);\n\t     *      g(4);//=> 10\n\t     */\n\t    var curry = function curry(fn) {\n\t        return curryN(fn.length, fn);\n\t    };\n\t\n\t    /**\n\t     * Divides two numbers. Equivalent to `a / b`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a / b`.\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `undefined` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.divide(71, 100); //=> 0.71\n\t     *\n\t     *      var half = R.divide(R.__, 2);\n\t     *      half(42); //=> 21\n\t     *\n\t     *      var reciprocal = R.divide(1);\n\t     *      reciprocal(4);   //=> 0.25\n\t     */\n\t    var divide = op(function divide(a, b) {\n\t        return a / b;\n\t    });\n\t\n\t    /**\n\t     * Performs a deep test on whether two items are equal.\n\t     * Equality implies the two items are semmatically equivalent.\n\t     * Cyclic structures are handled as expected\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig a -> b -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      var o = {};\n\t     *      R.eqDeep(o, o); //=> true\n\t     *      R.eqDeep(o, {}); //=> true\n\t     *      R.eqDeep(1, 1); //=> true\n\t     *      R.eqDeep(1, '1'); //=> false\n\t     *\n\t     *      var a = {}; a.v = a;\n\t     *      var b = {}; b.v = b;\n\t     *      R.eqDeep(a, b); //=> true\n\t     */\n\t    var eqDeep = _curry2(function eqDeep(a, b) {\n\t        return _eqDeep(a, b, [], []);\n\t    });\n\t\n\t    /**\n\t     * Creates a new object by evolving a shallow copy of `object`, according to the\n\t     * `transformation` functions.  All non-primitive properties are copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: (v -> v)} -> {k: v} -> {k: v}\n\t     * @param {Object} transformations The object specifying transformation functions to apply\n\t     *        to the object.\n\t     * @param {Object} object The object to be transformed.\n\t     * @return {Object} The transformed object.\n\t     * @example\n\t     *\n\t     *      R.evolve({ elapsed: R.add(1), remaining: R.add(-1) }, { name: 'Tomato', elapsed: 100, remaining: 1400 }); //=> { name: 'Tomato', elapsed: 101, remaining: 1399 }\n\t     */\n\t    var evolve = _curry2(function evolve(transformations, object) {\n\t        return _extend(_extend({}, object), mapObjIndexed(function (fn, key) {\n\t            return fn(object[key]);\n\t        }, transformations));\n\t    });\n\t\n\t    /**\n\t     * Returns a list of function names of object's own functions\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {*} -> [String]\n\t     * @param {Object} obj The objects with functions in it\n\t     * @return {Array} A list of the object's own properties that map to functions.\n\t     * @example\n\t     *\n\t     *      R.functions(R); // returns list of ramda's own function names\n\t     *\n\t     *      var F = function() { this.x = function(){}; this.y = 1; }\n\t     *      F.prototype.z = function() {};\n\t     *      F.prototype.a = 100;\n\t     *      R.functions(new F()); //=> [\"x\"]\n\t     */\n\t    var functions = _functionsWith(keys);\n\t\n\t    /**\n\t     * Returns true if the first parameter is greater than the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean} a > b\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `undefined` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.gt(2, 6); //=> false\n\t     *      R.gt(2, 0); //=> true\n\t     *      R.gt(2, 2); //=> false\n\t     *      R.gt(R.__, 2)(10); //=> true\n\t     *      R.gt(2)(10); //=> false\n\t     */\n\t    var gt = op(_gt);\n\t\n\t    /**\n\t     * Returns true if the first parameter is greater than or equal to the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean} a >= b\n\t     * @note Operator: this is right-curried by default, but can be called via sections\n\t     * @example\n\t     *\n\t     *      R.gte(2, 6); //=> false\n\t     *      R.gte(2, 0); //=> true\n\t     *      R.gte(2, 2); //=> true\n\t     *      R.gte(R.__, 6)(2); //=> false\n\t     *      R.gte(2)(0); //=> true\n\t     *      R.gte(R.__)(1, 2); //=> true\n\t     */\n\t    var gte = op(function gte(a, b) {\n\t        return a >= b;\n\t    });\n\t\n\t    /**\n\t     * Returns the first element in a list.\n\t     * In some libraries this function is named `first`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> a\n\t     * @param {Array} [list=[]] The array to consider.\n\t     * @return {*} The first element of the list, or `undefined` if the list is empty.\n\t     * @example\n\t     *\n\t     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'\n\t     */\n\t    var head = nth(0);\n\t\n\t    /**\n\t     * Returns all but the last element of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} [list=[]] The array to consider.\n\t     * @return {Array} A new array containing all but the last element of the input list, or an\n\t     *         empty list if the input list is empty.\n\t     * @example\n\t     *\n\t     *      R.init(['fi', 'fo', 'fum']); //=> ['fi', 'fo']\n\t     */\n\t    var init = slice(0, -1);\n\t\n\t    /* global R */\n\t    /**\n\t     * Expose the functions from ramda as properties of another object.\n\t     * If the provided object is the global object then the ramda\n\t     * functions become global functions.\n\t     * Warning: This function *will* mutate the object provided.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig -> {*} -> {*}\n\t     * @param {Object} obj The object to attach ramda functions\n\t     * @return {Object} a reference to the mutated object.\n\t     * @example\n\t     *\n\t     *      var x = {}\n\t     *      R.installTo(x); // x now contains ramda functions\n\t     *      R.installTo(this); // add ramda functions to `this` object\n\t     */\n\t    var installTo = function (obj) {\n\t        return _extend(obj, R);\n\t    };\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig [a] -> [a] -> [a]\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @see R.intersectionWith\n\t     * @return {Array} The list of elements found in both `list1` and `list2`.\n\t     * @example\n\t     *\n\t     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]\n\t     */\n\t    var intersection = _curry2(function intersection(list1, list2) {\n\t        return uniq(_filter(flip(_contains)(list1), list2));\n\t    });\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of those\n\t     * elements common to both lists.  Duplication is determined according\n\t     * to the value returned by applying the supplied predicate to two list\n\t     * elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n\t     * @param {Function} pred A predicate function that determines whether\n\t     *        the two supplied elements are equal.\n\t     * @param {Array} list1 One list of items to compare\n\t     * @param {Array} list2 A second list of items to compare\n\t     * @see R.intersection\n\t     * @return {Array} A new list containing those elements common to both lists.\n\t     * @example\n\t     *\n\t     *      var buffaloSpringfield = [\n\t     *        {id: 824, name: 'Richie Furay'},\n\t     *        {id: 956, name: 'Dewey Martin'},\n\t     *        {id: 313, name: 'Bruce Palmer'},\n\t     *        {id: 456, name: 'Stephen Stills'},\n\t     *        {id: 177, name: 'Neil Young'}\n\t     *      ];\n\t     *      var csny = [\n\t     *        {id: 204, name: 'David Crosby'},\n\t     *        {id: 456, name: 'Stephen Stills'},\n\t     *        {id: 539, name: 'Graham Nash'},\n\t     *        {id: 177, name: 'Neil Young'}\n\t     *      ];\n\t     *\n\t     *      var sameId = function(o1, o2) {return o1.id === o2.id;};\n\t     *\n\t     *      R.intersectionWith(sameId, buffaloSpringfield, csny);\n\t     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]\n\t     */\n\t    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {\n\t        var results = [], idx = -1;\n\t        while (++idx < list1.length) {\n\t            if (_containsWith(pred, list1[idx], list2)) {\n\t                results[results.length] = list1[idx];\n\t            }\n\t        }\n\t        return uniqWith(pred, results);\n\t    });\n\t\n\t    /**\n\t     * Same as R.invertObj, however this accounts for objects\n\t     * with duplicate values by putting the values into an\n\t     * array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {s: x} -> {x: [ s, ... ]}\n\t     * @param {Object} obj The object or array to invert\n\t     * @return {Object} out A new object with keys\n\t     * in an array.\n\t     * @example\n\t     *\n\t     *      var raceResultsByFirstName = {\n\t     *        first: 'alice',\n\t     *        second: 'jake',\n\t     *        third: 'alice',\n\t     *      };\n\t     *      R.invert(raceResultsByFirstName);\n\t     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }\n\t     *\n\t     */\n\t    var invert = function invert(obj) {\n\t        var props = keys(obj), len = props.length, idx = -1, out = {};\n\t        while (++idx < len) {\n\t            var key = props[idx], val = obj[key];\n\t            out[val] = out[val] || [];\n\t            out[val].push(key);\n\t        }\n\t        return out;\n\t    };\n\t\n\t    /**\n\t     * Returns a new object with the keys of the given object\n\t     * as values, and the values of the given object as keys.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {s: x} -> {x: s}\n\t     * @param {Object} obj The object or array to invert\n\t     * @return {Object} out A new object\n\t     * @example\n\t     *\n\t     *      var raceResults = {\n\t     *        first: 'alice',\n\t     *        second: 'jake'\n\t     *      };\n\t     *      R.invertObj(raceResults);\n\t     *      //=> { 'alice': 'first', 'jake':'second' }\n\t     *\n\t     *      // Alternatively:\n\t     *      var raceResults = ['alice', 'jake'];\n\t     *      R.invertObj(raceResults);\n\t     *      //=> { 'alice': '0', 'jake':'1' }\n\t     */\n\t    var invertObj = function invertObj(obj) {\n\t        var props = keys(obj), len = props.length, idx = -1, out = {};\n\t        while (++idx < len) {\n\t            var key = props[idx];\n\t            out[obj[key]] = key;\n\t        }\n\t        return out;\n\t    };\n\t\n\t    /**\n\t     * Returns the last element from a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig [a] -> a\n\t     * @param {Array} [list=[]] The array to consider.\n\t     * @return {*} The last element of the list, or `undefined` if the list is empty.\n\t     * @example\n\t     *\n\t     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n\t     */\n\t    var last = nth(-1);\n\t\n\t    /**\n\t     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that many\n\t     * lists (or other Functors).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @see R.lift\n\t     * @category Function\n\t     * @sig Number -> (*... -> *) -> ([*]... -> [*])\n\t     * @param {Function} fn The function to lift into higher context\n\t     * @return {Function} The function `fn` applicable to mappable objects.\n\t     * @example\n\t     *\n\t     *     var madd3 = R.liftN(3, R.curryN(3, function() {\n\t     *         return R.foldl(R.add, 0, arguments);\n\t     *     }));\n\t     *     madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n\t     */\n\t    var liftN = _curry2(function liftN(arity, fn) {\n\t        var lifted = curryN(arity, fn);\n\t        if (arguments.length === 0) {\n\t            throw _noArgsException();\n\t        }\n\t        return curryN(arity, function () {\n\t            return _foldl(_ap, _map(lifted, arguments[0]), _slice(arguments, 1));\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns true if the first parameter is less than the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean} a < b\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `undefined` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.lt(2, 6); //=> true\n\t     *      R.lt(2, 0); //=> false\n\t     *      R.lt(2, 2); //=> false\n\t     *      R.lt(5)(10); //=> true\n\t     *      R.lt(R.__, 5)(10); //=> false // right-sectioned currying\n\t     */\n\t    var lt = op(_lt);\n\t\n\t    /**\n\t     * Returns true if the first parameter is less than or equal to the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean} a <= b\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `R.__` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.lte(2, 6); //=> true\n\t     *      R.lte(2, 0); //=> false\n\t     *      R.lte(2, 2); //=> true\n\t     *      R.lte(R.__, 2)(1); //=> true\n\t     *      R.lte(2)(10); //=> true\n\t     *      R.lte(R.__)(5, 4) // => true\n\t     */\n\t    var lte = op(function lte(a, b) {\n\t        return a <= b;\n\t    });\n\t\n\t    /**\n\t     * mathMod behaves like the modulo operator should mathematically, unlike the `%`\n\t     * operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n\t     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n\t     * when the modulus is zero or negative.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} m The dividend.\n\t     * @param {Number} p the modulus.\n\t     * @return {Number} The result of `b mod a`.\n\t     * @see R.moduloBy\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `R.__` for its first argument.\n\t     * @example\n\t     *\n\t     *      R.mathMod(-17, 5);  //=> 3\n\t     *      R.mathMod(17, 5);   //=> 2\n\t     *      R.mathMod(17, -5);  //=> NaN\n\t     *      R.mathMod(17, 0);   //=> NaN\n\t     *      R.mathMod(17.2, 5); //=> NaN\n\t     *      R.mathMod(17, 5.3); //=> NaN\n\t     *\n\t     *      var clock = R.mathMod(R.__, 12);\n\t     *      clock(15); //=> 3\n\t     *      clock(24); //=> 0\n\t     *\n\t     *      var seventeenMod = R.mathMod(17);\n\t     *      seventeenMod(3);  //=> 2\n\t     *      seventeenMod(4);  //=> 1\n\t     *      seventeenMod(10); //=> 7\n\t     */\n\t    var mathMod = op(function mathMod(m, p) {\n\t        if (!_isInteger(m)) {\n\t            return NaN;\n\t        }\n\t        if (!_isInteger(p) || p < 1) {\n\t            return NaN;\n\t        }\n\t        return (m % p + p) % p;\n\t    });\n\t\n\t    /**\n\t     * Create a new object with the own properties of a\n\t     * merged with the own properties of object b.\n\t     * This function will *not* mutate passed-in objects.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig {k: v} -> {k: v} -> {k: v}\n\t     * @param {Object} a source object\n\t     * @param {Object} b object with higher precedence in output\n\t     * @return {Object} The destination object.\n\t     * @example\n\t     *\n\t     *      R.mixin({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n\t     *      //=> { 'name': 'fred', 'age': 40 }\n\t     */\n\t    var mixin = _curry2(function mixin(a, b) {\n\t        return _extend(_extend({}, a), b);\n\t    });\n\t\n\t    /**\n\t     * Divides the second parameter by the first and returns the remainder.\n\t     * Note that this functions preserves the JavaScript-style behavior for\n\t     * modulo. For mathematical modulo see `mathMod`\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The value to the divide.\n\t     * @param {Number} b The pseudo-modulus\n\t     * @return {Number} The result of `b % a`.\n\t     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n\t     *                 be curried right by explicitly passing `R.__` for its first argument.\n\t     * @see R.mathMod\n\t     * @example\n\t     *\n\t     *      R.modulo(17, 3); //=> 2\n\t     *      // JS behavior:\n\t     *      R.modulo(-17, 3); //=> -2\n\t     *      R.modulo(17, -3); //=> 2\n\t     *\n\t     *      var isOdd = R.modulo(R.__, 2);\n\t     *      isOdd(42); //=> 0\n\t     *      isOdd(21); //=> 1\n\t     */\n\t    var modulo = op(function modulo(a, b) {\n\t        return a % b;\n\t    });\n\t\n\t    /**\n\t     * Retrieve a nested path on an object separated by periods\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @sig String -> {*} -> *\n\t     * @param {String} path The dot path to use.\n\t     * @return {*} The data at `path`.\n\t     * @example\n\t     *\n\t     *      R.path('a.b', {a: {b: 2}}); //=> 2\n\t     */\n\t    var path = pathOn('.');\n\t\n\t    /**\n\t     * Returns a fixed list of size `n` containing a specified identical value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @sig a -> n -> [a]\n\t     * @param {*} value The value to repeat.\n\t     * @param {Number} n The desired size of the output list.\n\t     * @return {Array} A new array containing `n` `value`s.\n\t     * @example\n\t     *\n\t     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n\t     *\n\t     *      var obj = {};\n\t     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]\n\t     *      repeatedObjs[0] === repeatedObjs[1]; //=> true\n\t     */\n\t    var repeat = _curry2(function repeat(value, n) {\n\t        return times(always(value), n);\n\t    });\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of the\n\t     * elements of each list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig [a] -> [a] -> [a]\n\t     * @param {Array} as The first list.\n\t     * @param {Array} bs The second list.\n\t     * @return {Array} The first and second lists concatenated, with\n\t     *         duplicates removed.\n\t     * @example\n\t     *\n\t     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n\t     */\n\t    var union = _curry2(compose(uniq, _concat));\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is\n\t     * determined according to the value returned by applying the supplied predicate to two list elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Relation\n\t     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The first and second lists concatenated, with\n\t     *         duplicates removed.\n\t     * @see R.union\n\t     * @example\n\t     *\n\t     *      function cmp(x, y) { return x.a === y.a; }\n\t     *      var l1 = [{a: 1}, {a: 2}];\n\t     *      var l2 = [{a: 1}, {a: 4}];\n\t     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n\t     */\n\t    var unionWith = _curry3(function unionWith(pred, list1, list2) {\n\t        return uniqWith(pred, _concat(list1, list2));\n\t    });\n\t\n\t    /**\n\t     * Accepts a function `fn` and any number of transformer functions and returns a new\n\t     * function. When the new function is invoked, it calls the function `fn` with parameters\n\t     * consisting of the result of calling each supplied handler on successive arguments to the\n\t     * new function.\n\t     *\n\t     * If more arguments are passed to the returned function than transformer functions, those\n\t     * arguments are passed directly to `fn` as additional parameters. If you expect additional\n\t     * arguments that don't need to be transformed, although you can ignore them, it's best to\n\t     * pass an identity function so that the new function reports the correct arity.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig ((* -> *), (* -> *)...) -> (* -> *)\n\t     * @param {Function} fn The function to wrap.\n\t     * @param {...Function} transformers A variable number of transformer functions\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      // Example 1:\n\t     *\n\t     *      // Number -> [Person] -> [Person]\n\t     *      var byAge = R.useWith(R.filter, R.propEq('age'), R.identity);\n\t     *\n\t     *      var kids = [\n\t     *          {name: 'Abbie', age: 6},\n\t     *          {name: 'Brian', age: 5},\n\t     *          {name: 'Chris', age: 6},\n\t     *          {name: 'David', age: 4},\n\t     *          {name: 'Ellie', age: 5}\n\t     *      ];\n\t     *\n\t     *      byAge(5, kids); //=> [{name: 'Brian', age: 5}, {name: 'Ellie', age: 5}]\n\t     *\n\t     *\n\t     *      // Example 2:\n\t     *\n\t     *      var double = function(y) { return y * 2; };\n\t     *      var square = function(x) { return x * x; };\n\t     *      var add = function(a, b) { return a + b; };\n\t     *      // Adds any number of arguments together\n\t     *      var addAll = function() {\n\t     *        return R.foldl(add, 0, arguments);\n\t     *      };\n\t     *\n\t     *      // Basic example\n\t     *      var addDoubleAndSquare = R.useWith(addAll, double, square);\n\t     *\n\t     *      //≅ addAll(double(10), square(5));\n\t     *      addDoubleAndSquare(10, 5); //=> 45\n\t     *\n\t     *      // Example of passing more arguments than transformers\n\t     *      //≅ addAll(double(10), square(5), 100);\n\t     *      addDoubleAndSquare(10, 5, 100); //=> 145\n\t     *\n\t     *      // If there are extra _expected_ arguments that don't need to be transformed, although\n\t     *      // you can ignore them, it might be best to pass in the identity function so that the new\n\t     *      // function correctly reports arity.\n\t     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);\n\t     *      // addDoubleAndSquareWithExtraParams.length //=> 3\n\t     *      //≅ addAll(double(10), square(5), R.identity(100));\n\t     *      addDoubleAndSquare(10, 5, 100); //=> 145\n\t     */\n\t    /*, transformers */\n\t    var useWith = function useWith(fn) {\n\t        var transformers = _slice(arguments, 1);\n\t        var tlen = transformers.length;\n\t        return curry(arity(tlen, function () {\n\t            var args = [], idx = -1;\n\t            while (++idx < tlen) {\n\t                args[args.length] = transformers[idx](arguments[idx]);\n\t            }\n\t            return fn.apply(this, args.concat(_slice(arguments, tlen)));\n\t        }));\n\t    };\n\t\n\t    /**\n\t     * Turns a list of Functors into a Functor of a list.\n\t     *\n\t     * Note: `commute` may be more useful to convert a list of non-Array Functors (e.g.\n\t     * Maybe, Either, etc.) to Functor of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category List\n\t     * @see R.commuteMap\n\t     * @sig (x -> [x]) -> [[*]...]\n\t     * @param {Function} of A function that returns the data type to return\n\t     * @param {Array} list An Array (or other Functor) of Arrays (or other Functors)\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *     var as = [[1], [3, 4]];\n\t     *     R.commute(R.of, as); //=> [[1, 3], [1, 4]]\n\t     *\n\t     *     var bs = [[1, 2], [3]];\n\t     *     R.commute(R.of, bs); //=> [[1, 3], [2, 3]]\n\t     *\n\t     *     var cs = [[1, 2], [3, 4]];\n\t     *     R.commute(R.of, cs); //=> [[1, 3], [2, 3], [1, 4], [2, 4]]\n\t     */\n\t    var commute = commuteMap(map(identity));\n\t\n\t    /**\n\t     * Wraps a constructor function inside a curried function that can be called with the same\n\t     * arguments and returns the same type. The arity of the function returned is specified\n\t     * to allow using variadic constructor functions.\n\t     *\n\t     * NOTE: Does not work with some built-in objects such as Date.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig Number -> (* -> {*}) -> (* -> {*})\n\t     * @param {Number} n The arity of the constructor function.\n\t     * @param {Function} Fn The constructor function to wrap.\n\t     * @return {Function} A wrapped, curried constructor function.\n\t     * @example\n\t     *\n\t     *      // Variadic constructor function\n\t     *      var Widget = function() {\n\t     *        this.children = Array.prototype.slice.call(arguments);\n\t     *        // ...\n\t     *      };\n\t     *      Widget.prototype = {\n\t     *        // ...\n\t     *      };\n\t     *      var allConfigs = {\n\t     *        // ...\n\t     *      };\n\t     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets\n\t     */\n\t    var constructN = _curry2(function constructN(n, Fn) {\n\t        var f = function () {\n\t            var Temp = function () {\n\t                }, inst, ret;\n\t            Temp.prototype = Fn.prototype;\n\t            inst = new Temp();\n\t            ret = Fn.apply(inst, arguments);\n\t            return Object(ret) === ret ? ret : inst;\n\t        };\n\t        return n > 1 ? curry(nAry(n, f)) : f;\n\t    });\n\t\n\t    /**\n\t     * \"lifts\" a function of arity > 1 so that it may \"map over\" an Array or\n\t     * other Functor.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @see R.liftN\n\t     * @category Function\n\t     * @sig (*... -> *) -> ([*]... -> [*])\n\t     * @param {Function} fn The function to lift into higher context\n\t     * @return {Function} The function `fn` applicable to mappable objects.\n\t     * @example\n\t     *\n\t     *     var madd3 = R.lift(R.curryN(3, function(a, b, c) {\n\t     *         return a + b + c;\n\t     *     }));\n\t     *     madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n\t     *\n\t     *     var madd5 = R.lift(R.curryN(5, function(a, b, c, d, e) {\n\t     *         return a + b + c + d + e;\n\t     *     }));\n\t     *     madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n\t     */\n\t    var lift = function lift(fn) {\n\t        if (arguments.length === 0) {\n\t            throw _noArgsException();\n\t        }\n\t        return liftN(fn.length, fn);\n\t    };\n\t\n\t    /**\n\t     * Reasonable analog to SQL `select` statement.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Object\n\t     * @category Relation\n\t     * @sig [k] -> [{k: v}] -> [{k: v}]\n\t     * @param {Array} props The property names to project\n\t     * @param {Array} objs The objects to query\n\t     * @return {Array} An array of objects with just the `props` properties.\n\t     * @example\n\t     *\n\t     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};\n\t     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};\n\t     *      var kids = [abby, fred];\n\t     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n\t     */\n\t    // passing `identity` gives correct arity\n\t    var project = useWith(_map, pickAll, identity);\n\t\n\t    /**\n\t     * Wraps a constructor function inside a curried function that can be called with the same\n\t     * arguments and returns the same type.\n\t     *\n\t     * NOTE: Does not work with some built-in objects such as Date.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @category Function\n\t     * @sig (* -> {*}) -> (* -> {*})\n\t     * @param {Function} Fn The constructor function to wrap.\n\t     * @return {Function} A wrapped, curried constructor function.\n\t     * @example\n\t     *\n\t     *      // Constructor function\n\t     *      var Widget = function(config) {\n\t     *        // ...\n\t     *      };\n\t     *      Widget.prototype = {\n\t     *        // ...\n\t     *      };\n\t     *      var allConfigs = {\n\t     *        // ...\n\t     *      };\n\t     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets\n\t     */\n\t    var construct = function construct(Fn) {\n\t        return constructN(Fn.length, Fn);\n\t    };\n\t\n\t    var R = {\n\t        F: F,\n\t        I: I,\n\t        T: T,\n\t        __: __,\n\t        add: add,\n\t        all: all,\n\t        allPass: allPass,\n\t        always: always,\n\t        and: and,\n\t        any: any,\n\t        anyPass: anyPass,\n\t        ap: ap,\n\t        append: append,\n\t        appendTo: appendTo,\n\t        apply: apply,\n\t        arity: arity,\n\t        assoc: assoc,\n\t        assocPath: assocPath,\n\t        binary: binary,\n\t        bind: bind,\n\t        call: call,\n\t        chain: chain,\n\t        charAt: charAt,\n\t        charCodeAt: charCodeAt,\n\t        clone: clone,\n\t        commute: commute,\n\t        commuteMap: commuteMap,\n\t        comparator: comparator,\n\t        compose: compose,\n\t        concat: concat,\n\t        cond: cond,\n\t        construct: construct,\n\t        constructN: constructN,\n\t        contains: contains,\n\t        containsWith: containsWith,\n\t        converge: converge,\n\t        countBy: countBy,\n\t        createMapEntry: createMapEntry,\n\t        curry: curry,\n\t        curryN: curryN,\n\t        dec: dec,\n\t        difference: difference,\n\t        differenceWith: differenceWith,\n\t        divide: divide,\n\t        drop: drop,\n\t        dropWhile: dropWhile,\n\t        empty: empty,\n\t        eq: eq,\n\t        eqDeep: eqDeep,\n\t        eqProps: eqProps,\n\t        evolve: evolve,\n\t        filter: filter,\n\t        filterIndexed: filterIndexed,\n\t        find: find,\n\t        findIndex: findIndex,\n\t        findLast: findLast,\n\t        findLastIndex: findLastIndex,\n\t        flatten: flatten,\n\t        flip: flip,\n\t        foldl: foldl,\n\t        foldlIndexed: foldlIndexed,\n\t        foldr: foldr,\n\t        foldrIndexed: foldrIndexed,\n\t        forEach: forEach,\n\t        forEachIndexed: forEachIndexed,\n\t        fromPairs: fromPairs,\n\t        func: func,\n\t        functions: functions,\n\t        functionsIn: functionsIn,\n\t        get: get,\n\t        groupBy: groupBy,\n\t        gt: gt,\n\t        gte: gte,\n\t        has: has,\n\t        hasIn: hasIn,\n\t        head: head,\n\t        identity: identity,\n\t        ifElse: ifElse,\n\t        inc: inc,\n\t        indexOf: indexOf,\n\t        init: init,\n\t        insert: insert,\n\t        insertAll: insertAll,\n\t        installTo: installTo,\n\t        intersection: intersection,\n\t        intersectionWith: intersectionWith,\n\t        invert: invert,\n\t        invertObj: invertObj,\n\t        invoker: invoker,\n\t        is: is,\n\t        isArrayLike: isArrayLike,\n\t        isEmpty: isEmpty,\n\t        isNil: isNil,\n\t        isSet: isSet,\n\t        join: join,\n\t        keys: keys,\n\t        keysIn: keysIn,\n\t        lPartial: lPartial,\n\t        last: last,\n\t        lastIndexOf: lastIndexOf,\n\t        length: length,\n\t        lens: lens,\n\t        lift: lift,\n\t        liftN: liftN,\n\t        lt: lt,\n\t        lte: lte,\n\t        map: map,\n\t        mapAccumL: mapAccumL,\n\t        mapAccumR: mapAccumR,\n\t        mapIndexed: mapIndexed,\n\t        mapObj: mapObj,\n\t        mapObjIndexed: mapObjIndexed,\n\t        match: match,\n\t        mathMod: mathMod,\n\t        max: max,\n\t        maxBy: maxBy,\n\t        memoize: memoize,\n\t        min: min,\n\t        minBy: minBy,\n\t        mixin: mixin,\n\t        modulo: modulo,\n\t        multiply: multiply,\n\t        nAry: nAry,\n\t        negate: negate,\n\t        not: not,\n\t        nth: nth,\n\t        nthArg: nthArg,\n\t        of: of,\n\t        omit: omit,\n\t        once: once,\n\t        op: op,\n\t        or: or,\n\t        pCompose: pCompose,\n\t        pPipe: pPipe,\n\t        partition: partition,\n\t        path: path,\n\t        pathEq: pathEq,\n\t        pathOn: pathOn,\n\t        pick: pick,\n\t        pickAll: pickAll,\n\t        pickBy: pickBy,\n\t        pipe: pipe,\n\t        pluck: pluck,\n\t        prepend: prepend,\n\t        prependTo: prependTo,\n\t        product: product,\n\t        project: project,\n\t        prop: prop,\n\t        propEq: propEq,\n\t        propOf: propOf,\n\t        propOr: propOr,\n\t        props: props,\n\t        rPartial: rPartial,\n\t        range: range,\n\t        reject: reject,\n\t        rejectIndexed: rejectIndexed,\n\t        remove: remove,\n\t        repeat: repeat,\n\t        replace: replace,\n\t        reverse: reverse,\n\t        scanl: scanl,\n\t        slice: slice,\n\t        sort: sort,\n\t        sortBy: sortBy,\n\t        split: split,\n\t        strIndexOf: strIndexOf,\n\t        strLastIndexOf: strLastIndexOf,\n\t        substring: substring,\n\t        substringFrom: substringFrom,\n\t        substringTo: substringTo,\n\t        subtract: subtract,\n\t        sum: sum,\n\t        tail: tail,\n\t        take: take,\n\t        takeWhile: takeWhile,\n\t        tap: tap,\n\t        times: times,\n\t        toLower: toLower,\n\t        toPairs: toPairs,\n\t        toPairsIn: toPairsIn,\n\t        toUpper: toUpper,\n\t        trim: trim,\n\t        type: type,\n\t        unapply: unapply,\n\t        unary: unary,\n\t        unfoldr: unfoldr,\n\t        union: union,\n\t        unionWith: unionWith,\n\t        uniq: uniq,\n\t        uniqWith: uniqWith,\n\t        unnest: unnest,\n\t        useWith: useWith,\n\t        values: values,\n\t        valuesIn: valuesIn,\n\t        where: where,\n\t        wrap: wrap,\n\t        xprod: xprod,\n\t        zip: zip,\n\t        zipObj: zipObj,\n\t        zipWith: zipWith\n\t    };\n\t\n\t    /* TEST_ENTRY_POINT */\n\t\n\t    if (true) {\n\t        module.exports = R;\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        define(function() { return R; });\n\t    } else {\n\t        this.R = R;\n\t    }\n\t\n\t}.call(this));\n\n\n/***/ },\n\n/***/ 11:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * slice() reference.\n\t */\n\t\n\tvar slice = Array.prototype.slice;\n\t\n\t/**\n\t * Expose `co`.\n\t */\n\t\n\tmodule.exports = co['default'] = co.co = co;\n\t\n\t/**\n\t * Wrap the given generator `fn` into a\n\t * function that returns a promise.\n\t * This is a separate function so that\n\t * every `co()` call doesn't create a new,\n\t * unnecessary closure.\n\t *\n\t * @param {GeneratorFunction} fn\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tco.wrap = function (fn) {\n\t  return function () {\n\t    return co.call(this, fn.apply(this, arguments));\n\t  };\n\t};\n\t\n\t/**\n\t * Execute the generator function or a generator\n\t * and return a promise.\n\t *\n\t * @param {Function} fn\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction co(gen) {\n\t  var ctx = this;\n\t  if (typeof gen === 'function') gen = gen.call(this);\n\t  // we wrap everything in a promise to avoid promise chaining,\n\t  // which leads to memory leak errors.\n\t  // see https://github.com/tj/co/issues/180\n\t  return new Promise(function(resolve, reject) {\n\t    onFulfilled();\n\t\n\t    /**\n\t     * @param {Mixed} res\n\t     * @return {Promise}\n\t     * @api private\n\t     */\n\t\n\t    function onFulfilled(res) {\n\t      var ret;\n\t      try {\n\t        ret = gen.next(res);\n\t      } catch (e) {\n\t        return reject(e);\n\t      }\n\t      next(ret);\n\t    }\n\t\n\t    /**\n\t     * @param {Error} err\n\t     * @return {Promise}\n\t     * @api private\n\t     */\n\t\n\t    function onRejected(err) {\n\t      var ret;\n\t      try {\n\t        ret = gen.throw(err);\n\t      } catch (e) {\n\t        return reject(e);\n\t      }\n\t      next(ret);\n\t    }\n\t\n\t    /**\n\t     * Get the next value in the generator,\n\t     * return a promise.\n\t     *\n\t     * @param {Object} ret\n\t     * @return {Promise}\n\t     * @api private\n\t     */\n\t\n\t    function next(ret) {\n\t      if (ret.done) return resolve(ret.value);\n\t      var value = toPromise.call(ctx, ret.value);\n\t      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n\t      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n\t        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Convert a `yield`ed value into a promise.\n\t *\n\t * @param {Mixed} obj\n\t * @return {Promise}\n\t * @api private\n\t */\n\t\n\tfunction toPromise(obj) {\n\t  if (!obj) return obj;\n\t  if (isPromise(obj)) return obj;\n\t  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n\t  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n\t  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n\t  if (isObject(obj)) return objectToPromise.call(this, obj);\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Convert a thunk to a promise.\n\t *\n\t * @param {Function}\n\t * @return {Promise}\n\t * @api private\n\t */\n\t\n\tfunction thunkToPromise(fn) {\n\t  var ctx = this;\n\t  return new Promise(function (resolve, reject) {\n\t    fn.call(ctx, function (err, res) {\n\t      if (err) return reject(err);\n\t      if (arguments.length > 2) res = slice.call(arguments, 1);\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Convert an array of \"yieldables\" to a promise.\n\t * Uses `Promise.all()` internally.\n\t *\n\t * @param {Array} obj\n\t * @return {Promise}\n\t * @api private\n\t */\n\t\n\tfunction arrayToPromise(obj) {\n\t  return Promise.all(obj.map(toPromise, this));\n\t}\n\t\n\t/**\n\t * Convert an object of \"yieldables\" to a promise.\n\t * Uses `Promise.all()` internally.\n\t *\n\t * @param {Object} obj\n\t * @return {Promise}\n\t * @api private\n\t */\n\t\n\tfunction objectToPromise(obj){\n\t  var results = new obj.constructor();\n\t  var keys = Object.keys(obj);\n\t  var promises = [];\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    var promise = toPromise.call(this, obj[key]);\n\t    if (promise && isPromise(promise)) defer(promise, key);\n\t    else results[key] = obj[key];\n\t  }\n\t  return Promise.all(promises).then(function () {\n\t    return results;\n\t  });\n\t\n\t  function defer(promise, key) {\n\t    // predefine the key in the result\n\t    results[key] = undefined;\n\t    promises.push(promise.then(function (res) {\n\t      results[key] = res;\n\t    }));\n\t  }\n\t}\n\t\n\t/**\n\t * Check if `obj` is a promise.\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isPromise(obj) {\n\t  return 'function' == typeof obj.then;\n\t}\n\t\n\t/**\n\t * Check if `obj` is a generator.\n\t *\n\t * @param {Mixed} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isGenerator(obj) {\n\t  return 'function' == typeof obj.next && 'function' == typeof obj.throw;\n\t}\n\t\n\t/**\n\t * Check if `obj` is a generator function.\n\t *\n\t * @param {Mixed} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\tfunction isGeneratorFunction(obj) {\n\t  var constructor = obj.constructor;\n\t  var proto = constructor.prototype;\n\t  var name = constructor.displayName || constructor.name;\n\t  var nameLooksRight = 'GeneratorFunction' == name;\n\t  var methodsLooksRight = 'function' == typeof proto.next &&\n\t                          'function' == typeof proto.throw;\n\t  return nameLooksRight || methodsLooksRight;\n\t}\n\t\n\t/**\n\t * Check for plain object.\n\t *\n\t * @param {Mixed} val\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isObject(val) {\n\t  return Object == val.constructor;\n\t}\n\n\n/***/ },\n\n/***/ 13:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\tprocess.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t    && window.setImmediate;\n\t    var canMutationObserver = typeof window !== 'undefined'\n\t    && window.MutationObserver;\n\t    var canPost = typeof window !== 'undefined'\n\t    && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    var queue = [];\n\t\n\t    if (canMutationObserver) {\n\t        var hiddenDiv = document.createElement(\"div\");\n\t        var observer = new MutationObserver(function () {\n\t            var queueList = queue.slice();\n\t            queue.length = 0;\n\t            queueList.forEach(function (fn) {\n\t                fn();\n\t            });\n\t        });\n\t\n\t        observer.observe(hiddenDiv, { attributes: true });\n\t\n\t        return function nextTick(fn) {\n\t            if (!queue.length) {\n\t                hiddenDiv.setAttribute('yes', 'no');\n\t            }\n\t            queue.push(fn);\n\t        };\n\t    }\n\t\n\t    if (canPost) {\n\t        window.addEventListener('message', function (ev) {\n\t            var source = ev.source;\n\t            if ((source === window || source === null) && ev.data === 'process-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('process-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.fixed = fixed;\n\texports.wrapPromise = wrapPromise;\n\texports.bind = bind;\n\tfunction fixed(total, progress) {\n\t  if (!progress) {\n\t    return function () {};\n\t  }var loaded = 0;\n\t  progress.report(0, total);\n\t  return function (extra) {\n\t    return progress.report(++loaded, total, extra);\n\t  };\n\t}\n\t\n\tfunction wrapPromise(progress, f) {\n\t  var current = 0;\n\t  var total = 0;\n\t  return function () {\n\t    progress.report(current, ++total);\n\t    return Promise.resolve(f.apply(this, arguments)).tap(function () {\n\t      return progress.report(++current, total);\n\t    });\n\t  };\n\t}\n\t\n\tfunction bind(from, to) {\n\t  return from.watch(function () {\n\t    return to.report(from.current, from.total, from.extra);\n\t  });\n\t}\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 18:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.readBlob = readBlob;\n\texports[\"default\"] = readBlob;\n\tfunction readBlob(blob) {\n\t  return {\n\t    as: function as(type) {\n\t      return new Promise(function (resolve, reject) {\n\t        var reader = new FileReader();\n\t        reader.onload = function () {\n\t          resolve(reader.result);\n\t        };\n\t        reader.onerror = function () {\n\t          reject(new Error(\"Unable to read from Blob\"));\n\t        };\n\t        switch (type) {\n\t          case \"arraybuffer\":\n\t            reader.readAsArrayBuffer(blob);\n\t            break;\n\t          case \"text\":\n\t            reader.readAsText(blob);\n\t            break;\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 19:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar window = __webpack_require__(38);\n\t\n\tvar Context = window.AudioContext || window.webkitAudioContext;\n\tif (Context) module.exports = new Context;\n\n\n/***/ },\n\n/***/ 20:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tif (global._babelPolyfill) {\n\t  throw new Error(\"only one instance of babel/polyfill is allowed\");\n\t}\n\tglobal._babelPolyfill = true;\n\t\n\t__webpack_require__(21);\n\t__webpack_require__(22);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 21:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Core.js 0.5.4\n\t * https://github.com/zloirock/core-js\n\t * License: http://rock.mit-license.org\n\t * © 2015 Denis Pushkarev\n\t */\n\t!function(global, framework, undefined){\n\t'use strict';\n\t\n\t/******************************************************************************\n\t * Module : common                                                            *\n\t ******************************************************************************/\n\t\n\t  // Shortcuts for [[Class]] & property names\r\n\tvar OBJECT          = 'Object'\r\n\t  , FUNCTION        = 'Function'\r\n\t  , ARRAY           = 'Array'\r\n\t  , STRING          = 'String'\r\n\t  , NUMBER          = 'Number'\r\n\t  , REGEXP          = 'RegExp'\r\n\t  , DATE            = 'Date'\r\n\t  , MAP             = 'Map'\r\n\t  , SET             = 'Set'\r\n\t  , WEAKMAP         = 'WeakMap'\r\n\t  , WEAKSET         = 'WeakSet'\r\n\t  , SYMBOL          = 'Symbol'\r\n\t  , PROMISE         = 'Promise'\r\n\t  , MATH            = 'Math'\r\n\t  , ARGUMENTS       = 'Arguments'\r\n\t  , PROTOTYPE       = 'prototype'\r\n\t  , CONSTRUCTOR     = 'constructor'\r\n\t  , TO_STRING       = 'toString'\r\n\t  , TO_STRING_TAG   = TO_STRING + 'Tag'\r\n\t  , TO_LOCALE       = 'toLocaleString'\r\n\t  , HAS_OWN         = 'hasOwnProperty'\r\n\t  , FOR_EACH        = 'forEach'\r\n\t  , ITERATOR        = 'iterator'\r\n\t  , FF_ITERATOR     = '@@' + ITERATOR\r\n\t  , PROCESS         = 'process'\r\n\t  , CREATE_ELEMENT  = 'createElement'\r\n\t  // Aliases global objects and prototypes\r\n\t  , Function        = global[FUNCTION]\r\n\t  , Object          = global[OBJECT]\r\n\t  , Array           = global[ARRAY]\r\n\t  , String          = global[STRING]\r\n\t  , Number          = global[NUMBER]\r\n\t  , RegExp          = global[REGEXP]\r\n\t  , Date            = global[DATE]\r\n\t  , Map             = global[MAP]\r\n\t  , Set             = global[SET]\r\n\t  , WeakMap         = global[WEAKMAP]\r\n\t  , WeakSet         = global[WEAKSET]\r\n\t  , Symbol          = global[SYMBOL]\r\n\t  , Math            = global[MATH]\r\n\t  , TypeError       = global.TypeError\r\n\t  , RangeError      = global.RangeError\r\n\t  , setTimeout      = global.setTimeout\r\n\t  , setImmediate    = global.setImmediate\r\n\t  , clearImmediate  = global.clearImmediate\r\n\t  , parseInt        = global.parseInt\r\n\t  , isFinite        = global.isFinite\r\n\t  , process         = global[PROCESS]\r\n\t  , nextTick        = process && process.nextTick\r\n\t  , document        = global.document\r\n\t  , html            = document && document.documentElement\r\n\t  , navigator       = global.navigator\r\n\t  , define          = global.define\r\n\t  , ArrayProto      = Array[PROTOTYPE]\r\n\t  , ObjectProto     = Object[PROTOTYPE]\r\n\t  , FunctionProto   = Function[PROTOTYPE]\r\n\t  , Infinity        = 1 / 0\r\n\t  , DOT             = '.'\r\n\t  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md\r\n\t  , CONSOLE_METHODS = 'assert,clear,count,debug,dir,dirxml,error,exception,' +\r\n\t      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +\r\n\t      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +\r\n\t      'timelineEnd,timeStamp,trace,warn';\r\n\t\r\n\t// http://jsperf.com/core-js-isobject\r\n\tfunction isObject(it){\r\n\t  return it !== null && (typeof it == 'object' || typeof it == 'function');\r\n\t}\r\n\tfunction isFunction(it){\r\n\t  return typeof it == 'function';\r\n\t}\r\n\t// Native function?\r\n\tvar isNative = ctx(/./.test, /\\[native code\\]\\s*\\}\\s*$/, 1);\r\n\t\r\n\t// Object internal [[Class]] or toStringTag\r\n\t// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring\r\n\tvar toString = ObjectProto[TO_STRING];\r\n\tfunction setToStringTag(it, tag, stat){\r\n\t  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);\r\n\t}\r\n\tfunction cof(it){\r\n\t  return toString.call(it).slice(8, -1);\r\n\t}\r\n\tfunction classof(it){\r\n\t  var O, T;\r\n\t  return it == undefined ? it === undefined ? 'Undefined' : 'Null'\r\n\t    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);\r\n\t}\r\n\t\r\n\t// Function\r\n\tvar call  = FunctionProto.call\r\n\t  , apply = FunctionProto.apply\r\n\t  , REFERENCE_GET;\r\n\t// Partial apply\r\n\tfunction part(/* ...args */){\r\n\t  var fn     = assertFunction(this)\r\n\t    , length = arguments.length\r\n\t    , args   = Array(length)\r\n\t    , i      = 0\r\n\t    , _      = path._\r\n\t    , holder = false;\r\n\t  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;\r\n\t  return function(/* ...args */){\r\n\t    var that    = this\r\n\t      , _length = arguments.length\r\n\t      , i = 0, j = 0, _args;\r\n\t    if(!holder && !_length)return invoke(fn, args, that);\r\n\t    _args = args.slice();\r\n\t    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];\r\n\t    while(_length > j)_args.push(arguments[j++]);\r\n\t    return invoke(fn, _args, that);\r\n\t  }\r\n\t}\r\n\t// Optional / simple context binding\r\n\tfunction ctx(fn, that, length){\r\n\t  assertFunction(fn);\r\n\t  if(~length && that === undefined)return fn;\r\n\t  switch(length){\r\n\t    case 1: return function(a){\r\n\t      return fn.call(that, a);\r\n\t    }\r\n\t    case 2: return function(a, b){\r\n\t      return fn.call(that, a, b);\r\n\t    }\r\n\t    case 3: return function(a, b, c){\r\n\t      return fn.call(that, a, b, c);\r\n\t    }\r\n\t  } return function(/* ...args */){\r\n\t      return fn.apply(that, arguments);\r\n\t  }\r\n\t}\r\n\t// Fast apply\r\n\t// http://jsperf.lnkit.com/fast-apply/5\r\n\tfunction invoke(fn, args, that){\r\n\t  var un = that === undefined;\r\n\t  switch(args.length | 0){\r\n\t    case 0: return un ? fn()\r\n\t                      : fn.call(that);\r\n\t    case 1: return un ? fn(args[0])\r\n\t                      : fn.call(that, args[0]);\r\n\t    case 2: return un ? fn(args[0], args[1])\r\n\t                      : fn.call(that, args[0], args[1]);\r\n\t    case 3: return un ? fn(args[0], args[1], args[2])\r\n\t                      : fn.call(that, args[0], args[1], args[2]);\r\n\t    case 4: return un ? fn(args[0], args[1], args[2], args[3])\r\n\t                      : fn.call(that, args[0], args[1], args[2], args[3]);\r\n\t    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])\r\n\t                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);\r\n\t  } return              fn.apply(that, args);\r\n\t}\r\n\tfunction construct(target, argumentsList /*, newTarget*/){\r\n\t  var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]\r\n\t    , instance = create(isObject(proto) ? proto : ObjectProto)\r\n\t    , result   = apply.call(target, instance, argumentsList);\r\n\t  return isObject(result) ? result : instance;\r\n\t}\r\n\t\r\n\t// Object:\r\n\tvar create           = Object.create\r\n\t  , getPrototypeOf   = Object.getPrototypeOf\r\n\t  , setPrototypeOf   = Object.setPrototypeOf\r\n\t  , defineProperty   = Object.defineProperty\r\n\t  , defineProperties = Object.defineProperties\r\n\t  , getOwnDescriptor = Object.getOwnPropertyDescriptor\r\n\t  , getKeys          = Object.keys\r\n\t  , getNames         = Object.getOwnPropertyNames\r\n\t  , getSymbols       = Object.getOwnPropertySymbols\r\n\t  , isFrozen         = Object.isFrozen\r\n\t  , has              = ctx(call, ObjectProto[HAS_OWN], 2)\r\n\t  // Dummy, fix for not array-like ES3 string in es5 module\r\n\t  , ES5Object        = Object\r\n\t  , Dict;\r\n\tfunction toObject(it){\r\n\t  return ES5Object(assertDefined(it));\r\n\t}\r\n\tfunction returnIt(it){\r\n\t  return it;\r\n\t}\r\n\tfunction returnThis(){\r\n\t  return this;\r\n\t}\r\n\tfunction get(object, key){\r\n\t  if(has(object, key))return object[key];\r\n\t}\r\n\tfunction ownKeys(it){\r\n\t  assertObject(it);\r\n\t  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);\r\n\t}\r\n\t// 19.1.2.1 Object.assign(target, source, ...)\r\n\tvar assign = Object.assign || function(target, source){\r\n\t  var T = Object(assertDefined(target))\r\n\t    , l = arguments.length\r\n\t    , i = 1;\r\n\t  while(l > i){\r\n\t    var S      = ES5Object(arguments[i++])\r\n\t      , keys   = getKeys(S)\r\n\t      , length = keys.length\r\n\t      , j      = 0\r\n\t      , key;\r\n\t    while(length > j)T[key = keys[j++]] = S[key];\r\n\t  }\r\n\t  return T;\r\n\t}\r\n\tfunction keyOf(object, el){\r\n\t  var O      = toObject(object)\r\n\t    , keys   = getKeys(O)\r\n\t    , length = keys.length\r\n\t    , index  = 0\r\n\t    , key;\r\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\r\n\t}\r\n\t\r\n\t// Array\r\n\t// array('str1,str2,str3') => ['str1', 'str2', 'str3']\r\n\tfunction array(it){\r\n\t  return String(it).split(',');\r\n\t}\r\n\tvar push    = ArrayProto.push\r\n\t  , unshift = ArrayProto.unshift\r\n\t  , slice   = ArrayProto.slice\r\n\t  , splice  = ArrayProto.splice\r\n\t  , indexOf = ArrayProto.indexOf\r\n\t  , forEach = ArrayProto[FOR_EACH];\r\n\t/*\r\n\t * 0 -> forEach\r\n\t * 1 -> map\r\n\t * 2 -> filter\r\n\t * 3 -> some\r\n\t * 4 -> every\r\n\t * 5 -> find\r\n\t * 6 -> findIndex\r\n\t */\r\n\tfunction createArrayMethod(type){\r\n\t  var isMap       = type == 1\r\n\t    , isFilter    = type == 2\r\n\t    , isSome      = type == 3\r\n\t    , isEvery     = type == 4\r\n\t    , isFindIndex = type == 6\r\n\t    , noholes     = type == 5 || isFindIndex;\r\n\t  return function(callbackfn/*, that = undefined */){\r\n\t    var O      = Object(assertDefined(this))\r\n\t      , that   = arguments[1]\r\n\t      , self   = ES5Object(O)\r\n\t      , f      = ctx(callbackfn, that, 3)\r\n\t      , length = toLength(self.length)\r\n\t      , index  = 0\r\n\t      , result = isMap ? Array(length) : isFilter ? [] : undefined\r\n\t      , val, res;\r\n\t    for(;length > index; index++)if(noholes || index in self){\r\n\t      val = self[index];\r\n\t      res = f(val, index, O);\r\n\t      if(type){\r\n\t        if(isMap)result[index] = res;             // map\r\n\t        else if(res)switch(type){\r\n\t          case 3: return true;                    // some\r\n\t          case 5: return val;                     // find\r\n\t          case 6: return index;                   // findIndex\r\n\t          case 2: result.push(val);               // filter\r\n\t        } else if(isEvery)return false;           // every\r\n\t      }\r\n\t    }\r\n\t    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;\r\n\t  }\r\n\t}\r\n\tfunction createArrayContains(isContains){\r\n\t  return function(el /*, fromIndex = 0 */){\r\n\t    var O      = toObject(this)\r\n\t      , length = toLength(O.length)\r\n\t      , index  = toIndex(arguments[1], length);\r\n\t    if(isContains && el != el){\r\n\t      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;\r\n\t    } else for(;length > index; index++)if(isContains || index in O){\r\n\t      if(O[index] === el)return isContains || index;\r\n\t    } return !isContains && -1;\r\n\t  }\r\n\t}\r\n\tfunction generic(A, B){\r\n\t  // strange IE quirks mode bug -> use typeof vs isFunction\r\n\t  return typeof A == 'function' ? A : B;\r\n\t}\r\n\t\r\n\t// Math\r\n\tvar MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991\r\n\t  , pow    = Math.pow\r\n\t  , abs    = Math.abs\r\n\t  , ceil   = Math.ceil\r\n\t  , floor  = Math.floor\r\n\t  , max    = Math.max\r\n\t  , min    = Math.min\r\n\t  , random = Math.random\r\n\t  , trunc  = Math.trunc || function(it){\r\n\t      return (it > 0 ? floor : ceil)(it);\r\n\t    }\r\n\t// 20.1.2.4 Number.isNaN(number)\r\n\tfunction sameNaN(number){\r\n\t  return number != number;\r\n\t}\r\n\t// 7.1.4 ToInteger\r\n\tfunction toInteger(it){\r\n\t  return isNaN(it) ? 0 : trunc(it);\r\n\t}\r\n\t// 7.1.15 ToLength\r\n\tfunction toLength(it){\r\n\t  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;\r\n\t}\r\n\tfunction toIndex(index, length){\r\n\t  var index = toInteger(index);\r\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\r\n\t}\r\n\tfunction lz(num){\r\n\t  return num > 9 ? num : '0' + num;\r\n\t}\r\n\t\r\n\tfunction createReplacer(regExp, replace, isStatic){\r\n\t  var replacer = isObject(replace) ? function(part){\r\n\t    return replace[part];\r\n\t  } : replace;\r\n\t  return function(it){\r\n\t    return String(isStatic ? it : this).replace(regExp, replacer);\r\n\t  }\r\n\t}\r\n\tfunction createPointAt(toString){\r\n\t  return function(pos){\r\n\t    var s = String(assertDefined(this))\r\n\t      , i = toInteger(pos)\r\n\t      , l = s.length\r\n\t      , a, b;\r\n\t    if(i < 0 || i >= l)return toString ? '' : undefined;\r\n\t    a = s.charCodeAt(i);\r\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\r\n\t      ? toString ? s.charAt(i) : a\r\n\t      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\r\n\t  }\r\n\t}\r\n\t\r\n\t// Assertion & errors\r\n\tvar REDUCE_ERROR = 'Reduce of empty object with no initial value';\r\n\tfunction assert(condition, msg1, msg2){\r\n\t  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);\r\n\t}\r\n\tfunction assertDefined(it){\r\n\t  if(it == undefined)throw TypeError('Function called on null or undefined');\r\n\t  return it;\r\n\t}\r\n\tfunction assertFunction(it){\r\n\t  assert(isFunction(it), it, ' is not a function!');\r\n\t  return it;\r\n\t}\r\n\tfunction assertObject(it){\r\n\t  assert(isObject(it), it, ' is not an object!');\r\n\t  return it;\r\n\t}\r\n\tfunction assertInstance(it, Constructor, name){\r\n\t  assert(it instanceof Constructor, name, \": use the 'new' operator!\");\r\n\t}\r\n\t\r\n\t// Property descriptors & Symbol\r\n\tfunction descriptor(bitmap, value){\r\n\t  return {\r\n\t    enumerable  : !(bitmap & 1),\r\n\t    configurable: !(bitmap & 2),\r\n\t    writable    : !(bitmap & 4),\r\n\t    value       : value\r\n\t  }\r\n\t}\r\n\tfunction simpleSet(object, key, value){\r\n\t  object[key] = value;\r\n\t  return object;\r\n\t}\r\n\tfunction createDefiner(bitmap){\r\n\t  return DESC ? function(object, key, value){\r\n\t    return defineProperty(object, key, descriptor(bitmap, value));\r\n\t  } : simpleSet;\r\n\t}\r\n\tfunction uid(key){\r\n\t  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);\r\n\t}\r\n\tfunction getWellKnownSymbol(name, setter){\r\n\t  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);\r\n\t}\r\n\t// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\r\n\tvar DESC = !!function(){\r\n\t      try {\r\n\t        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;\r\n\t      } catch(e){}\r\n\t    }()\r\n\t  , sid    = 0\r\n\t  , hidden = createDefiner(1)\r\n\t  , set    = Symbol ? simpleSet : hidden\r\n\t  , safeSymbol = Symbol || uid;\r\n\tfunction assignHidden(target, src){\r\n\t  for(var key in src)hidden(target, key, src[key]);\r\n\t  return target;\r\n\t}\r\n\t\r\n\tvar SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')\r\n\t  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}\r\n\t  , SYMBOL_SPECIES     = getWellKnownSymbol('species');\r\n\tfunction setSpecies(C){\r\n\t  if(framework || !isNative(C))defineProperty(C, SYMBOL_SPECIES, {\r\n\t    configurable: true,\r\n\t    get: returnThis\r\n\t  });\r\n\t}\r\n\t\r\n\t// Iterators\r\n\tvar SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR)\r\n\t  , SYMBOL_TAG      = getWellKnownSymbol(TO_STRING_TAG)\r\n\t  , SUPPORT_FF_ITER = FF_ITERATOR in ArrayProto\r\n\t  , ITER  = safeSymbol('iter')\r\n\t  , KEY   = 1\r\n\t  , VALUE = 2\r\n\t  , Iterators = {}\r\n\t  , IteratorPrototype = {}\r\n\t  , NATIVE_ITERATORS = SYMBOL_ITERATOR in ArrayProto\r\n\t    // Safari define byggy iterators w/o `next`\r\n\t  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());\r\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\r\n\tsetIterator(IteratorPrototype, returnThis);\r\n\tfunction setIterator(O, value){\r\n\t  hidden(O, SYMBOL_ITERATOR, value);\r\n\t  // Add iterator for FF iterator protocol\r\n\t  SUPPORT_FF_ITER && hidden(O, FF_ITERATOR, value);\r\n\t}\r\n\tfunction createIterator(Constructor, NAME, next, proto){\r\n\t  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});\r\n\t  setToStringTag(Constructor, NAME + ' Iterator');\r\n\t}\r\n\tfunction defineIterator(Constructor, NAME, value, DEFAULT){\r\n\t  var proto = Constructor[PROTOTYPE]\r\n\t    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;\r\n\t  if(framework){\r\n\t    // Define iterator\r\n\t    setIterator(proto, iter);\r\n\t    if(iter !== value){\r\n\t      var iterProto = getPrototypeOf(iter.call(new Constructor));\r\n\t      // Set @@toStringTag to native iterators\r\n\t      setToStringTag(iterProto, NAME + ' Iterator', true);\r\n\t      // FF fix\r\n\t      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);\r\n\t    }\r\n\t  }\r\n\t  // Plug for library\r\n\t  Iterators[NAME] = iter;\r\n\t  // FF & v8 fix\r\n\t  Iterators[NAME + ' Iterator'] = returnThis;\r\n\t  return iter;\r\n\t}\r\n\tfunction defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){\r\n\t  function createIter(kind){\r\n\t    return function(){\r\n\t      return new Constructor(this, kind);\r\n\t    }\r\n\t  }\r\n\t  createIterator(Constructor, NAME, next);\r\n\t  var entries = createIter(KEY+VALUE)\r\n\t    , values  = createIter(VALUE);\r\n\t  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');\r\n\t  else entries = defineIterator(Base, NAME, entries, 'entries');\r\n\t  if(DEFAULT){\r\n\t    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {\r\n\t      entries: entries,\r\n\t      keys: IS_SET ? values : createIter(KEY),\r\n\t      values: values\r\n\t    });\r\n\t  }\r\n\t}\r\n\tfunction iterResult(done, value){\r\n\t  return {value: value, done: !!done};\r\n\t}\r\n\tfunction isIterable(it){\r\n\t  var O      = Object(it)\r\n\t    , Symbol = global[SYMBOL]\r\n\t    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;\r\n\t  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));\r\n\t}\r\n\tfunction getIterator(it){\r\n\t  var Symbol  = global[SYMBOL]\r\n\t    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]\r\n\t    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];\r\n\t  return assertObject(getIter.call(it));\r\n\t}\r\n\tfunction stepCall(fn, value, entries){\r\n\t  return entries ? invoke(fn, value) : fn(value);\r\n\t}\r\n\tfunction forOf(iterable, entries, fn, that){\r\n\t  var iterator = getIterator(iterable)\r\n\t    , f        = ctx(fn, that, entries ? 2 : 1)\r\n\t    , step;\r\n\t  while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false)return;\r\n\t}\r\n\t\r\n\t// core\r\n\tvar NODE = cof(process) == PROCESS\r\n\t  , core = {}\r\n\t  , path = framework ? global : core\r\n\t  , old  = global.core\r\n\t  , exportGlobal\r\n\t  // type bitmap\r\n\t  , FORCED = 1\r\n\t  , GLOBAL = 2\r\n\t  , STATIC = 4\r\n\t  , PROTO  = 8\r\n\t  , BIND   = 16\r\n\t  , WRAP   = 32\r\n\t  , SIMPLE = 64;\r\n\tfunction $define(type, name, source){\r\n\t  var key, own, out, exp\r\n\t    , isGlobal = type & GLOBAL\r\n\t    , target   = isGlobal ? global : (type & STATIC)\r\n\t        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]\r\n\t    , exports  = isGlobal ? core : core[name] || (core[name] = {});\r\n\t  if(isGlobal)source = name;\r\n\t  for(key in source){\r\n\t    // there is a similar native\r\n\t    own = !(type & FORCED) && target && key in target\r\n\t      && (!isFunction(target[key]) || isNative(target[key]));\r\n\t    // export native or passed\r\n\t    out = (own ? target : source)[key];\r\n\t    // prevent global pollution for namespaces\r\n\t    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];\r\n\t    // bind timers to global for call from export context\r\n\t    else if(type & BIND && own)exp = ctx(out, global);\r\n\t    // wrap global constructors for prevent change them in library\r\n\t    else if(type & WRAP && !framework && target[key] == out){\r\n\t      exp = function(param){\r\n\t        return this instanceof out ? new out(param) : out(param);\r\n\t      }\r\n\t      exp[PROTOTYPE] = out[PROTOTYPE];\r\n\t    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;\r\n\t    // extend global\r\n\t    if(framework && target && !own){\r\n\t      if(isGlobal || type & SIMPLE)target[key] = out;\r\n\t      else delete target[key] && hidden(target, key, out);\r\n\t    }\r\n\t    // export\r\n\t    if(exports[key] != out)hidden(exports, key, exp);\r\n\t  }\r\n\t}\r\n\t// CommonJS export\r\n\tif(typeof module != 'undefined' && module.exports)module.exports = core;\r\n\t// RequireJS export\r\n\telse if(isFunction(define) && define.amd)define(function(){return core});\r\n\t// Export to global object\r\n\telse exportGlobal = true;\r\n\tif(exportGlobal || framework){\r\n\t  core.noConflict = function(){\r\n\t    global.core = old;\r\n\t    return core;\r\n\t  }\r\n\t  global.core = core;\r\n\t}\n\t\n\t/******************************************************************************\n\t * Module : es6.symbol                                                        *\n\t ******************************************************************************/\n\t\n\t// ECMAScript 6 symbols shim\r\n\t!function(TAG, SymbolRegistry, AllSymbols, setter){\r\n\t  // 19.4.1.1 Symbol([description])\r\n\t  if(!isNative(Symbol)){\r\n\t    Symbol = function(description){\r\n\t      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);\r\n\t      var tag = uid(description)\r\n\t        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);\r\n\t      AllSymbols[tag] = sym;\r\n\t      DESC && setter && defineProperty(ObjectProto, tag, {\r\n\t        configurable: true,\r\n\t        set: function(value){\r\n\t          hidden(this, tag, value);\r\n\t        }\r\n\t      });\r\n\t      return sym;\r\n\t    }\r\n\t    hidden(Symbol[PROTOTYPE], TO_STRING, function(){\r\n\t      return this[TAG];\r\n\t    });\r\n\t  }\r\n\t  $define(GLOBAL + WRAP, {Symbol: Symbol});\r\n\t  \r\n\t  var symbolStatics = {\r\n\t    // 19.4.2.1 Symbol.for(key)\r\n\t    'for': function(key){\r\n\t      return has(SymbolRegistry, key += '')\r\n\t        ? SymbolRegistry[key]\r\n\t        : SymbolRegistry[key] = Symbol(key);\r\n\t    },\r\n\t    // 19.4.2.4 Symbol.iterator\r\n\t    iterator: SYMBOL_ITERATOR,\r\n\t    // 19.4.2.5 Symbol.keyFor(sym)\r\n\t    keyFor: part.call(keyOf, SymbolRegistry),\r\n\t    // 19.4.2.10 Symbol.species\r\n\t    species: SYMBOL_SPECIES,\r\n\t    // 19.4.2.13 Symbol.toStringTag\r\n\t    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),\r\n\t    // 19.4.2.14 Symbol.unscopables\r\n\t    unscopables: SYMBOL_UNSCOPABLES,\r\n\t    pure: safeSymbol,\r\n\t    set: set,\r\n\t    useSetter: function(){setter = true},\r\n\t    useSimple: function(){setter = false}\r\n\t  };\r\n\t  // 19.4.2.2 Symbol.hasInstance\r\n\t  // 19.4.2.3 Symbol.isConcatSpreadable\r\n\t  // 19.4.2.6 Symbol.match\r\n\t  // 19.4.2.8 Symbol.replace\r\n\t  // 19.4.2.9 Symbol.search\r\n\t  // 19.4.2.11 Symbol.split\r\n\t  // 19.4.2.12 Symbol.toPrimitive\r\n\t  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),\r\n\t    function(it){\r\n\t      symbolStatics[it] = getWellKnownSymbol(it);\r\n\t    }\r\n\t  );\r\n\t  $define(STATIC, SYMBOL, symbolStatics);\r\n\t  \r\n\t  setToStringTag(Symbol, SYMBOL);\r\n\t  \r\n\t  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {\r\n\t    // 19.1.2.7 Object.getOwnPropertyNames(O)\r\n\t    getOwnPropertyNames: function(it){\r\n\t      var names = getNames(toObject(it)), result = [], key, i = 0;\r\n\t      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);\r\n\t      return result;\r\n\t    },\r\n\t    // 19.1.2.8 Object.getOwnPropertySymbols(O)\r\n\t    getOwnPropertySymbols: function(it){\r\n\t      var names = getNames(toObject(it)), result = [], key, i = 0;\r\n\t      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);\r\n\t      return result;\r\n\t    }\r\n\t  });\r\n\t}(safeSymbol('tag'), {}, {}, true);\n\t\n\t/******************************************************************************\n\t * Module : es6.object                                                        *\n\t ******************************************************************************/\n\t\n\t!function(tmp){\r\n\t  var objectStatic = {\r\n\t    // 19.1.3.1 Object.assign(target, source)\r\n\t    assign: assign,\r\n\t    // 19.1.3.10 Object.is(value1, value2)\r\n\t    is: function(x, y){\r\n\t      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\r\n\t    }\r\n\t  };\r\n\t  // 19.1.3.19 Object.setPrototypeOf(O, proto)\r\n\t  // Works with __proto__ only. Old v8 can't works with null proto objects.\r\n\t  '__proto__' in ObjectProto && function(buggy, set){\r\n\t    try {\r\n\t      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);\r\n\t      set({}, ArrayProto);\r\n\t    } catch(e){ buggy = true }\r\n\t    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){\r\n\t      assertObject(O);\r\n\t      assert(proto === null || isObject(proto), proto, \": can't set as prototype!\");\r\n\t      if(buggy)O.__proto__ = proto;\r\n\t      else set(O, proto);\r\n\t      return O;\r\n\t    }\r\n\t  }();\r\n\t  $define(STATIC, OBJECT, objectStatic);\r\n\t  \r\n\t  if(framework){\r\n\t    // 19.1.3.6 Object.prototype.toString()\r\n\t    tmp[SYMBOL_TAG] = DOT;\r\n\t    if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){\r\n\t      return '[object ' + classof(this) + ']';\r\n\t    });\r\n\t  }\r\n\t  \r\n\t  // 20.2.1.9 Math[@@toStringTag]\r\n\t  setToStringTag(Math, MATH, true);\r\n\t  // 24.3.3 JSON[@@toStringTag]\r\n\t  setToStringTag(global.JSON, 'JSON', true);\r\n\t}({});\n\t\n\t/******************************************************************************\n\t * Module : es6.object.statics-accept-primitives                              *\n\t ******************************************************************************/\n\t\n\t!function(){\r\n\t  // Object static methods accept primitives\r\n\t  function wrapObjectMethod(key, MODE){\r\n\t    var fn  = Object[key]\r\n\t      , exp = core[OBJECT][key]\r\n\t      , f   = 0\r\n\t      , o   = {};\r\n\t    if(!exp || isNative(exp)){\r\n\t      o[key] = MODE == 1 ? function(it){\r\n\t        return isObject(it) ? fn(it) : it;\r\n\t      } : MODE == 2 ? function(it){\r\n\t        return isObject(it) ? fn(it) : true;\r\n\t      } : MODE == 3 ? function(it){\r\n\t        return isObject(it) ? fn(it) : false;\r\n\t      } : MODE == 4 ? function(it, key){\r\n\t        return fn(toObject(it), key);\r\n\t      } : function(it){\r\n\t        return fn(toObject(it));\r\n\t      };\r\n\t      try { fn(DOT) }\r\n\t      catch(e){ f = 1 }\r\n\t      $define(STATIC + FORCED * f, OBJECT, o);\r\n\t    }\r\n\t  }\r\n\t  wrapObjectMethod('freeze', 1);\r\n\t  wrapObjectMethod('seal', 1);\r\n\t  wrapObjectMethod('preventExtensions', 1);\r\n\t  wrapObjectMethod('isFrozen', 2);\r\n\t  wrapObjectMethod('isSealed', 2);\r\n\t  wrapObjectMethod('isExtensible', 3);\r\n\t  wrapObjectMethod('getOwnPropertyDescriptor', 4);\r\n\t  wrapObjectMethod('getPrototypeOf');\r\n\t  wrapObjectMethod('keys');\r\n\t  wrapObjectMethod('getOwnPropertyNames');\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es6.function                                                      *\n\t ******************************************************************************/\n\t\n\t!function(NAME){\r\n\t  // 19.2.4.2 name\r\n\t  NAME in FunctionProto || defineProperty(FunctionProto, NAME, {\r\n\t    configurable: true,\r\n\t    get: function(){\r\n\t      var match = String(this).match(/^\\s*function ([^ (]*)/)\r\n\t        , name  = match ? match[1] : '';\r\n\t      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));\r\n\t      return name;\r\n\t    },\r\n\t    set: function(value){\r\n\t      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));\r\n\t    }\r\n\t  });\r\n\t}('name');\n\t\n\t/******************************************************************************\n\t * Module : es6.number.constructor                                            *\n\t ******************************************************************************/\n\t\n\tNumber('0o1') && Number('0b1') || function(_Number, NumberProto){\r\n\t  function toNumber(it){\r\n\t    if(isObject(it))it = toPrimitive(it);\r\n\t    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){\r\n\t      var binary = false;\r\n\t      switch(it.charCodeAt(1)){\r\n\t        case 66 : case 98  : binary = true;\r\n\t        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);\r\n\t      }\r\n\t    } return +it;\r\n\t  }\r\n\t  function toPrimitive(it){\r\n\t    var fn, val;\r\n\t    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;\r\n\t    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;\r\n\t    throw TypeError(\"Can't convert object to number\");\r\n\t  }\r\n\t  Number = function Number(it){\r\n\t    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);\r\n\t  }\r\n\t  forEach.call(DESC ? getNames(_Number)\r\n\t  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){\r\n\t    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));\r\n\t  });\r\n\t  Number[PROTOTYPE] = NumberProto;\r\n\t  NumberProto[CONSTRUCTOR] = Number;\r\n\t  hidden(global, NUMBER, Number);\r\n\t}(Number, Number[PROTOTYPE]);\n\t\n\t/******************************************************************************\n\t * Module : es6.number                                                        *\n\t ******************************************************************************/\n\t\n\t!function(isInteger){\r\n\t  $define(STATIC, NUMBER, {\r\n\t    // 20.1.2.1 Number.EPSILON\r\n\t    EPSILON: pow(2, -52),\r\n\t    // 20.1.2.2 Number.isFinite(number)\r\n\t    isFinite: function(it){\r\n\t      return typeof it == 'number' && isFinite(it);\r\n\t    },\r\n\t    // 20.1.2.3 Number.isInteger(number)\r\n\t    isInteger: isInteger,\r\n\t    // 20.1.2.4 Number.isNaN(number)\r\n\t    isNaN: sameNaN,\r\n\t    // 20.1.2.5 Number.isSafeInteger(number)\r\n\t    isSafeInteger: function(number){\r\n\t      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;\r\n\t    },\r\n\t    // 20.1.2.6 Number.MAX_SAFE_INTEGER\r\n\t    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\r\n\t    // 20.1.2.10 Number.MIN_SAFE_INTEGER\r\n\t    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,\r\n\t    // 20.1.2.12 Number.parseFloat(string)\r\n\t    parseFloat: parseFloat,\r\n\t    // 20.1.2.13 Number.parseInt(string, radix)\r\n\t    parseInt: parseInt\r\n\t  });\r\n\t// 20.1.2.3 Number.isInteger(number)\r\n\t}(Number.isInteger || function(it){\r\n\t  return !isObject(it) && isFinite(it) && floor(it) === it;\r\n\t});\n\t\n\t/******************************************************************************\n\t * Module : es6.math                                                          *\n\t ******************************************************************************/\n\t\n\t// ECMAScript 6 shim\r\n\t!function(){\r\n\t  // 20.2.2.28 Math.sign(x)\r\n\t  var E    = Math.E\r\n\t    , exp  = Math.exp\r\n\t    , log  = Math.log\r\n\t    , sqrt = Math.sqrt\r\n\t    , sign = Math.sign || function(x){\r\n\t        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\r\n\t      };\r\n\t  \r\n\t  // 20.2.2.5 Math.asinh(x)\r\n\t  function asinh(x){\r\n\t    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));\r\n\t  }\r\n\t  // 20.2.2.14 Math.expm1(x)\r\n\t  function expm1(x){\r\n\t    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;\r\n\t  }\r\n\t    \r\n\t  $define(STATIC, MATH, {\r\n\t    // 20.2.2.3 Math.acosh(x)\r\n\t    acosh: function(x){\r\n\t      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;\r\n\t    },\r\n\t    // 20.2.2.5 Math.asinh(x)\r\n\t    asinh: asinh,\r\n\t    // 20.2.2.7 Math.atanh(x)\r\n\t    atanh: function(x){\r\n\t      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;\r\n\t    },\r\n\t    // 20.2.2.9 Math.cbrt(x)\r\n\t    cbrt: function(x){\r\n\t      return sign(x = +x) * pow(abs(x), 1 / 3);\r\n\t    },\r\n\t    // 20.2.2.11 Math.clz32(x)\r\n\t    clz32: function(x){\r\n\t      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;\r\n\t    },\r\n\t    // 20.2.2.12 Math.cosh(x)\r\n\t    cosh: function(x){\r\n\t      return (exp(x = +x) + exp(-x)) / 2;\r\n\t    },\r\n\t    // 20.2.2.14 Math.expm1(x)\r\n\t    expm1: expm1,\r\n\t    // 20.2.2.16 Math.fround(x)\r\n\t    // TODO: fallback for IE9-\r\n\t    fround: function(x){\r\n\t      return new Float32Array([x])[0];\r\n\t    },\r\n\t    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\r\n\t    hypot: function(value1, value2){\r\n\t      var sum  = 0\r\n\t        , len1 = arguments.length\r\n\t        , len2 = len1\r\n\t        , args = Array(len1)\r\n\t        , larg = -Infinity\r\n\t        , arg;\r\n\t      while(len1--){\r\n\t        arg = args[len1] = +arguments[len1];\r\n\t        if(arg == Infinity || arg == -Infinity)return Infinity;\r\n\t        if(arg > larg)larg = arg;\r\n\t      }\r\n\t      larg = arg || 1;\r\n\t      while(len2--)sum += pow(args[len2] / larg, 2);\r\n\t      return larg * sqrt(sum);\r\n\t    },\r\n\t    // 20.2.2.18 Math.imul(x, y)\r\n\t    imul: function(x, y){\r\n\t      var UInt16 = 0xffff\r\n\t        , xn = +x\r\n\t        , yn = +y\r\n\t        , xl = UInt16 & xn\r\n\t        , yl = UInt16 & yn;\r\n\t      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);\r\n\t    },\r\n\t    // 20.2.2.20 Math.log1p(x)\r\n\t    log1p: function(x){\r\n\t      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);\r\n\t    },\r\n\t    // 20.2.2.21 Math.log10(x)\r\n\t    log10: function(x){\r\n\t      return log(x) / Math.LN10;\r\n\t    },\r\n\t    // 20.2.2.22 Math.log2(x)\r\n\t    log2: function(x){\r\n\t      return log(x) / Math.LN2;\r\n\t    },\r\n\t    // 20.2.2.28 Math.sign(x)\r\n\t    sign: sign,\r\n\t    // 20.2.2.30 Math.sinh(x)\r\n\t    sinh: function(x){\r\n\t      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);\r\n\t    },\r\n\t    // 20.2.2.33 Math.tanh(x)\r\n\t    tanh: function(x){\r\n\t      var a = expm1(x = +x)\r\n\t        , b = expm1(-x);\r\n\t      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\r\n\t    },\r\n\t    // 20.2.2.34 Math.trunc(x)\r\n\t    trunc: trunc\r\n\t  });\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es6.string                                                        *\n\t ******************************************************************************/\n\t\n\t!function(fromCharCode){\r\n\t  function assertNotRegExp(it){\r\n\t    if(cof(it) == REGEXP)throw TypeError();\r\n\t  }\r\n\t  \r\n\t  $define(STATIC, STRING, {\r\n\t    // 21.1.2.2 String.fromCodePoint(...codePoints)\r\n\t    fromCodePoint: function(x){\r\n\t      var res = []\r\n\t        , len = arguments.length\r\n\t        , i   = 0\r\n\t        , code\r\n\t      while(len > i){\r\n\t        code = +arguments[i++];\r\n\t        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\r\n\t        res.push(code < 0x10000\r\n\t          ? fromCharCode(code)\r\n\t          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\r\n\t        );\r\n\t      } return res.join('');\r\n\t    },\r\n\t    // 21.1.2.4 String.raw(callSite, ...substitutions)\r\n\t    raw: function(callSite){\r\n\t      var raw = toObject(callSite.raw)\r\n\t        , len = toLength(raw.length)\r\n\t        , sln = arguments.length\r\n\t        , res = []\r\n\t        , i   = 0;\r\n\t      while(len > i){\r\n\t        res.push(String(raw[i++]));\r\n\t        if(i < sln)res.push(String(arguments[i]));\r\n\t      } return res.join('');\r\n\t    }\r\n\t  });\r\n\t  \r\n\t  $define(PROTO, STRING, {\r\n\t    // 21.1.3.3 String.prototype.codePointAt(pos)\r\n\t    codePointAt: createPointAt(false),\r\n\t    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\r\n\t    endsWith: function(searchString /*, endPosition = @length */){\r\n\t      assertNotRegExp(searchString);\r\n\t      var that = String(assertDefined(this))\r\n\t        , endPosition = arguments[1]\r\n\t        , len = toLength(that.length)\r\n\t        , end = endPosition === undefined ? len : min(toLength(endPosition), len);\r\n\t      searchString += '';\r\n\t      return that.slice(end - searchString.length, end) === searchString;\r\n\t    },\r\n\t    // 21.1.3.7 String.prototype.includes(searchString, position = 0)\r\n\t    includes: function(searchString /*, position = 0 */){\r\n\t      assertNotRegExp(searchString);\r\n\t      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);\r\n\t    },\r\n\t    // 21.1.3.13 String.prototype.repeat(count)\r\n\t    repeat: function(count){\r\n\t      var str = String(assertDefined(this))\r\n\t        , res = ''\r\n\t        , n   = toInteger(count);\r\n\t      if(0 > n || n == Infinity)throw RangeError(\"Count can't be negative\");\r\n\t      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\r\n\t      return res;\r\n\t    },\r\n\t    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])\r\n\t    startsWith: function(searchString /*, position = 0 */){\r\n\t      assertNotRegExp(searchString);\r\n\t      var that  = String(assertDefined(this))\r\n\t        , index = toLength(min(arguments[1], that.length));\r\n\t      searchString += '';\r\n\t      return that.slice(index, index + searchString.length) === searchString;\r\n\t    }\r\n\t  });\r\n\t}(String.fromCharCode);\n\t\n\t/******************************************************************************\n\t * Module : es6.array                                                         *\n\t ******************************************************************************/\n\t\n\t!function(){\r\n\t  $define(STATIC, ARRAY, {\r\n\t    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\r\n\t    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\r\n\t      var O       = Object(assertDefined(arrayLike))\r\n\t        , mapfn   = arguments[1]\r\n\t        , mapping = mapfn !== undefined\r\n\t        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined\r\n\t        , index   = 0\r\n\t        , length, result, iter, step;\r\n\t      if(isIterable(O))for(iter = getIterator(O), result = new (generic(this, Array)); !(step = iter.next()).done; index++){\r\n\t        result[index] = mapping ? f(step.value, index) : step.value;\r\n\t      } else for(result = new (generic(this, Array))(length = toLength(O.length)); length > index; index++){\r\n\t        result[index] = mapping ? f(O[index], index) : O[index];\r\n\t      }\r\n\t      result.length = index;\r\n\t      return result;\r\n\t    },\r\n\t    // 22.1.2.3 Array.of( ...items)\r\n\t    of: function(/* ...args */){\r\n\t      var index  = 0\r\n\t        , length = arguments.length\r\n\t        , result = new (generic(this, Array))(length);\r\n\t      while(length > index)result[index] = arguments[index++];\r\n\t      result.length = length;\r\n\t      return result;\r\n\t    }\r\n\t  });\r\n\t  \r\n\t  $define(PROTO, ARRAY, {\r\n\t    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\r\n\t    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){\r\n\t      var O     = Object(assertDefined(this))\r\n\t        , len   = toLength(O.length)\r\n\t        , to    = toIndex(target, len)\r\n\t        , from  = toIndex(start, len)\r\n\t        , end   = arguments[2]\r\n\t        , fin   = end === undefined ? len : toIndex(end, len)\r\n\t        , count = min(fin - from, len - to)\r\n\t        , inc   = 1;\r\n\t      if(from < to && to < from + count){\r\n\t        inc  = -1;\r\n\t        from = from + count - 1;\r\n\t        to   = to + count - 1;\r\n\t      }\r\n\t      while(count-- > 0){\r\n\t        if(from in O)O[to] = O[from];\r\n\t        else delete O[to];\r\n\t        to += inc;\r\n\t        from += inc;\r\n\t      } return O;\r\n\t    },\r\n\t    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\r\n\t    fill: function(value /*, start = 0, end = @length */){\r\n\t      var O      = Object(assertDefined(this))\r\n\t        , length = toLength(O.length)\r\n\t        , index  = toIndex(arguments[1], length)\r\n\t        , end    = arguments[2]\r\n\t        , endPos = end === undefined ? length : toIndex(end, length);\r\n\t      while(endPos > index)O[index++] = value;\r\n\t      return O;\r\n\t    },\r\n\t    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\r\n\t    find: createArrayMethod(5),\r\n\t    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\r\n\t    findIndex: createArrayMethod(6)\r\n\t  });\r\n\t  \r\n\t  if(framework){\r\n\t    // 22.1.3.31 Array.prototype[@@unscopables]\r\n\t    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){\r\n\t      ArrayUnscopables[it] = true;\r\n\t    });\r\n\t    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);\r\n\t  }  \r\n\t  \r\n\t  setSpecies(Array);\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es6.iterators                                                     *\n\t ******************************************************************************/\n\t\n\t!function(at){\r\n\t  // 22.1.3.4 Array.prototype.entries()\r\n\t  // 22.1.3.13 Array.prototype.keys()\r\n\t  // 22.1.3.29 Array.prototype.values()\r\n\t  // 22.1.3.30 Array.prototype[@@iterator]()\r\n\t  defineStdIterators(Array, ARRAY, function(iterated, kind){\r\n\t    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});\r\n\t  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\r\n\t  }, function(){\r\n\t    var iter  = this[ITER]\r\n\t      , O     = iter.o\r\n\t      , kind  = iter.k\r\n\t      , index = iter.i++;\r\n\t    if(!O || index >= O.length){\r\n\t      iter.o = undefined;\r\n\t      return iterResult(1);\r\n\t    }\r\n\t    if(kind == KEY)  return iterResult(0, index);\r\n\t    if(kind == VALUE)return iterResult(0, O[index]);\r\n\t                     return iterResult(0, [index, O[index]]);\r\n\t  }, VALUE);\r\n\t  \r\n\t  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\r\n\t  Iterators[ARGUMENTS] = Iterators[ARRAY];\r\n\t  \r\n\t  // 21.1.3.27 String.prototype[@@iterator]()\r\n\t  defineStdIterators(String, STRING, function(iterated){\r\n\t    set(this, ITER, {o: String(iterated), i: 0});\r\n\t  // 21.1.5.2.1 %StringIteratorPrototype%.next()\r\n\t  }, function(){\r\n\t    var iter  = this[ITER]\r\n\t      , O     = iter.o\r\n\t      , index = iter.i\r\n\t      , point;\r\n\t    if(index >= O.length)return iterResult(1);\r\n\t    point = at.call(O, index);\r\n\t    iter.i += point.length;\r\n\t    return iterResult(0, point);\r\n\t  });\r\n\t}(createPointAt(true));\n\t\n\t/******************************************************************************\n\t * Module : es6.regexp                                                        *\n\t ******************************************************************************/\n\t\n\t!function(RegExpProto, _RegExp){\r\n\t  function assertRegExpWrapper(fn){\r\n\t    return function(){\r\n\t      assert(cof(this) === REGEXP);\r\n\t      return fn(this);\r\n\t    }\r\n\t  }\r\n\t  \r\n\t  // RegExp allows a regex with flags as the pattern\r\n\t  if(DESC && !function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){\r\n\t    RegExp = function RegExp(pattern, flags){\r\n\t      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined\r\n\t        ? pattern.source : pattern, flags);\r\n\t    }\r\n\t    forEach.call(getNames(_RegExp), function(key){\r\n\t      key in RegExp || defineProperty(RegExp, key, {\r\n\t        configurable: true,\r\n\t        get: function(){ return _RegExp[key] },\r\n\t        set: function(it){ _RegExp[key] = it }\r\n\t      });\r\n\t    });\r\n\t    RegExpProto[CONSTRUCTOR] = RegExp;\r\n\t    RegExp[PROTOTYPE] = RegExpProto;\r\n\t    hidden(global, REGEXP, RegExp);\r\n\t  }\r\n\t  \r\n\t  // 21.2.5.3 get RegExp.prototype.flags()\r\n\t  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {\r\n\t    configurable: true,\r\n\t    get: assertRegExpWrapper(createReplacer(/^.*\\/(\\w*)$/, '$1', true))\r\n\t  });\r\n\t  \r\n\t  // 21.2.5.12 get RegExp.prototype.sticky()\r\n\t  // 21.2.5.15 get RegExp.prototype.unicode()\r\n\t  forEach.call(array('sticky,unicode'), function(key){\r\n\t    key in /./ || defineProperty(RegExpProto, key, DESC ? {\r\n\t      configurable: true,\r\n\t      get: assertRegExpWrapper(function(){\r\n\t        return false;\r\n\t      })\r\n\t    } : descriptor(5, false));\r\n\t  });\r\n\t  \r\n\t  setSpecies(RegExp);\r\n\t}(RegExp[PROTOTYPE], RegExp);\n\t\n\t/******************************************************************************\n\t * Module : web.immediate                                                     *\n\t ******************************************************************************/\n\t\n\t// setImmediate shim\r\n\t// Node.js 0.9+ & IE10+ has setImmediate, else:\r\n\tisFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){\r\n\t  var postMessage      = global.postMessage\r\n\t    , addEventListener = global.addEventListener\r\n\t    , MessageChannel   = global.MessageChannel\r\n\t    , counter          = 0\r\n\t    , queue            = {}\r\n\t    , defer, channel, port;\r\n\t  setImmediate = function(fn){\r\n\t    var args = [], i = 1;\r\n\t    while(arguments.length > i)args.push(arguments[i++]);\r\n\t    queue[++counter] = function(){\r\n\t      invoke(isFunction(fn) ? fn : Function(fn), args);\r\n\t    }\r\n\t    defer(counter);\r\n\t    return counter;\r\n\t  }\r\n\t  clearImmediate = function(id){\r\n\t    delete queue[id];\r\n\t  }\r\n\t  function run(id){\r\n\t    if(has(queue, id)){\r\n\t      var fn = queue[id];\r\n\t      delete queue[id];\r\n\t      fn();\r\n\t    }\r\n\t  }\r\n\t  function listner(event){\r\n\t    run(event.data);\r\n\t  }\r\n\t  // Node.js 0.8-\r\n\t  if(NODE){\r\n\t    defer = function(id){\r\n\t      nextTick(part.call(run, id));\r\n\t    }\r\n\t  // Modern browsers, skip implementation for WebWorkers\r\n\t  // IE8 has postMessage, but it's sync & typeof its postMessage is object\r\n\t  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){\r\n\t    defer = function(id){\r\n\t      postMessage(id, '*');\r\n\t    }\r\n\t    addEventListener('message', listner, false);\r\n\t  // WebWorkers\r\n\t  } else if(isFunction(MessageChannel)){\r\n\t    channel = new MessageChannel;\r\n\t    port    = channel.port2;\r\n\t    channel.port1.onmessage = listner;\r\n\t    defer = ctx(port.postMessage, port, 1);\r\n\t  // IE8-\r\n\t  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){\r\n\t    defer = function(id){\r\n\t      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){\r\n\t        html.removeChild(this);\r\n\t        run(id);\r\n\t      }\r\n\t    }\r\n\t  // Rest old browsers\r\n\t  } else {\r\n\t    defer = function(id){\r\n\t      setTimeout(run, 0, id);\r\n\t    }\r\n\t  }\r\n\t}('onreadystatechange');\r\n\t$define(GLOBAL + BIND, {\r\n\t  setImmediate:   setImmediate,\r\n\t  clearImmediate: clearImmediate\r\n\t});\n\t\n\t/******************************************************************************\n\t * Module : es6.promise                                                       *\n\t ******************************************************************************/\n\t\n\t// ES6 promises shim\r\n\t// Based on https://github.com/getify/native-promise-only/\r\n\t!function(Promise, test){\r\n\t  isFunction(Promise) && isFunction(Promise.resolve)\r\n\t  && Promise.resolve(test = new Promise(function(){})) == test\r\n\t  || function(asap, DEF){\r\n\t    function isThenable(o){\r\n\t      var then;\r\n\t      if(isObject(o))then = o.then;\r\n\t      return isFunction(then) ? then : false;\r\n\t    }\r\n\t    function notify(def){\r\n\t      var chain = def.chain;\r\n\t      chain.length && asap(function(){\r\n\t        var msg = def.msg\r\n\t          , ok  = def.state == 1\r\n\t          , i   = 0;\r\n\t        while(chain.length > i)!function(react){\r\n\t          var cb = ok ? react.ok : react.fail\r\n\t            , ret, then;\r\n\t          try {\r\n\t            if(cb){\r\n\t              ret = cb === true ? msg : cb(msg);\r\n\t              if(ret === react.P){\r\n\t                react.rej(TypeError(PROMISE + '-chain cycle'));\r\n\t              } else if(then = isThenable(ret)){\r\n\t                then.call(ret, react.res, react.rej);\r\n\t              } else react.res(ret);\r\n\t            } else react.rej(msg);\r\n\t          } catch(err){\r\n\t            react.rej(err);\r\n\t          }\r\n\t        }(chain[i++]);\r\n\t        chain.length = 0;\r\n\t      });\r\n\t    }\r\n\t    function resolve(msg){\r\n\t      var def = this\r\n\t        , then, wrapper;\r\n\t      if(def.done)return;\r\n\t      def.done = true;\r\n\t      def = def.def || def; // unwrap\r\n\t      try {\r\n\t        if(then = isThenable(msg)){\r\n\t          wrapper = {def: def, done: false}; // wrap\r\n\t          then.call(msg, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));\r\n\t        } else {\r\n\t          def.msg = msg;\r\n\t          def.state = 1;\r\n\t          notify(def);\r\n\t        }\r\n\t      } catch(err){\r\n\t        reject.call(wrapper || {def: def, done: false}, err); // wrap\r\n\t      }\r\n\t    }\r\n\t    function reject(msg){\r\n\t      var def = this;\r\n\t      if(def.done)return;\r\n\t      def.done = true;\r\n\t      def = def.def || def; // unwrap\r\n\t      def.msg = msg;\r\n\t      def.state = 2;\r\n\t      notify(def);\r\n\t    }\r\n\t    function getConstructor(C){\r\n\t      var S = assertObject(C)[SYMBOL_SPECIES];\r\n\t      return S != undefined ? S : C;\r\n\t    }\r\n\t    // 25.4.3.1 Promise(executor)\r\n\t    Promise = function(executor){\r\n\t      assertFunction(executor);\r\n\t      assertInstance(this, Promise, PROMISE);\r\n\t      var def = {chain: [], state: 0, done: false, msg: undefined};\r\n\t      hidden(this, DEF, def);\r\n\t      try {\r\n\t        executor(ctx(resolve, def, 1), ctx(reject, def, 1));\r\n\t      } catch(err){\r\n\t        reject.call(def, err);\r\n\t      }\r\n\t    }\r\n\t    assignHidden(Promise[PROTOTYPE], {\r\n\t      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\r\n\t      then: function(onFulfilled, onRejected){\r\n\t        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];\r\n\t        var react = {\r\n\t          ok:   isFunction(onFulfilled) ? onFulfilled : true,\r\n\t          fail: isFunction(onRejected)  ? onRejected  : false\r\n\t        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){\r\n\t          react.res = assertFunction(resolve);\r\n\t          react.rej = assertFunction(reject);\r\n\t        }), def = this[DEF];\r\n\t        def.chain.push(react);\r\n\t        def.state && notify(def);\r\n\t        return P;\r\n\t      },\r\n\t      // 25.4.5.1 Promise.prototype.catch(onRejected)\r\n\t      'catch': function(onRejected){\r\n\t        return this.then(undefined, onRejected);\r\n\t      }\r\n\t    });\r\n\t    assignHidden(Promise, {\r\n\t      // 25.4.4.1 Promise.all(iterable)\r\n\t      all: function(iterable){\r\n\t        var Promise = getConstructor(this)\r\n\t          , values  = [];\r\n\t        return new Promise(function(resolve, reject){\r\n\t          forOf(iterable, false, push, values);\r\n\t          var remaining = values.length\r\n\t            , results   = Array(remaining);\r\n\t          if(remaining)forEach.call(values, function(promise, index){\r\n\t            Promise.resolve(promise).then(function(value){\r\n\t              results[index] = value;\r\n\t              --remaining || resolve(results);\r\n\t            }, reject);\r\n\t          });\r\n\t          else resolve(results);\r\n\t        });\r\n\t      },\r\n\t      // 25.4.4.4 Promise.race(iterable)\r\n\t      race: function(iterable){\r\n\t        var Promise = getConstructor(this);\r\n\t        return new Promise(function(resolve, reject){\r\n\t          forOf(iterable, false, function(promise){\r\n\t            Promise.resolve(promise).then(resolve, reject);\r\n\t          });\r\n\t        });\r\n\t      },\r\n\t      // 25.4.4.5 Promise.reject(r)\r\n\t      reject: function(r){\r\n\t        return new (getConstructor(this))(function(resolve, reject){\r\n\t          reject(r);\r\n\t        });\r\n\t      },\r\n\t      // 25.4.4.6 Promise.resolve(x)\r\n\t      resolve: function(x){\r\n\t        return isObject(x) && DEF in x && getPrototypeOf(x) === this[PROTOTYPE]\r\n\t          ? x : new (getConstructor(this))(function(resolve, reject){\r\n\t            resolve(x);\r\n\t          });\r\n\t      }\r\n\t    });\r\n\t  }(nextTick || setImmediate, safeSymbol('def'));\r\n\t  setToStringTag(Promise, PROMISE);\r\n\t  setSpecies(Promise);\r\n\t  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});\r\n\t}(global[PROMISE]);\n\t\n\t/******************************************************************************\n\t * Module : es6.collections                                                   *\n\t ******************************************************************************/\n\t\n\t// ECMAScript 6 collections shim\r\n\t!function(){\r\n\t  var UID   = safeSymbol('uid')\r\n\t    , O1    = safeSymbol('O1')\r\n\t    , WEAK  = safeSymbol('weak')\r\n\t    , LEAK  = safeSymbol('leak')\r\n\t    , LAST  = safeSymbol('last')\r\n\t    , FIRST = safeSymbol('first')\r\n\t    , SIZE  = DESC ? safeSymbol('size') : 'size'\r\n\t    , uid   = 0\r\n\t    , tmp   = {};\r\n\t  \r\n\t  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){\r\n\t    var ADDER = isMap ? 'set' : 'add'\r\n\t      , proto = C && C[PROTOTYPE]\r\n\t      , O     = {};\r\n\t    function initFromIterable(that, iterable){\r\n\t      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);\r\n\t      return that;\r\n\t    }\r\n\t    function fixSVZ(key, chain){\r\n\t      var method = proto[key];\r\n\t      if(framework)proto[key] = function(a, b){\r\n\t        var result = method.call(this, a === 0 ? 0 : a, b);\r\n\t        return chain ? this : result;\r\n\t      };\r\n\t    }\r\n\t    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){\r\n\t      // create collection constructor\r\n\t      C = isWeak\r\n\t        ? function(iterable){\r\n\t            assertInstance(this, C, NAME);\r\n\t            set(this, UID, uid++);\r\n\t            initFromIterable(this, iterable);\r\n\t          }\r\n\t        : function(iterable){\r\n\t            var that = this;\r\n\t            assertInstance(that, C, NAME);\r\n\t            set(that, O1, create(null));\r\n\t            set(that, SIZE, 0);\r\n\t            set(that, LAST, undefined);\r\n\t            set(that, FIRST, undefined);\r\n\t            initFromIterable(that, iterable);\r\n\t          };\r\n\t      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);\r\n\t      isWeak || defineProperty(C[PROTOTYPE], 'size', {get: function(){\r\n\t        return assertDefined(this[SIZE]);\r\n\t      }});\r\n\t    } else {\r\n\t      var Native = C\r\n\t        , inst   = new C\r\n\t        , chain  = inst[ADDER](isWeak ? {} : -0, 1)\r\n\t        , buggyZero;\r\n\t      // wrap to init collections from iterable\r\n\t      if(!NATIVE_ITERATORS || !C.length){\r\n\t        C = function(iterable){\r\n\t          assertInstance(this, C, NAME);\r\n\t          return initFromIterable(new Native, iterable);\r\n\t        }\r\n\t        C[PROTOTYPE] = proto;\r\n\t        if(framework)proto[CONSTRUCTOR] = C;\r\n\t      }\r\n\t      isWeak || inst[FOR_EACH](function(val, key){\r\n\t        buggyZero = 1 / key === -Infinity;\r\n\t      });\r\n\t      // fix converting -0 key to +0\r\n\t      if(buggyZero){\r\n\t        fixSVZ('delete');\r\n\t        fixSVZ('has');\r\n\t        isMap && fixSVZ('get');\r\n\t      }\r\n\t      // + fix .add & .set for chaining\r\n\t      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);\r\n\t    }\r\n\t    setToStringTag(C, NAME);\r\n\t    setSpecies(C);\r\n\t    \r\n\t    O[NAME] = C;\r\n\t    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);\r\n\t    \r\n\t    // add .keys, .values, .entries, [@@iterator]\r\n\t    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\r\n\t    isWeak || defineStdIterators(C, NAME, function(iterated, kind){\r\n\t      set(this, ITER, {o: iterated, k: kind});\r\n\t    }, function(){\r\n\t      var iter  = this[ITER]\r\n\t        , kind  = iter.k\r\n\t        , entry = iter.l;\r\n\t      // revert to the last existing entry\r\n\t      while(entry && entry.r)entry = entry.p;\r\n\t      // get next entry\r\n\t      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){\r\n\t        // or finish the iteration\r\n\t        iter.o = undefined;\r\n\t        return iterResult(1);\r\n\t      }\r\n\t      // return step by kind\r\n\t      if(kind == KEY)  return iterResult(0, entry.k);\r\n\t      if(kind == VALUE)return iterResult(0, entry.v);\r\n\t                       return iterResult(0, [entry.k, entry.v]);   \r\n\t    }, isMap ? KEY+VALUE : VALUE, !isMap);\r\n\t    \r\n\t    return C;\r\n\t  }\r\n\t  \r\n\t  function fastKey(it, create){\r\n\t    // return primitive with prefix\r\n\t    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;\r\n\t    // can't set id to frozen object\r\n\t    if(isFrozen(it))return 'F';\r\n\t    if(!has(it, UID)){\r\n\t      // not necessary to add id\r\n\t      if(!create)return 'E';\r\n\t      // add missing object id\r\n\t      hidden(it, UID, ++uid);\r\n\t    // return object id with prefix\r\n\t    } return 'O' + it[UID];\r\n\t  }\r\n\t  function getEntry(that, key){\r\n\t    // fast case\r\n\t    var index = fastKey(key), entry;\r\n\t    if(index != 'F')return that[O1][index];\r\n\t    // frozen object case\r\n\t    for(entry = that[FIRST]; entry; entry = entry.n){\r\n\t      if(entry.k == key)return entry;\r\n\t    }\r\n\t  }\r\n\t  function def(that, key, value){\r\n\t    var entry = getEntry(that, key)\r\n\t      , prev, index;\r\n\t    // change existing entry\r\n\t    if(entry)entry.v = value;\r\n\t    // create new entry\r\n\t    else {\r\n\t      that[LAST] = entry = {\r\n\t        i: index = fastKey(key, true), // <- index\r\n\t        k: key,                        // <- key\r\n\t        v: value,                      // <- value\r\n\t        p: prev = that[LAST],          // <- previous entry\r\n\t        n: undefined,                  // <- next entry\r\n\t        r: false                       // <- removed\r\n\t      };\r\n\t      if(!that[FIRST])that[FIRST] = entry;\r\n\t      if(prev)prev.n = entry;\r\n\t      that[SIZE]++;\r\n\t      // add to index\r\n\t      if(index != 'F')that[O1][index] = entry;\r\n\t    } return that;\r\n\t  }\r\n\t\r\n\t  var collectionMethods = {\r\n\t    // 23.1.3.1 Map.prototype.clear()\r\n\t    // 23.2.3.2 Set.prototype.clear()\r\n\t    clear: function(){\r\n\t      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){\r\n\t        entry.r = true;\r\n\t        if(entry.p)entry.p = entry.p.n = undefined;\r\n\t        delete data[entry.i];\r\n\t      }\r\n\t      that[FIRST] = that[LAST] = undefined;\r\n\t      that[SIZE] = 0;\r\n\t    },\r\n\t    // 23.1.3.3 Map.prototype.delete(key)\r\n\t    // 23.2.3.4 Set.prototype.delete(value)\r\n\t    'delete': function(key){\r\n\t      var that  = this\r\n\t        , entry = getEntry(that, key);\r\n\t      if(entry){\r\n\t        var next = entry.n\r\n\t          , prev = entry.p;\r\n\t        delete that[O1][entry.i];\r\n\t        entry.r = true;\r\n\t        if(prev)prev.n = next;\r\n\t        if(next)next.p = prev;\r\n\t        if(that[FIRST] == entry)that[FIRST] = next;\r\n\t        if(that[LAST] == entry)that[LAST] = prev;\r\n\t        that[SIZE]--;\r\n\t      } return !!entry;\r\n\t    },\r\n\t    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\r\n\t    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\r\n\t    forEach: function(callbackfn /*, that = undefined */){\r\n\t      var f = ctx(callbackfn, arguments[1], 3)\r\n\t        , entry;\r\n\t      while(entry = entry ? entry.n : this[FIRST]){\r\n\t        f(entry.v, entry.k, this);\r\n\t        // revert to the last existing entry\r\n\t        while(entry && entry.r)entry = entry.p;\r\n\t      }\r\n\t    },\r\n\t    // 23.1.3.7 Map.prototype.has(key)\r\n\t    // 23.2.3.7 Set.prototype.has(value)\r\n\t    has: function(key){\r\n\t      return !!getEntry(this, key);\r\n\t    }\r\n\t  }\r\n\t  \r\n\t  // 23.1 Map Objects\r\n\t  Map = getCollection(Map, MAP, {\r\n\t    // 23.1.3.6 Map.prototype.get(key)\r\n\t    get: function(key){\r\n\t      var entry = getEntry(this, key);\r\n\t      return entry && entry.v;\r\n\t    },\r\n\t    // 23.1.3.9 Map.prototype.set(key, value)\r\n\t    set: function(key, value){\r\n\t      return def(this, key === 0 ? 0 : key, value);\r\n\t    }\r\n\t  }, collectionMethods, true);\r\n\t  \r\n\t  // 23.2 Set Objects\r\n\t  Set = getCollection(Set, SET, {\r\n\t    // 23.2.3.1 Set.prototype.add(value)\r\n\t    add: function(value){\r\n\t      return def(this, value = value === 0 ? 0 : value, value);\r\n\t    }\r\n\t  }, collectionMethods);\r\n\t  \r\n\t  function defWeak(that, key, value){\r\n\t    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);\r\n\t    else {\r\n\t      has(key, WEAK) || hidden(key, WEAK, {});\r\n\t      key[WEAK][that[UID]] = value;\r\n\t    } return that;\r\n\t  }\r\n\t  function leakStore(that){\r\n\t    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];\r\n\t  }\r\n\t  \r\n\t  var weakMethods = {\r\n\t    // 23.3.3.2 WeakMap.prototype.delete(key)\r\n\t    // 23.4.3.3 WeakSet.prototype.delete(value)\r\n\t    'delete': function(key){\r\n\t      if(!isObject(key))return false;\r\n\t      if(isFrozen(key))return leakStore(this)['delete'](key);\r\n\t      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];\r\n\t    },\r\n\t    // 23.3.3.4 WeakMap.prototype.has(key)\r\n\t    // 23.4.3.4 WeakSet.prototype.has(value)\r\n\t    has: function(key){\r\n\t      if(!isObject(key))return false;\r\n\t      if(isFrozen(key))return leakStore(this).has(key);\r\n\t      return has(key, WEAK) && has(key[WEAK], this[UID]);\r\n\t    }\r\n\t  };\r\n\t  \r\n\t  // 23.3 WeakMap Objects\r\n\t  WeakMap = getCollection(WeakMap, WEAKMAP, {\r\n\t    // 23.3.3.3 WeakMap.prototype.get(key)\r\n\t    get: function(key){\r\n\t      if(isObject(key)){\r\n\t        if(isFrozen(key))return leakStore(this).get(key);\r\n\t        if(has(key, WEAK))return key[WEAK][this[UID]];\r\n\t      }\r\n\t    },\r\n\t    // 23.3.3.5 WeakMap.prototype.set(key, value)\r\n\t    set: function(key, value){\r\n\t      return defWeak(this, key, value);\r\n\t    }\r\n\t  }, weakMethods, true, true);\r\n\t  \r\n\t  // IE11 WeakMap frozen keys fix\r\n\t  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){\r\n\t    forEach.call(array('delete,has,get,set'), function(key){\r\n\t      var method = WeakMap[PROTOTYPE][key];\r\n\t      WeakMap[PROTOTYPE][key] = function(a, b){\r\n\t        // store frozen objects on leaky map\r\n\t        if(isObject(a) && isFrozen(a)){\r\n\t          var result = leakStore(this)[key](a, b);\r\n\t          return key == 'set' ? this : result;\r\n\t        // store all the rest on native weakmap\r\n\t        } return method.call(this, a, b);\r\n\t      };\r\n\t    });\r\n\t  }\r\n\t  \r\n\t  // 23.4 WeakSet Objects\r\n\t  WeakSet = getCollection(WeakSet, WEAKSET, {\r\n\t    // 23.4.3.1 WeakSet.prototype.add(value)\r\n\t    add: function(value){\r\n\t      return defWeak(this, value, true);\r\n\t    }\r\n\t  }, weakMethods, false, true);\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es6.reflect                                                       *\n\t ******************************************************************************/\n\t\n\t!function(){\r\n\t  function Enumerate(iterated){\r\n\t    var keys = [], key;\r\n\t    for(key in iterated)keys.push(key);\r\n\t    set(this, ITER, {o: iterated, a: keys, i: 0});\r\n\t  }\r\n\t  createIterator(Enumerate, OBJECT, function(){\r\n\t    var iter = this[ITER]\r\n\t      , keys = iter.a\r\n\t      , key;\r\n\t    do {\r\n\t      if(iter.i >= keys.length)return iterResult(1);\r\n\t    } while(!((key = keys[iter.i++]) in iter.o));\r\n\t    return iterResult(0, key);\r\n\t  });\r\n\t  \r\n\t  function wrap(fn){\r\n\t    return function(it){\r\n\t      assertObject(it);\r\n\t      try {\r\n\t        return fn.apply(undefined, arguments), true;\r\n\t      } catch(e){\r\n\t        return false;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t  \r\n\t  function reflectGet(target, propertyKey/*, receiver*/){\r\n\t    var receiver = arguments.length < 3 ? target : arguments[2]\r\n\t      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;\r\n\t    if(desc)return has(desc, 'value')\r\n\t      ? desc.value\r\n\t      : desc.get === undefined\r\n\t        ? undefined\r\n\t        : desc.get.call(receiver);\r\n\t    return isObject(proto = getPrototypeOf(target))\r\n\t      ? reflectGet(proto, propertyKey, receiver)\r\n\t      : undefined;\r\n\t  }\r\n\t  function reflectSet(target, propertyKey, V/*, receiver*/){\r\n\t    var receiver = arguments.length < 4 ? target : arguments[3]\r\n\t      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)\r\n\t      , existingDescriptor, proto;\r\n\t    if(!ownDesc){\r\n\t      if(isObject(proto = getPrototypeOf(target))){\r\n\t        return reflectSet(proto, propertyKey, V, receiver);\r\n\t      }\r\n\t      ownDesc = descriptor(0);\r\n\t    }\r\n\t    if(has(ownDesc, 'value')){\r\n\t      if(ownDesc.writable === false || !isObject(receiver))return false;\r\n\t      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);\r\n\t      existingDescriptor.value = V;\r\n\t      return defineProperty(receiver, propertyKey, existingDescriptor), true;\r\n\t    }\r\n\t    return ownDesc.set === undefined\r\n\t      ? false\r\n\t      : (ownDesc.set.call(receiver, V), true);\r\n\t  }\r\n\t  var isExtensible = Object.isExtensible || returnIt;\r\n\t  \r\n\t  var reflect = {\r\n\t    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\r\n\t    apply: ctx(call, apply, 3),\r\n\t    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\r\n\t    construct: construct,\r\n\t    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\r\n\t    defineProperty: wrap(defineProperty),\r\n\t    // 26.1.4 Reflect.deleteProperty(target, propertyKey)\r\n\t    deleteProperty: function(target, propertyKey){\r\n\t      var desc = getOwnDescriptor(assertObject(target), propertyKey);\r\n\t      return desc && !desc.configurable ? false : delete target[propertyKey];\r\n\t    },\r\n\t    // 26.1.5 Reflect.enumerate(target)\r\n\t    enumerate: function(target){\r\n\t      return new Enumerate(assertObject(target));\r\n\t    },\r\n\t    // 26.1.6 Reflect.get(target, propertyKey [, receiver])\r\n\t    get: reflectGet,\r\n\t    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\r\n\t    getOwnPropertyDescriptor: function(target, propertyKey){\r\n\t      return getOwnDescriptor(assertObject(target), propertyKey);\r\n\t    },\r\n\t    // 26.1.8 Reflect.getPrototypeOf(target)\r\n\t    getPrototypeOf: function(target){\r\n\t      return getPrototypeOf(assertObject(target));\r\n\t    },\r\n\t    // 26.1.9 Reflect.has(target, propertyKey)\r\n\t    has: function(target, propertyKey){\r\n\t      return propertyKey in target;\r\n\t    },\r\n\t    // 26.1.10 Reflect.isExtensible(target)\r\n\t    isExtensible: function(target){\r\n\t      return !!isExtensible(assertObject(target));\r\n\t    },\r\n\t    // 26.1.11 Reflect.ownKeys(target)\r\n\t    ownKeys: ownKeys,\r\n\t    // 26.1.12 Reflect.preventExtensions(target)\r\n\t    preventExtensions: wrap(Object.preventExtensions || returnIt),\r\n\t    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\r\n\t    set: reflectSet\r\n\t  }\r\n\t  // 26.1.14 Reflect.setPrototypeOf(target, proto)\r\n\t  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){\r\n\t    return setPrototypeOf(assertObject(target), proto), true;\r\n\t  };\r\n\t  \r\n\t  $define(GLOBAL, {Reflect: {}});\r\n\t  $define(STATIC, 'Reflect', reflect);\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es7.proposals                                                     *\n\t ******************************************************************************/\n\t\n\t!function(){\r\n\t  $define(PROTO, ARRAY, {\r\n\t    // https://github.com/domenic/Array.prototype.includes\r\n\t    includes: createArrayContains(true)\r\n\t  });\r\n\t  $define(PROTO, STRING, {\r\n\t    // https://github.com/mathiasbynens/String.prototype.at\r\n\t    at: createPointAt(true)\r\n\t  });\r\n\t  \r\n\t  function createObjectToArray(isEntries){\r\n\t    return function(object){\r\n\t      var O      = toObject(object)\r\n\t        , keys   = getKeys(object)\r\n\t        , length = keys.length\r\n\t        , i      = 0\r\n\t        , result = Array(length)\r\n\t        , key;\r\n\t      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];\r\n\t      else while(length > i)result[i] = O[keys[i++]];\r\n\t      return result;\r\n\t    }\r\n\t  }\r\n\t  $define(STATIC, OBJECT, {\r\n\t    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues\r\n\t    values: createObjectToArray(false),\r\n\t    entries: createObjectToArray(true)\r\n\t  });\r\n\t  $define(STATIC, REGEXP, {\r\n\t    // https://gist.github.com/kangax/9698100\r\n\t    escape: createReplacer(/([\\\\\\-[\\]{}()*+?.,^$|])/g, '\\\\$1', true)\r\n\t  });\r\n\t}();\n\t\n\t/******************************************************************************\n\t * Module : es7.abstract-refs                                                 *\n\t ******************************************************************************/\n\t\n\t// https://github.com/zenparsing/es-abstract-refs\r\n\t!function(REFERENCE){\r\n\t  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);\r\n\t  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)\r\n\t    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);\r\n\t  \r\n\t  $define(STATIC, SYMBOL, {\r\n\t    referenceGet: REFERENCE_GET,\r\n\t    referenceSet: REFERENCE_SET,\r\n\t    referenceDelete: REFERENCE_DELETE\r\n\t  });\r\n\t  \r\n\t  hidden(FunctionProto, REFERENCE_GET, returnThis);\r\n\t  \r\n\t  function setMapMethods(Constructor){\r\n\t    if(Constructor){\r\n\t      var MapProto = Constructor[PROTOTYPE];\r\n\t      hidden(MapProto, REFERENCE_GET, MapProto.get);\r\n\t      hidden(MapProto, REFERENCE_SET, MapProto.set);\r\n\t      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);\r\n\t    }\r\n\t  }\r\n\t  setMapMethods(Map);\r\n\t  setMapMethods(WeakMap);\r\n\t}('reference');\n\t\n\t/******************************************************************************\n\t * Module : js.array.statics                                                  *\n\t ******************************************************************************/\n\t\n\t// JavaScript 1.6 / Strawman array statics shim\r\n\t!function(arrayStatics){\r\n\t  function setArrayStatics(keys, length){\r\n\t    forEach.call(array(keys), function(key){\r\n\t      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);\r\n\t    });\r\n\t  }\r\n\t  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);\r\n\t  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);\r\n\t  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +\r\n\t                  'reduce,reduceRight,copyWithin,fill,turn');\r\n\t  $define(STATIC, ARRAY, arrayStatics);\r\n\t}({});\n\t\n\t/******************************************************************************\n\t * Module : web.dom.itarable                                                  *\n\t ******************************************************************************/\n\t\n\t!function(NodeList){\r\n\t  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){\r\n\t    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);\r\n\t  }\r\n\t  Iterators.NodeList = Iterators[ARRAY];\r\n\t}(global.NodeList);\n\t}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);\n\n/***/ },\n\n/***/ 22:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var iteratorSymbol =\n\t    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    genFun.__proto__ = GeneratorFunctionPrototype;\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    return new Promise(function(resolve, reject) {\n\t      var generator = wrap(innerFn, outerFn, self, tryLocsList);\n\t      var callNext = step.bind(generator.next);\n\t      var callThrow = step.bind(generator[\"throw\"]);\n\t\n\t      function step(arg) {\n\t        var record = tryCatch(this, null, arg);\n\t        if (record.type === \"throw\") {\n\t          reject(record.arg);\n\t          return;\n\t        }\n\t\n\t        var info = record.arg;\n\t        if (info.done) {\n\t          resolve(info.value);\n\t        } else {\n\t          Promise.resolve(info.value).then(callNext, callThrow);\n\t        }\n\t      }\n\t\n\t      callNext();\n\t    });\n\t  };\n\t\n\t  function Generator(innerFn, outerFn, self, tryLocsList) {\n\t    var generator = outerFn ? Object.create(outerFn.prototype) : this;\n\t    var context = new Context(tryLocsList);\n\t    var state = GenStateSuspendedStart;\n\t\n\t    function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var record = tryCatch(\n\t            delegate.iterator[method],\n\t            delegate.iterator,\n\t            arg\n\t          );\n\t\n\t          if (record.type === \"throw\") {\n\t            context.delegate = null;\n\t\n\t            // Like returning generator.throw(uncaught), but without the\n\t            // overhead of an extra function call.\n\t            method = \"throw\";\n\t            arg = record.arg;\n\t\n\t            continue;\n\t          }\n\t\n\t          // Delegate generator ran and handled its own exceptions so\n\t          // regardless of what the method was, we continue as if it is\n\t          // \"next\" with an undefined arg.\n\t          method = \"next\";\n\t          arg = undefined;\n\t\n\t          var info = record.arg;\n\t          if (info.done) {\n\t            context[delegate.resultName] = info.value;\n\t            context.next = delegate.nextLoc;\n\t          } else {\n\t            state = GenStateSuspendedYield;\n\t            return info;\n\t          }\n\t\n\t          context.delegate = null;\n\t        }\n\t\n\t        if (method === \"next\") {\n\t          if (state === GenStateSuspendedStart &&\n\t              typeof arg !== \"undefined\") {\n\t            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t            throw new TypeError(\n\t              \"attempt to send \" + JSON.stringify(arg) + \" to newborn generator\"\n\t            );\n\t          }\n\t\n\t          if (state === GenStateSuspendedYield) {\n\t            context.sent = arg;\n\t          } else {\n\t            delete context.sent;\n\t          }\n\t\n\t        } else if (method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw arg;\n\t          }\n\t\n\t          if (context.dispatchException(arg)) {\n\t            // If the dispatched exception was caught by a catch block,\n\t            // then let that catch block handle the exception normally.\n\t            method = \"next\";\n\t            arg = undefined;\n\t          }\n\t\n\t        } else if (method === \"return\") {\n\t          context.abrupt(\"return\", arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          var info = {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            if (context.delegate && method === \"next\") {\n\t              // Deliberately forget the last sent value so that we don't\n\t              // accidentally pass it on to the delegate.\n\t              arg = undefined;\n\t            }\n\t          } else {\n\t            return info;\n\t          }\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t\n\t          if (method === \"next\") {\n\t            context.dispatchException(record.arg);\n\t          } else {\n\t            arg = record.arg;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    generator.next = invoke.bind(generator, \"next\");\n\t    generator[\"throw\"] = invoke.bind(generator, \"throw\");\n\t    generator[\"return\"] = invoke.bind(generator, \"return\");\n\t\n\t    return generator;\n\t  }\n\t\n\t  Gp[iteratorSymbol] = function() {\n\t    return this;\n\t  };\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset();\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function() {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      this.sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      // Pre-initialize at least 20 temporary variables to enable hidden\n\t      // class optimizations for simple generators.\n\t      for (var tempIndex = 0, tempName;\n\t           hasOwn.call(this, tempName = \"t\" + tempIndex) || tempIndex < 20;\n\t           ++tempIndex) {\n\t        this[tempName] = null;\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t        return !!caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    _findFinallyEntry: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") && (\n\t              entry.finallyLoc === finallyLoc ||\n\t              this.prev < entry.finallyLoc)) {\n\t          return entry;\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      var entry = this._findFinallyEntry();\n\t      var record = entry ? entry.completion : {};\n\t\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (entry) {\n\t        this.next = entry.finallyLoc;\n\t      } else {\n\t        this.complete(record);\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = record.arg;\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      var entry = this._findFinallyEntry(finallyLoc);\n\t      return this.complete(entry.completion, entry.afterLoc);\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 23:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(20);\n\n\n/***/ },\n\n/***/ 24:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };\n\t\n\t__webpack_require__(23);\n\t\n\tvar debug = _interopRequire(__webpack_require__(5));\n\t\n\tvar Bluebird = _interopRequire(__webpack_require__(25));\n\t\n\tglobal.DEBUG = debug;\n\tglobal.Promise = Bluebird;\n\t\n\tPromise.prototype.log = function () {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return this.tap(function (value) {\n\t    return console.log.apply(console, _toConsumableArray(args.concat([value])));\n\t  });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 25:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {/* @preserve\n\t * The MIT License (MIT)\n\t * \n\t * Copyright (c) 2014 Petka Antonov\n\t * \n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:</p>\n\t * \n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\t * \n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t * THE SOFTWARE.\n\t * \n\t */\n\t/**\n\t * bluebird build version 2.9.12\n\t * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, progress, cancel, using, filter, any, each, timers\n\t*/\n\t!function(e){if(true)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise) {\n\tvar SomePromiseArray = Promise._SomePromiseArray;\n\tfunction any(promises) {\n\t    var ret = new SomePromiseArray(promises);\n\t    var promise = ret.promise();\n\t    ret.setHowMany(1);\n\t    ret.setUnwrap();\n\t    ret.init();\n\t    return promise;\n\t}\n\t\n\tPromise.any = function (promises) {\n\t    return any(promises);\n\t};\n\t\n\tPromise.prototype.any = function () {\n\t    return any(this);\n\t};\n\t\n\t};\n\t\n\t},{}],2:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar firstLineError;\n\ttry {throw new Error(); } catch (e) {firstLineError = e;}\n\tvar schedule = _dereq_(\"./schedule.js\");\n\tvar Queue = _dereq_(\"./queue.js\");\n\tvar _process = typeof process !== \"undefined\" ? process : undefined;\n\t\n\tfunction Async() {\n\t    this._isTickUsed = false;\n\t    this._lateQueue = new Queue(16);\n\t    this._normalQueue = new Queue(16);\n\t    var self = this;\n\t    this.drainQueues = function () {\n\t        self._drainQueues();\n\t    };\n\t    this._schedule =\n\t        schedule.isStatic ? schedule(this.drainQueues) : schedule;\n\t}\n\t\n\tAsync.prototype.haveItemsQueued = function () {\n\t    return this._normalQueue.length() > 0;\n\t};\n\t\n\tAsync.prototype._withDomain = function(fn) {\n\t    if (_process !== undefined &&\n\t        _process.domain != null &&\n\t        !fn.domain) {\n\t        fn = _process.domain.bind(fn);\n\t    }\n\t    return fn;\n\t};\n\t\n\tAsync.prototype.throwLater = function(fn, arg) {\n\t    if (arguments.length === 1) {\n\t        arg = fn;\n\t        fn = function () { throw arg; };\n\t    }\n\t    fn = this._withDomain(fn);\n\t    if (typeof setTimeout !== \"undefined\") {\n\t        setTimeout(function() {\n\t            fn(arg);\n\t        }, 0);\n\t    } else try {\n\t        this._schedule(function() {\n\t            fn(arg);\n\t        });\n\t    } catch (e) {\n\t        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n\t    }\n\t};\n\t\n\tAsync.prototype.invokeLater = function (fn, receiver, arg) {\n\t    fn = this._withDomain(fn);\n\t    this._lateQueue.push(fn, receiver, arg);\n\t    this._queueTick();\n\t};\n\t\n\tAsync.prototype.invokeFirst = function (fn, receiver, arg) {\n\t    fn = this._withDomain(fn);\n\t    this._normalQueue.unshift(fn, receiver, arg);\n\t    this._queueTick();\n\t};\n\t\n\tAsync.prototype.invoke = function (fn, receiver, arg) {\n\t    fn = this._withDomain(fn);\n\t    this._normalQueue.push(fn, receiver, arg);\n\t    this._queueTick();\n\t};\n\t\n\tAsync.prototype.settlePromises = function(promise) {\n\t    this._normalQueue._pushOne(promise);\n\t    this._queueTick();\n\t};\n\t\n\tAsync.prototype._drainQueue = function(queue) {\n\t    while (queue.length() > 0) {\n\t        var fn = queue.shift();\n\t        if (typeof fn !== \"function\") {\n\t            fn._settlePromises();\n\t            continue;\n\t        }\n\t        var receiver = queue.shift();\n\t        var arg = queue.shift();\n\t        fn.call(receiver, arg);\n\t    }\n\t};\n\t\n\tAsync.prototype._drainQueues = function () {\n\t    this._drainQueue(this._normalQueue);\n\t    this._reset();\n\t    this._drainQueue(this._lateQueue);\n\t};\n\t\n\tAsync.prototype._queueTick = function () {\n\t    if (!this._isTickUsed) {\n\t        this._isTickUsed = true;\n\t        this._schedule(this.drainQueues);\n\t    }\n\t};\n\t\n\tAsync.prototype._reset = function () {\n\t    this._isTickUsed = false;\n\t};\n\t\n\tmodule.exports = new Async();\n\tmodule.exports.firstLineError = firstLineError;\n\t\n\t},{\"./queue.js\":28,\"./schedule.js\":31}],3:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL, tryConvertToPromise) {\n\tvar rejectThis = function(_, e) {\n\t    this._reject(e);\n\t};\n\t\n\tvar targetRejected = function(e, context) {\n\t    context.promiseRejectionQueued = true;\n\t    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n\t};\n\t\n\tvar bindingResolved = function(thisArg, context) {\n\t    this._setBoundTo(thisArg);\n\t    if (this._isPending()) {\n\t        this._resolveCallback(context.target);\n\t    }\n\t};\n\t\n\tvar bindingRejected = function(e, context) {\n\t    if (!context.promiseRejectionQueued) this._reject(e);\n\t};\n\t\n\tPromise.prototype.bind = function (thisArg) {\n\t    var maybePromise = tryConvertToPromise(thisArg);\n\t    var ret = new Promise(INTERNAL);\n\t    ret._propagateFrom(this, 1);\n\t    var target = this._target();\n\t    if (maybePromise instanceof Promise) {\n\t        var context = {\n\t            promiseRejectionQueued: false,\n\t            promise: ret,\n\t            target: target,\n\t            bindingPromise: maybePromise\n\t        };\n\t        target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n\t        maybePromise._then(\n\t            bindingResolved, bindingRejected, ret._progress, ret, context);\n\t    } else {\n\t        ret._setBoundTo(thisArg);\n\t        ret._resolveCallback(target);\n\t    }\n\t    return ret;\n\t};\n\t\n\tPromise.prototype._setBoundTo = function (obj) {\n\t    if (obj !== undefined) {\n\t        this._bitField = this._bitField | 131072;\n\t        this._boundTo = obj;\n\t    } else {\n\t        this._bitField = this._bitField & (~131072);\n\t    }\n\t};\n\t\n\tPromise.prototype._isBound = function () {\n\t    return (this._bitField & 131072) === 131072;\n\t};\n\t\n\tPromise.bind = function (thisArg, value) {\n\t    var maybePromise = tryConvertToPromise(thisArg);\n\t    var ret = new Promise(INTERNAL);\n\t\n\t    if (maybePromise instanceof Promise) {\n\t        maybePromise._then(function(thisArg) {\n\t            ret._setBoundTo(thisArg);\n\t            ret._resolveCallback(value);\n\t        }, ret._reject, ret._progress, ret, null);\n\t    } else {\n\t        ret._setBoundTo(thisArg);\n\t        ret._resolveCallback(value);\n\t    }\n\t    return ret;\n\t};\n\t};\n\t\n\t},{}],4:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar old;\n\tif (typeof Promise !== \"undefined\") old = Promise;\n\tfunction noConflict() {\n\t    try { if (Promise === bluebird) Promise = old; }\n\t    catch (e) {}\n\t    return bluebird;\n\t}\n\tvar bluebird = _dereq_(\"./promise.js\")();\n\tbluebird.noConflict = noConflict;\n\tmodule.exports = bluebird;\n\t\n\t},{\"./promise.js\":23}],5:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar cr = Object.create;\n\tif (cr) {\n\t    var callerCache = cr(null);\n\t    var getterCache = cr(null);\n\t    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n\t}\n\t\n\tmodule.exports = function(Promise) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar canEvaluate = util.canEvaluate;\n\tvar isIdentifier = util.isIdentifier;\n\t\n\tvar getMethodCaller;\n\tvar getGetter;\n\tif (false) {\n\tvar makeMethodCaller = function (methodName) {\n\t    return new Function(\"ensureMethod\", \"                                    \\n\\\n\t        return function(obj) {                                               \\n\\\n\t            'use strict'                                                     \\n\\\n\t            var len = this.length;                                           \\n\\\n\t            ensureMethod(obj, 'methodName');                                 \\n\\\n\t            switch(len) {                                                    \\n\\\n\t                case 1: return obj.methodName(this[0]);                      \\n\\\n\t                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n\t                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n\t                case 0: return obj.methodName();                             \\n\\\n\t                default:                                                     \\n\\\n\t                    return obj.methodName.apply(obj, this);                  \\n\\\n\t            }                                                                \\n\\\n\t        };                                                                   \\n\\\n\t        \".replace(/methodName/g, methodName))(ensureMethod);\n\t};\n\t\n\tvar makeGetter = function (propertyName) {\n\t    return new Function(\"obj\", \"                                             \\n\\\n\t        'use strict';                                                        \\n\\\n\t        return obj.propertyName;                                             \\n\\\n\t        \".replace(\"propertyName\", propertyName));\n\t};\n\t\n\tvar getCompiled = function(name, compiler, cache) {\n\t    var ret = cache[name];\n\t    if (typeof ret !== \"function\") {\n\t        if (!isIdentifier(name)) {\n\t            return null;\n\t        }\n\t        ret = compiler(name);\n\t        cache[name] = ret;\n\t        cache[\" size\"]++;\n\t        if (cache[\" size\"] > 512) {\n\t            var keys = Object.keys(cache);\n\t            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n\t            cache[\" size\"] = keys.length - 256;\n\t        }\n\t    }\n\t    return ret;\n\t};\n\t\n\tgetMethodCaller = function(name) {\n\t    return getCompiled(name, makeMethodCaller, callerCache);\n\t};\n\t\n\tgetGetter = function(name) {\n\t    return getCompiled(name, makeGetter, getterCache);\n\t};\n\t}\n\t\n\tfunction ensureMethod(obj, methodName) {\n\t    var fn;\n\t    if (obj != null) fn = obj[methodName];\n\t    if (typeof fn !== \"function\") {\n\t        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n\t            util.toString(methodName) + \"'\";\n\t        throw new Promise.TypeError(message);\n\t    }\n\t    return fn;\n\t}\n\t\n\tfunction caller(obj) {\n\t    var methodName = this.pop();\n\t    var fn = ensureMethod(obj, methodName);\n\t    return fn.apply(obj, this);\n\t}\n\tPromise.prototype.call = function (methodName) {\n\t    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n\t    if (false) {\n\t        if (canEvaluate) {\n\t            var maybeCaller = getMethodCaller(methodName);\n\t            if (maybeCaller !== null) {\n\t                return this._then(\n\t                    maybeCaller, undefined, undefined, args, undefined);\n\t            }\n\t        }\n\t    }\n\t    args.push(methodName);\n\t    return this._then(caller, undefined, undefined, args, undefined);\n\t};\n\t\n\tfunction namedGetter(obj) {\n\t    return obj[this];\n\t}\n\tfunction indexedGetter(obj) {\n\t    var index = +this;\n\t    if (index < 0) index = Math.max(0, index + obj.length);\n\t    return obj[index];\n\t}\n\tPromise.prototype.get = function (propertyName) {\n\t    var isIndex = (typeof propertyName === \"number\");\n\t    var getter;\n\t    if (!isIndex) {\n\t        if (canEvaluate) {\n\t            var maybeGetter = getGetter(propertyName);\n\t            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n\t        } else {\n\t            getter = namedGetter;\n\t        }\n\t    } else {\n\t        getter = indexedGetter;\n\t    }\n\t    return this._then(getter, undefined, undefined, propertyName, undefined);\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],6:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise) {\n\tvar errors = _dereq_(\"./errors.js\");\n\tvar async = _dereq_(\"./async.js\");\n\tvar CancellationError = errors.CancellationError;\n\t\n\tPromise.prototype._cancel = function (reason) {\n\t    if (!this.isCancellable()) return this;\n\t    var parent;\n\t    var promiseToReject = this;\n\t    while ((parent = promiseToReject._cancellationParent) !== undefined &&\n\t        parent.isCancellable()) {\n\t        promiseToReject = parent;\n\t    }\n\t    this._unsetCancellable();\n\t    promiseToReject._target()._rejectCallback(reason, false, true);\n\t};\n\t\n\tPromise.prototype.cancel = function (reason) {\n\t    if (!this.isCancellable()) return this;\n\t    if (reason === undefined) reason = new CancellationError();\n\t    async.invokeLater(this._cancel, this, reason);\n\t    return this;\n\t};\n\t\n\tPromise.prototype.cancellable = function () {\n\t    if (this._cancellable()) return this;\n\t    this._setCancellable();\n\t    this._cancellationParent = undefined;\n\t    return this;\n\t};\n\t\n\tPromise.prototype.uncancellable = function () {\n\t    var ret = this.then();\n\t    ret._unsetCancellable();\n\t    return ret;\n\t};\n\t\n\tPromise.prototype.fork = function (didFulfill, didReject, didProgress) {\n\t    var ret = this._then(didFulfill, didReject, didProgress,\n\t                         undefined, undefined);\n\t\n\t    ret._setCancellable();\n\t    ret._cancellationParent = undefined;\n\t    return ret;\n\t};\n\t};\n\t\n\t},{\"./async.js\":2,\"./errors.js\":13}],7:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function() {\n\tvar async = _dereq_(\"./async.js\");\n\tvar util = _dereq_(\"./util.js\");\n\tvar bluebirdFramePattern =\n\t    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\n\tvar stackFramePattern = null;\n\tvar formatStack = null;\n\tvar indentStackFrames = false;\n\tvar warn;\n\t\n\tfunction CapturedTrace(parent) {\n\t    this._parent = parent;\n\t    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n\t    captureStackTrace(this, CapturedTrace);\n\t    if (length > 32) this.uncycle();\n\t}\n\tutil.inherits(CapturedTrace, Error);\n\t\n\tCapturedTrace.prototype.uncycle = function() {\n\t    var length = this._length;\n\t    if (length < 2) return;\n\t    var nodes = [];\n\t    var stackToIndex = {};\n\t\n\t    for (var i = 0, node = this; node !== undefined; ++i) {\n\t        nodes.push(node);\n\t        node = node._parent;\n\t    }\n\t    length = this._length = i;\n\t    for (var i = length - 1; i >= 0; --i) {\n\t        var stack = nodes[i].stack;\n\t        if (stackToIndex[stack] === undefined) {\n\t            stackToIndex[stack] = i;\n\t        }\n\t    }\n\t    for (var i = 0; i < length; ++i) {\n\t        var currentStack = nodes[i].stack;\n\t        var index = stackToIndex[currentStack];\n\t        if (index !== undefined && index !== i) {\n\t            if (index > 0) {\n\t                nodes[index - 1]._parent = undefined;\n\t                nodes[index - 1]._length = 1;\n\t            }\n\t            nodes[i]._parent = undefined;\n\t            nodes[i]._length = 1;\n\t            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\t\n\t            if (index < length - 1) {\n\t                cycleEdgeNode._parent = nodes[index + 1];\n\t                cycleEdgeNode._parent.uncycle();\n\t                cycleEdgeNode._length =\n\t                    cycleEdgeNode._parent._length + 1;\n\t            } else {\n\t                cycleEdgeNode._parent = undefined;\n\t                cycleEdgeNode._length = 1;\n\t            }\n\t            var currentChildLength = cycleEdgeNode._length + 1;\n\t            for (var j = i - 2; j >= 0; --j) {\n\t                nodes[j]._length = currentChildLength;\n\t                currentChildLength++;\n\t            }\n\t            return;\n\t        }\n\t    }\n\t};\n\t\n\tCapturedTrace.prototype.parent = function() {\n\t    return this._parent;\n\t};\n\t\n\tCapturedTrace.prototype.hasParent = function() {\n\t    return this._parent !== undefined;\n\t};\n\t\n\tCapturedTrace.prototype.attachExtraTrace = function(error) {\n\t    if (error.__stackCleaned__) return;\n\t    this.uncycle();\n\t    var parsed = CapturedTrace.parseStackAndMessage(error);\n\t    var message = parsed.message;\n\t    var stacks = [parsed.stack];\n\t\n\t    var trace = this;\n\t    while (trace !== undefined) {\n\t        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n\t        trace = trace._parent;\n\t    }\n\t    removeCommonRoots(stacks);\n\t    removeDuplicateOrEmptyJumps(stacks);\n\t    error.stack = reconstructStack(message, stacks);\n\t    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n\t};\n\t\n\tfunction reconstructStack(message, stacks) {\n\t    for (var i = 0; i < stacks.length - 1; ++i) {\n\t        stacks[i].push(\"From previous event:\");\n\t        stacks[i] = stacks[i].join(\"\\n\");\n\t    }\n\t    if (i < stacks.length) {\n\t        stacks[i] = stacks[i].join(\"\\n\");\n\t    }\n\t    return message + \"\\n\" + stacks.join(\"\\n\");\n\t}\n\t\n\tfunction removeDuplicateOrEmptyJumps(stacks) {\n\t    for (var i = 0; i < stacks.length; ++i) {\n\t        if (stacks[i].length === 0 ||\n\t            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n\t            stacks.splice(i, 1);\n\t            i--;\n\t        }\n\t    }\n\t}\n\t\n\tfunction removeCommonRoots(stacks) {\n\t    var current = stacks[0];\n\t    for (var i = 1; i < stacks.length; ++i) {\n\t        var prev = stacks[i];\n\t        var currentLastIndex = current.length - 1;\n\t        var currentLastLine = current[currentLastIndex];\n\t        var commonRootMeetPoint = -1;\n\t\n\t        for (var j = prev.length - 1; j >= 0; --j) {\n\t            if (prev[j] === currentLastLine) {\n\t                commonRootMeetPoint = j;\n\t                break;\n\t            }\n\t        }\n\t\n\t        for (var j = commonRootMeetPoint; j >= 0; --j) {\n\t            var line = prev[j];\n\t            if (current[currentLastIndex] === line) {\n\t                current.pop();\n\t                currentLastIndex--;\n\t            } else {\n\t                break;\n\t            }\n\t        }\n\t        current = prev;\n\t    }\n\t}\n\t\n\tfunction cleanStack(stack) {\n\t    var ret = [];\n\t    for (var i = 0; i < stack.length; ++i) {\n\t        var line = stack[i];\n\t        var isTraceLine = stackFramePattern.test(line) ||\n\t            \"    (No stack trace)\" === line;\n\t        var isInternalFrame = isTraceLine && shouldIgnore(line);\n\t        if (isTraceLine && !isInternalFrame) {\n\t            if (indentStackFrames && line.charAt(0) !== \" \") {\n\t                line = \"    \" + line;\n\t            }\n\t            ret.push(line);\n\t        }\n\t    }\n\t    return ret;\n\t}\n\t\n\tfunction stackFramesAsArray(error) {\n\t    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n\t    for (var i = 0; i < stack.length; ++i) {\n\t        var line = stack[i];\n\t        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n\t            break;\n\t        }\n\t    }\n\t    if (i > 0) {\n\t        stack = stack.slice(i);\n\t    }\n\t    return stack;\n\t}\n\t\n\tCapturedTrace.parseStackAndMessage = function(error) {\n\t    var stack = error.stack;\n\t    var message = error.toString();\n\t    stack = typeof stack === \"string\" && stack.length > 0\n\t                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n\t    return {\n\t        message: message,\n\t        stack: cleanStack(stack)\n\t    };\n\t};\n\t\n\tCapturedTrace.formatAndLogError = function(error, title) {\n\t    if (typeof console !== \"undefined\") {\n\t        var message;\n\t        if (typeof error === \"object\" || typeof error === \"function\") {\n\t            var stack = error.stack;\n\t            message = title + formatStack(stack, error);\n\t        } else {\n\t            message = title + String(error);\n\t        }\n\t        if (typeof warn === \"function\") {\n\t            warn(message);\n\t        } else if (typeof console.log === \"function\" ||\n\t            typeof console.log === \"object\") {\n\t            console.log(message);\n\t        }\n\t    }\n\t};\n\t\n\tCapturedTrace.unhandledRejection = function (reason) {\n\t    CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n\t};\n\t\n\tCapturedTrace.isSupported = function () {\n\t    return typeof captureStackTrace === \"function\";\n\t};\n\t\n\tCapturedTrace.fireRejectionEvent =\n\tfunction(name, localHandler, reason, promise) {\n\t    var localEventFired = false;\n\t    try {\n\t        if (typeof localHandler === \"function\") {\n\t            localEventFired = true;\n\t            if (name === \"rejectionHandled\") {\n\t                localHandler(promise);\n\t            } else {\n\t                localHandler(reason, promise);\n\t            }\n\t        }\n\t    } catch (e) {\n\t        async.throwLater(e);\n\t    }\n\t\n\t    var globalEventFired = false;\n\t    try {\n\t        globalEventFired = fireGlobalEvent(name, reason, promise);\n\t    } catch (e) {\n\t        globalEventFired = true;\n\t        async.throwLater(e);\n\t    }\n\t\n\t    var domEventFired = false;\n\t    if (fireDomEvent) {\n\t        try {\n\t            domEventFired = fireDomEvent(name.toLowerCase(), {\n\t                reason: reason,\n\t                promise: promise\n\t            });\n\t        } catch (e) {\n\t            domEventFired = true;\n\t            async.throwLater(e);\n\t        }\n\t    }\n\t\n\t    if (!globalEventFired && !localEventFired && !domEventFired &&\n\t        name === \"unhandledRejection\") {\n\t        CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n\t    }\n\t};\n\t\n\tfunction formatNonError(obj) {\n\t    var str;\n\t    if (typeof obj === \"function\") {\n\t        str = \"[function \" +\n\t            (obj.name || \"anonymous\") +\n\t            \"]\";\n\t    } else {\n\t        str = obj.toString();\n\t        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n\t        if (ruselessToString.test(str)) {\n\t            try {\n\t                var newStr = JSON.stringify(obj);\n\t                str = newStr;\n\t            }\n\t            catch(e) {\n\t\n\t            }\n\t        }\n\t        if (str.length === 0) {\n\t            str = \"(empty array)\";\n\t        }\n\t    }\n\t    return (\"(<\" + snip(str) + \">, no stack trace)\");\n\t}\n\t\n\tfunction snip(str) {\n\t    var maxChars = 41;\n\t    if (str.length < maxChars) {\n\t        return str;\n\t    }\n\t    return str.substr(0, maxChars - 3) + \"...\";\n\t}\n\t\n\tvar shouldIgnore = function() { return false; };\n\tvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\n\tfunction parseLineInfo(line) {\n\t    var matches = line.match(parseLineInfoRegex);\n\t    if (matches) {\n\t        return {\n\t            fileName: matches[1],\n\t            line: parseInt(matches[2], 10)\n\t        };\n\t    }\n\t}\n\tCapturedTrace.setBounds = function(firstLineError, lastLineError) {\n\t    if (!CapturedTrace.isSupported()) return;\n\t    var firstStackLines = firstLineError.stack.split(\"\\n\");\n\t    var lastStackLines = lastLineError.stack.split(\"\\n\");\n\t    var firstIndex = -1;\n\t    var lastIndex = -1;\n\t    var firstFileName;\n\t    var lastFileName;\n\t    for (var i = 0; i < firstStackLines.length; ++i) {\n\t        var result = parseLineInfo(firstStackLines[i]);\n\t        if (result) {\n\t            firstFileName = result.fileName;\n\t            firstIndex = result.line;\n\t            break;\n\t        }\n\t    }\n\t    for (var i = 0; i < lastStackLines.length; ++i) {\n\t        var result = parseLineInfo(lastStackLines[i]);\n\t        if (result) {\n\t            lastFileName = result.fileName;\n\t            lastIndex = result.line;\n\t            break;\n\t        }\n\t    }\n\t    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n\t        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n\t        return;\n\t    }\n\t\n\t    shouldIgnore = function(line) {\n\t        if (bluebirdFramePattern.test(line)) return true;\n\t        var info = parseLineInfo(line);\n\t        if (info) {\n\t            if (info.fileName === firstFileName &&\n\t                (firstIndex <= info.line && info.line <= lastIndex)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t};\n\t\n\tvar captureStackTrace = (function stackDetection() {\n\t    var v8stackFramePattern = /^\\s*at\\s*/;\n\t    var v8stackFormatter = function(stack, error) {\n\t        if (typeof stack === \"string\") return stack;\n\t\n\t        if (error.name !== undefined &&\n\t            error.message !== undefined) {\n\t            return error.toString();\n\t        }\n\t        return formatNonError(error);\n\t    };\n\t\n\t    if (typeof Error.stackTraceLimit === \"number\" &&\n\t        typeof Error.captureStackTrace === \"function\") {\n\t        Error.stackTraceLimit = Error.stackTraceLimit + 6;\n\t        stackFramePattern = v8stackFramePattern;\n\t        formatStack = v8stackFormatter;\n\t        var captureStackTrace = Error.captureStackTrace;\n\t\n\t        shouldIgnore = function(line) {\n\t            return bluebirdFramePattern.test(line);\n\t        };\n\t        return function(receiver, ignoreUntil) {\n\t            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n\t            captureStackTrace(receiver, ignoreUntil);\n\t            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n\t        };\n\t    }\n\t    var err = new Error();\n\t\n\t    if (typeof err.stack === \"string\" &&\n\t        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n\t        stackFramePattern = /@/;\n\t        formatStack = v8stackFormatter;\n\t        indentStackFrames = true;\n\t        return function captureStackTrace(o) {\n\t            o.stack = new Error().stack;\n\t        };\n\t    }\n\t\n\t    var hasStackAfterThrow;\n\t    try { throw new Error(); }\n\t    catch(e) {\n\t        hasStackAfterThrow = (\"stack\" in e);\n\t    }\n\t    if (!(\"stack\" in err) && hasStackAfterThrow) {\n\t        stackFramePattern = v8stackFramePattern;\n\t        formatStack = v8stackFormatter;\n\t        return function captureStackTrace(o) {\n\t            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n\t            try { throw new Error(); }\n\t            catch(e) { o.stack = e.stack; }\n\t            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n\t        };\n\t    }\n\t\n\t    formatStack = function(stack, error) {\n\t        if (typeof stack === \"string\") return stack;\n\t\n\t        if ((typeof error === \"object\" ||\n\t            typeof error === \"function\") &&\n\t            error.name !== undefined &&\n\t            error.message !== undefined) {\n\t            return error.toString();\n\t        }\n\t        return formatNonError(error);\n\t    };\n\t\n\t    return null;\n\t\n\t})([]);\n\t\n\tvar fireDomEvent;\n\tvar fireGlobalEvent = (function() {\n\t    if (util.isNode) {\n\t        return function(name, reason, promise) {\n\t            if (name === \"rejectionHandled\") {\n\t                return process.emit(name, promise);\n\t            } else {\n\t                return process.emit(name, reason, promise);\n\t            }\n\t        };\n\t    } else {\n\t        var customEventWorks = false;\n\t        var anyEventWorks = true;\n\t        try {\n\t            var ev = new self.CustomEvent(\"test\");\n\t            customEventWorks = ev instanceof CustomEvent;\n\t        } catch (e) {}\n\t        if (!customEventWorks) {\n\t            try {\n\t                var event = document.createEvent(\"CustomEvent\");\n\t                event.initCustomEvent(\"testingtheevent\", false, true, {});\n\t                self.dispatchEvent(event);\n\t            } catch (e) {\n\t                anyEventWorks = false;\n\t            }\n\t        }\n\t        if (anyEventWorks) {\n\t            fireDomEvent = function(type, detail) {\n\t                var event;\n\t                if (customEventWorks) {\n\t                    event = new self.CustomEvent(type, {\n\t                        detail: detail,\n\t                        bubbles: false,\n\t                        cancelable: true\n\t                    });\n\t                } else if (self.dispatchEvent) {\n\t                    event = document.createEvent(\"CustomEvent\");\n\t                    event.initCustomEvent(type, false, true, detail);\n\t                }\n\t\n\t                return event ? !self.dispatchEvent(event) : false;\n\t            };\n\t        }\n\t\n\t        var toWindowMethodNameMap = {};\n\t        toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" +\n\t            \"unhandledRejection\").toLowerCase();\n\t        toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" +\n\t            \"rejectionHandled\").toLowerCase();\n\t\n\t        return function(name, reason, promise) {\n\t            var methodName = toWindowMethodNameMap[name];\n\t            var method = self[methodName];\n\t            if (!method) return false;\n\t            if (name === \"rejectionHandled\") {\n\t                method.call(self, promise);\n\t            } else {\n\t                method.call(self, reason, promise);\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t})();\n\t\n\tif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n\t    warn = function (message) {\n\t        console.warn(message);\n\t    };\n\t    if (util.isNode && process.stderr.isTTY) {\n\t        warn = function(message) {\n\t            process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n\t        };\n\t    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n\t        warn = function(message) {\n\t            console.warn(\"%c\" + message, \"color: red\");\n\t        };\n\t    }\n\t}\n\t\n\treturn CapturedTrace;\n\t};\n\t\n\t},{\"./async.js\":2,\"./util.js\":38}],8:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(NEXT_FILTER) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar errors = _dereq_(\"./errors.js\");\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\tvar keys = _dereq_(\"./es5.js\").keys;\n\tvar TypeError = errors.TypeError;\n\t\n\tfunction CatchFilter(instances, callback, promise) {\n\t    this._instances = instances;\n\t    this._callback = callback;\n\t    this._promise = promise;\n\t}\n\t\n\tfunction safePredicate(predicate, e) {\n\t    var safeObject = {};\n\t    var retfilter = tryCatch(predicate).call(safeObject, e);\n\t\n\t    if (retfilter === errorObj) return retfilter;\n\t\n\t    var safeKeys = keys(safeObject);\n\t    if (safeKeys.length) {\n\t        errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n\t        return errorObj;\n\t    }\n\t    return retfilter;\n\t}\n\t\n\tCatchFilter.prototype.doFilter = function (e) {\n\t    var cb = this._callback;\n\t    var promise = this._promise;\n\t    var boundTo = promise._boundTo;\n\t    for (var i = 0, len = this._instances.length; i < len; ++i) {\n\t        var item = this._instances[i];\n\t        var itemIsErrorType = item === Error ||\n\t            (item != null && item.prototype instanceof Error);\n\t\n\t        if (itemIsErrorType && e instanceof item) {\n\t            var ret = tryCatch(cb).call(boundTo, e);\n\t            if (ret === errorObj) {\n\t                NEXT_FILTER.e = ret.e;\n\t                return NEXT_FILTER;\n\t            }\n\t            return ret;\n\t        } else if (typeof item === \"function\" && !itemIsErrorType) {\n\t            var shouldHandle = safePredicate(item, e);\n\t            if (shouldHandle === errorObj) {\n\t                e = errorObj.e;\n\t                break;\n\t            } else if (shouldHandle) {\n\t                var ret = tryCatch(cb).call(boundTo, e);\n\t                if (ret === errorObj) {\n\t                    NEXT_FILTER.e = ret.e;\n\t                    return NEXT_FILTER;\n\t                }\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    NEXT_FILTER.e = e;\n\t    return NEXT_FILTER;\n\t};\n\t\n\treturn CatchFilter;\n\t};\n\t\n\t},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],9:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, CapturedTrace, isDebugging) {\n\tvar contextStack = [];\n\tfunction Context() {\n\t    this._trace = new CapturedTrace(peekContext());\n\t}\n\tContext.prototype._pushContext = function () {\n\t    if (!isDebugging()) return;\n\t    if (this._trace !== undefined) {\n\t        contextStack.push(this._trace);\n\t    }\n\t};\n\t\n\tContext.prototype._popContext = function () {\n\t    if (!isDebugging()) return;\n\t    if (this._trace !== undefined) {\n\t        contextStack.pop();\n\t    }\n\t};\n\t\n\tfunction createContext() {\n\t    if (isDebugging()) return new Context();\n\t}\n\t\n\tfunction peekContext() {\n\t    var lastIndex = contextStack.length - 1;\n\t    if (lastIndex >= 0) {\n\t        return contextStack[lastIndex];\n\t    }\n\t    return undefined;\n\t}\n\t\n\tPromise.prototype._peekContext = peekContext;\n\tPromise.prototype._pushContext = Context.prototype._pushContext;\n\tPromise.prototype._popContext = Context.prototype._popContext;\n\t\n\treturn createContext;\n\t};\n\t\n\t},{}],10:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, CapturedTrace) {\n\tvar async = _dereq_(\"./async.js\");\n\tvar Warning = _dereq_(\"./errors.js\").Warning;\n\tvar util = _dereq_(\"./util.js\");\n\tvar canAttachTrace = util.canAttachTrace;\n\tvar unhandledRejectionHandled;\n\tvar possiblyUnhandledRejection;\n\tvar debugging = false || (util.isNode &&\n\t                    (!!process.env[\"BLUEBIRD_DEBUG\"] ||\n\t                     process.env[\"NODE_ENV\"] === \"development\"));\n\t\n\tPromise.prototype._ensurePossibleRejectionHandled = function () {\n\t    this._setRejectionIsUnhandled();\n\t    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n\t};\n\t\n\tPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n\t    CapturedTrace.fireRejectionEvent(\"rejectionHandled\",\n\t                                  unhandledRejectionHandled, undefined, this);\n\t};\n\t\n\tPromise.prototype._notifyUnhandledRejection = function () {\n\t    if (this._isRejectionUnhandled()) {\n\t        var reason = this._getCarriedStackTrace() || this._settledValue;\n\t        this._setUnhandledRejectionIsNotified();\n\t        CapturedTrace.fireRejectionEvent(\"unhandledRejection\",\n\t                                      possiblyUnhandledRejection, reason, this);\n\t    }\n\t};\n\t\n\tPromise.prototype._setUnhandledRejectionIsNotified = function () {\n\t    this._bitField = this._bitField | 524288;\n\t};\n\t\n\tPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n\t    this._bitField = this._bitField & (~524288);\n\t};\n\t\n\tPromise.prototype._isUnhandledRejectionNotified = function () {\n\t    return (this._bitField & 524288) > 0;\n\t};\n\t\n\tPromise.prototype._setRejectionIsUnhandled = function () {\n\t    this._bitField = this._bitField | 2097152;\n\t};\n\t\n\tPromise.prototype._unsetRejectionIsUnhandled = function () {\n\t    this._bitField = this._bitField & (~2097152);\n\t    if (this._isUnhandledRejectionNotified()) {\n\t        this._unsetUnhandledRejectionIsNotified();\n\t        this._notifyUnhandledRejectionIsHandled();\n\t    }\n\t};\n\t\n\tPromise.prototype._isRejectionUnhandled = function () {\n\t    return (this._bitField & 2097152) > 0;\n\t};\n\t\n\tPromise.prototype._setCarriedStackTrace = function (capturedTrace) {\n\t    this._bitField = this._bitField | 1048576;\n\t    this._fulfillmentHandler0 = capturedTrace;\n\t};\n\t\n\tPromise.prototype._isCarryingStackTrace = function () {\n\t    return (this._bitField & 1048576) > 0;\n\t};\n\t\n\tPromise.prototype._getCarriedStackTrace = function () {\n\t    return this._isCarryingStackTrace()\n\t        ? this._fulfillmentHandler0\n\t        : undefined;\n\t};\n\t\n\tPromise.prototype._captureStackTrace = function () {\n\t    if (debugging) {\n\t        this._trace = new CapturedTrace(this._peekContext());\n\t    }\n\t    return this;\n\t};\n\t\n\tPromise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n\t    if (debugging && canAttachTrace(error)) {\n\t        var trace = this._trace;\n\t        if (trace !== undefined) {\n\t            if (ignoreSelf) trace = trace._parent;\n\t        }\n\t        if (trace !== undefined) {\n\t            trace.attachExtraTrace(error);\n\t        } else if (!error.__stackCleaned__) {\n\t            var parsed = CapturedTrace.parseStackAndMessage(error);\n\t            error.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n\t            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n\t        }\n\t    }\n\t};\n\t\n\tPromise.prototype._warn = function(message) {\n\t    var warning = new Warning(message);\n\t    var ctx = this._peekContext();\n\t    if (ctx) {\n\t        ctx.attachExtraTrace(warning);\n\t    } else {\n\t        var parsed = CapturedTrace.parseStackAndMessage(warning);\n\t        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n\t    }\n\t    CapturedTrace.formatAndLogError(warning, \"\");\n\t};\n\t\n\tPromise.onPossiblyUnhandledRejection = function (fn) {\n\t    possiblyUnhandledRejection = typeof fn === \"function\" ? fn : undefined;\n\t};\n\t\n\tPromise.onUnhandledRejectionHandled = function (fn) {\n\t    unhandledRejectionHandled = typeof fn === \"function\" ? fn : undefined;\n\t};\n\t\n\tPromise.longStackTraces = function () {\n\t    if (async.haveItemsQueued() &&\n\t        debugging === false\n\t   ) {\n\t        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n\t    }\n\t    debugging = CapturedTrace.isSupported();\n\t};\n\t\n\tPromise.hasLongStackTraces = function () {\n\t    return debugging && CapturedTrace.isSupported();\n\t};\n\t\n\tif (!CapturedTrace.isSupported()) {\n\t    Promise.longStackTraces = function(){};\n\t    debugging = false;\n\t}\n\t\n\treturn function() {\n\t    return debugging;\n\t};\n\t};\n\t\n\t},{\"./async.js\":2,\"./errors.js\":13,\"./util.js\":38}],11:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar util = _dereq_(\"./util.js\");\n\tvar isPrimitive = util.isPrimitive;\n\tvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\n\t\n\tmodule.exports = function(Promise) {\n\tvar returner = function () {\n\t    return this;\n\t};\n\tvar thrower = function () {\n\t    throw this;\n\t};\n\t\n\tvar wrapper = function (value, action) {\n\t    if (action === 1) {\n\t        return function () {\n\t            throw value;\n\t        };\n\t    } else if (action === 2) {\n\t        return function () {\n\t            return value;\n\t        };\n\t    }\n\t};\n\t\n\t\n\tPromise.prototype[\"return\"] =\n\tPromise.prototype.thenReturn = function (value) {\n\t    if (wrapsPrimitiveReceiver && isPrimitive(value)) {\n\t        return this._then(\n\t            wrapper(value, 2),\n\t            undefined,\n\t            undefined,\n\t            undefined,\n\t            undefined\n\t       );\n\t    }\n\t    return this._then(returner, undefined, undefined, value, undefined);\n\t};\n\t\n\tPromise.prototype[\"throw\"] =\n\tPromise.prototype.thenThrow = function (reason) {\n\t    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {\n\t        return this._then(\n\t            wrapper(reason, 1),\n\t            undefined,\n\t            undefined,\n\t            undefined,\n\t            undefined\n\t       );\n\t    }\n\t    return this._then(thrower, undefined, undefined, reason, undefined);\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],12:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL) {\n\tvar PromiseReduce = Promise.reduce;\n\t\n\tPromise.prototype.each = function (fn) {\n\t    return PromiseReduce(this, fn, null, INTERNAL);\n\t};\n\t\n\tPromise.each = function (promises, fn) {\n\t    return PromiseReduce(promises, fn, null, INTERNAL);\n\t};\n\t};\n\t\n\t},{}],13:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar es5 = _dereq_(\"./es5.js\");\n\tvar Objectfreeze = es5.freeze;\n\tvar util = _dereq_(\"./util.js\");\n\tvar inherits = util.inherits;\n\tvar notEnumerableProp = util.notEnumerableProp;\n\t\n\tfunction subError(nameProperty, defaultMessage) {\n\t    function SubError(message) {\n\t        if (!(this instanceof SubError)) return new SubError(message);\n\t        notEnumerableProp(this, \"message\",\n\t            typeof message === \"string\" ? message : defaultMessage);\n\t        notEnumerableProp(this, \"name\", nameProperty);\n\t        if (Error.captureStackTrace) {\n\t            Error.captureStackTrace(this, this.constructor);\n\t        } else {\n\t            Error.call(this);\n\t        }\n\t    }\n\t    inherits(SubError, Error);\n\t    return SubError;\n\t}\n\t\n\tvar _TypeError, _RangeError;\n\tvar Warning = subError(\"Warning\", \"warning\");\n\tvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\n\tvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\n\tvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\n\ttry {\n\t    _TypeError = TypeError;\n\t    _RangeError = RangeError;\n\t} catch(e) {\n\t    _TypeError = subError(\"TypeError\", \"type error\");\n\t    _RangeError = subError(\"RangeError\", \"range error\");\n\t}\n\t\n\tvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n\t    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\t\n\tfor (var i = 0; i < methods.length; ++i) {\n\t    if (typeof Array.prototype[methods[i]] === \"function\") {\n\t        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n\t    }\n\t}\n\t\n\tes5.defineProperty(AggregateError.prototype, \"length\", {\n\t    value: 0,\n\t    configurable: false,\n\t    writable: true,\n\t    enumerable: true\n\t});\n\tAggregateError.prototype[\"isOperational\"] = true;\n\tvar level = 0;\n\tAggregateError.prototype.toString = function() {\n\t    var indent = Array(level * 4 + 1).join(\" \");\n\t    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n\t    level++;\n\t    indent = Array(level * 4 + 1).join(\" \");\n\t    for (var i = 0; i < this.length; ++i) {\n\t        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n\t        var lines = str.split(\"\\n\");\n\t        for (var j = 0; j < lines.length; ++j) {\n\t            lines[j] = indent + lines[j];\n\t        }\n\t        str = lines.join(\"\\n\");\n\t        ret += str + \"\\n\";\n\t    }\n\t    level--;\n\t    return ret;\n\t};\n\t\n\tfunction OperationalError(message) {\n\t    if (!(this instanceof OperationalError))\n\t        return new OperationalError(message);\n\t    notEnumerableProp(this, \"name\", \"OperationalError\");\n\t    notEnumerableProp(this, \"message\", message);\n\t    this.cause = message;\n\t    this[\"isOperational\"] = true;\n\t\n\t    if (message instanceof Error) {\n\t        notEnumerableProp(this, \"message\", message.message);\n\t        notEnumerableProp(this, \"stack\", message.stack);\n\t    } else if (Error.captureStackTrace) {\n\t        Error.captureStackTrace(this, this.constructor);\n\t    }\n\t\n\t}\n\tinherits(OperationalError, Error);\n\t\n\tvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\n\tif (!errorTypes) {\n\t    errorTypes = Objectfreeze({\n\t        CancellationError: CancellationError,\n\t        TimeoutError: TimeoutError,\n\t        OperationalError: OperationalError,\n\t        RejectionError: OperationalError,\n\t        AggregateError: AggregateError\n\t    });\n\t    notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n\t}\n\t\n\tmodule.exports = {\n\t    Error: Error,\n\t    TypeError: _TypeError,\n\t    RangeError: _RangeError,\n\t    CancellationError: errorTypes.CancellationError,\n\t    OperationalError: errorTypes.OperationalError,\n\t    TimeoutError: errorTypes.TimeoutError,\n\t    AggregateError: errorTypes.AggregateError,\n\t    Warning: Warning\n\t};\n\t\n\t},{\"./es5.js\":14,\"./util.js\":38}],14:[function(_dereq_,module,exports){\n\tvar isES5 = (function(){\n\t    \"use strict\";\n\t    return this === undefined;\n\t})();\n\t\n\tif (isES5) {\n\t    module.exports = {\n\t        freeze: Object.freeze,\n\t        defineProperty: Object.defineProperty,\n\t        getDescriptor: Object.getOwnPropertyDescriptor,\n\t        keys: Object.keys,\n\t        names: Object.getOwnPropertyNames,\n\t        getPrototypeOf: Object.getPrototypeOf,\n\t        isArray: Array.isArray,\n\t        isES5: isES5,\n\t        propertyIsWritable: function(obj, prop) {\n\t            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n\t            return !!(!descriptor || descriptor.writable || descriptor.set);\n\t        }\n\t    };\n\t} else {\n\t    var has = {}.hasOwnProperty;\n\t    var str = {}.toString;\n\t    var proto = {}.constructor.prototype;\n\t\n\t    var ObjectKeys = function (o) {\n\t        var ret = [];\n\t        for (var key in o) {\n\t            if (has.call(o, key)) {\n\t                ret.push(key);\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t\n\t    var ObjectGetDescriptor = function(o, key) {\n\t        return {value: o[key]};\n\t    };\n\t\n\t    var ObjectDefineProperty = function (o, key, desc) {\n\t        o[key] = desc.value;\n\t        return o;\n\t    };\n\t\n\t    var ObjectFreeze = function (obj) {\n\t        return obj;\n\t    };\n\t\n\t    var ObjectGetPrototypeOf = function (obj) {\n\t        try {\n\t            return Object(obj).constructor.prototype;\n\t        }\n\t        catch (e) {\n\t            return proto;\n\t        }\n\t    };\n\t\n\t    var ArrayIsArray = function (obj) {\n\t        try {\n\t            return str.call(obj) === \"[object Array]\";\n\t        }\n\t        catch(e) {\n\t            return false;\n\t        }\n\t    };\n\t\n\t    module.exports = {\n\t        isArray: ArrayIsArray,\n\t        keys: ObjectKeys,\n\t        names: ObjectKeys,\n\t        defineProperty: ObjectDefineProperty,\n\t        getDescriptor: ObjectGetDescriptor,\n\t        freeze: ObjectFreeze,\n\t        getPrototypeOf: ObjectGetPrototypeOf,\n\t        isES5: isES5,\n\t        propertyIsWritable: function() {\n\t            return true;\n\t        }\n\t    };\n\t}\n\t\n\t},{}],15:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL) {\n\tvar PromiseMap = Promise.map;\n\t\n\tPromise.prototype.filter = function (fn, options) {\n\t    return PromiseMap(this, fn, options, INTERNAL);\n\t};\n\t\n\tPromise.filter = function (promises, fn, options) {\n\t    return PromiseMap(promises, fn, options, INTERNAL);\n\t};\n\t};\n\t\n\t},{}],16:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\n\tvar isPrimitive = util.isPrimitive;\n\tvar thrower = util.thrower;\n\t\n\tfunction returnThis() {\n\t    return this;\n\t}\n\tfunction throwThis() {\n\t    throw this;\n\t}\n\tfunction return$(r) {\n\t    return function() {\n\t        return r;\n\t    };\n\t}\n\tfunction throw$(r) {\n\t    return function() {\n\t        throw r;\n\t    };\n\t}\n\tfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n\t    var then;\n\t    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {\n\t        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n\t    } else {\n\t        then = isFulfilled ? returnThis : throwThis;\n\t    }\n\t    return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n\t}\n\t\n\tfunction finallyHandler(reasonOrValue) {\n\t    var promise = this.promise;\n\t    var handler = this.handler;\n\t\n\t    var ret = promise._isBound()\n\t                    ? handler.call(promise._boundTo)\n\t                    : handler();\n\t\n\t    if (ret !== undefined) {\n\t        var maybePromise = tryConvertToPromise(ret, promise);\n\t        if (maybePromise instanceof Promise) {\n\t            maybePromise = maybePromise._target();\n\t            return promisedFinally(maybePromise, reasonOrValue,\n\t                                    promise.isFulfilled());\n\t        }\n\t    }\n\t\n\t    if (promise.isRejected()) {\n\t        NEXT_FILTER.e = reasonOrValue;\n\t        return NEXT_FILTER;\n\t    } else {\n\t        return reasonOrValue;\n\t    }\n\t}\n\t\n\tfunction tapHandler(value) {\n\t    var promise = this.promise;\n\t    var handler = this.handler;\n\t\n\t    var ret = promise._isBound()\n\t                    ? handler.call(promise._boundTo, value)\n\t                    : handler(value);\n\t\n\t    if (ret !== undefined) {\n\t        var maybePromise = tryConvertToPromise(ret, promise);\n\t        if (maybePromise instanceof Promise) {\n\t            maybePromise = maybePromise._target();\n\t            return promisedFinally(maybePromise, value, true);\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\tPromise.prototype._passThroughHandler = function (handler, isFinally) {\n\t    if (typeof handler !== \"function\") return this.then();\n\t\n\t    var promiseAndHandler = {\n\t        promise: this,\n\t        handler: handler\n\t    };\n\t\n\t    return this._then(\n\t            isFinally ? finallyHandler : tapHandler,\n\t            isFinally ? finallyHandler : undefined, undefined,\n\t            promiseAndHandler, undefined);\n\t};\n\t\n\tPromise.prototype.lastly =\n\tPromise.prototype[\"finally\"] = function (handler) {\n\t    return this._passThroughHandler(handler, true);\n\t};\n\t\n\tPromise.prototype.tap = function (handler) {\n\t    return this._passThroughHandler(handler, false);\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],17:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise,\n\t                          apiRejection,\n\t                          INTERNAL,\n\t                          tryConvertToPromise) {\n\tvar errors = _dereq_(\"./errors.js\");\n\tvar TypeError = errors.TypeError;\n\tvar util = _dereq_(\"./util.js\");\n\tvar errorObj = util.errorObj;\n\tvar tryCatch = util.tryCatch;\n\tvar yieldHandlers = [];\n\t\n\tfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n\t    for (var i = 0; i < yieldHandlers.length; ++i) {\n\t        traceParent._pushContext();\n\t        var result = tryCatch(yieldHandlers[i])(value);\n\t        traceParent._popContext();\n\t        if (result === errorObj) {\n\t            traceParent._pushContext();\n\t            var ret = Promise.reject(errorObj.e);\n\t            traceParent._popContext();\n\t            return ret;\n\t        }\n\t        var maybePromise = tryConvertToPromise(result, traceParent);\n\t        if (maybePromise instanceof Promise) return maybePromise;\n\t    }\n\t    return null;\n\t}\n\t\n\tfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n\t    var promise = this._promise = new Promise(INTERNAL);\n\t    promise._captureStackTrace();\n\t    this._stack = stack;\n\t    this._generatorFunction = generatorFunction;\n\t    this._receiver = receiver;\n\t    this._generator = undefined;\n\t    this._yieldHandlers = typeof yieldHandler === \"function\"\n\t        ? [yieldHandler].concat(yieldHandlers)\n\t        : yieldHandlers;\n\t}\n\t\n\tPromiseSpawn.prototype.promise = function () {\n\t    return this._promise;\n\t};\n\t\n\tPromiseSpawn.prototype._run = function () {\n\t    this._generator = this._generatorFunction.call(this._receiver);\n\t    this._receiver =\n\t        this._generatorFunction = undefined;\n\t    this._next(undefined);\n\t};\n\t\n\tPromiseSpawn.prototype._continue = function (result) {\n\t    if (result === errorObj) {\n\t        return this._promise._rejectCallback(result.e, false, true);\n\t    }\n\t\n\t    var value = result.value;\n\t    if (result.done === true) {\n\t        this._promise._resolveCallback(value);\n\t    } else {\n\t        var maybePromise = tryConvertToPromise(value, this._promise);\n\t        if (!(maybePromise instanceof Promise)) {\n\t            maybePromise =\n\t                promiseFromYieldHandler(maybePromise,\n\t                                        this._yieldHandlers,\n\t                                        this._promise);\n\t            if (maybePromise === null) {\n\t                this._throw(\n\t                    new TypeError(\n\t                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) +\n\t                        \"From coroutine:\\u000a\" +\n\t                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n\t                    )\n\t                );\n\t                return;\n\t            }\n\t        }\n\t        maybePromise._then(\n\t            this._next,\n\t            this._throw,\n\t            undefined,\n\t            this,\n\t            null\n\t       );\n\t    }\n\t};\n\t\n\tPromiseSpawn.prototype._throw = function (reason) {\n\t    this._promise._attachExtraTrace(reason);\n\t    this._promise._pushContext();\n\t    var result = tryCatch(this._generator[\"throw\"])\n\t        .call(this._generator, reason);\n\t    this._promise._popContext();\n\t    this._continue(result);\n\t};\n\t\n\tPromiseSpawn.prototype._next = function (value) {\n\t    this._promise._pushContext();\n\t    var result = tryCatch(this._generator.next).call(this._generator, value);\n\t    this._promise._popContext();\n\t    this._continue(result);\n\t};\n\t\n\tPromise.coroutine = function (generatorFunction, options) {\n\t    if (typeof generatorFunction !== \"function\") {\n\t        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n\t    }\n\t    var yieldHandler = Object(options).yieldHandler;\n\t    var PromiseSpawn$ = PromiseSpawn;\n\t    var stack = new Error().stack;\n\t    return function () {\n\t        var generator = generatorFunction.apply(this, arguments);\n\t        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n\t                                      stack);\n\t        spawn._generator = generator;\n\t        spawn._next(undefined);\n\t        return spawn.promise();\n\t    };\n\t};\n\t\n\tPromise.coroutine.addYieldHandler = function(fn) {\n\t    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    yieldHandlers.push(fn);\n\t};\n\t\n\tPromise.spawn = function (generatorFunction) {\n\t    if (typeof generatorFunction !== \"function\") {\n\t        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n\t    }\n\t    var spawn = new PromiseSpawn(generatorFunction, this);\n\t    var ret = spawn.promise();\n\t    spawn._run(Promise.spawn);\n\t    return ret;\n\t};\n\t};\n\t\n\t},{\"./errors.js\":13,\"./util.js\":38}],18:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports =\n\tfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar canEvaluate = util.canEvaluate;\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\tvar reject;\n\t\n\tif (false) {\n\tif (canEvaluate) {\n\t    var thenCallback = function(i) {\n\t        return new Function(\"value\", \"holder\", \"                             \\n\\\n\t            'use strict';                                                    \\n\\\n\t            holder.pIndex = value;                                           \\n\\\n\t            holder.checkFulfillment(this);                                   \\n\\\n\t            \".replace(/Index/g, i));\n\t    };\n\t\n\t    var caller = function(count) {\n\t        var values = [];\n\t        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n\t        return new Function(\"holder\", \"                                      \\n\\\n\t            'use strict';                                                    \\n\\\n\t            var callback = holder.fn;                                        \\n\\\n\t            return callback(values);                                         \\n\\\n\t            \".replace(/values/g, values.join(\", \")));\n\t    };\n\t    var thenCallbacks = [];\n\t    var callers = [undefined];\n\t    for (var i = 1; i <= 5; ++i) {\n\t        thenCallbacks.push(thenCallback(i));\n\t        callers.push(caller(i));\n\t    }\n\t\n\t    var Holder = function(total, fn) {\n\t        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n\t        this.fn = fn;\n\t        this.total = total;\n\t        this.now = 0;\n\t    };\n\t\n\t    Holder.prototype.callers = callers;\n\t    Holder.prototype.checkFulfillment = function(promise) {\n\t        var now = this.now;\n\t        now++;\n\t        var total = this.total;\n\t        if (now >= total) {\n\t            var handler = this.callers[total];\n\t            promise._pushContext();\n\t            var ret = tryCatch(handler)(this);\n\t            promise._popContext();\n\t            if (ret === errorObj) {\n\t                promise._rejectCallback(ret.e, false, true);\n\t            } else {\n\t                promise._resolveCallback(ret);\n\t            }\n\t        } else {\n\t            this.now = now;\n\t        }\n\t    };\n\t\n\t    var reject = function (reason) {\n\t        this._reject(reason);\n\t    };\n\t}\n\t}\n\t\n\tPromise.join = function () {\n\t    var last = arguments.length - 1;\n\t    var fn;\n\t    if (last > 0 && typeof arguments[last] === \"function\") {\n\t        fn = arguments[last];\n\t        if (false) {\n\t            if (last < 6 && canEvaluate) {\n\t                var ret = new Promise(INTERNAL);\n\t                ret._captureStackTrace();\n\t                var holder = new Holder(last, fn);\n\t                var callbacks = thenCallbacks;\n\t                for (var i = 0; i < last; ++i) {\n\t                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n\t                    if (maybePromise instanceof Promise) {\n\t                        maybePromise = maybePromise._target();\n\t                        if (maybePromise._isPending()) {\n\t                            maybePromise._then(callbacks[i], reject,\n\t                                               undefined, ret, holder);\n\t                        } else if (maybePromise._isFulfilled()) {\n\t                            callbacks[i].call(ret,\n\t                                              maybePromise._value(), holder);\n\t                        } else {\n\t                            ret._reject(maybePromise._reason());\n\t                        }\n\t                    } else {\n\t                        callbacks[i].call(ret, maybePromise, holder);\n\t                    }\n\t                }\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n\t    if (fn) args.pop();\n\t    var ret = new PromiseArray(args).promise();\n\t    return fn !== undefined ? ret.spread(fn) : ret;\n\t};\n\t\n\t};\n\t\n\t},{\"./util.js\":38}],19:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise,\n\t                          PromiseArray,\n\t                          apiRejection,\n\t                          tryConvertToPromise,\n\t                          INTERNAL) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\tvar PENDING = {};\n\tvar EMPTY_ARRAY = [];\n\t\n\tfunction MappingPromiseArray(promises, fn, limit, _filter) {\n\t    this.constructor$(promises);\n\t    this._promise._captureStackTrace();\n\t    this._callback = fn;\n\t    this._preservedValues = _filter === INTERNAL\n\t        ? new Array(this.length())\n\t        : null;\n\t    this._limit = limit;\n\t    this._inFlight = 0;\n\t    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n\t    this._init$(undefined, -2);\n\t}\n\tutil.inherits(MappingPromiseArray, PromiseArray);\n\t\n\tMappingPromiseArray.prototype._init = function () {};\n\t\n\tMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n\t    var values = this._values;\n\t    var length = this.length();\n\t    var preservedValues = this._preservedValues;\n\t    var limit = this._limit;\n\t    if (values[index] === PENDING) {\n\t        values[index] = value;\n\t        if (limit >= 1) {\n\t            this._inFlight--;\n\t            this._drainQueue();\n\t            if (this._isResolved()) return;\n\t        }\n\t    } else {\n\t        if (limit >= 1 && this._inFlight >= limit) {\n\t            values[index] = value;\n\t            this._queue.push(index);\n\t            return;\n\t        }\n\t        if (preservedValues !== null) preservedValues[index] = value;\n\t\n\t        var callback = this._callback;\n\t        var receiver = this._promise._boundTo;\n\t        this._promise._pushContext();\n\t        var ret = tryCatch(callback).call(receiver, value, index, length);\n\t        this._promise._popContext();\n\t        if (ret === errorObj) return this._reject(ret.e);\n\t\n\t        var maybePromise = tryConvertToPromise(ret, this._promise);\n\t        if (maybePromise instanceof Promise) {\n\t            maybePromise = maybePromise._target();\n\t            if (maybePromise._isPending()) {\n\t                if (limit >= 1) this._inFlight++;\n\t                values[index] = PENDING;\n\t                return maybePromise._proxyPromiseArray(this, index);\n\t            } else if (maybePromise._isFulfilled()) {\n\t                ret = maybePromise._value();\n\t            } else {\n\t                return this._reject(maybePromise._reason());\n\t            }\n\t        }\n\t        values[index] = ret;\n\t    }\n\t    var totalResolved = ++this._totalResolved;\n\t    if (totalResolved >= length) {\n\t        if (preservedValues !== null) {\n\t            this._filter(values, preservedValues);\n\t        } else {\n\t            this._resolve(values);\n\t        }\n\t\n\t    }\n\t};\n\t\n\tMappingPromiseArray.prototype._drainQueue = function () {\n\t    var queue = this._queue;\n\t    var limit = this._limit;\n\t    var values = this._values;\n\t    while (queue.length > 0 && this._inFlight < limit) {\n\t        if (this._isResolved()) return;\n\t        var index = queue.pop();\n\t        this._promiseFulfilled(values[index], index);\n\t    }\n\t};\n\t\n\tMappingPromiseArray.prototype._filter = function (booleans, values) {\n\t    var len = values.length;\n\t    var ret = new Array(len);\n\t    var j = 0;\n\t    for (var i = 0; i < len; ++i) {\n\t        if (booleans[i]) ret[j++] = values[i];\n\t    }\n\t    ret.length = j;\n\t    this._resolve(ret);\n\t};\n\t\n\tMappingPromiseArray.prototype.preservedValues = function () {\n\t    return this._preservedValues;\n\t};\n\t\n\tfunction map(promises, fn, options, _filter) {\n\t    var limit = typeof options === \"object\" && options !== null\n\t        ? options.concurrency\n\t        : 0;\n\t    limit = typeof limit === \"number\" &&\n\t        isFinite(limit) && limit >= 1 ? limit : 0;\n\t    return new MappingPromiseArray(promises, fn, limit, _filter);\n\t}\n\t\n\tPromise.prototype.map = function (fn, options) {\n\t    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t\n\t    return map(this, fn, options, null).promise();\n\t};\n\t\n\tPromise.map = function (promises, fn, options, _filter) {\n\t    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    return map(promises, fn, options, _filter).promise();\n\t};\n\t\n\t\n\t};\n\t\n\t},{\"./util.js\":38}],20:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports =\n\tfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar tryCatch = util.tryCatch;\n\t\n\tPromise.method = function (fn) {\n\t    if (typeof fn !== \"function\") {\n\t        throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    }\n\t    return function () {\n\t        var ret = new Promise(INTERNAL);\n\t        ret._captureStackTrace();\n\t        ret._pushContext();\n\t        var value = tryCatch(fn).apply(this, arguments);\n\t        ret._popContext();\n\t        ret._resolveFromSyncValue(value);\n\t        return ret;\n\t    };\n\t};\n\t\n\tPromise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n\t    if (typeof fn !== \"function\") {\n\t        return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    }\n\t    var ret = new Promise(INTERNAL);\n\t    ret._captureStackTrace();\n\t    ret._pushContext();\n\t    var value = util.isArray(args)\n\t        ? tryCatch(fn).apply(ctx, args)\n\t        : tryCatch(fn).call(ctx, args);\n\t    ret._popContext();\n\t    ret._resolveFromSyncValue(value);\n\t    return ret;\n\t};\n\t\n\tPromise.prototype._resolveFromSyncValue = function (value) {\n\t    if (value === util.errorObj) {\n\t        this._rejectCallback(value.e, false, true);\n\t    } else {\n\t        this._resolveCallback(value, true);\n\t    }\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],21:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar async = _dereq_(\"./async.js\");\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\t\n\tfunction spreadAdapter(val, nodeback) {\n\t    var promise = this;\n\t    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n\t    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));\n\t    if (ret === errorObj) {\n\t        async.throwLater(ret.e);\n\t    }\n\t}\n\t\n\tfunction successAdapter(val, nodeback) {\n\t    var promise = this;\n\t    var receiver = promise._boundTo;\n\t    var ret = val === undefined\n\t        ? tryCatch(nodeback).call(receiver, null)\n\t        : tryCatch(nodeback).call(receiver, null, val);\n\t    if (ret === errorObj) {\n\t        async.throwLater(ret.e);\n\t    }\n\t}\n\tfunction errorAdapter(reason, nodeback) {\n\t    var promise = this;\n\t    if (!reason) {\n\t        var target = promise._target();\n\t        var newReason = target._getCarriedStackTrace();\n\t        newReason.cause = reason;\n\t        reason = newReason;\n\t    }\n\t    var ret = tryCatch(nodeback).call(promise._boundTo, reason);\n\t    if (ret === errorObj) {\n\t        async.throwLater(ret.e);\n\t    }\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback, options) {\n\t    if (typeof nodeback == \"function\") {\n\t        var adapter = successAdapter;\n\t        if (options !== undefined && Object(options).spread) {\n\t            adapter = spreadAdapter;\n\t        }\n\t        this._then(\n\t            adapter,\n\t            errorAdapter,\n\t            undefined,\n\t            this,\n\t            nodeback\n\t        );\n\t    }\n\t    return this;\n\t};\n\t};\n\t\n\t},{\"./async.js\":2,\"./util.js\":38}],22:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, PromiseArray) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar async = _dereq_(\"./async.js\");\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\t\n\tPromise.prototype.progressed = function (handler) {\n\t    return this._then(undefined, undefined, handler, undefined, undefined);\n\t};\n\t\n\tPromise.prototype._progress = function (progressValue) {\n\t    if (this._isFollowingOrFulfilledOrRejected()) return;\n\t    this._target()._progressUnchecked(progressValue);\n\t\n\t};\n\t\n\tPromise.prototype._progressHandlerAt = function (index) {\n\t    return index === 0\n\t        ? this._progressHandler0\n\t        : this[(index << 2) + index - 5 + 2];\n\t};\n\t\n\tPromise.prototype._doProgressWith = function (progression) {\n\t    var progressValue = progression.value;\n\t    var handler = progression.handler;\n\t    var promise = progression.promise;\n\t    var receiver = progression.receiver;\n\t\n\t    var ret = tryCatch(handler).call(receiver, progressValue);\n\t    if (ret === errorObj) {\n\t        if (ret.e != null &&\n\t            ret.e.name !== \"StopProgressPropagation\") {\n\t            var trace = util.canAttachTrace(ret.e)\n\t                ? ret.e : new Error(util.toString(ret.e));\n\t            promise._attachExtraTrace(trace);\n\t            promise._progress(ret.e);\n\t        }\n\t    } else if (ret instanceof Promise) {\n\t        ret._then(promise._progress, null, null, promise, undefined);\n\t    } else {\n\t        promise._progress(ret);\n\t    }\n\t};\n\t\n\t\n\tPromise.prototype._progressUnchecked = function (progressValue) {\n\t    var len = this._length();\n\t    var progress = this._progress;\n\t    for (var i = 0; i < len; i++) {\n\t        var handler = this._progressHandlerAt(i);\n\t        var promise = this._promiseAt(i);\n\t        if (!(promise instanceof Promise)) {\n\t            var receiver = this._receiverAt(i);\n\t            if (typeof handler === \"function\") {\n\t                handler.call(receiver, progressValue, promise);\n\t            } else if (receiver instanceof PromiseArray &&\n\t                       !receiver._isResolved()) {\n\t                receiver._promiseProgressed(progressValue, promise);\n\t            }\n\t            continue;\n\t        }\n\t\n\t        if (typeof handler === \"function\") {\n\t            async.invoke(this._doProgressWith, this, {\n\t                handler: handler,\n\t                promise: promise,\n\t                receiver: this._receiverAt(i),\n\t                value: progressValue\n\t            });\n\t        } else {\n\t            async.invoke(progress, promise, progressValue);\n\t        }\n\t    }\n\t};\n\t};\n\t\n\t},{\"./async.js\":2,\"./util.js\":38}],23:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function() {\n\tvar makeSelfResolutionError = function () {\n\t    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n\t};\n\tvar reflect = function() {\n\t    return new Promise.PromiseInspection(this._target());\n\t};\n\tvar apiRejection = function(msg) {\n\t    return Promise.reject(new TypeError(msg));\n\t};\n\tvar util = _dereq_(\"./util.js\");\n\tvar async = _dereq_(\"./async.js\");\n\tvar errors = _dereq_(\"./errors.js\");\n\tvar TypeError = Promise.TypeError = errors.TypeError;\n\tPromise.RangeError = errors.RangeError;\n\tPromise.CancellationError = errors.CancellationError;\n\tPromise.TimeoutError = errors.TimeoutError;\n\tPromise.OperationalError = errors.OperationalError;\n\tPromise.RejectionError = errors.OperationalError;\n\tPromise.AggregateError = errors.AggregateError;\n\tvar INTERNAL = function(){};\n\tvar APPLY = {};\n\tvar NEXT_FILTER = {e: null};\n\tvar tryConvertToPromise = _dereq_(\"./thenables.js\")(Promise, INTERNAL);\n\tvar PromiseArray =\n\t    _dereq_(\"./promise_array.js\")(Promise, INTERNAL,\n\t                                    tryConvertToPromise, apiRejection);\n\tvar CapturedTrace = _dereq_(\"./captured_trace.js\")();\n\tvar isDebugging = _dereq_(\"./debuggability.js\")(Promise, CapturedTrace);\n\t /*jshint unused:false*/\n\tvar createContext =\n\t    _dereq_(\"./context.js\")(Promise, CapturedTrace, isDebugging);\n\tvar CatchFilter = _dereq_(\"./catch_filter.js\")(NEXT_FILTER);\n\tvar PromiseResolver = _dereq_(\"./promise_resolver.js\");\n\tvar nodebackForPromise = PromiseResolver._nodebackForPromise;\n\tvar errorObj = util.errorObj;\n\tvar tryCatch = util.tryCatch;\n\tfunction Promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n\t    }\n\t    if (this.constructor !== Promise) {\n\t        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n\t    }\n\t    this._bitField = 0;\n\t    this._fulfillmentHandler0 = undefined;\n\t    this._rejectionHandler0 = undefined;\n\t    this._progressHandler0 = undefined;\n\t    this._promise0 = undefined;\n\t    this._receiver0 = undefined;\n\t    this._settledValue = undefined;\n\t    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n\t    var len = arguments.length;\n\t    if (len > 1) {\n\t        var catchInstances = new Array(len - 1),\n\t            j = 0, i;\n\t        for (i = 0; i < len - 1; ++i) {\n\t            var item = arguments[i];\n\t            if (typeof item === \"function\") {\n\t                catchInstances[j++] = item;\n\t            } else {\n\t                return Promise.reject(\n\t                    new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n\t            }\n\t        }\n\t        catchInstances.length = j;\n\t        fn = arguments[i];\n\t        var catchFilter = new CatchFilter(catchInstances, fn, this);\n\t        return this._then(undefined, catchFilter.doFilter, undefined,\n\t            catchFilter, undefined);\n\t    }\n\t    return this._then(undefined, fn, undefined, undefined, undefined);\n\t};\n\t\n\tPromise.prototype.reflect = function () {\n\t    return this._then(reflect, reflect, undefined, this, undefined);\n\t};\n\t\n\tPromise.prototype.then = function (didFulfill, didReject, didProgress) {\n\t    if (isDebugging() && arguments.length > 0 &&\n\t        typeof didFulfill !== \"function\" &&\n\t        typeof didReject !== \"function\") {\n\t        var msg = \".then() only accepts functions but was passed: \" +\n\t                util.classString(didFulfill);\n\t        if (arguments.length > 1) {\n\t            msg += \", \" + util.classString(didReject);\n\t        }\n\t        this._warn(msg);\n\t    }\n\t    return this._then(didFulfill, didReject, didProgress,\n\t        undefined, undefined);\n\t};\n\t\n\tPromise.prototype.done = function (didFulfill, didReject, didProgress) {\n\t    var promise = this._then(didFulfill, didReject, didProgress,\n\t        undefined, undefined);\n\t    promise._setIsFinal();\n\t};\n\t\n\tPromise.prototype.spread = function (didFulfill, didReject) {\n\t    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n\t};\n\t\n\tPromise.prototype.isCancellable = function () {\n\t    return !this.isResolved() &&\n\t        this._cancellable();\n\t};\n\t\n\tPromise.prototype.toJSON = function () {\n\t    var ret = {\n\t        isFulfilled: false,\n\t        isRejected: false,\n\t        fulfillmentValue: undefined,\n\t        rejectionReason: undefined\n\t    };\n\t    if (this.isFulfilled()) {\n\t        ret.fulfillmentValue = this.value();\n\t        ret.isFulfilled = true;\n\t    } else if (this.isRejected()) {\n\t        ret.rejectionReason = this.reason();\n\t        ret.isRejected = true;\n\t    }\n\t    return ret;\n\t};\n\t\n\tPromise.prototype.all = function () {\n\t    return new PromiseArray(this).promise();\n\t};\n\t\n\tPromise.prototype.error = function (fn) {\n\t    return this.caught(util.originatesFromRejection, fn);\n\t};\n\t\n\tPromise.is = function (val) {\n\t    return val instanceof Promise;\n\t};\n\t\n\tPromise.fromNode = function(fn) {\n\t    var ret = new Promise(INTERNAL);\n\t    var result = tryCatch(fn)(nodebackForPromise(ret));\n\t    if (result === errorObj) {\n\t        ret._rejectCallback(result.e, true, true);\n\t    }\n\t    return ret;\n\t};\n\t\n\tPromise.all = function (promises) {\n\t    return new PromiseArray(promises).promise();\n\t};\n\t\n\tPromise.defer = Promise.pending = function () {\n\t    var promise = new Promise(INTERNAL);\n\t    return new PromiseResolver(promise);\n\t};\n\t\n\tPromise.cast = function (obj) {\n\t    var ret = tryConvertToPromise(obj);\n\t    if (!(ret instanceof Promise)) {\n\t        var val = ret;\n\t        ret = new Promise(INTERNAL);\n\t        ret._fulfillUnchecked(val);\n\t    }\n\t    return ret;\n\t};\n\t\n\tPromise.resolve = Promise.fulfilled = Promise.cast;\n\t\n\tPromise.reject = Promise.rejected = function (reason) {\n\t    var ret = new Promise(INTERNAL);\n\t    ret._captureStackTrace();\n\t    ret._rejectCallback(reason, true);\n\t    return ret;\n\t};\n\t\n\tPromise.setScheduler = function(fn) {\n\t    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    var prev = async._schedule;\n\t    async._schedule = fn;\n\t    return prev;\n\t};\n\t\n\tPromise.prototype._then = function (\n\t    didFulfill,\n\t    didReject,\n\t    didProgress,\n\t    receiver,\n\t    internalData\n\t) {\n\t    var haveInternalData = internalData !== undefined;\n\t    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\t\n\t    if (!haveInternalData) {\n\t        ret._propagateFrom(this, 4 | 1);\n\t        ret._captureStackTrace();\n\t    }\n\t\n\t    var target = this._target();\n\t    if (target !== this) {\n\t        if (receiver === undefined) receiver = this._boundTo;\n\t        if (!haveInternalData) ret._setIsMigrated();\n\t    }\n\t\n\t    var callbackIndex =\n\t        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);\n\t\n\t    if (target._isResolved() && !target._isSettlePromisesQueued()) {\n\t        async.invoke(\n\t            target._settlePromiseAtPostResolution, target, callbackIndex);\n\t    }\n\t\n\t    return ret;\n\t};\n\t\n\tPromise.prototype._settlePromiseAtPostResolution = function (index) {\n\t    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n\t    this._settlePromiseAt(index);\n\t};\n\t\n\tPromise.prototype._length = function () {\n\t    return this._bitField & 131071;\n\t};\n\t\n\tPromise.prototype._isFollowingOrFulfilledOrRejected = function () {\n\t    return (this._bitField & 939524096) > 0;\n\t};\n\t\n\tPromise.prototype._isFollowing = function () {\n\t    return (this._bitField & 536870912) === 536870912;\n\t};\n\t\n\tPromise.prototype._setLength = function (len) {\n\t    this._bitField = (this._bitField & -131072) |\n\t        (len & 131071);\n\t};\n\t\n\tPromise.prototype._setFulfilled = function () {\n\t    this._bitField = this._bitField | 268435456;\n\t};\n\t\n\tPromise.prototype._setRejected = function () {\n\t    this._bitField = this._bitField | 134217728;\n\t};\n\t\n\tPromise.prototype._setFollowing = function () {\n\t    this._bitField = this._bitField | 536870912;\n\t};\n\t\n\tPromise.prototype._setIsFinal = function () {\n\t    this._bitField = this._bitField | 33554432;\n\t};\n\t\n\tPromise.prototype._isFinal = function () {\n\t    return (this._bitField & 33554432) > 0;\n\t};\n\t\n\tPromise.prototype._cancellable = function () {\n\t    return (this._bitField & 67108864) > 0;\n\t};\n\t\n\tPromise.prototype._setCancellable = function () {\n\t    this._bitField = this._bitField | 67108864;\n\t};\n\t\n\tPromise.prototype._unsetCancellable = function () {\n\t    this._bitField = this._bitField & (~67108864);\n\t};\n\t\n\tPromise.prototype._setIsMigrated = function () {\n\t    this._bitField = this._bitField | 4194304;\n\t};\n\t\n\tPromise.prototype._unsetIsMigrated = function () {\n\t    this._bitField = this._bitField & (~4194304);\n\t};\n\t\n\tPromise.prototype._isMigrated = function () {\n\t    return (this._bitField & 4194304) > 0;\n\t};\n\t\n\tPromise.prototype._receiverAt = function (index) {\n\t    var ret = index === 0\n\t        ? this._receiver0\n\t        : this[\n\t            index * 5 - 5 + 4];\n\t    if (ret === undefined && this._isBound()) {\n\t        return this._boundTo;\n\t    }\n\t    return ret;\n\t};\n\t\n\tPromise.prototype._promiseAt = function (index) {\n\t    return index === 0\n\t        ? this._promise0\n\t        : this[index * 5 - 5 + 3];\n\t};\n\t\n\tPromise.prototype._fulfillmentHandlerAt = function (index) {\n\t    return index === 0\n\t        ? this._fulfillmentHandler0\n\t        : this[index * 5 - 5 + 0];\n\t};\n\t\n\tPromise.prototype._rejectionHandlerAt = function (index) {\n\t    return index === 0\n\t        ? this._rejectionHandler0\n\t        : this[index * 5 - 5 + 1];\n\t};\n\t\n\tPromise.prototype._migrateCallbacks = function (follower, index) {\n\t    var fulfill = follower._fulfillmentHandlerAt(index);\n\t    var reject = follower._rejectionHandlerAt(index);\n\t    var progress = follower._progressHandlerAt(index);\n\t    var promise = follower._promiseAt(index);\n\t    var receiver = follower._receiverAt(index);\n\t    if (promise instanceof Promise) promise._setIsMigrated();\n\t    this._addCallbacks(fulfill, reject, progress, promise, receiver);\n\t};\n\t\n\tPromise.prototype._addCallbacks = function (\n\t    fulfill,\n\t    reject,\n\t    progress,\n\t    promise,\n\t    receiver\n\t) {\n\t    var index = this._length();\n\t\n\t    if (index >= 131071 - 5) {\n\t        index = 0;\n\t        this._setLength(0);\n\t    }\n\t\n\t    if (index === 0) {\n\t        this._promise0 = promise;\n\t        if (receiver !== undefined) this._receiver0 = receiver;\n\t        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace())\n\t            this._fulfillmentHandler0 = fulfill;\n\t        if (typeof reject === \"function\") this._rejectionHandler0 = reject;\n\t        if (typeof progress === \"function\") this._progressHandler0 = progress;\n\t    } else {\n\t        var base = index * 5 - 5;\n\t        this[base + 3] = promise;\n\t        this[base + 4] = receiver;\n\t        if (typeof fulfill === \"function\")\n\t            this[base + 0] = fulfill;\n\t        if (typeof reject === \"function\")\n\t            this[base + 1] = reject;\n\t        if (typeof progress === \"function\")\n\t            this[base + 2] = progress;\n\t    }\n\t    this._setLength(index + 1);\n\t    return index;\n\t};\n\t\n\tPromise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n\t    var index = this._length();\n\t\n\t    if (index >= 131071 - 5) {\n\t        index = 0;\n\t        this._setLength(0);\n\t    }\n\t    if (index === 0) {\n\t        this._promise0 = promiseSlotValue;\n\t        this._receiver0 = receiver;\n\t    } else {\n\t        var base = index * 5 - 5;\n\t        this[base + 3] = promiseSlotValue;\n\t        this[base + 4] = receiver;\n\t    }\n\t    this._setLength(index + 1);\n\t};\n\t\n\tPromise.prototype._proxyPromiseArray = function (promiseArray, index) {\n\t    this._setProxyHandlers(promiseArray, index);\n\t};\n\t\n\tPromise.prototype._resolveCallback = function(value, shouldBind) {\n\t    if (this._isFollowingOrFulfilledOrRejected()) return;\n\t    if (value === this)\n\t        return this._rejectCallback(makeSelfResolutionError(), false, true);\n\t    var maybePromise = tryConvertToPromise(value, this);\n\t    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\t\n\t    var propagationFlags = 1 | (shouldBind ? 4 : 0);\n\t    this._propagateFrom(maybePromise, propagationFlags);\n\t    var promise = maybePromise._target();\n\t    if (promise._isPending()) {\n\t        var len = this._length();\n\t        for (var i = 0; i < len; ++i) {\n\t            promise._migrateCallbacks(this, i);\n\t        }\n\t        this._setFollowing();\n\t        this._setLength(0);\n\t        this._setFollowee(promise);\n\t    } else if (promise._isFulfilled()) {\n\t        this._fulfillUnchecked(promise._value());\n\t    } else {\n\t        this._rejectUnchecked(promise._reason(),\n\t            promise._getCarriedStackTrace());\n\t    }\n\t};\n\t\n\tPromise.prototype._rejectCallback =\n\tfunction(reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n\t    if (!shouldNotMarkOriginatingFromRejection) {\n\t        util.markAsOriginatingFromRejection(reason);\n\t    }\n\t    var trace = util.ensureErrorObject(reason);\n\t    var hasStack = trace === reason;\n\t    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n\t    this._reject(reason, hasStack ? undefined : trace);\n\t};\n\t\n\tPromise.prototype._resolveFromResolver = function (resolver) {\n\t    var promise = this;\n\t    this._captureStackTrace();\n\t    this._pushContext();\n\t    var synchronous = true;\n\t    var r = tryCatch(resolver)(function(value) {\n\t        if (promise === null) return;\n\t        promise._resolveCallback(value);\n\t        promise = null;\n\t    }, function (reason) {\n\t        if (promise === null) return;\n\t        promise._rejectCallback(reason, synchronous);\n\t        promise = null;\n\t    });\n\t    synchronous = false;\n\t    this._popContext();\n\t\n\t    if (r !== undefined && r === errorObj && promise !== null) {\n\t        promise._rejectCallback(r.e, true, true);\n\t        promise = null;\n\t    }\n\t};\n\t\n\tPromise.prototype._settlePromiseFromHandler = function (\n\t    handler, receiver, value, promise\n\t) {\n\t    if (promise._isRejected()) return;\n\t    promise._pushContext();\n\t    var x;\n\t    if (receiver === APPLY && !this._isRejected()) {\n\t        x = tryCatch(handler).apply(this._boundTo, value);\n\t    } else {\n\t        x = tryCatch(handler).call(receiver, value);\n\t    }\n\t    promise._popContext();\n\t\n\t    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n\t        var err = x === promise ? makeSelfResolutionError() : x.e;\n\t        promise._rejectCallback(err, false, true);\n\t    } else {\n\t        promise._resolveCallback(x);\n\t    }\n\t};\n\t\n\tPromise.prototype._target = function() {\n\t    var ret = this;\n\t    while (ret._isFollowing()) ret = ret._followee();\n\t    return ret;\n\t};\n\t\n\tPromise.prototype._followee = function() {\n\t    return this._rejectionHandler0;\n\t};\n\t\n\tPromise.prototype._setFollowee = function(promise) {\n\t    this._rejectionHandler0 = promise;\n\t};\n\t\n\tPromise.prototype._cleanValues = function () {\n\t    if (this._cancellable()) {\n\t        this._cancellationParent = undefined;\n\t    }\n\t};\n\t\n\tPromise.prototype._propagateFrom = function (parent, flags) {\n\t    if ((flags & 1) > 0 && parent._cancellable()) {\n\t        this._setCancellable();\n\t        this._cancellationParent = parent;\n\t    }\n\t    if ((flags & 4) > 0 && parent._isBound()) {\n\t        this._setBoundTo(parent._boundTo);\n\t    }\n\t};\n\t\n\tPromise.prototype._fulfill = function (value) {\n\t    if (this._isFollowingOrFulfilledOrRejected()) return;\n\t    this._fulfillUnchecked(value);\n\t};\n\t\n\tPromise.prototype._reject = function (reason, carriedStackTrace) {\n\t    if (this._isFollowingOrFulfilledOrRejected()) return;\n\t    this._rejectUnchecked(reason, carriedStackTrace);\n\t};\n\t\n\tPromise.prototype._settlePromiseAt = function (index) {\n\t    var promise = this._promiseAt(index);\n\t    var isPromise = promise instanceof Promise;\n\t\n\t    if (isPromise && promise._isMigrated()) {\n\t        promise._unsetIsMigrated();\n\t        return async.invoke(this._settlePromiseAt, this, index);\n\t    }\n\t    var handler = this._isFulfilled()\n\t        ? this._fulfillmentHandlerAt(index)\n\t        : this._rejectionHandlerAt(index);\n\t\n\t    var carriedStackTrace =\n\t        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n\t    var value = this._settledValue;\n\t    var receiver = this._receiverAt(index);\n\t\n\t\n\t    this._clearCallbackDataAtIndex(index);\n\t\n\t    if (typeof handler === \"function\") {\n\t        if (!isPromise) {\n\t            handler.call(receiver, value, promise);\n\t        } else {\n\t            this._settlePromiseFromHandler(handler, receiver, value, promise);\n\t        }\n\t    } else if (receiver instanceof PromiseArray) {\n\t        if (!receiver._isResolved()) {\n\t            if (this._isFulfilled()) {\n\t                receiver._promiseFulfilled(value, promise);\n\t            }\n\t            else {\n\t                receiver._promiseRejected(value, promise);\n\t            }\n\t        }\n\t    } else if (isPromise) {\n\t        if (this._isFulfilled()) {\n\t            promise._fulfill(value);\n\t        } else {\n\t            promise._reject(value, carriedStackTrace);\n\t        }\n\t    }\n\t\n\t    if (index >= 4 && (index & 31) === 4)\n\t        async.invokeLater(this._setLength, this, 0);\n\t};\n\t\n\tPromise.prototype._clearCallbackDataAtIndex = function(index) {\n\t    if (index === 0) {\n\t        if (!this._isCarryingStackTrace()) {\n\t            this._fulfillmentHandler0 = undefined;\n\t        }\n\t        this._rejectionHandler0 =\n\t        this._progressHandler0 =\n\t        this._receiver0 =\n\t        this._promise0 = undefined;\n\t    } else {\n\t        var base = index * 5 - 5;\n\t        this[base + 3] =\n\t        this[base + 4] =\n\t        this[base + 0] =\n\t        this[base + 1] =\n\t        this[base + 2] = undefined;\n\t    }\n\t};\n\t\n\tPromise.prototype._isSettlePromisesQueued = function () {\n\t    return (this._bitField &\n\t            -1073741824) === -1073741824;\n\t};\n\t\n\tPromise.prototype._setSettlePromisesQueued = function () {\n\t    this._bitField = this._bitField | -1073741824;\n\t};\n\t\n\tPromise.prototype._unsetSettlePromisesQueued = function () {\n\t    this._bitField = this._bitField & (~-1073741824);\n\t};\n\t\n\tPromise.prototype._queueSettlePromises = function() {\n\t    async.settlePromises(this);\n\t    this._setSettlePromisesQueued();\n\t};\n\t\n\tPromise.prototype._fulfillUnchecked = function (value) {\n\t    if (value === this) {\n\t        var err = makeSelfResolutionError();\n\t        this._attachExtraTrace(err);\n\t        return this._rejectUnchecked(err, undefined);\n\t    }\n\t    this._setFulfilled();\n\t    this._settledValue = value;\n\t    this._cleanValues();\n\t\n\t    if (this._length() > 0) {\n\t        this._queueSettlePromises();\n\t    }\n\t};\n\t\n\tPromise.prototype._rejectUncheckedCheckError = function (reason) {\n\t    var trace = util.ensureErrorObject(reason);\n\t    this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n\t};\n\t\n\tPromise.prototype._rejectUnchecked = function (reason, trace) {\n\t    if (reason === this) {\n\t        var err = makeSelfResolutionError();\n\t        this._attachExtraTrace(err);\n\t        return this._rejectUnchecked(err);\n\t    }\n\t    this._setRejected();\n\t    this._settledValue = reason;\n\t    this._cleanValues();\n\t\n\t    if (this._isFinal()) {\n\t        async.throwLater(function(e) {\n\t            if (\"stack\" in e) {\n\t                async.invokeFirst(\n\t                    CapturedTrace.unhandledRejection, undefined, e);\n\t            }\n\t            throw e;\n\t        }, trace === undefined ? reason : trace);\n\t        return;\n\t    }\n\t\n\t    if (trace !== undefined && trace !== reason) {\n\t        this._setCarriedStackTrace(trace);\n\t    }\n\t\n\t    if (this._length() > 0) {\n\t        this._queueSettlePromises();\n\t    } else {\n\t        this._ensurePossibleRejectionHandled();\n\t    }\n\t};\n\t\n\tPromise.prototype._settlePromises = function () {\n\t    this._unsetSettlePromisesQueued();\n\t    var len = this._length();\n\t    for (var i = 0; i < len; i++) {\n\t        this._settlePromiseAt(i);\n\t    }\n\t};\n\t\n\tPromise._makeSelfResolutionError = makeSelfResolutionError;\n\t_dereq_(\"./method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n\t_dereq_(\"./bind.js\")(Promise, INTERNAL, tryConvertToPromise);\n\t_dereq_(\"./finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\n\t_dereq_(\"./direct_resolve.js\")(Promise);\n\t_dereq_(\"./synchronous_inspection.js\")(Promise);\n\t_dereq_(\"./join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\n\tPromise.Promise = Promise;\n\t_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n\t_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);\n\t_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);\n\t_dereq_('./nodeify.js')(Promise);\n\t_dereq_('./cancel.js')(Promise);\n\t_dereq_('./promisify.js')(Promise, INTERNAL);\n\t_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n\t_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n\t_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n\t_dereq_('./settle.js')(Promise, PromiseArray);\n\t_dereq_('./call_get.js')(Promise);\n\t_dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n\t_dereq_('./progress.js')(Promise, PromiseArray);\n\t_dereq_('./any.js')(Promise);\n\t_dereq_('./each.js')(Promise, INTERNAL);\n\t_dereq_('./timers.js')(Promise, INTERNAL);\n\t_dereq_('./filter.js')(Promise, INTERNAL);\n\t                                                         \n\t    util.toFastProperties(Promise);                                          \n\t    util.toFastProperties(Promise.prototype);                                \n\t    function fillTypes(value) {                                              \n\t        var p = new Promise(INTERNAL);                                       \n\t        p._fulfillmentHandler0 = value;                                      \n\t        p._rejectionHandler0 = value;                                        \n\t        p._progressHandler0 = value;                                         \n\t        p._promise0 = value;                                                 \n\t        p._receiver0 = value;                                                \n\t        p._settledValue = value;                                             \n\t    }                                                                        \n\t    // Complete slack tracking, opt out of field-type tracking and           \n\t    // stabilize map                                                         \n\t    fillTypes({a: 1});                                                       \n\t    fillTypes({b: 2});                                                       \n\t    fillTypes({c: 3});                                                       \n\t    fillTypes(1);                                                            \n\t    fillTypes(function(){});                                                 \n\t    fillTypes(undefined);                                                    \n\t    fillTypes(false);                                                        \n\t    fillTypes(new Promise(INTERNAL));                                        \n\t    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       \n\t    return Promise;                                                          \n\t\n\t};\n\t\n\t},{\"./any.js\":1,\"./async.js\":2,\"./bind.js\":3,\"./call_get.js\":5,\"./cancel.js\":6,\"./captured_trace.js\":7,\"./catch_filter.js\":8,\"./context.js\":9,\"./debuggability.js\":10,\"./direct_resolve.js\":11,\"./each.js\":12,\"./errors.js\":13,\"./filter.js\":15,\"./finally.js\":16,\"./generators.js\":17,\"./join.js\":18,\"./map.js\":19,\"./method.js\":20,\"./nodeify.js\":21,\"./progress.js\":22,\"./promise_array.js\":24,\"./promise_resolver.js\":25,\"./promisify.js\":26,\"./props.js\":27,\"./race.js\":29,\"./reduce.js\":30,\"./settle.js\":32,\"./some.js\":33,\"./synchronous_inspection.js\":34,\"./thenables.js\":35,\"./timers.js\":36,\"./using.js\":37,\"./util.js\":38}],24:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n\t    apiRejection) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar isArray = util.isArray;\n\t\n\tfunction toResolutionValue(val) {\n\t    switch(val) {\n\t    case -2: return [];\n\t    case -3: return {};\n\t    }\n\t}\n\t\n\tfunction PromiseArray(values) {\n\t    var promise = this._promise = new Promise(INTERNAL);\n\t    var parent;\n\t    if (values instanceof Promise) {\n\t        parent = values;\n\t        promise._propagateFrom(parent, 1 | 4);\n\t    }\n\t    this._values = values;\n\t    this._length = 0;\n\t    this._totalResolved = 0;\n\t    this._init(undefined, -2);\n\t}\n\tPromiseArray.prototype.length = function () {\n\t    return this._length;\n\t};\n\t\n\tPromiseArray.prototype.promise = function () {\n\t    return this._promise;\n\t};\n\t\n\tPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n\t    var values = tryConvertToPromise(this._values, this._promise);\n\t    if (values instanceof Promise) {\n\t        values = values._target();\n\t        this._values = values;\n\t        if (values._isFulfilled()) {\n\t            values = values._value();\n\t            if (!isArray(values)) {\n\t                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n\t                this.__hardReject__(err);\n\t                return;\n\t            }\n\t        } else if (values._isPending()) {\n\t            values._then(\n\t                init,\n\t                this._reject,\n\t                undefined,\n\t                this,\n\t                resolveValueIfEmpty\n\t           );\n\t            return;\n\t        } else {\n\t            this._reject(values._reason());\n\t            return;\n\t        }\n\t    } else if (!isArray(values)) {\n\t        this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n\t        return;\n\t    }\n\t\n\t    if (values.length === 0) {\n\t        if (resolveValueIfEmpty === -5) {\n\t            this._resolveEmptyArray();\n\t        }\n\t        else {\n\t            this._resolve(toResolutionValue(resolveValueIfEmpty));\n\t        }\n\t        return;\n\t    }\n\t    var len = this.getActualLength(values.length);\n\t    this._length = len;\n\t    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n\t    var promise = this._promise;\n\t    for (var i = 0; i < len; ++i) {\n\t        var isResolved = this._isResolved();\n\t        var maybePromise = tryConvertToPromise(values[i], promise);\n\t        if (maybePromise instanceof Promise) {\n\t            maybePromise = maybePromise._target();\n\t            if (isResolved) {\n\t                maybePromise._unsetRejectionIsUnhandled();\n\t            } else if (maybePromise._isPending()) {\n\t                maybePromise._proxyPromiseArray(this, i);\n\t            } else if (maybePromise._isFulfilled()) {\n\t                this._promiseFulfilled(maybePromise._value(), i);\n\t            } else {\n\t                this._promiseRejected(maybePromise._reason(), i);\n\t            }\n\t        } else if (!isResolved) {\n\t            this._promiseFulfilled(maybePromise, i);\n\t        }\n\t    }\n\t};\n\t\n\tPromiseArray.prototype._isResolved = function () {\n\t    return this._values === null;\n\t};\n\t\n\tPromiseArray.prototype._resolve = function (value) {\n\t    this._values = null;\n\t    this._promise._fulfill(value);\n\t};\n\t\n\tPromiseArray.prototype.__hardReject__ =\n\tPromiseArray.prototype._reject = function (reason) {\n\t    this._values = null;\n\t    this._promise._rejectCallback(reason, false, true);\n\t};\n\t\n\tPromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n\t    this._promise._progress({\n\t        index: index,\n\t        value: progressValue\n\t    });\n\t};\n\t\n\t\n\tPromiseArray.prototype._promiseFulfilled = function (value, index) {\n\t    this._values[index] = value;\n\t    var totalResolved = ++this._totalResolved;\n\t    if (totalResolved >= this._length) {\n\t        this._resolve(this._values);\n\t    }\n\t};\n\t\n\tPromiseArray.prototype._promiseRejected = function (reason, index) {\n\t    this._totalResolved++;\n\t    this._reject(reason);\n\t};\n\t\n\tPromiseArray.prototype.shouldCopyValues = function () {\n\t    return true;\n\t};\n\t\n\tPromiseArray.prototype.getActualLength = function (len) {\n\t    return len;\n\t};\n\t\n\treturn PromiseArray;\n\t};\n\t\n\t},{\"./util.js\":38}],25:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar util = _dereq_(\"./util.js\");\n\tvar maybeWrapAsError = util.maybeWrapAsError;\n\tvar errors = _dereq_(\"./errors.js\");\n\tvar TimeoutError = errors.TimeoutError;\n\tvar OperationalError = errors.OperationalError;\n\tvar haveGetters = util.haveGetters;\n\tvar es5 = _dereq_(\"./es5.js\");\n\t\n\tfunction isUntypedError(obj) {\n\t    return obj instanceof Error &&\n\t        es5.getPrototypeOf(obj) === Error.prototype;\n\t}\n\t\n\tvar rErrorKey = /^(?:name|message|stack|cause)$/;\n\tfunction wrapAsOperationalError(obj) {\n\t    var ret;\n\t    if (isUntypedError(obj)) {\n\t        ret = new OperationalError(obj);\n\t        ret.name = obj.name;\n\t        ret.message = obj.message;\n\t        ret.stack = obj.stack;\n\t        var keys = es5.keys(obj);\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (!rErrorKey.test(key)) {\n\t                ret[key] = obj[key];\n\t            }\n\t        }\n\t        return ret;\n\t    }\n\t    util.markAsOriginatingFromRejection(obj);\n\t    return obj;\n\t}\n\t\n\tfunction nodebackForPromise(promise) {\n\t    return function(err, value) {\n\t        if (promise === null) return;\n\t\n\t        if (err) {\n\t            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n\t            promise._attachExtraTrace(wrapped);\n\t            promise._reject(wrapped);\n\t        } else if (arguments.length > 2) {\n\t            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n\t            promise._fulfill(args);\n\t        } else {\n\t            promise._fulfill(value);\n\t        }\n\t\n\t        promise = null;\n\t    };\n\t}\n\t\n\t\n\tvar PromiseResolver;\n\tif (!haveGetters) {\n\t    PromiseResolver = function (promise) {\n\t        this.promise = promise;\n\t        this.asCallback = nodebackForPromise(promise);\n\t        this.callback = this.asCallback;\n\t    };\n\t}\n\telse {\n\t    PromiseResolver = function (promise) {\n\t        this.promise = promise;\n\t    };\n\t}\n\tif (haveGetters) {\n\t    var prop = {\n\t        get: function() {\n\t            return nodebackForPromise(this.promise);\n\t        }\n\t    };\n\t    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n\t    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n\t}\n\t\n\tPromiseResolver._nodebackForPromise = nodebackForPromise;\n\t\n\tPromiseResolver.prototype.toString = function () {\n\t    return \"[object PromiseResolver]\";\n\t};\n\t\n\tPromiseResolver.prototype.resolve =\n\tPromiseResolver.prototype.fulfill = function (value) {\n\t    if (!(this instanceof PromiseResolver)) {\n\t        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n\t    }\n\t    this.promise._resolveCallback(value);\n\t};\n\t\n\tPromiseResolver.prototype.reject = function (reason) {\n\t    if (!(this instanceof PromiseResolver)) {\n\t        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n\t    }\n\t    this.promise._rejectCallback(reason);\n\t};\n\t\n\tPromiseResolver.prototype.progress = function (value) {\n\t    if (!(this instanceof PromiseResolver)) {\n\t        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n\t    }\n\t    this.promise._progress(value);\n\t};\n\t\n\tPromiseResolver.prototype.cancel = function (err) {\n\t    this.promise.cancel(err);\n\t};\n\t\n\tPromiseResolver.prototype.timeout = function () {\n\t    this.reject(new TimeoutError(\"timeout\"));\n\t};\n\t\n\tPromiseResolver.prototype.isResolved = function () {\n\t    return this.promise.isResolved();\n\t};\n\t\n\tPromiseResolver.prototype.toJSON = function () {\n\t    return this.promise.toJSON();\n\t};\n\t\n\tmodule.exports = PromiseResolver;\n\t\n\t},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],26:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL) {\n\tvar THIS = {};\n\tvar util = _dereq_(\"./util.js\");\n\tvar nodebackForPromise = _dereq_(\"./promise_resolver.js\")\n\t    ._nodebackForPromise;\n\tvar withAppended = util.withAppended;\n\tvar maybeWrapAsError = util.maybeWrapAsError;\n\tvar canEvaluate = util.canEvaluate;\n\tvar TypeError = _dereq_(\"./errors\").TypeError;\n\tvar defaultSuffix = \"Async\";\n\tvar defaultPromisified = {__isPromisified__: true};\n\tvar noCopyPropsPattern =\n\t    /^(?:length|name|arguments|caller|prototype|__isPromisified__)$/;\n\tvar defaultFilter = function(name, func) {\n\t    return util.isIdentifier(name) &&\n\t        name.charAt(0) !== \"_\" &&\n\t        !util.isClass(func);\n\t};\n\t\n\tfunction propsFilter(key) {\n\t    return !noCopyPropsPattern.test(key);\n\t}\n\t\n\tfunction isPromisified(fn) {\n\t    try {\n\t        return fn.__isPromisified__ === true;\n\t    }\n\t    catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\tfunction hasPromisified(obj, key, suffix) {\n\t    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n\t                                            defaultPromisified);\n\t    return val ? isPromisified(val) : false;\n\t}\n\tfunction checkValid(ret, suffix, suffixRegexp) {\n\t    for (var i = 0; i < ret.length; i += 2) {\n\t        var key = ret[i];\n\t        if (suffixRegexp.test(key)) {\n\t            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n\t            for (var j = 0; j < ret.length; j += 2) {\n\t                if (ret[j] === keyWithoutAsyncSuffix) {\n\t                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\"\n\t                        .replace(\"%s\", suffix));\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n\t    var keys = util.inheritedDataKeys(obj);\n\t    var ret = [];\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var value = obj[key];\n\t        var passesDefaultFilter = filter === defaultFilter\n\t            ? true : defaultFilter(key, value, obj);\n\t        if (typeof value === \"function\" &&\n\t            !isPromisified(value) &&\n\t            !hasPromisified(obj, key, suffix) &&\n\t            filter(key, value, obj, passesDefaultFilter)) {\n\t            ret.push(key, value);\n\t        }\n\t    }\n\t    checkValid(ret, suffix, suffixRegexp);\n\t    return ret;\n\t}\n\t\n\tvar escapeIdentRegex = function(str) {\n\t    return str.replace(/([$])/, \"\\\\$\");\n\t};\n\t\n\tvar makeNodePromisifiedEval;\n\tif (false) {\n\tvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n\t    var ret = [likelyArgumentCount];\n\t    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n\t    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n\t        ret.push(i);\n\t    }\n\t    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n\t        ret.push(i);\n\t    }\n\t    return ret;\n\t};\n\t\n\tvar argumentSequence = function(argumentCount) {\n\t    return util.filledRange(argumentCount, \"_arg\", \"\");\n\t};\n\t\n\tvar parameterDeclaration = function(parameterCount) {\n\t    return util.filledRange(\n\t        Math.max(parameterCount, 3), \"_arg\", \"\");\n\t};\n\t\n\tvar parameterCount = function(fn) {\n\t    if (typeof fn.length === \"number\") {\n\t        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n\t    }\n\t    return 0;\n\t};\n\t\n\tmakeNodePromisifiedEval =\n\tfunction(callback, receiver, originalName, fn) {\n\t    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n\t    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n\t    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\t\n\t    function generateCallForArgumentCount(count) {\n\t        var args = argumentSequence(count).join(\", \");\n\t        var comma = count > 0 ? \", \" : \"\";\n\t        var ret;\n\t        if (shouldProxyThis) {\n\t            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n\t        } else {\n\t            ret = receiver === undefined\n\t                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n\t                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n\t        }\n\t        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n\t    }\n\t\n\t    function generateArgumentSwitchCase() {\n\t        var ret = \"\";\n\t        for (var i = 0; i < argumentOrder.length; ++i) {\n\t            ret += \"case \" + argumentOrder[i] +\":\" +\n\t                generateCallForArgumentCount(argumentOrder[i]);\n\t        }\n\t\n\t        ret += \"                                                             \\n\\\n\t        default:                                                             \\n\\\n\t            var args = new Array(len + 1);                                   \\n\\\n\t            var i = 0;                                                       \\n\\\n\t            for (var i = 0; i < len; ++i) {                                  \\n\\\n\t               args[i] = arguments[i];                                       \\n\\\n\t            }                                                                \\n\\\n\t            args[i] = nodeback;                                              \\n\\\n\t            [CodeForCall]                                                    \\n\\\n\t            break;                                                           \\n\\\n\t        \".replace(\"[CodeForCall]\", (shouldProxyThis\n\t                                ? \"ret = callback.apply(this, args);\\n\"\n\t                                : \"ret = callback.apply(receiver, args);\\n\"));\n\t        return ret;\n\t    }\n\t\n\t    var getFunctionCode = typeof callback === \"string\"\n\t                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n\t                                : \"fn\";\n\t\n\t    return new Function(\"Promise\",\n\t                        \"fn\",\n\t                        \"receiver\",\n\t                        \"withAppended\",\n\t                        \"maybeWrapAsError\",\n\t                        \"nodebackForPromise\",\n\t                        \"tryCatch\",\n\t                        \"errorObj\",\n\t                        \"INTERNAL\",\"'use strict';                            \\n\\\n\t        var ret = function (Parameters) {                                    \\n\\\n\t            'use strict';                                                    \\n\\\n\t            var len = arguments.length;                                      \\n\\\n\t            var promise = new Promise(INTERNAL);                             \\n\\\n\t            promise._captureStackTrace();                                    \\n\\\n\t            var nodeback = nodebackForPromise(promise);                      \\n\\\n\t            var ret;                                                         \\n\\\n\t            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n\t            switch(len) {                                                    \\n\\\n\t                [CodeForSwitchCase]                                          \\n\\\n\t            }                                                                \\n\\\n\t            if (ret === errorObj) {                                          \\n\\\n\t                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n\t            }                                                                \\n\\\n\t            return promise;                                                  \\n\\\n\t        };                                                                   \\n\\\n\t        ret.__isPromisified__ = true;                                        \\n\\\n\t        return ret;                                                          \\n\\\n\t        \"\n\t        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n\t        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n\t        .replace(\"[GetFunctionCode]\", getFunctionCode))(\n\t            Promise,\n\t            fn,\n\t            receiver,\n\t            withAppended,\n\t            maybeWrapAsError,\n\t            nodebackForPromise,\n\t            util.tryCatch,\n\t            util.errorObj,\n\t            INTERNAL\n\t        );\n\t};\n\t}\n\t\n\tfunction makeNodePromisifiedClosure(callback, receiver, _, fn) {\n\t    var defaultThis = (function() {return this;})();\n\t    var method = callback;\n\t    if (typeof method === \"string\") {\n\t        callback = fn;\n\t    }\n\t    function promisified() {\n\t        var _receiver = receiver;\n\t        if (receiver === THIS) _receiver = this;\n\t        var promise = new Promise(INTERNAL);\n\t        promise._captureStackTrace();\n\t        var cb = typeof method === \"string\" && this !== defaultThis\n\t            ? this[method] : callback;\n\t        var fn = nodebackForPromise(promise);\n\t        try {\n\t            cb.apply(_receiver, withAppended(arguments, fn));\n\t        } catch(e) {\n\t            promise._rejectCallback(maybeWrapAsError(e), true, true);\n\t        }\n\t        return promise;\n\t    }\n\t    promisified.__isPromisified__ = true;\n\t    return promisified;\n\t}\n\t\n\tvar makeNodePromisified = canEvaluate\n\t    ? makeNodePromisifiedEval\n\t    : makeNodePromisifiedClosure;\n\t\n\tfunction promisifyAll(obj, suffix, filter, promisifier) {\n\t    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n\t    var methods =\n\t        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\t\n\t    for (var i = 0, len = methods.length; i < len; i+= 2) {\n\t        var key = methods[i];\n\t        var fn = methods[i+1];\n\t        var promisifiedKey = key + suffix;\n\t        obj[promisifiedKey] = promisifier === makeNodePromisified\n\t                ? makeNodePromisified(key, THIS, key, fn, suffix)\n\t                : promisifier(fn, function() {\n\t                    return makeNodePromisified(key, THIS, key, fn, suffix);\n\t                });\n\t    }\n\t    util.toFastProperties(obj);\n\t    return obj;\n\t}\n\t\n\tfunction promisify(callback, receiver) {\n\t    return makeNodePromisified(callback, receiver, undefined, callback);\n\t}\n\t\n\tPromise.promisify = function (fn, receiver) {\n\t    if (typeof fn !== \"function\") {\n\t        throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    }\n\t    if (isPromisified(fn)) {\n\t        return fn;\n\t    }\n\t    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n\t    util.copyDescriptors(fn, ret, propsFilter);\n\t    return ret;\n\t};\n\t\n\tPromise.promisifyAll = function (target, options) {\n\t    if (typeof target !== \"function\" && typeof target !== \"object\") {\n\t        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n\t    }\n\t    options = Object(options);\n\t    var suffix = options.suffix;\n\t    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n\t    var filter = options.filter;\n\t    if (typeof filter !== \"function\") filter = defaultFilter;\n\t    var promisifier = options.promisifier;\n\t    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\t\n\t    if (!util.isIdentifier(suffix)) {\n\t        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n\t    }\n\t\n\t    var keys = util.inheritedDataKeys(target);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var value = target[keys[i]];\n\t        if (keys[i] !== \"constructor\" &&\n\t            util.isClass(value)) {\n\t            promisifyAll(value.prototype, suffix, filter, promisifier);\n\t            promisifyAll(value, suffix, filter, promisifier);\n\t        }\n\t    }\n\t\n\t    return promisifyAll(target, suffix, filter, promisifier);\n\t};\n\t};\n\t\n\t\n\t},{\"./errors\":13,\"./promise_resolver.js\":25,\"./util.js\":38}],27:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(\n\t    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar isObject = util.isObject;\n\tvar es5 = _dereq_(\"./es5.js\");\n\t\n\tfunction PropertiesPromiseArray(obj) {\n\t    var keys = es5.keys(obj);\n\t    var len = keys.length;\n\t    var values = new Array(len * 2);\n\t    for (var i = 0; i < len; ++i) {\n\t        var key = keys[i];\n\t        values[i] = obj[key];\n\t        values[i + len] = key;\n\t    }\n\t    this.constructor$(values);\n\t}\n\tutil.inherits(PropertiesPromiseArray, PromiseArray);\n\t\n\tPropertiesPromiseArray.prototype._init = function () {\n\t    this._init$(undefined, -3) ;\n\t};\n\t\n\tPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n\t    this._values[index] = value;\n\t    var totalResolved = ++this._totalResolved;\n\t    if (totalResolved >= this._length) {\n\t        var val = {};\n\t        var keyOffset = this.length();\n\t        for (var i = 0, len = this.length(); i < len; ++i) {\n\t            val[this._values[i + keyOffset]] = this._values[i];\n\t        }\n\t        this._resolve(val);\n\t    }\n\t};\n\t\n\tPropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n\t    this._promise._progress({\n\t        key: this._values[index + this.length()],\n\t        value: value\n\t    });\n\t};\n\t\n\tPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n\t    return false;\n\t};\n\t\n\tPropertiesPromiseArray.prototype.getActualLength = function (len) {\n\t    return len >> 1;\n\t};\n\t\n\tfunction props(promises) {\n\t    var ret;\n\t    var castValue = tryConvertToPromise(promises);\n\t\n\t    if (!isObject(castValue)) {\n\t        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n\t    } else if (castValue instanceof Promise) {\n\t        ret = castValue._then(\n\t            Promise.props, undefined, undefined, undefined, undefined);\n\t    } else {\n\t        ret = new PropertiesPromiseArray(castValue).promise();\n\t    }\n\t\n\t    if (castValue instanceof Promise) {\n\t        ret._propagateFrom(castValue, 4);\n\t    }\n\t    return ret;\n\t}\n\t\n\tPromise.prototype.props = function () {\n\t    return props(this);\n\t};\n\t\n\tPromise.props = function (promises) {\n\t    return props(promises);\n\t};\n\t};\n\t\n\t},{\"./es5.js\":14,\"./util.js\":38}],28:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n\t    for (var j = 0; j < len; ++j) {\n\t        dst[j + dstIndex] = src[j + srcIndex];\n\t        src[j + srcIndex] = void 0;\n\t    }\n\t}\n\t\n\tfunction Queue(capacity) {\n\t    this._capacity = capacity;\n\t    this._length = 0;\n\t    this._front = 0;\n\t}\n\t\n\tQueue.prototype._willBeOverCapacity = function (size) {\n\t    return this._capacity < size;\n\t};\n\t\n\tQueue.prototype._pushOne = function (arg) {\n\t    var length = this.length();\n\t    this._checkCapacity(length + 1);\n\t    var i = (this._front + length) & (this._capacity - 1);\n\t    this[i] = arg;\n\t    this._length = length + 1;\n\t};\n\t\n\tQueue.prototype._unshiftOne = function(value) {\n\t    var capacity = this._capacity;\n\t    this._checkCapacity(this.length() + 1);\n\t    var front = this._front;\n\t    var i = (((( front - 1 ) &\n\t                    ( capacity - 1) ) ^ capacity ) - capacity );\n\t    this[i] = value;\n\t    this._front = i;\n\t    this._length = this.length() + 1;\n\t};\n\t\n\tQueue.prototype.unshift = function(fn, receiver, arg) {\n\t    this._unshiftOne(arg);\n\t    this._unshiftOne(receiver);\n\t    this._unshiftOne(fn);\n\t};\n\t\n\tQueue.prototype.push = function (fn, receiver, arg) {\n\t    var length = this.length() + 3;\n\t    if (this._willBeOverCapacity(length)) {\n\t        this._pushOne(fn);\n\t        this._pushOne(receiver);\n\t        this._pushOne(arg);\n\t        return;\n\t    }\n\t    var j = this._front + length - 3;\n\t    this._checkCapacity(length);\n\t    var wrapMask = this._capacity - 1;\n\t    this[(j + 0) & wrapMask] = fn;\n\t    this[(j + 1) & wrapMask] = receiver;\n\t    this[(j + 2) & wrapMask] = arg;\n\t    this._length = length;\n\t};\n\t\n\tQueue.prototype.shift = function () {\n\t    var front = this._front,\n\t        ret = this[front];\n\t\n\t    this[front] = undefined;\n\t    this._front = (front + 1) & (this._capacity - 1);\n\t    this._length--;\n\t    return ret;\n\t};\n\t\n\tQueue.prototype.length = function () {\n\t    return this._length;\n\t};\n\t\n\tQueue.prototype._checkCapacity = function (size) {\n\t    if (this._capacity < size) {\n\t        this._resizeTo(this._capacity << 1);\n\t    }\n\t};\n\t\n\tQueue.prototype._resizeTo = function (capacity) {\n\t    var oldCapacity = this._capacity;\n\t    this._capacity = capacity;\n\t    var front = this._front;\n\t    var length = this._length;\n\t    var moveItemsCount = (front + length) & (oldCapacity - 1);\n\t    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n\t};\n\t\n\tmodule.exports = Queue;\n\t\n\t},{}],29:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(\n\t    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n\tvar isArray = _dereq_(\"./util.js\").isArray;\n\t\n\tvar raceLater = function (promise) {\n\t    return promise.then(function(array) {\n\t        return race(array, promise);\n\t    });\n\t};\n\t\n\tfunction race(promises, parent) {\n\t    var maybePromise = tryConvertToPromise(promises);\n\t\n\t    if (maybePromise instanceof Promise) {\n\t        return raceLater(maybePromise);\n\t    } else if (!isArray(promises)) {\n\t        return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n\t    }\n\t\n\t    var ret = new Promise(INTERNAL);\n\t    if (parent !== undefined) {\n\t        ret._propagateFrom(parent, 4 | 1);\n\t    }\n\t    var fulfill = ret._fulfill;\n\t    var reject = ret._reject;\n\t    for (var i = 0, len = promises.length; i < len; ++i) {\n\t        var val = promises[i];\n\t\n\t        if (val === undefined && !(i in promises)) {\n\t            continue;\n\t        }\n\t\n\t        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n\t    }\n\t    return ret;\n\t}\n\t\n\tPromise.race = function (promises) {\n\t    return race(promises, undefined);\n\t};\n\t\n\tPromise.prototype.race = function () {\n\t    return race(this, undefined);\n\t};\n\t\n\t};\n\t\n\t},{\"./util.js\":38}],30:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise,\n\t                          PromiseArray,\n\t                          apiRejection,\n\t                          tryConvertToPromise,\n\t                          INTERNAL) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar tryCatch = util.tryCatch;\n\tvar errorObj = util.errorObj;\n\tfunction ReductionPromiseArray(promises, fn, accum, _each) {\n\t    this.constructor$(promises);\n\t    this._promise._captureStackTrace();\n\t    this._preservedValues = _each === INTERNAL ? [] : null;\n\t    this._zerothIsAccum = (accum === undefined);\n\t    this._gotAccum = false;\n\t    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n\t    this._valuesPhase = undefined;\n\t    var maybePromise = tryConvertToPromise(accum, this._promise);\n\t    var rejected = false;\n\t    var isPromise = maybePromise instanceof Promise;\n\t    if (isPromise) {\n\t        maybePromise = maybePromise._target();\n\t        if (maybePromise._isPending()) {\n\t            maybePromise._proxyPromiseArray(this, -1);\n\t        } else if (maybePromise._isFulfilled()) {\n\t            accum = maybePromise._value();\n\t            this._gotAccum = true;\n\t        } else {\n\t            this._reject(maybePromise._reason());\n\t            rejected = true;\n\t        }\n\t    }\n\t    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n\t    this._callback = fn;\n\t    this._accum = accum;\n\t    if (!rejected) this._init$(undefined, -5);\n\t}\n\tutil.inherits(ReductionPromiseArray, PromiseArray);\n\t\n\tReductionPromiseArray.prototype._init = function () {};\n\t\n\tReductionPromiseArray.prototype._resolveEmptyArray = function () {\n\t    if (this._gotAccum || this._zerothIsAccum) {\n\t        this._resolve(this._preservedValues !== null\n\t                        ? [] : this._accum);\n\t    }\n\t};\n\t\n\tReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n\t    var values = this._values;\n\t    values[index] = value;\n\t    var length = this.length();\n\t    var preservedValues = this._preservedValues;\n\t    var isEach = preservedValues !== null;\n\t    var gotAccum = this._gotAccum;\n\t    var valuesPhase = this._valuesPhase;\n\t    var valuesPhaseIndex;\n\t    if (!valuesPhase) {\n\t        valuesPhase = this._valuesPhase = new Array(length);\n\t        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n\t            valuesPhase[valuesPhaseIndex] = 0;\n\t        }\n\t    }\n\t    valuesPhaseIndex = valuesPhase[index];\n\t\n\t    if (index === 0 && this._zerothIsAccum) {\n\t        this._accum = value;\n\t        this._gotAccum = gotAccum = true;\n\t        valuesPhase[index] = ((valuesPhaseIndex === 0)\n\t            ? 1 : 2);\n\t    } else if (index === -1) {\n\t        this._accum = value;\n\t        this._gotAccum = gotAccum = true;\n\t    } else {\n\t        if (valuesPhaseIndex === 0) {\n\t            valuesPhase[index] = 1;\n\t        } else {\n\t            valuesPhase[index] = 2;\n\t            this._accum = value;\n\t        }\n\t    }\n\t    if (!gotAccum) return;\n\t\n\t    var callback = this._callback;\n\t    var receiver = this._promise._boundTo;\n\t    var ret;\n\t\n\t    for (var i = this._reducingIndex; i < length; ++i) {\n\t        valuesPhaseIndex = valuesPhase[i];\n\t        if (valuesPhaseIndex === 2) {\n\t            this._reducingIndex = i + 1;\n\t            continue;\n\t        }\n\t        if (valuesPhaseIndex !== 1) return;\n\t        value = values[i];\n\t        this._promise._pushContext();\n\t        if (isEach) {\n\t            preservedValues.push(value);\n\t            ret = tryCatch(callback).call(receiver, value, i, length);\n\t        }\n\t        else {\n\t            ret = tryCatch(callback)\n\t                .call(receiver, this._accum, value, i, length);\n\t        }\n\t        this._promise._popContext();\n\t\n\t        if (ret === errorObj) return this._reject(ret.e);\n\t\n\t        var maybePromise = tryConvertToPromise(ret, this._promise);\n\t        if (maybePromise instanceof Promise) {\n\t            maybePromise = maybePromise._target();\n\t            if (maybePromise._isPending()) {\n\t                valuesPhase[i] = 4;\n\t                return maybePromise._proxyPromiseArray(this, i);\n\t            } else if (maybePromise._isFulfilled()) {\n\t                ret = maybePromise._value();\n\t            } else {\n\t                return this._reject(maybePromise._reason());\n\t            }\n\t        }\n\t\n\t        this._reducingIndex = i + 1;\n\t        this._accum = ret;\n\t    }\n\t\n\t    this._resolve(isEach ? preservedValues : this._accum);\n\t};\n\t\n\tfunction reduce(promises, fn, initialValue, _each) {\n\t    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n\t    return array.promise();\n\t}\n\t\n\tPromise.prototype.reduce = function (fn, initialValue) {\n\t    return reduce(this, fn, initialValue, null);\n\t};\n\t\n\tPromise.reduce = function (promises, fn, initialValue, _each) {\n\t    return reduce(promises, fn, initialValue, _each);\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],31:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar schedule;\n\tif (_dereq_(\"./util.js\").isNode) {\n\t    var version = process.versions.node.split(\".\").map(Number);\n\t    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)\n\t        ? global.setImmediate : process.nextTick;\n\t}\n\telse if (typeof MutationObserver !== \"undefined\") {\n\t    schedule = function(fn) {\n\t        var div = document.createElement(\"div\");\n\t        var observer = new MutationObserver(fn);\n\t        observer.observe(div, {attributes: true});\n\t        return function() { div.classList.toggle(\"foo\"); };\n\t    };\n\t    schedule.isStatic = true;\n\t}\n\telse if (typeof setTimeout !== \"undefined\") {\n\t    schedule = function (fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t}\n\telse {\n\t    schedule = function() {\n\t        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n\t    };\n\t}\n\tmodule.exports = schedule;\n\t\n\t},{\"./util.js\":38}],32:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports =\n\t    function(Promise, PromiseArray) {\n\tvar PromiseInspection = Promise.PromiseInspection;\n\tvar util = _dereq_(\"./util.js\");\n\t\n\tfunction SettledPromiseArray(values) {\n\t    this.constructor$(values);\n\t}\n\tutil.inherits(SettledPromiseArray, PromiseArray);\n\t\n\tSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n\t    this._values[index] = inspection;\n\t    var totalResolved = ++this._totalResolved;\n\t    if (totalResolved >= this._length) {\n\t        this._resolve(this._values);\n\t    }\n\t};\n\t\n\tSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n\t    var ret = new PromiseInspection();\n\t    ret._bitField = 268435456;\n\t    ret._settledValue = value;\n\t    this._promiseResolved(index, ret);\n\t};\n\tSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n\t    var ret = new PromiseInspection();\n\t    ret._bitField = 134217728;\n\t    ret._settledValue = reason;\n\t    this._promiseResolved(index, ret);\n\t};\n\t\n\tPromise.settle = function (promises) {\n\t    return new SettledPromiseArray(promises).promise();\n\t};\n\t\n\tPromise.prototype.settle = function () {\n\t    return new SettledPromiseArray(this).promise();\n\t};\n\t};\n\t\n\t},{\"./util.js\":38}],33:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports =\n\tfunction(Promise, PromiseArray, apiRejection) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar RangeError = _dereq_(\"./errors.js\").RangeError;\n\tvar AggregateError = _dereq_(\"./errors.js\").AggregateError;\n\tvar isArray = util.isArray;\n\t\n\t\n\tfunction SomePromiseArray(values) {\n\t    this.constructor$(values);\n\t    this._howMany = 0;\n\t    this._unwrap = false;\n\t    this._initialized = false;\n\t}\n\tutil.inherits(SomePromiseArray, PromiseArray);\n\t\n\tSomePromiseArray.prototype._init = function () {\n\t    if (!this._initialized) {\n\t        return;\n\t    }\n\t    if (this._howMany === 0) {\n\t        this._resolve([]);\n\t        return;\n\t    }\n\t    this._init$(undefined, -5);\n\t    var isArrayResolved = isArray(this._values);\n\t    if (!this._isResolved() &&\n\t        isArrayResolved &&\n\t        this._howMany > this._canPossiblyFulfill()) {\n\t        this._reject(this._getRangeError(this.length()));\n\t    }\n\t};\n\t\n\tSomePromiseArray.prototype.init = function () {\n\t    this._initialized = true;\n\t    this._init();\n\t};\n\t\n\tSomePromiseArray.prototype.setUnwrap = function () {\n\t    this._unwrap = true;\n\t};\n\t\n\tSomePromiseArray.prototype.howMany = function () {\n\t    return this._howMany;\n\t};\n\t\n\tSomePromiseArray.prototype.setHowMany = function (count) {\n\t    this._howMany = count;\n\t};\n\t\n\tSomePromiseArray.prototype._promiseFulfilled = function (value) {\n\t    this._addFulfilled(value);\n\t    if (this._fulfilled() === this.howMany()) {\n\t        this._values.length = this.howMany();\n\t        if (this.howMany() === 1 && this._unwrap) {\n\t            this._resolve(this._values[0]);\n\t        } else {\n\t            this._resolve(this._values);\n\t        }\n\t    }\n\t\n\t};\n\tSomePromiseArray.prototype._promiseRejected = function (reason) {\n\t    this._addRejected(reason);\n\t    if (this.howMany() > this._canPossiblyFulfill()) {\n\t        var e = new AggregateError();\n\t        for (var i = this.length(); i < this._values.length; ++i) {\n\t            e.push(this._values[i]);\n\t        }\n\t        this._reject(e);\n\t    }\n\t};\n\t\n\tSomePromiseArray.prototype._fulfilled = function () {\n\t    return this._totalResolved;\n\t};\n\t\n\tSomePromiseArray.prototype._rejected = function () {\n\t    return this._values.length - this.length();\n\t};\n\t\n\tSomePromiseArray.prototype._addRejected = function (reason) {\n\t    this._values.push(reason);\n\t};\n\t\n\tSomePromiseArray.prototype._addFulfilled = function (value) {\n\t    this._values[this._totalResolved++] = value;\n\t};\n\t\n\tSomePromiseArray.prototype._canPossiblyFulfill = function () {\n\t    return this.length() - this._rejected();\n\t};\n\t\n\tSomePromiseArray.prototype._getRangeError = function (count) {\n\t    var message = \"Input array must contain at least \" +\n\t            this._howMany + \" items but contains only \" + count + \" items\";\n\t    return new RangeError(message);\n\t};\n\t\n\tSomePromiseArray.prototype._resolveEmptyArray = function () {\n\t    this._reject(this._getRangeError(0));\n\t};\n\t\n\tfunction some(promises, howMany) {\n\t    if ((howMany | 0) !== howMany || howMany < 0) {\n\t        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n\t    }\n\t    var ret = new SomePromiseArray(promises);\n\t    var promise = ret.promise();\n\t    ret.setHowMany(howMany);\n\t    ret.init();\n\t    return promise;\n\t}\n\t\n\tPromise.some = function (promises, howMany) {\n\t    return some(promises, howMany);\n\t};\n\t\n\tPromise.prototype.some = function (howMany) {\n\t    return some(this, howMany);\n\t};\n\t\n\tPromise._SomePromiseArray = SomePromiseArray;\n\t};\n\t\n\t},{\"./errors.js\":13,\"./util.js\":38}],34:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise) {\n\tfunction PromiseInspection(promise) {\n\t    if (promise !== undefined) {\n\t        promise = promise._target();\n\t        this._bitField = promise._bitField;\n\t        this._settledValue = promise._settledValue;\n\t    }\n\t    else {\n\t        this._bitField = 0;\n\t        this._settledValue = undefined;\n\t    }\n\t}\n\t\n\tPromiseInspection.prototype.value = function () {\n\t    if (!this.isFulfilled()) {\n\t        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n\t    }\n\t    return this._settledValue;\n\t};\n\t\n\tPromiseInspection.prototype.error =\n\tPromiseInspection.prototype.reason = function () {\n\t    if (!this.isRejected()) {\n\t        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n\t    }\n\t    return this._settledValue;\n\t};\n\t\n\tPromiseInspection.prototype.isFulfilled =\n\tPromise.prototype._isFulfilled = function () {\n\t    return (this._bitField & 268435456) > 0;\n\t};\n\t\n\tPromiseInspection.prototype.isRejected =\n\tPromise.prototype._isRejected = function () {\n\t    return (this._bitField & 134217728) > 0;\n\t};\n\t\n\tPromiseInspection.prototype.isPending =\n\tPromise.prototype._isPending = function () {\n\t    return (this._bitField & 402653184) === 0;\n\t};\n\t\n\tPromiseInspection.prototype.isResolved =\n\tPromise.prototype._isResolved = function () {\n\t    return (this._bitField & 402653184) > 0;\n\t};\n\t\n\tPromise.prototype.isPending = function() {\n\t    return this._target()._isPending();\n\t};\n\t\n\tPromise.prototype.isRejected = function() {\n\t    return this._target()._isRejected();\n\t};\n\t\n\tPromise.prototype.isFulfilled = function() {\n\t    return this._target()._isFulfilled();\n\t};\n\t\n\tPromise.prototype.isResolved = function() {\n\t    return this._target()._isResolved();\n\t};\n\t\n\tPromise.prototype._value = function() {\n\t    return this._settledValue;\n\t};\n\t\n\tPromise.prototype._reason = function() {\n\t    this._unsetRejectionIsUnhandled();\n\t    return this._settledValue;\n\t};\n\t\n\tPromise.prototype.value = function() {\n\t    var target = this._target();\n\t    if (!target.isFulfilled()) {\n\t        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n\t    }\n\t    return target._settledValue;\n\t};\n\t\n\tPromise.prototype.reason = function() {\n\t    var target = this._target();\n\t    if (!target.isRejected()) {\n\t        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n\t    }\n\t    target._unsetRejectionIsUnhandled();\n\t    return target._settledValue;\n\t};\n\t\n\t\n\tPromise.PromiseInspection = PromiseInspection;\n\t};\n\t\n\t},{}],35:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar errorObj = util.errorObj;\n\tvar isObject = util.isObject;\n\t\n\tfunction tryConvertToPromise(obj, context) {\n\t    if (isObject(obj)) {\n\t        if (obj instanceof Promise) {\n\t            return obj;\n\t        }\n\t        else if (isAnyBluebirdPromise(obj)) {\n\t            var ret = new Promise(INTERNAL);\n\t            obj._then(\n\t                ret._fulfillUnchecked,\n\t                ret._rejectUncheckedCheckError,\n\t                ret._progressUnchecked,\n\t                ret,\n\t                null\n\t            );\n\t            return ret;\n\t        }\n\t        var then = util.tryCatch(getThen)(obj);\n\t        if (then === errorObj) {\n\t            if (context) context._pushContext();\n\t            var ret = Promise.reject(then.e);\n\t            if (context) context._popContext();\n\t            return ret;\n\t        } else if (typeof then === \"function\") {\n\t            return doThenable(obj, then, context);\n\t        }\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction getThen(obj) {\n\t    return obj.then;\n\t}\n\t\n\tvar hasProp = {}.hasOwnProperty;\n\tfunction isAnyBluebirdPromise(obj) {\n\t    return hasProp.call(obj, \"_promise0\");\n\t}\n\t\n\tfunction doThenable(x, then, context) {\n\t    var promise = new Promise(INTERNAL);\n\t    var ret = promise;\n\t    if (context) context._pushContext();\n\t    promise._captureStackTrace();\n\t    if (context) context._popContext();\n\t    var synchronous = true;\n\t    var result = util.tryCatch(then).call(x,\n\t                                        resolveFromThenable,\n\t                                        rejectFromThenable,\n\t                                        progressFromThenable);\n\t    synchronous = false;\n\t    if (promise && result === errorObj) {\n\t        promise._rejectCallback(result.e, true, true);\n\t        promise = null;\n\t    }\n\t\n\t    function resolveFromThenable(value) {\n\t        if (!promise) return;\n\t        if (x === value) {\n\t            promise._rejectCallback(\n\t                Promise._makeSelfResolutionError(), false, true);\n\t        } else {\n\t            promise._resolveCallback(value);\n\t        }\n\t        promise = null;\n\t    }\n\t\n\t    function rejectFromThenable(reason) {\n\t        if (!promise) return;\n\t        promise._rejectCallback(reason, synchronous, true);\n\t        promise = null;\n\t    }\n\t\n\t    function progressFromThenable(value) {\n\t        if (!promise) return;\n\t        if (typeof promise._progress === \"function\") {\n\t            promise._progress(value);\n\t        }\n\t    }\n\t    return ret;\n\t}\n\t\n\treturn tryConvertToPromise;\n\t};\n\t\n\t},{\"./util.js\":38}],36:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function(Promise, INTERNAL) {\n\tvar util = _dereq_(\"./util.js\");\n\tvar TimeoutError = Promise.TimeoutError;\n\t\n\tvar afterTimeout = function (promise, message) {\n\t    if (!promise.isPending()) return;\n\t    if (typeof message !== \"string\") {\n\t        message = \"operation timed out\";\n\t    }\n\t    var err = new TimeoutError(message);\n\t    util.markAsOriginatingFromRejection(err);\n\t    promise._attachExtraTrace(err);\n\t    promise._cancel(err);\n\t};\n\t\n\tvar afterValue = function(value) { return delay(+this).thenReturn(value); };\n\tvar delay = Promise.delay = function (value, ms) {\n\t    if (ms === undefined) {\n\t        ms = value;\n\t        value = undefined;\n\t        var ret = new Promise(INTERNAL);\n\t        setTimeout(function() { ret._fulfill(); }, ms);\n\t        return ret;\n\t    }\n\t    ms = +ms;\n\t    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n\t};\n\t\n\tPromise.prototype.delay = function (ms) {\n\t    return delay(this, ms);\n\t};\n\t\n\tfunction successClear(value) {\n\t    var handle = this;\n\t    if (handle instanceof Number) handle = +handle;\n\t    clearTimeout(handle);\n\t    return value;\n\t}\n\t\n\tfunction failureClear(reason) {\n\t    var handle = this;\n\t    if (handle instanceof Number) handle = +handle;\n\t    clearTimeout(handle);\n\t    throw reason;\n\t}\n\t\n\tPromise.prototype.timeout = function (ms, message) {\n\t    ms = +ms;\n\t    var ret = this.then().cancellable();\n\t    ret._cancellationParent = this;\n\t    var handle = setTimeout(function timeoutTimeout() {\n\t        afterTimeout(ret, message);\n\t    }, ms);\n\t    return ret._then(successClear, failureClear, undefined, handle, undefined);\n\t};\n\t\n\t};\n\t\n\t},{\"./util.js\":38}],37:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n\t    createContext) {\n\t    var TypeError = _dereq_(\"./errors.js\").TypeError;\n\t    var inherits = _dereq_(\"./util.js\").inherits;\n\t    var PromiseInspection = Promise.PromiseInspection;\n\t\n\t    function inspectionMapper(inspections) {\n\t        var len = inspections.length;\n\t        for (var i = 0; i < len; ++i) {\n\t            var inspection = inspections[i];\n\t            if (inspection.isRejected()) {\n\t                return Promise.reject(inspection.error());\n\t            }\n\t            inspections[i] = inspection._settledValue;\n\t        }\n\t        return inspections;\n\t    }\n\t\n\t    function thrower(e) {\n\t        setTimeout(function(){throw e;}, 0);\n\t    }\n\t\n\t    function castPreservingDisposable(thenable) {\n\t        var maybePromise = tryConvertToPromise(thenable);\n\t        if (maybePromise !== thenable &&\n\t            typeof thenable._isDisposable === \"function\" &&\n\t            typeof thenable._getDisposer === \"function\" &&\n\t            thenable._isDisposable()) {\n\t            maybePromise._setDisposable(thenable._getDisposer());\n\t        }\n\t        return maybePromise;\n\t    }\n\t    function dispose(resources, inspection) {\n\t        var i = 0;\n\t        var len = resources.length;\n\t        var ret = Promise.defer();\n\t        function iterator() {\n\t            if (i >= len) return ret.resolve();\n\t            var maybePromise = castPreservingDisposable(resources[i++]);\n\t            if (maybePromise instanceof Promise &&\n\t                maybePromise._isDisposable()) {\n\t                try {\n\t                    maybePromise = tryConvertToPromise(\n\t                        maybePromise._getDisposer().tryDispose(inspection),\n\t                        resources.promise);\n\t                } catch (e) {\n\t                    return thrower(e);\n\t                }\n\t                if (maybePromise instanceof Promise) {\n\t                    return maybePromise._then(iterator, thrower,\n\t                                              null, null, null);\n\t                }\n\t            }\n\t            iterator();\n\t        }\n\t        iterator();\n\t        return ret.promise;\n\t    }\n\t\n\t    function disposerSuccess(value) {\n\t        var inspection = new PromiseInspection();\n\t        inspection._settledValue = value;\n\t        inspection._bitField = 268435456;\n\t        return dispose(this, inspection).thenReturn(value);\n\t    }\n\t\n\t    function disposerFail(reason) {\n\t        var inspection = new PromiseInspection();\n\t        inspection._settledValue = reason;\n\t        inspection._bitField = 134217728;\n\t        return dispose(this, inspection).thenThrow(reason);\n\t    }\n\t\n\t    function Disposer(data, promise, context) {\n\t        this._data = data;\n\t        this._promise = promise;\n\t        this._context = context;\n\t    }\n\t\n\t    Disposer.prototype.data = function () {\n\t        return this._data;\n\t    };\n\t\n\t    Disposer.prototype.promise = function () {\n\t        return this._promise;\n\t    };\n\t\n\t    Disposer.prototype.resource = function () {\n\t        if (this.promise().isFulfilled()) {\n\t            return this.promise().value();\n\t        }\n\t        return null;\n\t    };\n\t\n\t    Disposer.prototype.tryDispose = function(inspection) {\n\t        var resource = this.resource();\n\t        var context = this._context;\n\t        if (context !== undefined) context._pushContext();\n\t        var ret = resource !== null\n\t            ? this.doDispose(resource, inspection) : null;\n\t        if (context !== undefined) context._popContext();\n\t        this._promise._unsetDisposable();\n\t        this._data = null;\n\t        return ret;\n\t    };\n\t\n\t    Disposer.isDisposer = function (d) {\n\t        return (d != null &&\n\t                typeof d.resource === \"function\" &&\n\t                typeof d.tryDispose === \"function\");\n\t    };\n\t\n\t    function FunctionDisposer(fn, promise, context) {\n\t        this.constructor$(fn, promise, context);\n\t    }\n\t    inherits(FunctionDisposer, Disposer);\n\t\n\t    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n\t        var fn = this.data();\n\t        return fn.call(resource, resource, inspection);\n\t    };\n\t\n\t    function maybeUnwrapDisposer(value) {\n\t        if (Disposer.isDisposer(value)) {\n\t            this.resources[this.index]._setDisposable(value);\n\t            return value.promise();\n\t        }\n\t        return value;\n\t    }\n\t\n\t    Promise.using = function () {\n\t        var len = arguments.length;\n\t        if (len < 2) return apiRejection(\n\t                        \"you must pass at least 2 arguments to Promise.using\");\n\t        var fn = arguments[len - 1];\n\t        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\t        len--;\n\t        var resources = new Array(len);\n\t        for (var i = 0; i < len; ++i) {\n\t            var resource = arguments[i];\n\t            if (Disposer.isDisposer(resource)) {\n\t                var disposer = resource;\n\t                resource = resource.promise();\n\t                resource._setDisposable(disposer);\n\t            } else {\n\t                var maybePromise = tryConvertToPromise(resource);\n\t                if (maybePromise instanceof Promise) {\n\t                    resource =\n\t                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n\t                            resources: resources,\n\t                            index: i\n\t                    }, undefined);\n\t                }\n\t            }\n\t            resources[i] = resource;\n\t        }\n\t\n\t        var promise = Promise.settle(resources)\n\t            .then(inspectionMapper)\n\t            .then(function(vals) {\n\t                promise._pushContext();\n\t                var ret;\n\t                try {\n\t                    ret = fn.apply(undefined, vals);\n\t                } finally {\n\t                    promise._popContext();\n\t                }\n\t                return ret;\n\t            })\n\t            ._then(\n\t                disposerSuccess, disposerFail, undefined, resources, undefined);\n\t        resources.promise = promise;\n\t        return promise;\n\t    };\n\t\n\t    Promise.prototype._setDisposable = function (disposer) {\n\t        this._bitField = this._bitField | 262144;\n\t        this._disposer = disposer;\n\t    };\n\t\n\t    Promise.prototype._isDisposable = function () {\n\t        return (this._bitField & 262144) > 0;\n\t    };\n\t\n\t    Promise.prototype._getDisposer = function () {\n\t        return this._disposer;\n\t    };\n\t\n\t    Promise.prototype._unsetDisposable = function () {\n\t        this._bitField = this._bitField & (~262144);\n\t        this._disposer = undefined;\n\t    };\n\t\n\t    Promise.prototype.disposer = function (fn) {\n\t        if (typeof fn === \"function\") {\n\t            return new FunctionDisposer(fn, this, createContext());\n\t        }\n\t        throw new TypeError();\n\t    };\n\t\n\t};\n\t\n\t},{\"./errors.js\":13,\"./util.js\":38}],38:[function(_dereq_,module,exports){\n\t\"use strict\";\n\tvar es5 = _dereq_(\"./es5.js\");\n\tvar canEvaluate = typeof navigator == \"undefined\";\n\tvar haveGetters = (function(){\n\t    try {\n\t        var o = {};\n\t        es5.defineProperty(o, \"f\", {\n\t            get: function () {\n\t                return 3;\n\t            }\n\t        });\n\t        return o.f === 3;\n\t    }\n\t    catch (e) {\n\t        return false;\n\t    }\n\t\n\t})();\n\t\n\tvar errorObj = {e: {}};\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    } catch (e) {\n\t        errorObj.e = e;\n\t        return errorObj;\n\t    }\n\t}\n\tfunction tryCatch(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\t\n\tvar inherits = function(Child, Parent) {\n\t    var hasProp = {}.hasOwnProperty;\n\t\n\t    function T() {\n\t        this.constructor = Child;\n\t        this.constructor$ = Parent;\n\t        for (var propertyName in Parent.prototype) {\n\t            if (hasProp.call(Parent.prototype, propertyName) &&\n\t                propertyName.charAt(propertyName.length-1) !== \"$\"\n\t           ) {\n\t                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n\t            }\n\t        }\n\t    }\n\t    T.prototype = Parent.prototype;\n\t    Child.prototype = new T();\n\t    return Child.prototype;\n\t};\n\t\n\t\n\tfunction isPrimitive(val) {\n\t    return val == null || val === true || val === false ||\n\t        typeof val === \"string\" || typeof val === \"number\";\n\t\n\t}\n\t\n\tfunction isObject(value) {\n\t    return !isPrimitive(value);\n\t}\n\t\n\tfunction maybeWrapAsError(maybeError) {\n\t    if (!isPrimitive(maybeError)) return maybeError;\n\t\n\t    return new Error(safeToString(maybeError));\n\t}\n\t\n\tfunction withAppended(target, appendee) {\n\t    var len = target.length;\n\t    var ret = new Array(len + 1);\n\t    var i;\n\t    for (i = 0; i < len; ++i) {\n\t        ret[i] = target[i];\n\t    }\n\t    ret[i] = appendee;\n\t    return ret;\n\t}\n\t\n\tfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n\t    if (es5.isES5) {\n\t        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\t        if (desc != null) {\n\t            return desc.get == null && desc.set == null\n\t                    ? desc.value\n\t                    : defaultValue;\n\t        }\n\t    } else {\n\t        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n\t    }\n\t}\n\t\n\tfunction notEnumerableProp(obj, name, value) {\n\t    if (isPrimitive(obj)) return obj;\n\t    var descriptor = {\n\t        value: value,\n\t        configurable: true,\n\t        enumerable: false,\n\t        writable: true\n\t    };\n\t    es5.defineProperty(obj, name, descriptor);\n\t    return obj;\n\t}\n\t\n\t\n\tvar wrapsPrimitiveReceiver = (function() {\n\t    return this !== \"string\";\n\t}).call(\"string\");\n\t\n\tfunction thrower(r) {\n\t    throw r;\n\t}\n\t\n\tvar inheritedDataKeys = (function() {\n\t    if (es5.isES5) {\n\t        var oProto = Object.prototype;\n\t        var getKeys = Object.getOwnPropertyNames;\n\t        return function(obj) {\n\t            var ret = [];\n\t            var visitedKeys = Object.create(null);\n\t            while (obj != null && obj !== oProto) {\n\t                var keys;\n\t                try {\n\t                    keys = getKeys(obj);\n\t                } catch (e) {\n\t                    return ret;\n\t                }\n\t                for (var i = 0; i < keys.length; ++i) {\n\t                    var key = keys[i];\n\t                    if (visitedKeys[key]) continue;\n\t                    visitedKeys[key] = true;\n\t                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n\t                    if (desc != null && desc.get == null && desc.set == null) {\n\t                        ret.push(key);\n\t                    }\n\t                }\n\t                obj = es5.getPrototypeOf(obj);\n\t            }\n\t            return ret;\n\t        };\n\t    } else {\n\t        return function(obj) {\n\t            var ret = [];\n\t            /*jshint forin:false */\n\t            for (var key in obj) {\n\t                ret.push(key);\n\t            }\n\t            return ret;\n\t        };\n\t    }\n\t\n\t})();\n\t\n\tfunction isClass(fn) {\n\t    try {\n\t        if (typeof fn === \"function\") {\n\t            var keys = es5.names(fn.prototype);\n\t            if (es5.isES5) return keys.length > 1;\n\t            return keys.length > 0 &&\n\t                   !(keys.length === 1 && keys[0] === \"constructor\");\n\t        }\n\t        return false;\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\tfunction toFastProperties(obj) {\n\t    /*jshint -W027*/\n\t    function f() {}\n\t    f.prototype = obj;\n\t    return f;\n\t    eval(obj);\n\t}\n\t\n\tvar rident = /^[a-z$_][a-z$_0-9]*$/i;\n\tfunction isIdentifier(str) {\n\t    return rident.test(str);\n\t}\n\t\n\tfunction filledRange(count, prefix, suffix) {\n\t    var ret = new Array(count);\n\t    for(var i = 0; i < count; ++i) {\n\t        ret[i] = prefix + i + suffix;\n\t    }\n\t    return ret;\n\t}\n\t\n\tfunction safeToString(obj) {\n\t    try {\n\t        return obj + \"\";\n\t    } catch (e) {\n\t        return \"[no string representation]\";\n\t    }\n\t}\n\t\n\tfunction markAsOriginatingFromRejection(e) {\n\t    try {\n\t        notEnumerableProp(e, \"isOperational\", true);\n\t    }\n\t    catch(ignore) {}\n\t}\n\t\n\tfunction originatesFromRejection(e) {\n\t    if (e == null) return false;\n\t    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n\t        e[\"isOperational\"] === true);\n\t}\n\t\n\tfunction canAttachTrace(obj) {\n\t    return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n\t}\n\t\n\tvar ensureErrorObject = (function() {\n\t    if (!(\"stack\" in new Error())) {\n\t        return function(value) {\n\t            if (canAttachTrace(value)) return value;\n\t            try {throw new Error(safeToString(value));}\n\t            catch(err) {return err;}\n\t        };\n\t    } else {\n\t        return function(value) {\n\t            if (canAttachTrace(value)) return value;\n\t            return new Error(safeToString(value));\n\t        };\n\t    }\n\t})();\n\t\n\tfunction classString(obj) {\n\t    return {}.toString.call(obj);\n\t}\n\t\n\tfunction copyDescriptors(from, to, filter) {\n\t    var keys = es5.names(from);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        if (filter(key)) {\n\t            es5.defineProperty(to, key, es5.getDescriptor(from, key));\n\t        }\n\t    }\n\t}\n\t\n\tvar ret = {\n\t    isClass: isClass,\n\t    isIdentifier: isIdentifier,\n\t    inheritedDataKeys: inheritedDataKeys,\n\t    getDataPropertyOrDefault: getDataPropertyOrDefault,\n\t    thrower: thrower,\n\t    isArray: es5.isArray,\n\t    haveGetters: haveGetters,\n\t    notEnumerableProp: notEnumerableProp,\n\t    isPrimitive: isPrimitive,\n\t    isObject: isObject,\n\t    canEvaluate: canEvaluate,\n\t    errorObj: errorObj,\n\t    tryCatch: tryCatch,\n\t    inherits: inherits,\n\t    withAppended: withAppended,\n\t    maybeWrapAsError: maybeWrapAsError,\n\t    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,\n\t    toFastProperties: toFastProperties,\n\t    filledRange: filledRange,\n\t    toString: safeToString,\n\t    canAttachTrace: canAttachTrace,\n\t    ensureErrorObject: ensureErrorObject,\n\t    originatesFromRejection: originatesFromRejection,\n\t    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n\t    classString: classString,\n\t    copyDescriptors: copyDescriptors,\n\t    isNode: typeof process !== \"undefined\" &&\n\t        classString(process).toLowerCase() === \"[object process]\"\n\t};\n\ttry {throw new Error(); } catch (e) {ret.lastLineError = e;}\n\tmodule.exports = ret;\n\t\n\t},{\"./es5.js\":14}]},{},[4])(4)\n\t});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), (function() { return this; }())))\n\n/***/ },\n\n/***/ 26:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(27);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n\n/***/ 27:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 's':\n\t      return n * s;\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n\n/***/ 29:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\tvar readBlob = _interopRequire(__webpack_require__(18));\n\t\n\tvar defaultAudioContext = _interopRequire(__webpack_require__(19));\n\t\n\tvar SamplingMaster = exports.SamplingMaster = (function () {\n\t  function SamplingMaster(audioContext) {\n\t    _classCallCheck(this, SamplingMaster);\n\t\n\t    this._audioContext = audioContext || defaultAudioContext;\n\t    this._samples = [];\n\t    this._instances = new Set();\n\t  }\n\t\n\t  _prototypeProperties(SamplingMaster, null, {\n\t    unmute: {\n\t\n\t      /**\n\t       * Connects a dummy node to the audio, thereby unmuting the audio system on\n\t       * iOS devices.\n\t       */\n\t      value: function unmute() {\n\t        var ctx = this._audioContext;\n\t        var gain = ctx.createGain();\n\t        gain.connect(ctx.destination);\n\t        gain.disconnect();\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    audioContext: {\n\t      get: function () {\n\t        return this._audioContext;\n\t      },\n\t      configurable: true\n\t    },\n\t    destroy: {\n\t      value: function destroy() {\n\t        if (this._destroyed) {\n\t          return;\n\t        }this._destroyed = true;\n\t        for (var _iterator = this._samples[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n\t          var sample = _step.value;\n\t          sample.destroy();\n\t        }for (var _iterator2 = this._instances[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {\n\t          var instance = _step2.value;\n\t          instance.destroy();\n\t        }this._samples = null;\n\t        this._instances = null;\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    sample: {\n\t      value: function sample(blobOrArrayBuffer) {\n\t        var _this = this;\n\t        return this._coerceToArrayBuffer(blobOrArrayBuffer).then(function (arrayBuffer) {\n\t          return _this._decodeAudio(arrayBuffer);\n\t        }).then(function (audioBuffer) {\n\t          if (_this._destroyed) throw new Error(\"SamplingMaster already destroyed!\");\n\t          var sample = new Sample(_this, audioBuffer);\n\t          _this._samples.push(sample);\n\t          return sample;\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _coerceToArrayBuffer: {\n\t      value: function _coerceToArrayBuffer(blobOrArrayBuffer) {\n\t        if (blobOrArrayBuffer instanceof ArrayBuffer) {\n\t          return Promise.resolve(blobOrArrayBuffer);\n\t        } else {\n\t          return readBlob(blobOrArrayBuffer).as(\"arraybuffer\");\n\t        }\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _decodeAudio: {\n\t      value: function _decodeAudio(arrayBuffer) {\n\t        var _this = this;\n\t        return new Promise(function (resolve, reject) {\n\t          _this.audioContext.decodeAudioData(arrayBuffer, function decodeAudioDataSuccess(audioBuffer) {\n\t            resolve(audioBuffer);\n\t          }, function decodeAudioDataFailure(e) {\n\t            reject(\"Unable to decode audio: \" + e);\n\t          });\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _startPlaying: {\n\t      value: function _startPlaying(instance) {\n\t        this._instances.add(instance);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _stoppedPlaying: {\n\t      value: function _stoppedPlaying(instance) {\n\t        this._instances[\"delete\"](instance);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return SamplingMaster;\n\t})();\n\tvar Sample = (function () {\n\t  function Sample(samplingMaster, audioBuffer) {\n\t    _classCallCheck(this, Sample);\n\t\n\t    this._master = samplingMaster;\n\t    this._buffer = audioBuffer;\n\t  }\n\t\n\t  _prototypeProperties(Sample, null, {\n\t    play: {\n\t      value: function play(delay, node) {\n\t        return new PlayInstance(this._master, this._buffer, delay, node);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    destroy: {\n\t      value: function destroy() {\n\t        this._master = null;\n\t        this._buffer = null;\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return Sample;\n\t})();\n\t\n\tvar PlayInstance = (function () {\n\t  function PlayInstance(samplingMaster, buffer, delay, node) {\n\t    var _this = this;\n\t    _classCallCheck(this, PlayInstance);\n\t\n\t    this._master = samplingMaster;\n\t    var context = samplingMaster.audioContext;\n\t    var source = context.createBufferSource();\n\t    source.buffer = buffer;\n\t    var gain = context.createGain();\n\t    source.connect(gain);\n\t    gain.connect(node || context.destination);\n\t    this._source = source;\n\t    this._gain = gain;\n\t    source.start(!delay ? 0 : Math.max(0, context.currentTime + delay));\n\t    setTimeout(function () {\n\t      return _this.stop();\n\t    }, (delay + buffer.duration + 0.01) * 1000);\n\t    this._master._startPlaying(this);\n\t  }\n\t\n\t  _prototypeProperties(PlayInstance, null, {\n\t    stop: {\n\t      value: function stop() {\n\t        if (!this._source) {\n\t          return;\n\t        }this._source.stop(0);\n\t        this._source.disconnect();\n\t        this._gain.disconnect();\n\t        this._source = null;\n\t        this._gain = null;\n\t        this._master._stoppedPlaying(this);\n\t        if (this.onstop) this.onstop();\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    destroy: {\n\t      value: function destroy() {\n\t        this.stop();\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return PlayInstance;\n\t})();\n\t\n\texports[\"default\"] = SamplingMaster;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 33:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = DataStructure\n\t\n\tfunction DataStructure() {\n\t\n\t  var schemas = [].slice.call(arguments)\n\t\n\t  function Constructor(object) {\n\t    Constructor.validate(object)\n\t    return object\n\t  }\n\t\n\t  Constructor.validate = function(object) {\n\t    for (var i = 0; i < schemas.length; i ++) {\n\t      validate(schemas[i], object)\n\t    }\n\t  }\n\t\n\t  return Constructor\n\t\n\t}\n\t\n\tDataStructure.maybe = function maybe(schema) {\n\t  function MaybeValidator(object) {\n\t    MaybeValidator.validate(object)\n\t    return object\n\t  }\n\t  MaybeValidator.validate = function(value) {\n\t    if (value === null || value === undefined) return\n\t    validate(schema, value)\n\t  }\n\t  return MaybeValidator\n\t}\n\t\n\tfunction validate(schema, value) {\n\t  if (schema === Number) schema = 'number'\n\t  if (schema === String) schema = 'string'\n\t  if (typeof schema === 'string') {\n\t    if (typeof value !== schema) throw new Error('should be a ' + schema)\n\t  } else if (typeof schema === 'function') {\n\t    if (typeof schema.validate === 'function') {\n\t      schema.validate(value)\n\t    } else if (!(value instanceof schema)) {\n\t      throw new Error('should be an instance of ' + schema)\n\t    }\n\t  } else if (typeof schema === 'object') {\n\t    if (!value) throw new Error('should be an object')\n\t    validateObject(schema, value)\n\t  } else {\n\t    throw new Error('invalid schema')\n\t  }\n\t}\n\t\n\tfunction validateObject(schema, object) {\n\t  for (var prop in schema) {\n\t    if (!(prop in object)) {\n\t      throw new Error('missing property: \"' + prop + '\"')\n\t    }\n\t    try {\n\t      validate(schema[prop], object[prop])\n\t    } catch (e) {\n\t      throw new Error('error in property \"' + prop + '\": ' + e.message)\n\t    }\n\t  }\n\t}\n\t\n\n\n/***/ },\n\n/***/ 37:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t\n\tvar base64 = __webpack_require__(108)\n\tvar ieee754 = __webpack_require__(109)\n\tvar isArray = __webpack_require__(110)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = Buffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar kMaxLength = 0x3fffffff\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Note:\n\t *\n\t * - Implementation must support adding new properties to `Uint8Array` instances.\n\t *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n\t *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *    incorrect length in some situations.\n\t *\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will\n\t * get the Object implementation, which is slower but will work correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = (function () {\n\t  try {\n\t    var buf = new ArrayBuffer(0)\n\t    var arr = new Uint8Array(buf)\n\t    arr.foo = function () { return 42 }\n\t    return 42 === arr.foo() && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t})()\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (subject, encoding, noZero) {\n\t  if (!(this instanceof Buffer))\n\t    return new Buffer(subject, encoding, noZero)\n\t\n\t  var type = typeof subject\n\t\n\t  // Find the length\n\t  var length\n\t  if (type === 'number')\n\t    length = subject > 0 ? subject >>> 0 : 0\n\t  else if (type === 'string') {\n\t    if (encoding === 'base64')\n\t      subject = base64clean(subject)\n\t    length = Buffer.byteLength(subject, encoding)\n\t  } else if (type === 'object' && subject !== null) { // assume object is array-like\n\t    if (subject.type === 'Buffer' && isArray(subject.data))\n\t      subject = subject.data\n\t    length = +subject.length > 0 ? Math.floor(+subject.length) : 0\n\t  } else\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t\n\t  if (this.length > kMaxLength)\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t      'size: 0x' + kMaxLength.toString(16) + ' bytes')\n\t\n\t  var buf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Preferred: Return an augmented `Uint8Array` instance for best performance\n\t    buf = Buffer._augment(new Uint8Array(length))\n\t  } else {\n\t    // Fallback: Return THIS instance of Buffer (created by `new`)\n\t    buf = this\n\t    buf.length = length\n\t    buf._isBuffer = true\n\t  }\n\t\n\t  var i\n\t  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {\n\t    // Speed optimization -- use set if we're copying from a typed array\n\t    buf._set(subject)\n\t  } else if (isArrayish(subject)) {\n\t    // Treat array-ish objects as a byte array\n\t    if (Buffer.isBuffer(subject)) {\n\t      for (i = 0; i < length; i++)\n\t        buf[i] = subject.readUInt8(i)\n\t    } else {\n\t      for (i = 0; i < length; i++)\n\t        buf[i] = ((subject[i] % 256) + 256) % 256\n\t    }\n\t  } else if (type === 'string') {\n\t    buf.write(subject, 0, encoding)\n\t  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {\n\t    for (i = 0; i < length; i++) {\n\t      buf[i] = 0\n\t    }\n\t  }\n\t\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))\n\t    throw new TypeError('Arguments must be Buffers')\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function (list, totalLength) {\n\t  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  } else if (list.length === 1) {\n\t    return list[0]\n\t  }\n\t\n\t  var i\n\t  if (totalLength === undefined) {\n\t    totalLength = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      totalLength += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(totalLength)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tBuffer.byteLength = function (str, encoding) {\n\t  var ret\n\t  str = str + ''\n\t  switch (encoding || 'utf8') {\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'raw':\n\t      ret = str.length\n\t      break\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      ret = str.length * 2\n\t      break\n\t    case 'hex':\n\t      ret = str.length >>> 1\n\t      break\n\t    case 'utf8':\n\t    case 'utf-8':\n\t      ret = utf8ToBytes(str).length\n\t      break\n\t    case 'base64':\n\t      ret = base64ToBytes(str).length\n\t      break\n\t    default:\n\t      ret = str.length\n\t  }\n\t  return ret\n\t}\n\t\n\t// pre-set for values that may exist in the future\n\tBuffer.prototype.length = undefined\n\tBuffer.prototype.parent = undefined\n\t\n\t// toString(encoding, start=0, end=buffer.length)\n\tBuffer.prototype.toString = function (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start >>> 0\n\t  end = end === undefined || end === Infinity ? this.length : end >>> 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase)\n\t          throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.equals = function (b) {\n\t  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max)\n\t      str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\t// `get` will be removed in Node 0.13+\n\tBuffer.prototype.get = function (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` will be removed in Node 0.13+\n\tBuffer.prototype.set = function (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var byte = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(byte)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = byte\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)\n\t  return charsWritten\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)\n\t  return charsWritten\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)\n\t  return charsWritten\n\t}\n\t\n\tfunction utf16leWrite (buf, string, offset, length) {\n\t  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)\n\t  return charsWritten\n\t}\n\t\n\tBuffer.prototype.write = function (string, offset, length, encoding) {\n\t  // Support both (string, offset, length, encoding)\n\t  // and the legacy (string, encoding, offset, length)\n\t  if (isFinite(offset)) {\n\t    if (!isFinite(length)) {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  } else {  // legacy\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length\n\t    length = swap\n\t  }\n\t\n\t  offset = Number(offset) || 0\n\t  var remaining = this.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t  encoding = String(encoding || 'utf8').toLowerCase()\n\t\n\t  var ret\n\t  switch (encoding) {\n\t    case 'hex':\n\t      ret = hexWrite(this, string, offset, length)\n\t      break\n\t    case 'utf8':\n\t    case 'utf-8':\n\t      ret = utf8Write(this, string, offset, length)\n\t      break\n\t    case 'ascii':\n\t      ret = asciiWrite(this, string, offset, length)\n\t      break\n\t    case 'binary':\n\t      ret = binaryWrite(this, string, offset, length)\n\t      break\n\t    case 'base64':\n\t      ret = base64Write(this, string, offset, length)\n\t      break\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      ret = utf16leWrite(this, string, offset, length)\n\t      break\n\t    default:\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\t  return ret\n\t}\n\t\n\tBuffer.prototype.toJSON = function () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  var res = ''\n\t  var tmp = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    if (buf[i] <= 0x7F) {\n\t      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n\t      tmp = ''\n\t    } else {\n\t      tmp += '%' + buf[i].toString(16)\n\t    }\n\t  }\n\t\n\t  return res + decodeUtf8Char(tmp)\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  return asciiSlice(buf, start, end)\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0)\n\t      start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0)\n\t      end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start)\n\t    end = start\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    return Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    var newBuf = new Buffer(sliceLen, undefined, true)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t    return newBuf\n\t  }\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0)\n\t    throw new RangeError('offset is not uint')\n\t  if (offset + ext > length)\n\t    throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t      ((this[offset + 1] << 16) |\n\t      (this[offset + 2] << 8) |\n\t      this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readInt8 = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80))\n\t    return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16) |\n\t      (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t      (this[offset + 1] << 16) |\n\t      (this[offset + 2] << 8) |\n\t      (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n\t  if (!noAssert)\n\t    checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new TypeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new TypeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = value\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = value\n\t    this[offset + 1] = (value >>> 8)\n\t  } else objectWriteUInt16(this, value, offset, true)\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = value\n\t  } else objectWriteUInt16(this, value, offset, false)\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = value\n\t  } else objectWriteUInt32(this, value, offset, true)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = value\n\t  } else objectWriteUInt32(this, value, offset, false)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = value\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = value\n\t    this[offset + 1] = (value >>> 8)\n\t  } else objectWriteUInt16(this, value, offset, true)\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = value\n\t  } else objectWriteUInt16(this, value, offset, false)\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = value\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else objectWriteUInt32(this, value, offset, true)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset >>> 0\n\t  if (!noAssert)\n\t    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = value\n\t  } else objectWriteUInt32(this, value, offset, false)\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new TypeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new TypeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert)\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert)\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function (target, target_start, start, end) {\n\t  var source = this\n\t\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (!target_start) target_start = 0\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return\n\t  if (target.length === 0 || source.length === 0) return\n\t\n\t  // Fatal error conditions\n\t  if (end < start) throw new TypeError('sourceEnd < sourceStart')\n\t  if (target_start < 0 || target_start >= target.length)\n\t    throw new TypeError('targetStart out of bounds')\n\t  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')\n\t  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length)\n\t    end = this.length\n\t  if (target.length - target_start < end - start)\n\t    end = target.length - target_start + start\n\t\n\t  var len = end - start\n\t\n\t  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < len; i++) {\n\t      target[i + target_start] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), target_start)\n\t  }\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new TypeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array get/set methods before overwriting\n\t  arr._get = arr.get\n\t  arr._set = arr.set\n\t\n\t  // deprecated, will be removed in node 0.13+\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-z]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction isArrayish (subject) {\n\t  return isArray(subject) || Buffer.isBuffer(subject) ||\n\t      subject && typeof subject === 'object' &&\n\t      typeof subject.length === 'number'\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    var b = str.charCodeAt(i)\n\t    if (b <= 0x7F) {\n\t      byteArray.push(b)\n\t    } else {\n\t      var start = i\n\t      if (b >= 0xD800 && b <= 0xDFFF) i++\n\t      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n\t      for (var j = 0; j < h.length; j++) {\n\t        byteArray.push(parseInt(h[j], 16))\n\t      }\n\t    }\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(str)\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length, unitSize) {\n\t  if (unitSize) length -= length % unitSize;\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length))\n\t      break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction decodeUtf8Char (str) {\n\t  try {\n\t    return decodeURIComponent(str)\n\t  } catch (err) {\n\t    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).Buffer))\n\n/***/ },\n\n/***/ 38:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== \"undefined\") {\n\t    module.exports = window;\n\t} else if (typeof global !== \"undefined\") {\n\t    module.exports = global;\n\t} else {\n\t    module.exports = {};\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 39:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.download = download;\n\tfunction download(url) {\n\t  return {\n\t    as: function as(type, progress) {\n\t      return new Promise(function (resolve, reject) {\n\t        var xh = new XMLHttpRequest();\n\t        xh.open(\"GET\", url, true);\n\t        xh.responseType = type;\n\t        xh.onload = function () {\n\t          if (+xh.status === 200) {\n\t            resolve(xh.response);\n\t          } else {\n\t            reject(new Error(\"Unable to download \" + url + \": HTTP \" + xh.status));\n\t          }\n\t        };\n\t        xh.onerror = function () {\n\t          return reject(new Error(\"Unable to download \" + url));\n\t        };\n\t        if (progress) xh.onprogress = function (e) {\n\t          return progress.report(e.loaded, e.total);\n\t        };\n\t        xh.send(null);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\texports[\"default\"] = download;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 42:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar punycode = __webpack_require__(111);\n\t\n\texports.parse = urlParse;\n\texports.resolve = urlResolve;\n\texports.resolveObject = urlResolveObject;\n\texports.format = urlFormat;\n\t\n\texports.Url = Url;\n\t\n\tfunction Url() {\n\t  this.protocol = null;\n\t  this.slashes = null;\n\t  this.auth = null;\n\t  this.host = null;\n\t  this.port = null;\n\t  this.hostname = null;\n\t  this.hash = null;\n\t  this.search = null;\n\t  this.query = null;\n\t  this.pathname = null;\n\t  this.path = null;\n\t  this.href = null;\n\t}\n\t\n\t// Reference: RFC 3986, RFC 1808, RFC 2396\n\t\n\t// define these here so at least they only have to be\n\t// compiled once on the first module load.\n\tvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n\t    portPattern = /:[0-9]*$/,\n\t\n\t    // RFC 2396: characters reserved for delimiting URLs.\n\t    // We actually just auto-escape these.\n\t    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\t\n\t    // RFC 2396: characters not allowed for various reasons.\n\t    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\t\n\t    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n\t    autoEscape = ['\\''].concat(unwise),\n\t    // Characters that are never ever allowed in a hostname.\n\t    // Note that any invalid chars are also handled, but these\n\t    // are the ones that are *expected* to be seen, so we fast-path\n\t    // them.\n\t    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n\t    hostEndingChars = ['/', '?', '#'],\n\t    hostnameMaxLen = 255,\n\t    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n\t    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n\t    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n\t    unsafeProtocol = {\n\t      'javascript': true,\n\t      'javascript:': true\n\t    },\n\t    // protocols that never have a hostname.\n\t    hostlessProtocol = {\n\t      'javascript': true,\n\t      'javascript:': true\n\t    },\n\t    // protocols that always contain a // bit.\n\t    slashedProtocol = {\n\t      'http': true,\n\t      'https': true,\n\t      'ftp': true,\n\t      'gopher': true,\n\t      'file': true,\n\t      'http:': true,\n\t      'https:': true,\n\t      'ftp:': true,\n\t      'gopher:': true,\n\t      'file:': true\n\t    },\n\t    querystring = __webpack_require__(127);\n\t\n\tfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n\t  if (url && isObject(url) && url instanceof Url) return url;\n\t\n\t  var u = new Url;\n\t  u.parse(url, parseQueryString, slashesDenoteHost);\n\t  return u;\n\t}\n\t\n\tUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n\t  if (!isString(url)) {\n\t    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n\t  }\n\t\n\t  var rest = url;\n\t\n\t  // trim before proceeding.\n\t  // This is to support parse stuff like \"  http://foo.com  \\n\"\n\t  rest = rest.trim();\n\t\n\t  var proto = protocolPattern.exec(rest);\n\t  if (proto) {\n\t    proto = proto[0];\n\t    var lowerProto = proto.toLowerCase();\n\t    this.protocol = lowerProto;\n\t    rest = rest.substr(proto.length);\n\t  }\n\t\n\t  // figure out if it's got a host\n\t  // user@server is *always* interpreted as a hostname, and url\n\t  // resolution will treat //foo/bar as host=foo,path=bar because that's\n\t  // how the browser resolves relative URLs.\n\t  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n\t    var slashes = rest.substr(0, 2) === '//';\n\t    if (slashes && !(proto && hostlessProtocol[proto])) {\n\t      rest = rest.substr(2);\n\t      this.slashes = true;\n\t    }\n\t  }\n\t\n\t  if (!hostlessProtocol[proto] &&\n\t      (slashes || (proto && !slashedProtocol[proto]))) {\n\t\n\t    // there's a hostname.\n\t    // the first instance of /, ?, ;, or # ends the host.\n\t    //\n\t    // If there is an @ in the hostname, then non-host chars *are* allowed\n\t    // to the left of the last @ sign, unless some host-ending character\n\t    // comes *before* the @-sign.\n\t    // URLs are obnoxious.\n\t    //\n\t    // ex:\n\t    // http://a@b@c/ => user:a@b host:c\n\t    // http://a@b?@c => user:a host:c path:/?@c\n\t\n\t    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n\t    // Review our test case against browsers more comprehensively.\n\t\n\t    // find the first instance of any hostEndingChars\n\t    var hostEnd = -1;\n\t    for (var i = 0; i < hostEndingChars.length; i++) {\n\t      var hec = rest.indexOf(hostEndingChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\t\n\t    // at this point, either we have an explicit point where the\n\t    // auth portion cannot go past, or the last @ char is the decider.\n\t    var auth, atSign;\n\t    if (hostEnd === -1) {\n\t      // atSign can be anywhere.\n\t      atSign = rest.lastIndexOf('@');\n\t    } else {\n\t      // atSign must be in auth portion.\n\t      // http://a@b/c@d => host:b auth:a path:/c@d\n\t      atSign = rest.lastIndexOf('@', hostEnd);\n\t    }\n\t\n\t    // Now we have a portion which is definitely the auth.\n\t    // Pull that off.\n\t    if (atSign !== -1) {\n\t      auth = rest.slice(0, atSign);\n\t      rest = rest.slice(atSign + 1);\n\t      this.auth = decodeURIComponent(auth);\n\t    }\n\t\n\t    // the host is the remaining to the left of the first non-host char\n\t    hostEnd = -1;\n\t    for (var i = 0; i < nonHostChars.length; i++) {\n\t      var hec = rest.indexOf(nonHostChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\t    // if we still have not hit it, then the entire thing is a host.\n\t    if (hostEnd === -1)\n\t      hostEnd = rest.length;\n\t\n\t    this.host = rest.slice(0, hostEnd);\n\t    rest = rest.slice(hostEnd);\n\t\n\t    // pull out port.\n\t    this.parseHost();\n\t\n\t    // we've indicated that there is a hostname,\n\t    // so even if it's empty, it has to be present.\n\t    this.hostname = this.hostname || '';\n\t\n\t    // if hostname begins with [ and ends with ]\n\t    // assume that it's an IPv6 address.\n\t    var ipv6Hostname = this.hostname[0] === '[' &&\n\t        this.hostname[this.hostname.length - 1] === ']';\n\t\n\t    // validate a little.\n\t    if (!ipv6Hostname) {\n\t      var hostparts = this.hostname.split(/\\./);\n\t      for (var i = 0, l = hostparts.length; i < l; i++) {\n\t        var part = hostparts[i];\n\t        if (!part) continue;\n\t        if (!part.match(hostnamePartPattern)) {\n\t          var newpart = '';\n\t          for (var j = 0, k = part.length; j < k; j++) {\n\t            if (part.charCodeAt(j) > 127) {\n\t              // we replace non-ASCII char with a temporary placeholder\n\t              // we need this to make sure size of hostname is not\n\t              // broken by replacing non-ASCII by nothing\n\t              newpart += 'x';\n\t            } else {\n\t              newpart += part[j];\n\t            }\n\t          }\n\t          // we test again with ASCII char only\n\t          if (!newpart.match(hostnamePartPattern)) {\n\t            var validParts = hostparts.slice(0, i);\n\t            var notHost = hostparts.slice(i + 1);\n\t            var bit = part.match(hostnamePartStart);\n\t            if (bit) {\n\t              validParts.push(bit[1]);\n\t              notHost.unshift(bit[2]);\n\t            }\n\t            if (notHost.length) {\n\t              rest = '/' + notHost.join('.') + rest;\n\t            }\n\t            this.hostname = validParts.join('.');\n\t            break;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (this.hostname.length > hostnameMaxLen) {\n\t      this.hostname = '';\n\t    } else {\n\t      // hostnames are always lower case.\n\t      this.hostname = this.hostname.toLowerCase();\n\t    }\n\t\n\t    if (!ipv6Hostname) {\n\t      // IDNA Support: Returns a puny coded representation of \"domain\".\n\t      // It only converts the part of the domain name that\n\t      // has non ASCII characters. I.e. it dosent matter if\n\t      // you call it with a domain that already is in ASCII.\n\t      var domainArray = this.hostname.split('.');\n\t      var newOut = [];\n\t      for (var i = 0; i < domainArray.length; ++i) {\n\t        var s = domainArray[i];\n\t        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n\t            'xn--' + punycode.encode(s) : s);\n\t      }\n\t      this.hostname = newOut.join('.');\n\t    }\n\t\n\t    var p = this.port ? ':' + this.port : '';\n\t    var h = this.hostname || '';\n\t    this.host = h + p;\n\t    this.href += this.host;\n\t\n\t    // strip [ and ] from the hostname\n\t    // the host field still retains them, though\n\t    if (ipv6Hostname) {\n\t      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\t      if (rest[0] !== '/') {\n\t        rest = '/' + rest;\n\t      }\n\t    }\n\t  }\n\t\n\t  // now rest is set to the post-host stuff.\n\t  // chop off any delim chars.\n\t  if (!unsafeProtocol[lowerProto]) {\n\t\n\t    // First, make 100% sure that any \"autoEscape\" chars get\n\t    // escaped, even if encodeURIComponent doesn't think they\n\t    // need to be.\n\t    for (var i = 0, l = autoEscape.length; i < l; i++) {\n\t      var ae = autoEscape[i];\n\t      var esc = encodeURIComponent(ae);\n\t      if (esc === ae) {\n\t        esc = escape(ae);\n\t      }\n\t      rest = rest.split(ae).join(esc);\n\t    }\n\t  }\n\t\n\t\n\t  // chop off from the tail first.\n\t  var hash = rest.indexOf('#');\n\t  if (hash !== -1) {\n\t    // got a fragment string.\n\t    this.hash = rest.substr(hash);\n\t    rest = rest.slice(0, hash);\n\t  }\n\t  var qm = rest.indexOf('?');\n\t  if (qm !== -1) {\n\t    this.search = rest.substr(qm);\n\t    this.query = rest.substr(qm + 1);\n\t    if (parseQueryString) {\n\t      this.query = querystring.parse(this.query);\n\t    }\n\t    rest = rest.slice(0, qm);\n\t  } else if (parseQueryString) {\n\t    // no query string, but parseQueryString still requested\n\t    this.search = '';\n\t    this.query = {};\n\t  }\n\t  if (rest) this.pathname = rest;\n\t  if (slashedProtocol[lowerProto] &&\n\t      this.hostname && !this.pathname) {\n\t    this.pathname = '/';\n\t  }\n\t\n\t  //to support http.request\n\t  if (this.pathname || this.search) {\n\t    var p = this.pathname || '';\n\t    var s = this.search || '';\n\t    this.path = p + s;\n\t  }\n\t\n\t  // finally, reconstruct the href based on what has been validated.\n\t  this.href = this.format();\n\t  return this;\n\t};\n\t\n\t// format a parsed object into a url string\n\tfunction urlFormat(obj) {\n\t  // ensure it's an object, and not a string url.\n\t  // If it's an obj, this is a no-op.\n\t  // this way, you can call url_format() on strings\n\t  // to clean up potentially wonky urls.\n\t  if (isString(obj)) obj = urlParse(obj);\n\t  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n\t  return obj.format();\n\t}\n\t\n\tUrl.prototype.format = function() {\n\t  var auth = this.auth || '';\n\t  if (auth) {\n\t    auth = encodeURIComponent(auth);\n\t    auth = auth.replace(/%3A/i, ':');\n\t    auth += '@';\n\t  }\n\t\n\t  var protocol = this.protocol || '',\n\t      pathname = this.pathname || '',\n\t      hash = this.hash || '',\n\t      host = false,\n\t      query = '';\n\t\n\t  if (this.host) {\n\t    host = auth + this.host;\n\t  } else if (this.hostname) {\n\t    host = auth + (this.hostname.indexOf(':') === -1 ?\n\t        this.hostname :\n\t        '[' + this.hostname + ']');\n\t    if (this.port) {\n\t      host += ':' + this.port;\n\t    }\n\t  }\n\t\n\t  if (this.query &&\n\t      isObject(this.query) &&\n\t      Object.keys(this.query).length) {\n\t    query = querystring.stringify(this.query);\n\t  }\n\t\n\t  var search = this.search || (query && ('?' + query)) || '';\n\t\n\t  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\t\n\t  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n\t  // unless they had them to begin with.\n\t  if (this.slashes ||\n\t      (!protocol || slashedProtocol[protocol]) && host !== false) {\n\t    host = '//' + (host || '');\n\t    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n\t  } else if (!host) {\n\t    host = '';\n\t  }\n\t\n\t  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n\t  if (search && search.charAt(0) !== '?') search = '?' + search;\n\t\n\t  pathname = pathname.replace(/[?#]/g, function(match) {\n\t    return encodeURIComponent(match);\n\t  });\n\t  search = search.replace('#', '%23');\n\t\n\t  return protocol + host + pathname + search + hash;\n\t};\n\t\n\tfunction urlResolve(source, relative) {\n\t  return urlParse(source, false, true).resolve(relative);\n\t}\n\t\n\tUrl.prototype.resolve = function(relative) {\n\t  return this.resolveObject(urlParse(relative, false, true)).format();\n\t};\n\t\n\tfunction urlResolveObject(source, relative) {\n\t  if (!source) return relative;\n\t  return urlParse(source, false, true).resolveObject(relative);\n\t}\n\t\n\tUrl.prototype.resolveObject = function(relative) {\n\t  if (isString(relative)) {\n\t    var rel = new Url();\n\t    rel.parse(relative, false, true);\n\t    relative = rel;\n\t  }\n\t\n\t  var result = new Url();\n\t  Object.keys(this).forEach(function(k) {\n\t    result[k] = this[k];\n\t  }, this);\n\t\n\t  // hash is always overridden, no matter what.\n\t  // even href=\"\" will remove it.\n\t  result.hash = relative.hash;\n\t\n\t  // if the relative url is empty, then there's nothing left to do here.\n\t  if (relative.href === '') {\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  // hrefs like //foo/bar always cut to the protocol.\n\t  if (relative.slashes && !relative.protocol) {\n\t    // take everything except the protocol from relative\n\t    Object.keys(relative).forEach(function(k) {\n\t      if (k !== 'protocol')\n\t        result[k] = relative[k];\n\t    });\n\t\n\t    //urlParse appends trailing / to urls like http://www.example.com\n\t    if (slashedProtocol[result.protocol] &&\n\t        result.hostname && !result.pathname) {\n\t      result.path = result.pathname = '/';\n\t    }\n\t\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  if (relative.protocol && relative.protocol !== result.protocol) {\n\t    // if it's a known url protocol, then changing\n\t    // the protocol does weird things\n\t    // first, if it's not file:, then we MUST have a host,\n\t    // and if there was a path\n\t    // to begin with, then we MUST have a path.\n\t    // if it is file:, then the host is dropped,\n\t    // because that's known to be hostless.\n\t    // anything else is assumed to be absolute.\n\t    if (!slashedProtocol[relative.protocol]) {\n\t      Object.keys(relative).forEach(function(k) {\n\t        result[k] = relative[k];\n\t      });\n\t      result.href = result.format();\n\t      return result;\n\t    }\n\t\n\t    result.protocol = relative.protocol;\n\t    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n\t      var relPath = (relative.pathname || '').split('/');\n\t      while (relPath.length && !(relative.host = relPath.shift()));\n\t      if (!relative.host) relative.host = '';\n\t      if (!relative.hostname) relative.hostname = '';\n\t      if (relPath[0] !== '') relPath.unshift('');\n\t      if (relPath.length < 2) relPath.unshift('');\n\t      result.pathname = relPath.join('/');\n\t    } else {\n\t      result.pathname = relative.pathname;\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    result.host = relative.host || '';\n\t    result.auth = relative.auth;\n\t    result.hostname = relative.hostname || relative.host;\n\t    result.port = relative.port;\n\t    // to support http.request\n\t    if (result.pathname || result.search) {\n\t      var p = result.pathname || '';\n\t      var s = result.search || '';\n\t      result.path = p + s;\n\t    }\n\t    result.slashes = result.slashes || relative.slashes;\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n\t      isRelAbs = (\n\t          relative.host ||\n\t          relative.pathname && relative.pathname.charAt(0) === '/'\n\t      ),\n\t      mustEndAbs = (isRelAbs || isSourceAbs ||\n\t                    (result.host && relative.pathname)),\n\t      removeAllDots = mustEndAbs,\n\t      srcPath = result.pathname && result.pathname.split('/') || [],\n\t      relPath = relative.pathname && relative.pathname.split('/') || [],\n\t      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\t\n\t  // if the url is a non-slashed url, then relative\n\t  // links like ../.. should be able\n\t  // to crawl up to the hostname, as well.  This is strange.\n\t  // result.protocol has already been set by now.\n\t  // Later on, put the first path part into the host field.\n\t  if (psychotic) {\n\t    result.hostname = '';\n\t    result.port = null;\n\t    if (result.host) {\n\t      if (srcPath[0] === '') srcPath[0] = result.host;\n\t      else srcPath.unshift(result.host);\n\t    }\n\t    result.host = '';\n\t    if (relative.protocol) {\n\t      relative.hostname = null;\n\t      relative.port = null;\n\t      if (relative.host) {\n\t        if (relPath[0] === '') relPath[0] = relative.host;\n\t        else relPath.unshift(relative.host);\n\t      }\n\t      relative.host = null;\n\t    }\n\t    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n\t  }\n\t\n\t  if (isRelAbs) {\n\t    // it's absolute.\n\t    result.host = (relative.host || relative.host === '') ?\n\t                  relative.host : result.host;\n\t    result.hostname = (relative.hostname || relative.hostname === '') ?\n\t                      relative.hostname : result.hostname;\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    srcPath = relPath;\n\t    // fall through to the dot-handling below.\n\t  } else if (relPath.length) {\n\t    // it's relative\n\t    // throw away the existing file, and take the new path instead.\n\t    if (!srcPath) srcPath = [];\n\t    srcPath.pop();\n\t    srcPath = srcPath.concat(relPath);\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t  } else if (!isNullOrUndefined(relative.search)) {\n\t    // just pull out the search.\n\t    // like href='?foo'.\n\t    // Put this after the other two cases because it simplifies the booleans\n\t    if (psychotic) {\n\t      result.hostname = result.host = srcPath.shift();\n\t      //occationaly the auth can get stuck only in host\n\t      //this especialy happens in cases like\n\t      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t                       result.host.split('@') : false;\n\t      if (authInHost) {\n\t        result.auth = authInHost.shift();\n\t        result.host = result.hostname = authInHost.shift();\n\t      }\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    //to support http.request\n\t    if (!isNull(result.pathname) || !isNull(result.search)) {\n\t      result.path = (result.pathname ? result.pathname : '') +\n\t                    (result.search ? result.search : '');\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  if (!srcPath.length) {\n\t    // no path at all.  easy.\n\t    // we've already handled the other stuff above.\n\t    result.pathname = null;\n\t    //to support http.request\n\t    if (result.search) {\n\t      result.path = '/' + result.search;\n\t    } else {\n\t      result.path = null;\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  // if a url ENDs in . or .., then it must get a trailing slash.\n\t  // however, if it ends in anything else non-slashy,\n\t  // then it must NOT get a trailing slash.\n\t  var last = srcPath.slice(-1)[0];\n\t  var hasTrailingSlash = (\n\t      (result.host || relative.host) && (last === '.' || last === '..') ||\n\t      last === '');\n\t\n\t  // strip single dots, resolve double dots to parent dir\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = srcPath.length; i >= 0; i--) {\n\t    last = srcPath[i];\n\t    if (last == '.') {\n\t      srcPath.splice(i, 1);\n\t    } else if (last === '..') {\n\t      srcPath.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      srcPath.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (!mustEndAbs && !removeAllDots) {\n\t    for (; up--; up) {\n\t      srcPath.unshift('..');\n\t    }\n\t  }\n\t\n\t  if (mustEndAbs && srcPath[0] !== '' &&\n\t      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n\t    srcPath.unshift('');\n\t  }\n\t\n\t  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n\t    srcPath.push('');\n\t  }\n\t\n\t  var isAbsolute = srcPath[0] === '' ||\n\t      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\t\n\t  // put the host back\n\t  if (psychotic) {\n\t    result.hostname = result.host = isAbsolute ? '' :\n\t                                    srcPath.length ? srcPath.shift() : '';\n\t    //occationaly the auth can get stuck only in host\n\t    //this especialy happens in cases like\n\t    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t                     result.host.split('@') : false;\n\t    if (authInHost) {\n\t      result.auth = authInHost.shift();\n\t      result.host = result.hostname = authInHost.shift();\n\t    }\n\t  }\n\t\n\t  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\t\n\t  if (mustEndAbs && !isAbsolute) {\n\t    srcPath.unshift('');\n\t  }\n\t\n\t  if (!srcPath.length) {\n\t    result.pathname = null;\n\t    result.path = null;\n\t  } else {\n\t    result.pathname = srcPath.join('/');\n\t  }\n\t\n\t  //to support request.http\n\t  if (!isNull(result.pathname) || !isNull(result.search)) {\n\t    result.path = (result.pathname ? result.pathname : '') +\n\t                  (result.search ? result.search : '');\n\t  }\n\t  result.auth = relative.auth || result.auth;\n\t  result.slashes = result.slashes || relative.slashes;\n\t  result.href = result.format();\n\t  return result;\n\t};\n\t\n\tUrl.prototype.parseHost = function() {\n\t  var host = this.host;\n\t  var port = portPattern.exec(host);\n\t  if (port) {\n\t    port = port[0];\n\t    if (port !== ':') {\n\t      this.port = port.substr(1);\n\t    }\n\t    host = host.substr(0, host.length - port.length);\n\t  }\n\t  if (host) this.hostname = host;\n\t};\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === \"string\";\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\tfunction isNullOrUndefined(arg) {\n\t  return  arg == null;\n\t}\n\n\n/***/ },\n\n/***/ 47:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n\n/***/ 56:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = function(det, rec, confidence, name, lang) {\n\t  this.confidence = confidence;\n\t  this.name = name || rec.name(det);\n\t  this.lang = lang;\n\t};\n\n\n/***/ },\n\n/***/ 108:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}(false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n\n/***/ 109:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.read = function(buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m,\n\t      eLen = nBytes * 8 - mLen - 1,\n\t      eMax = (1 << eLen) - 1,\n\t      eBias = eMax >> 1,\n\t      nBits = -7,\n\t      i = isLE ? (nBytes - 1) : 0,\n\t      d = isLE ? -1 : 1,\n\t      s = buffer[offset + i];\n\t\n\t  i += d;\n\t\n\t  e = s & ((1 << (-nBits)) - 1);\n\t  s >>= (-nBits);\n\t  nBits += eLen;\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\t\n\t  m = e & ((1 << (-nBits)) - 1);\n\t  e >>= (-nBits);\n\t  nBits += mLen;\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias;\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity);\n\t  } else {\n\t    m = m + Math.pow(2, mLen);\n\t    e = e - eBias;\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n\t};\n\t\n\texports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c,\n\t      eLen = nBytes * 8 - mLen - 1,\n\t      eMax = (1 << eLen) - 1,\n\t      eBias = eMax >> 1,\n\t      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n\t      i = isLE ? 0 : (nBytes - 1),\n\t      d = isLE ? 1 : -1,\n\t      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\t\n\t  value = Math.abs(value);\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0;\n\t    e = eMax;\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2);\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--;\n\t      c *= 2;\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c;\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias);\n\t    }\n\t    if (value * c >= 2) {\n\t      e++;\n\t      c /= 2;\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0;\n\t      e = eMax;\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen);\n\t      e = e + eBias;\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n\t      e = 0;\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\t\n\t  e = (e << mLen) | m;\n\t  eLen += mLen;\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\t\n\t  buffer[offset + i - d] |= s * 128;\n\t};\n\n\n/***/ },\n\n/***/ 110:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * isArray\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * toString\n\t */\n\t\n\tvar str = Object.prototype.toString;\n\t\n\t/**\n\t * Whether or not the given `val`\n\t * is an array.\n\t *\n\t * example:\n\t *\n\t *        isArray([]);\n\t *        // > true\n\t *        isArray(arguments);\n\t *        // > false\n\t *        isArray('');\n\t *        // > false\n\t *\n\t * @param {mixed} val\n\t * @return {bool}\n\t */\n\t\n\tmodule.exports = isArray || function (val) {\n\t  return !! val && '[object Array]' == str.call(val);\n\t};\n\n\n/***/ },\n\n/***/ 111:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */\n\t;(function(root) {\n\t\n\t\t/** Detect free variables */\n\t\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t\t!exports.nodeType && exports;\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\t!module.nodeType && module;\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (\n\t\t\tfreeGlobal.global === freeGlobal ||\n\t\t\tfreeGlobal.window === freeGlobal ||\n\t\t\tfreeGlobal.self === freeGlobal\n\t\t) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/**\n\t\t * The `punycode` object.\n\t\t * @name punycode\n\t\t * @type Object\n\t\t */\n\t\tvar punycode,\n\t\n\t\t/** Highest positive signed 32-bit float value */\n\t\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\t\n\t\t/** Bootstring parameters */\n\t\tbase = 36,\n\t\ttMin = 1,\n\t\ttMax = 26,\n\t\tskew = 38,\n\t\tdamp = 700,\n\t\tinitialBias = 72,\n\t\tinitialN = 128, // 0x80\n\t\tdelimiter = '-', // '\\x2D'\n\t\n\t\t/** Regular expressions */\n\t\tregexPunycode = /^xn--/,\n\t\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\t\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\t\n\t\t/** Error messages */\n\t\terrors = {\n\t\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t\t'invalid-input': 'Invalid input'\n\t\t},\n\t\n\t\t/** Convenience shortcuts */\n\t\tbaseMinusTMin = base - tMin,\n\t\tfloor = Math.floor,\n\t\tstringFromCharCode = String.fromCharCode,\n\t\n\t\t/** Temporary variable */\n\t\tkey;\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/**\n\t\t * A generic error utility function.\n\t\t * @private\n\t\t * @param {String} type The error type.\n\t\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t\t */\n\t\tfunction error(type) {\n\t\t\tthrow RangeError(errors[type]);\n\t\t}\n\t\n\t\t/**\n\t\t * A generic `Array#map` utility function.\n\t\t * @private\n\t\t * @param {Array} array The array to iterate over.\n\t\t * @param {Function} callback The function that gets called for every array\n\t\t * item.\n\t\t * @returns {Array} A new array of values returned by the callback function.\n\t\t */\n\t\tfunction map(array, fn) {\n\t\t\tvar length = array.length;\n\t\t\tvar result = [];\n\t\t\twhile (length--) {\n\t\t\t\tresult[length] = fn(array[length]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t\t * addresses.\n\t\t * @private\n\t\t * @param {String} domain The domain name or email address.\n\t\t * @param {Function} callback The function that gets called for every\n\t\t * character.\n\t\t * @returns {Array} A new string of characters returned by the callback\n\t\t * function.\n\t\t */\n\t\tfunction mapDomain(string, fn) {\n\t\t\tvar parts = string.split('@');\n\t\t\tvar result = '';\n\t\t\tif (parts.length > 1) {\n\t\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\t\tresult = parts[0] + '@';\n\t\t\t\tstring = parts[1];\n\t\t\t}\n\t\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\t\tvar labels = string.split('.');\n\t\t\tvar encoded = map(labels, fn).join('.');\n\t\t\treturn result + encoded;\n\t\t}\n\t\n\t\t/**\n\t\t * Creates an array containing the numeric code points of each Unicode\n\t\t * character in the string. While JavaScript uses UCS-2 internally,\n\t\t * this function will convert a pair of surrogate halves (each of which\n\t\t * UCS-2 exposes as separate characters) into a single code point,\n\t\t * matching UTF-16.\n\t\t * @see `punycode.ucs2.encode`\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode.ucs2\n\t\t * @name decode\n\t\t * @param {String} string The Unicode input string (UCS-2).\n\t\t * @returns {Array} The new array of code points.\n\t\t */\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [],\n\t\t\t    counter = 0,\n\t\t\t    length = string.length,\n\t\t\t    value,\n\t\t\t    extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t/**\n\t\t * Creates a string based on an array of numeric code points.\n\t\t * @see `punycode.ucs2.decode`\n\t\t * @memberOf punycode.ucs2\n\t\t * @name encode\n\t\t * @param {Array} codePoints The array of numeric code points.\n\t\t * @returns {String} The new Unicode string (UCS-2).\n\t\t */\n\t\tfunction ucs2encode(array) {\n\t\t\treturn map(array, function(value) {\n\t\t\t\tvar output = '';\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t\treturn output;\n\t\t\t}).join('');\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a basic code point into a digit/integer.\n\t\t * @see `digitToBasic()`\n\t\t * @private\n\t\t * @param {Number} codePoint The basic numeric code point value.\n\t\t * @returns {Number} The numeric value of a basic code point (for use in\n\t\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t\t * the code point does not represent a value.\n\t\t */\n\t\tfunction basicToDigit(codePoint) {\n\t\t\tif (codePoint - 48 < 10) {\n\t\t\t\treturn codePoint - 22;\n\t\t\t}\n\t\t\tif (codePoint - 65 < 26) {\n\t\t\t\treturn codePoint - 65;\n\t\t\t}\n\t\t\tif (codePoint - 97 < 26) {\n\t\t\t\treturn codePoint - 97;\n\t\t\t}\n\t\t\treturn base;\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a digit/integer into a basic code point.\n\t\t * @see `basicToDigit()`\n\t\t * @private\n\t\t * @param {Number} digit The numeric value of a basic code point.\n\t\t * @returns {Number} The basic code point whose value (when used for\n\t\t * representing integers) is `digit`, which needs to be in the range\n\t\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t\t * used; else, the lowercase form is used. The behavior is undefined\n\t\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t\t */\n\t\tfunction digitToBasic(digit, flag) {\n\t\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t\t// 26..35 map to ASCII 0..9\n\t\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t\t}\n\t\n\t\t/**\n\t\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t\t * @private\n\t\t */\n\t\tfunction adapt(delta, numPoints, firstTime) {\n\t\t\tvar k = 0;\n\t\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\t\tdelta += floor(delta / numPoints);\n\t\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t\t}\n\t\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t\t * symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t\t * @returns {String} The resulting string of Unicode symbols.\n\t\t */\n\t\tfunction decode(input) {\n\t\t\t// Don't use UCS-2\n\t\t\tvar output = [],\n\t\t\t    inputLength = input.length,\n\t\t\t    out,\n\t\t\t    i = 0,\n\t\t\t    n = initialN,\n\t\t\t    bias = initialBias,\n\t\t\t    basic,\n\t\t\t    j,\n\t\t\t    index,\n\t\t\t    oldi,\n\t\t\t    w,\n\t\t\t    k,\n\t\t\t    digit,\n\t\t\t    t,\n\t\t\t    /** Cached calculation results */\n\t\t\t    baseMinusT;\n\t\n\t\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t\t// the first basic code points to the output.\n\t\n\t\t\tbasic = input.lastIndexOf(delimiter);\n\t\t\tif (basic < 0) {\n\t\t\t\tbasic = 0;\n\t\t\t}\n\t\n\t\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t\t// if it's not a basic code point\n\t\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\t\terror('not-basic');\n\t\t\t\t}\n\t\t\t\toutput.push(input.charCodeAt(j));\n\t\t\t}\n\t\n\t\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t\t// points were copied; start at the beginning otherwise.\n\t\n\t\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\t\n\t\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t\t// value at the end to obtain `delta`.\n\t\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\t\n\t\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\t\terror('invalid-input');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\t\n\t\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti += digit * w;\n\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\n\t\t\t\t\tif (digit < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tw *= baseMinusT;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tout = output.length + 1;\n\t\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\t\n\t\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tn += floor(i / out);\n\t\t\t\ti %= out;\n\t\n\t\t\t\t// Insert `n` at position `i` of the output\n\t\t\t\toutput.splice(i++, 0, n);\n\t\n\t\t\t}\n\t\n\t\t\treturn ucs2encode(output);\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t\t * Punycode string of ASCII-only symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The string of Unicode symbols.\n\t\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t\t */\n\t\tfunction encode(input) {\n\t\t\tvar n,\n\t\t\t    delta,\n\t\t\t    handledCPCount,\n\t\t\t    basicLength,\n\t\t\t    bias,\n\t\t\t    j,\n\t\t\t    m,\n\t\t\t    q,\n\t\t\t    k,\n\t\t\t    t,\n\t\t\t    currentValue,\n\t\t\t    output = [],\n\t\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t\t    inputLength,\n\t\t\t    /** Cached calculation results */\n\t\t\t    handledCPCountPlusOne,\n\t\t\t    baseMinusT,\n\t\t\t    qMinusT;\n\t\n\t\t\t// Convert the input in UCS-2 to Unicode\n\t\t\tinput = ucs2decode(input);\n\t\n\t\t\t// Cache the length\n\t\t\tinputLength = input.length;\n\t\n\t\t\t// Initialize the state\n\t\t\tn = initialN;\n\t\t\tdelta = 0;\n\t\t\tbias = initialBias;\n\t\n\t\t\t// Handle the basic code points\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue < 0x80) {\n\t\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thandledCPCount = basicLength = output.length;\n\t\n\t\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t\t// `basicLength` is the number of basic code points.\n\t\n\t\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\t\tif (basicLength) {\n\t\t\t\toutput.push(delimiter);\n\t\t\t}\n\t\n\t\t\t// Main encoding loop:\n\t\t\twhile (handledCPCount < inputLength) {\n\t\n\t\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t\t// larger one:\n\t\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\t\tm = currentValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t\t// but guard against overflow\n\t\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\t\tn = m;\n\t\n\t\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\n\t\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\t\tdelta = 0;\n\t\t\t\t\t\t++handledCPCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t++delta;\n\t\t\t\t++n;\n\t\n\t\t\t}\n\t\t\treturn output.join('');\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Punycode string representing a domain name or an email address\n\t\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t\t * it doesn't matter if you call it on a string that has already been\n\t\t * converted to Unicode.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycoded domain name or email address to\n\t\t * convert to Unicode.\n\t\t * @returns {String} The Unicode representation of the given Punycode\n\t\t * string.\n\t\t */\n\t\tfunction toUnicode(input) {\n\t\t\treturn mapDomain(input, function(string) {\n\t\t\t\treturn regexPunycode.test(string)\n\t\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t\t: string;\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Unicode string representing a domain name or an email address to\n\t\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t\t * ASCII.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The domain name or email address to convert, as a\n\t\t * Unicode string.\n\t\t * @returns {String} The Punycode representation of the given domain name or\n\t\t * email address.\n\t\t */\n\t\tfunction toASCII(input) {\n\t\t\treturn mapDomain(input, function(string) {\n\t\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t\t: string;\n\t\t\t});\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/** Define the public API */\n\t\tpunycode = {\n\t\t\t/**\n\t\t\t * A string representing the current Punycode.js version number.\n\t\t\t * @memberOf punycode\n\t\t\t * @type String\n\t\t\t */\n\t\t\t'version': '1.3.2',\n\t\t\t/**\n\t\t\t * An object of methods to convert from JavaScript's internal character\n\t\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t\t * @memberOf punycode\n\t\t\t * @type Object\n\t\t\t */\n\t\t\t'ucs2': {\n\t\t\t\t'decode': ucs2decode,\n\t\t\t\t'encode': ucs2encode\n\t\t\t},\n\t\t\t'decode': decode,\n\t\t\t'encode': encode,\n\t\t\t'toASCII': toASCII,\n\t\t\t'toUnicode': toUnicode\n\t\t};\n\t\n\t\t/** Expose `punycode` */\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn punycode;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if (freeExports && freeModule) {\n\t\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = punycode;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tfor (key in punycode) {\n\t\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.punycode = punycode;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module), (function() { return this; }())))\n\n/***/ },\n\n/***/ 112:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * `BMSChart` holds information about a particular BMS notechart.\n\t *\n\t * @module bms/chart\n\t */\n\t\n\tvar BMSHeaders = __webpack_require__(113)\n\tvar BMSObjects = __webpack_require__(114)\n\tvar TimeSignatures = __webpack_require__(116)\n\t\n\tmodule.exports = BMSChart\n\t\n\t/**\n\t * Generates an empty `BMSChart`.\n\t *\n\t * @class BMSChart\n\t * @constructor\n\t */\n\tfunction BMSChart() {\n\t  this.headers = new BMSHeaders()\n\t  this.objects = new BMSObjects()\n\t  this.timeSignatures = new TimeSignatures()\n\t}\n\t\n\t/**\n\t * Converts measure+fraction into beat.\n\t *\n\t * @method measureToBeat\n\t * @param {Number} measure   Measure number starting from 0\n\t * @param {Number} fraction  Fraction inside the measure (0 to 1)\n\t * @return {Number} The beat number starting from 0\n\t */\n\tBMSChart.prototype.measureToBeat = function(measure, fraction) {\n\t  return this.timeSignatures.measureToBeat(measure, fraction)\n\t}\n\t\n\n\n/***/ },\n\n/***/ 113:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @module bms/headers\n\t */\n\tmodule.exports = BMSHeaders\n\t\n\t/**\n\t * @class BMSHeaders\n\t * @constructor\n\t */\n\tfunction BMSHeaders() {\n\t  this._data = { }\n\t  this._dataAll = { }\n\t}\n\t\n\t/**\n\t * Invokes a function at each header.\n\t *\n\t * @method each\n\t * @param  {Function} callback function to be invoked\n\t * @return {BMSHeaders} self\n\t */\n\tBMSHeaders.prototype.each = function(callback) {\n\t  for (var i in this._data) {\n\t    callback(i, this._data[i])\n\t  }\n\t}\n\t\n\t/**\n\t * Retrieves the header.\n\t *\n\t * @method get\n\t * @param  {String} name The header name (case-insensitive)\n\t * @return {String} The value of specified header\n\t */\n\tBMSHeaders.prototype.get = function(name) {\n\t  return this._data[name.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Retrieves all headers (when header is specified multiple times).\n\t *\n\t * @method get\n\t * @param  {String} name The header name (case-insensitive)\n\t * @return {String[]} The values of specified header\n\t */\n\tBMSHeaders.prototype.getAll = function(name) {\n\t  return this._dataAll[name.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Sets the header.\n\t *\n\t * @method set\n\t * @param  {String} name The header name (case-insensitive)\n\t * @param  {String} value The value to set\n\t */\n\tBMSHeaders.prototype.set = function(name, value) {\n\t  var key = name.toLowerCase()\n\t  this._data[key] = value\n\t  ;(this._dataAll[key] || (this._dataAll[key] = [])).push(value)\n\t}\n\t\n\n\n/***/ },\n\n/***/ 114:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @module bms/objects\n\t */\n\tmodule.exports = BMSObjects\n\t\n\t/**\n\t * Holds a collection of objects inside a BMS notechart.\n\t *\n\t * @class BMSObjects\n\t * @constructor\n\t */\n\tfunction BMSObjects() {\n\t  this._objects = []\n\t}\n\t\n\t/**\n\t * Adds a new object to the collection. If an object already exists on the\n\t * same channel and position, the object is replaced (except for autokeysound\n\t * tracks).\n\t *\n\t * @method add\n\t * @param {BMSObject} object\n\t */\n\tBMSObjects.prototype.add = function(object) {\n\t  if (object.channel !== '01') {\n\t    for (var i = 0; i < this._objects.length; i ++) {\n\t      var test = this._objects[i]\n\t      if (test.channel === object.channel &&\n\t          test.measure === object.measure &&\n\t          test.fraction === object.fraction) {\n\t        this._objects[i] = object\n\t        return\n\t      }\n\t    }\n\t  }\n\t  this._objects.push(object)\n\t}\n\t\n\t/**\n\t * Returns a list of all objects.\n\t *\n\t * @method all\n\t * @return {BMSObject[]}\n\t */\n\tBMSObjects.prototype.all = function() {\n\t  return this._objects.slice()\n\t}\n\t\n\t/**\n\t * Returns a sorted list of all objects.\n\t *\n\t * @method all\n\t * @return {BMSObject[]}\n\t */\n\tBMSObjects.prototype.allSorted = function() {\n\t  var list = this.all()\n\t  list.sort(function(a, b) {\n\t    return (a.measure + a.fraction) - (b.measure + b.fraction)\n\t  })\n\t  return list\n\t}\n\t\n\t\n\t/**\n\t * @class BMSObject\n\t */\n\t/**\n\t * The raw two-character BMS channel of this object.\n\t *\n\t * @property channel\n\t * @type String\n\t */\n\t/**\n\t * The measure number, starting at 0 (corresponds to `#000`)\n\t *\n\t * @property measure\n\t * @type Number\n\t */\n\t/**\n\t * The fractional position inside the measure, ranging from 0 (inclusive)\n\t * to 1 (exclusive). 0 means that the object is at the start of the measure,\n\t * where 1 means that the object is at the end of the measure.\n\t *\n\t * @property fraction\n\t * @type Number\n\t */\n\t/**\n\t * The raw value of the BMS object — a two-character string.\n\t *\n\t * @property value\n\t * @type String\n\t */\n\n\n/***/ },\n\n/***/ 115:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar Segment = __webpack_require__(135)\n\t\n\t/**\n\t * Speedcore is a library to help compute the speed and position\n\t * of linear motion. A Speedcore is constructed from an array of Segments.\n\t *\n\t * @module speedcore\n\t */\n\tmodule.exports = Speedcore\n\t\n\t/**\n\t * Construct a new `Speedcore` from segments\n\t *\n\t * @class Speedcore\n\t * @constructor\n\t * @param {Segment[]} segments  An array of segments.\n\t */\n\tfunction Speedcore(segments) {\n\t  this._segments = segments.map(Segment)\n\t}\n\t\n\tSpeedcore.prototype.t = function(x) {\n\t  for (var i = 0; i < this._segments.length; i ++) {\n\t    if (i + 1 >= this._segments.length || x <= this._segments[i + 1].x) {\n\t      var segment = this._segments[i]\n\t      return segment.t + (x - segment.x) / segment.dx\n\t    }\n\t  }\n\t}\n\t\n\tSpeedcore.prototype.x = function(t) {\n\t  for (var i = 0; i < this._segments.length; i ++) {\n\t    if (i + 1 >= this._segments.length || t <= this._segments[i + 1].t) {\n\t      var segment = this._segments[i]\n\t      return segment.x + (t - segment.t) * segment.dx\n\t    }\n\t  }\n\t}\n\n\n/***/ },\n\n/***/ 116:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @module time-signatures\n\t */\n\tmodule.exports = TimeSignatures\n\t\n\t/**\n\t * @class TimeSignatures\n\t * @constructor\n\t */\n\tfunction TimeSignatures() {\n\t  this._values = { }\n\t}\n\t\n\t/**\n\t * @method set\n\t * @param {Number} measure  The measure number\n\t * @param {Number} value    The time signature value. 1 represents 4/4, and\n\t *                          0.75 represents 3/4. You get the idea.\n\t */\n\tTimeSignatures.prototype.set = function(measure, value) {\n\t  this._values[measure] = value\n\t}\n\t\n\t/**\n\t * @method get\n\t * @param {Number} measure\n\t * @return {Number}\n\t */\n\tTimeSignatures.prototype.get = function(measure) {\n\t  return this._values[measure] || 1\n\t}\n\t\n\t/**\n\t * @method getBeats\n\t * @param {Number} measure\n\t * @return {Number}\n\t */\n\tTimeSignatures.prototype.getBeats = function(measure) {\n\t  return this.get(measure) * 4\n\t}\n\t\n\t/**\n\t * @method measureToBeat\n\t * @param {Number} measure\n\t * @param {Number} fraction\n\t */\n\tTimeSignatures.prototype.measureToBeat = function(measure, fraction) {\n\t  var sum = 0\n\t  for (var i = 0; i < measure; i ++) sum += this.getBeats(i)\n\t  return sum + this.getBeats(measure) * fraction\n\t}\n\t\n\n\n/***/ },\n\n/***/ 117:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = match\n\t\n\tfunction match(text) {\n\t  var matched = false\n\t  return {\n\t    when: function(pattern, callback) {\n\t      if (matched) return this\n\t      var match = text.match(pattern)\n\t      if (match) {\n\t        matched = true\n\t        callback(match)\n\t      }\n\t      return this\n\t    },\n\t    else: function(callback) {\n\t      if (matched) return this\n\t      callback()\n\t    }\n\t  }\n\t}\n\t\n\n\n/***/ },\n\n/***/ 128:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar formatRegExp = /%[sdj%]/g;\n\texports.format = function(f) {\n\t  if (!isString(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\t\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect(x);\n\t    }\n\t  }\n\t  return str;\n\t};\n\t\n\t\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\texports.deprecate = function(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global.process)) {\n\t    return function() {\n\t      return exports.deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\t\n\t  if (process.noDeprecation === true) {\n\t    return fn;\n\t  }\n\t\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (process.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (process.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\t\n\t  return deprecated;\n\t};\n\t\n\t\n\tvar debugs = {};\n\tvar debugEnviron;\n\texports.debuglog = function(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = process.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = process.pid;\n\t      debugs[set] = function() {\n\t        var msg = exports.format.apply(exports, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t};\n\t\n\t\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    exports._extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\texports.inspect = inspect;\n\t\n\t\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\t\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\t\n\t\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect.styles[styleType];\n\t\n\t  if (style) {\n\t    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\t\n\t\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\t\n\t\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\t\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\t\n\t  return hash;\n\t}\n\t\n\t\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== exports.inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\t\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\t\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\t\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\t\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\t\n\t  var base = '', array = false, braces = ['{', '}'];\n\t\n\t  // Make Array say that they are Array\n\t  if (isArray(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\t\n\t  // Make functions say that they are functions\n\t  if (isFunction(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\t\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\t\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\t\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\t\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\t\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\t\n\t  ctx.seen.push(value);\n\t\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\t\n\t  ctx.seen.pop();\n\t\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\t\n\t\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\t\n\t\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\t\n\t\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\t\n\t\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\t\n\t  return name + ': ' + str;\n\t}\n\t\n\t\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var numLinesEst = 0;\n\t  var length = output.reduce(function(prev, cur) {\n\t    numLinesEst++;\n\t    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\t\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\t\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\t\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray(ar) {\n\t  return Array.isArray(ar);\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return isObject(re) && objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return isObject(d) && objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return isObject(e) &&\n\t      (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = __webpack_require__(368);\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t\n\tfunction pad(n) {\n\t  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n\t}\n\t\n\t\n\tvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n\t              'Oct', 'Nov', 'Dec'];\n\t\n\t// 26 Feb 16:19:34\n\tfunction timestamp() {\n\t  var d = new Date();\n\t  var time = [pad(d.getHours()),\n\t              pad(d.getMinutes()),\n\t              pad(d.getSeconds())].join(':');\n\t  return [d.getDate(), months[d.getMonth()], time].join(' ');\n\t}\n\t\n\t\n\t// log is just a thin wrapper to console.log that prepends a timestamp\n\texports.log = function() {\n\t  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n\t};\n\t\n\t\n\t/**\n\t * Inherit the prototype methods from one constructor into another.\n\t *\n\t * The Function.prototype.inherits from lang.js rewritten as a standalone\n\t * function (not on Function.prototype). NOTE: If this file is to be loaded\n\t * during bootstrapping this function needs to be rewritten using some native\n\t * functions as prototype setup using normal JavaScript does not work as\n\t * expected during bootstrapping (see mirror.js in r114903).\n\t *\n\t * @param {function} ctor Constructor function which needs to inherit the\n\t *     prototype.\n\t * @param {function} superCtor Constructor function to inherit prototype from.\n\t */\n\texports.inherits = __webpack_require__(367);\n\t\n\texports._extend = function(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject(add)) return origin;\n\t\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t};\n\t\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(13)))\n\n/***/ },\n\n/***/ 129:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; };\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\tvar R = _interopRequire(__webpack_require__(10));\n\t\n\tvar SamplingMaster = _interopRequire(__webpack_require__(29));\n\t\n\tvar ProgressUtils = _interopRequireWildcard(__webpack_require__(14));\n\t\n\tvar AudioLoader = exports.AudioLoader = (function () {\n\t  function AudioLoader(assets, master) {\n\t    _classCallCheck(this, AudioLoader);\n\t\n\t    this._assets = assets;\n\t    this._master = master || new SamplingMaster();\n\t  }\n\t\n\t  _prototypeProperties(AudioLoader, null, {\n\t    loadFrom: {\n\t      value: function loadFrom(keysounds, loadProgress, decodeProgress) {\n\t        var _this = this;\n\t        var files = keysounds.files();\n\t        var onload = ProgressUtils.fixed(files.length, loadProgress);\n\t        var ondecode = ProgressUtils.fixed(files.length, decodeProgress);\n\t        var load = function (name) {\n\t          return _this._loadSample(name, onload, ondecode);\n\t        };\n\t        return Promise.map(files, load).then(R.fromPairs);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _loadSample: {\n\t      value: function _loadSample(name, onload, ondecode) {\n\t        var _this = this;\n\t        return this._getFile(name).then(function (file) {\n\t          return file.read().tap(function () {\n\t            return onload(name);\n\t          }).then(function (buffer) {\n\t            return _this._decode(buffer);\n\t          }).tap(function () {\n\t            return ondecode(name);\n\t          }).then(function (sample) {\n\t            return [name, sample];\n\t          })[\"catch\"](function (e) {\n\t            console.error(\"Unable to decode: \" + name, e);\n\t            return null;\n\t          });\n\t        }, function () {\n\t          return null;\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _decode: {\n\t      value: function _decode(buffer) {\n\t        return this._master.sample(buffer);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _getFile: {\n\t      value: function _getFile(name) {\n\t        var _this = this;\n\t        return this._assets.file(name)[\"catch\"](function () {\n\t          return _this._assets.file(name.replace(/\\.\\w+$/, \".mp3\"));\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return AudioLoader;\n\t})();\n\texports[\"default\"] = AudioLoader;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 131:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; };\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\tvar resolve = __webpack_require__(42).resolve;\n\tvar addLazyProperty = _interopRequire(__webpack_require__(138));\n\t\n\tvar R = _interopRequire(__webpack_require__(10));\n\t\n\tvar download = _interopRequire(__webpack_require__(39));\n\t\n\tvar readBlob = _interopRequire(__webpack_require__(18));\n\t\n\tvar throat = _interopRequire(__webpack_require__(139));\n\t\n\tvar ProgressUtils = _interopRequireWildcard(__webpack_require__(14));\n\t\n\tvar Progress = _interopRequire(__webpack_require__(43));\n\t\n\tvar BemusePackageResources = exports.BemusePackageResources = (function () {\n\t  function BemusePackageResources(url) {\n\t    var _this = this;\n\t    _classCallCheck(this, BemusePackageResources);\n\t\n\t    var lazy = addLazyProperty.bind(null, this);\n\t    this._url = url;\n\t    lazy(\"metadata\", function () {\n\t      return download(resolve(_this._url, \"metadata.json\")).as(\"text\").then(function (str) {\n\t        return JSON.parse(str);\n\t      });\n\t    });\n\t    lazy(\"refs\", function () {\n\t      return _this.metadata.then(function (metadata) {\n\t        return metadata.refs.map(function (spec) {\n\t          return new Ref(_this, spec);\n\t        });\n\t      });\n\t    });\n\t    this.progress = {\n\t      all: new Progress(),\n\t      current: new Progress() };\n\t    this._loadPayload = ProgressUtils.wrapPromise(this.progress.all, throat(1, function (url) {\n\t      return download(url).as(\"blob\", _this.progress.current).then(getPayload);\n\t    }));\n\t  }\n\t\n\t  _prototypeProperties(BemusePackageResources, null, {\n\t    url: {\n\t      get: function () {\n\t        return this._url;\n\t      },\n\t      configurable: true\n\t    },\n\t    file: {\n\t      value: function file(name) {\n\t        var _this = this;\n\t        return this.metadata.then(function (metadata) {\n\t          var file = R.find(function (file) {\n\t            return file.name === name;\n\t          }, metadata.files);\n\t          if (!file) throw new Error(\"Unable to find: \" + name);\n\t          return new BemusePackageFileResource(_this, file.ref);\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    getBlob: {\n\t      value: function getBlob(ref) {\n\t        var _ref = _slicedToArray(ref, 3);\n\t\n\t        var index = _ref[0];\n\t        var start = _ref[1];\n\t        var end = _ref[2];\n\t        return this.refs.then(function (refs) {\n\t          return refs[index];\n\t        }).then(function (ref) {\n\t          return ref.load();\n\t        }).then(function (payload) {\n\t          return payload.slice(start, end);\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return BemusePackageResources;\n\t})();\n\tvar BemusePackageFileResource = (function () {\n\t  function BemusePackageFileResource(resources, ref) {\n\t    _classCallCheck(this, BemusePackageFileResource);\n\t\n\t    this._resources = resources;\n\t    this._ref = ref;\n\t  }\n\t\n\t  _prototypeProperties(BemusePackageFileResource, null, {\n\t    read: {\n\t      value: function read() {\n\t        return this._resources.getBlob(this._ref).then(function (blob) {\n\t          return readBlob(blob).as(\"arraybuffer\");\n\t        });\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return BemusePackageFileResource;\n\t})();\n\t\n\tvar Ref = (function () {\n\t  function Ref(resources, spec) {\n\t    _classCallCheck(this, Ref);\n\t\n\t    this._resources = resources;\n\t    this._url = resolve(resources.url, spec.path);\n\t  }\n\t\n\t  _prototypeProperties(Ref, null, {\n\t    load: {\n\t      value: function load() {\n\t        return this._promise || (this._promise = this._resources._loadPayload(this._url));\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return Ref;\n\t})();\n\t\n\texports[\"default\"] = BemusePackageResources;\n\t\n\t\n\tfunction getPayload(blob) {\n\t  return readBlob(blob.slice(0, 10)).as(\"text\").then(function (magic) {\n\t    if (magic !== \"BEMUSEPACK\") {\n\t      throw new Error(\"Invalid magic number\");\n\t    }\n\t    return readBlob(blob.slice(10, 14)).as(\"arraybuffer\");\n\t  }).then(function (buffer) {\n\t    var array = new Uint8Array(buffer);\n\t    var length = array[0] + (array[1] << 8) + (array[2] << 16) + (array[3] << 24);\n\t    return length;\n\t  }).then(function (metadataLength) {\n\t    return blob.slice(14 + metadataLength);\n\t  });\n\t}\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 132:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar match = __webpack_require__(117)\n\tvar BMSChart = __webpack_require__(112)\n\t\n\texports.compile = function(text) {\n\t\n\t  var chart = new BMSChart()\n\t\n\t  var result = {\n\t    headerSentences: 0,\n\t    channelSentences: 0,\n\t    malformedSentences: 0,\n\t    chart: chart,\n\t    warnings: []\n\t  }\n\t\n\t  eachLine(text, function(text, lineNumber) {\n\t    void lineNumber\n\t    if (text.charAt(0) !== '#') return\n\t    match(text)\n\t    .when(/^#(\\d\\d\\d)02:(\\S*)$/, function(m) {\n\t      result.channelSentences += 1\n\t      chart.timeSignatures.set(+m[1], +m[2])\n\t    })\n\t    .when(/^#(\\d\\d\\d)(\\S\\S):(\\S*)$/, function(m) {\n\t      result.channelSentences += 1\n\t      handleChannelSentence(+m[1], m[2], m[3], lineNumber)\n\t    })\n\t    .when(/^#(\\w+)(?:\\s+(\\S.*))?$/, function(m) {\n\t      result.headerSentences += 1\n\t      chart.headers.set(m[1], m[2])\n\t    })\n\t    .else(function() {\n\t      warn(lineNumber, 'Invalid command')\n\t    })\n\t  })\n\t\n\t  return result\n\t\n\t  function handleChannelSentence(measure, channel, string, lineNumber) {\n\t    var items = Math.floor(string.length / 2)\n\t    if (items === 0) return\n\t    for (var i = 0; i < items; i ++) {\n\t      var value = string.substr(i * 2, 2)\n\t      var fraction = i / items\n\t      if (value === '00') continue\n\t      chart.objects.add({\n\t        measure: measure, \n\t        fraction: fraction,\n\t        value: value,\n\t        channel: channel,\n\t        lineNumber: lineNumber,\n\t      })\n\t    }\n\t  }\n\t\n\t  function warn(lineNumber, message) {\n\t    result.warnings.push({\n\t      lineNumber: lineNumber,\n\t      message: message,\n\t    })\n\t  }\n\t\n\t}\n\t\n\tfunction eachLine(text, callback) {\n\t  text.split(/\\r\\n|\\r|\\n/)\n\t      .map(function(line) { return line.trim() })\n\t      .forEach(function(line, index) {\n\t    callback(line, index + 1)\n\t  })\n\t}\n\t\n\n\n/***/ },\n\n/***/ 133:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar Note = __webpack_require__(134)\n\t\n\tmodule.exports = Notes\n\t\n\tvar CHANNEL_MAPPING = {\n\t  IIDX_P1: {\n\t    '11': { column: '1'  },\n\t    '12': { column: '2'  },\n\t    '13': { column: '3'  },\n\t    '14': { column: '4'  },\n\t    '15': { column: '5'  },\n\t    '18': { column: '6'  },\n\t    '19': { column: '7'  },\n\t    '16': { column: 'SC' },\n\t  },\n\t}\n\t\n\t/**\n\t * The Notes class holds the Note objects in the game. A note object may or\n\t * may not be playable.\n\t *\n\t * @class Notes\n\t * @constructor\n\t */\n\tfunction Notes(notes) {\n\t  notes.forEach(Note.validate)\n\t  this._notes = notes\n\t}\n\t\n\t/**\n\t * Returns the number of notes in this object.\n\t *\n\t * @method count\n\t * @return {Number}\n\t */\n\tNotes.prototype.count = function() {\n\t  return this._notes.length\n\t}\n\t\n\t/**\n\t * Returns an Array of all notes.\n\t *\n\t * @method all\n\t * @return {Note[]}\n\t */\n\tNotes.prototype.all = function() {\n\t  return this._notes.slice()\n\t}\n\t\n\t/**\n\t * Creates a Notes object from a BMSChart.\n\t *\n\t * @static\n\t * @method fromBMSChart\n\t * @param {BMSChart} chart    the chart to process\n\t * @param {Object}   options  the note options\n\t */\n\tNotes.fromBMSChart = function(chart, options) {\n\t  options = options || { }\n\t  var builder = new BMSNoteBuilder(chart)\n\t  return builder.build()\n\t}\n\t\n\tfunction BMSNoteBuilder(chart) {\n\t  this._chart = chart\n\t}\n\t\n\tBMSNoteBuilder.prototype.build = function() {\n\t  this._notes = []\n\t  this._activeLN = { }\n\t  this._channelMapping = CHANNEL_MAPPING.IIDX_P1\n\t  this._objects = this._chart.objects.allSorted()\n\t  this._objects.forEach(function(object) {\n\t    this._handle(object)\n\t  }.bind(this))\n\t  return new Notes(this._notes)\n\t}\n\t\n\tBMSNoteBuilder.prototype._handle = function(object) {\n\t  if (object.channel === '01') {\n\t    this._handleNormalNote(object)\n\t  } else {\n\t    switch (object.channel.charAt(0)) {\n\t    case '1': case '2':\n\t      this._handleNormalNote(object)\n\t      break\n\t    case '5': case '6':\n\t      this._handleLongNote(object)\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\tBMSNoteBuilder.prototype._handleNormalNote = function(object) {\n\t  var channel = this._normalizeChannel(object.channel)\n\t  var beat = this._getBeat(object)\n\t  this._notes.push({\n\t    beat: beat,\n\t    column: this._getColumn(channel),\n\t  })\n\t}\n\t\n\tBMSNoteBuilder.prototype._handleLongNote = function(object) {\n\t  var channel = this._normalizeChannel(object.channel)\n\t  var beat = this._getBeat(object)\n\t  if (this._activeLN[channel]) {\n\t    var note = this._activeLN[channel]\n\t    note.endBeat = beat\n\t    this._notes.push(note)\n\t    ;delete this._activeLN[channel]\n\t  } else {\n\t    this._activeLN[channel] = {\n\t      beat: beat,\n\t      keysound: object.value,\n\t      column: this._getColumn(object.channel),\n\t    }\n\t  }\n\t}\n\t\n\tBMSNoteBuilder.prototype._getBeat = function(object) {\n\t  return this._chart.measureToBeat(object.measure, object.fraction)\n\t}\n\t\n\tBMSNoteBuilder.prototype._getColumn = function(channel) {\n\t  return this._channelMapping[channel]\n\t}\n\t\n\tBMSNoteBuilder.prototype._normalizeChannel = function(channel) {\n\t  return channel.replace(/^5/, '1').replace(/^6/, '2')\n\t}\n\t\n\n\n/***/ },\n\n/***/ 134:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar DataStructure = __webpack_require__(33)\n\t\n\tvar Column = new DataStructure({\n\t  column: String,\n\t})\n\t\n\t/**\n\t * @class Note\n\t */\n\tmodule.exports = new DataStructure({\n\t\n\t  /**\n\t   * @property beat\n\t   * @type Number\n\t   */\n\t  beat: Number,\n\t\n\t  /**\n\t   * @property column\n\t   * @type Column|undefined\n\t   */\n\t  column: DataStructure.maybe(Column),\n\t\n\t  /**\n\t   * @property keysound\n\t   * @type String\n\t   */\n\t  keysound: String,\n\t\n\t})\n\n\n/***/ },\n\n/***/ 135:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar DataStructure = __webpack_require__(33)\n\t\n\t/**\n\t * @class Segment\n\t */\n\tmodule.exports = new DataStructure({\n\t\n\t  /**\n\t   * @property t\n\t   * @type Number\n\t   */\n\t  t: Number,\n\t\n\t  /**\n\t   * @property x\n\t   * @type Number\n\t   */\n\t  x: Number,\n\t\n\t  /**\n\t   * @property dx\n\t   * @type Number\n\t   */\n\t  dx: Number,\n\t\n\t})\n\t\n\n\n/***/ },\n\n/***/ 136:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t// The Timing module converts between beats and seconds.\n\t// They are created from a notechart.\n\t\n\tvar Speedcore = __webpack_require__(115)\n\t\n\t/**\n\t * @module timing\n\t */\n\tmodule.exports = Timing\n\t\n\tvar precedence = { bpm: 1, stop: 2 }\n\t\n\tfunction Timing(initialBPM, actions) {\n\t  var state = { bpm: initialBPM, beat: 0, seconds: 0 }\n\t  var segments = [{ t: 0, x: 0, dx: initialBPM / 60 }]\n\t  actions = actions.slice()\n\t  actions.sort(function(a, b) {\n\t    return a.beat - b.beat || precedence[a.type] - precedence[b.type]\n\t  })\n\t  actions.forEach(function(action) {\n\t    var beat    = action.beat\n\t    var seconds = state.seconds + (beat - state.beat) * 60 / state.bpm\n\t    switch (action.type) {\n\t    case 'bpm':\n\t      state.bpm = action.bpm\n\t      segments.push({ t: seconds, x: beat, dx: state.bpm / 60 })\n\t      break\n\t    case 'stop':\n\t      segments.push({ t: seconds, x: beat, dx: 0 })\n\t      seconds += (action.stopBeats || 0) * 60 / state.bpm\n\t      segments.push({ t: seconds, x: beat, dx: state.bpm / 60 })\n\t      break\n\t    default:\n\t      throw new Error(\"Unrecognized segment object!\")\n\t    }\n\t    state.beat    = beat\n\t    state.seconds = seconds\n\t  })\n\t  this._speedcore = new Speedcore(segments)\n\t}\n\t\n\tTiming.prototype.beatToSeconds = function(beat) {\n\t  return this._speedcore.t(beat)\n\t}\n\t\n\tTiming.prototype.secondsToBeat = function(seconds) {\n\t  return this._speedcore.x(seconds)\n\t}\n\t\n\tTiming.fromBMSChart = function(chart) {\n\t  var actions = []\n\t  chart.objects.all().forEach(function(object) {\n\t    var bpm\n\t    var beat = chart.measureToBeat(object.measure, object.fraction)\n\t    if (object.channel === '03') {\n\t      bpm = parseInt(object.value, 16)\n\t      actions.push({ type: 'bpm', beat: beat, bpm: bpm })\n\t    } else if (object.channel === '08') {\n\t      bpm = chart.headers.get('bpm' + object.value)\n\t      actions.push({ type: 'bpm', beat: beat, bpm: bpm })\n\t    } else if (object.channel === '09') {\n\t      var stopBeats = chart.headers.get('stop' + object.value) / 48\n\t      actions.push({ type: 'stop', beat: beat, stopBeats: stopBeats })\n\t    }\n\t  })\n\t  return new Timing(+chart.headers.get('bpm') || 60, actions)\n\t}\n\t\n\n\n/***/ },\n\n/***/ 138:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\"\n\t\n\tfunction addLazyProperty(object, name, initializer, enumerable) {\n\t  Object.defineProperty(object, name, {\n\t    get: function() {\n\t      var v = initializer.call(this)\n\t      Object.defineProperty(this, name, { value: v, enumerable: !!enumerable, writable: true })\n\t      return v\n\t    },\n\t    set: function(v) {\n\t      Object.defineProperty(this, name, { value: v, enumerable: !!enumerable, writable: true })\n\t      return v\n\t    },\n\t    enumerable: !!enumerable,\n\t    configurable: true\n\t  })\n\t}\n\t\n\tmodule.exports = addLazyProperty\n\n\n/***/ },\n\n/***/ 139:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict'\n\t\n\tmodule.exports = function (PromiseArgument) {\n\t  var Promise;\n\t  function throat(size, fn) {\n\t    var queue = []\n\t    function run(fn, self, args) {\n\t      if (size) {\n\t        size--\n\t        var result = new Promise(function (resolve) {\n\t          resolve(fn.apply(self, args))\n\t        })\n\t        result.then(release, release)\n\t        return result\n\t      } else {\n\t        return new Promise(function (resolve) {\n\t          queue.push(new Delayed(resolve, fn, self, args))\n\t        })\n\t      }\n\t    }\n\t    function release() {\n\t      size++\n\t      if (queue.length) {\n\t        var next = queue.shift()\n\t        next.resolve(run(next.fn, next.self, next.args))\n\t      }\n\t    }\n\t    if (typeof size === 'function' && typeof fn === 'number') {\n\t      var temp = fn;\n\t      fn = size;\n\t      size = temp;\n\t    }\n\t    if (typeof fn === 'function') {\n\t      return function () {\n\t        var args = [];\n\t        for (var i = 0; i < arguments.length; i++) {\n\t          args.push(arguments[i]);\n\t        }\n\t        return run(fn, this, args)\n\t      }\n\t    } else {\n\t      return function (fn) {\n\t        var args = [];\n\t        for (var i = 1; i < arguments.length; i++) {\n\t          args.push(arguments[i]);\n\t        }\n\t        return run(fn, this, args)\n\t      }\n\t    }\n\t  }\n\t  if (typeof arguments[0] === 'number' || typeof arguments[1] === 'number') {\n\t    Promise = module.exports.Promise;\n\t    if (typeof Promise !== 'function') {\n\t      throw new Error('You must provide a Promise polyfill for this library to work in older environments');\n\t    }\n\t    return throat(arguments[0], arguments[1]);\n\t  } else {\n\t    Promise = PromiseArgument;\n\t    return throat;\n\t  }\n\t}\n\t\n\t/* istanbul ignore next */\n\tif (typeof Promise === 'function') {\n\t  module.exports.Promise = Promise;\n\t}\n\t\n\tfunction Delayed(resolve, fn, self, args) {\n\t  this.resolve = resolve\n\t  this.fn = fn\n\t  this.self = self || null\n\t  this.args = args\n\t}\n\n\n/***/ },\n\n/***/ 152:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\texports.main = main;\n\tvar SCENE_MANAGER = _interopRequire(__webpack_require__(197));\n\t\n\tvar LoadingScene = _interopRequire(__webpack_require__(194));\n\t\n\tvar GameLoader = _interopRequire(__webpack_require__(193));\n\t\n\tvar URLResource = _interopRequire(__webpack_require__(196));\n\t\n\tvar BemusePackageResources = _interopRequire(__webpack_require__(131));\n\t\n\tfunction main() {\n\t  var song = {\n\t    title: \"オリヴィアの幻術\",\n\t    subtitles: [\"[Tonalite]\"],\n\t    artist: \"葵\",\n\t    genre: \"Sexy Dance\",\n\t    subartists: [\"mov:いとう まさき/obj:止ヒ糸\"] };\n\t  var loader = new GameLoader();\n\t  var promise = loader.load({\n\t    bms: new URLResource(\"/music/[aoi]olivia/olivia_SPpp.bml\"),\n\t    assets: new BemusePackageResources(\"/music/[aoi]olivia/assets/\") });\n\t  SCENE_MANAGER.display(new LoadingScene({ loader: loader, song: song }));\n\t  promise.then(function () {\n\t    SCENE_MANAGER.display(null);\n\t  }).done();\n\t}\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 193:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {\"use strict\";\n\t\n\tvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; };\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\tvar co = _interopRequire(__webpack_require__(11));\n\t\n\tvar BMS = _interopRequire(__webpack_require__(199));\n\t\n\tvar Progress = _interopRequire(__webpack_require__(43));\n\t\n\tvar ProgressUtils = _interopRequireWildcard(__webpack_require__(14));\n\t\n\tvar EventEmitter = __webpack_require__(363).EventEmitter;\n\tvar LoadingContext = _interopRequire(__webpack_require__(149));\n\t\n\tvar AudioLoader = _interopRequire(__webpack_require__(129));\n\t\n\tvar bytes = _interopRequire(__webpack_require__(210));\n\t\n\tvar Formatters = {\n\t  NORMAL: function (progress) {\n\t    return progress.total ? \"\" + progress.current + \" / \" + progress.total : \"\";\n\t  },\n\t  EXTRA: function (progress) {\n\t    return progress.extra;\n\t  },\n\t  BYTES: function (progress) {\n\t    return progress.total ? \"\" + bytes(progress.current) + \" / \" + bytes(progress.total) : \"\";\n\t  } };\n\t\n\tvar GameLoader = exports.GameLoader = (function (EventEmitter) {\n\t  function GameLoader() {\n\t    _classCallCheck(this, GameLoader);\n\t\n\t    this._tasks = [];\n\t  }\n\t\n\t  _inherits(GameLoader, EventEmitter);\n\t\n\t  _prototypeProperties(GameLoader, null, {\n\t    tasks: {\n\t      get: function () {\n\t        return this._tasks;\n\t      },\n\t      configurable: true\n\t    },\n\t    load: {\n\t      value: function load(song) {\n\t        return co(regeneratorRuntime.mark(function callee$2$0() {\n\t          var _this = this;\n\t          var promises;\n\t          return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n\t            while (1) switch (context$3$0.prev = context$3$0.next) {\n\t              case 0:\n\t                promises = {\n\t                  graphics: _this._loadEngine(),\n\t                  song: _this._loadSong(song) };\n\t                context$3$0.next = 3;\n\t                return Promise.all([promises.graphics, promises.song]);\n\t              case 3:\n\t              case \"end\":\n\t                return context$3$0.stop();\n\t            }\n\t          }, callee$2$0, this);\n\t        }).bind(this));\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _loadEngine: {\n\t      value: function _loadEngine() {\n\t        var progress = {\n\t          engine: this._task(\"Loading game engine\", Formatters.BYTES),\n\t          skin: this._task(\"Loading skin\") };\n\t        return co(regeneratorRuntime.mark(function callee$2$0() {\n\t          var Scintillator, skin, context;\n\t          return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n\t            while (1) switch (context$3$0.prev = context$3$0.next) {\n\t              case 0:\n\t                context$3$0.next = 2;\n\t                return loadEngineModule(progress.engine);\n\t              case 2:\n\t                Scintillator = context$3$0.sent;\n\t                context$3$0.next = 5;\n\t                return Scintillator.load(\"/skins/default/skin.xml\", progress.skin);\n\t              case 5:\n\t                skin = context$3$0.sent;\n\t                context = new Scintillator.Context(skin);\n\t                return context$3$0.abrupt(\"return\", { skin: skin, context: context });\n\t              case 8:\n\t              case \"end\":\n\t                return context$3$0.stop();\n\t            }\n\t          }, callee$2$0, this);\n\t        }).bind(this));\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _loadSong: {\n\t      value: function _loadSong(song) {\n\t        var bms = song.bms;\n\t        var assets = song.assets;\n\t        var progress = {\n\t          bms: this._task(\"Loading \" + bms.name, Formatters.BYTES),\n\t          cpack: this._task(\"Loading package\", Formatters.BYTES),\n\t          pack: this._task(\"Loading song packages\"),\n\t          audio: this._task(\"Loading audio\"),\n\t          bga: this._task(\"Loading BGA\"),\n\t          decode: this._task(\"Decoding audio\", Formatters.EXTRA) };\n\t        if (assets.progress) {\n\t          if (assets.progress.current) {\n\t            ProgressUtils.bind(assets.progress.current, progress.cpack);\n\t          }\n\t          if (assets.progress.all) {\n\t            ProgressUtils.bind(assets.progress.all, progress.pack);\n\t          }\n\t        }\n\t        return co(regeneratorRuntime.mark(function callee$2$0() {\n\t          var buffer, source, compileResult, chart, keysounds, audioLoader, audio;\n\t          return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n\t            while (1) switch (context$3$0.prev = context$3$0.next) {\n\t              case 0:\n\t                context$3$0.next = 2;\n\t                return bms.read(progress.bms);\n\t              case 2:\n\t                buffer = context$3$0.sent;\n\t                context$3$0.next = 5;\n\t                return readBMS(buffer);\n\t              case 5:\n\t                source = context$3$0.sent;\n\t                compileResult = BMS.Compiler.compile(source);\n\t                chart = compileResult.chart;\n\t                keysounds = BMS.Keysounds.fromBMSChart(chart);\n\t                audioLoader = new AudioLoader(assets);\n\t                context$3$0.next = 12;\n\t                return audioLoader.loadFrom(keysounds, progress.audio, progress.decode);\n\t              case 12:\n\t                audio = context$3$0.sent;\n\t                console.log(audio);\n\t              case 14:\n\t              case \"end\":\n\t                return context$3$0.stop();\n\t            }\n\t          }, callee$2$0, this);\n\t        }).bind(this));\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    _task: {\n\t      value: function _task(text, formatter) {\n\t        var _this = this;\n\t        formatter = formatter || Formatters.NORMAL;\n\t        var progress = new Progress();\n\t        var task = { text: text, progress: null, progressText: \"\" };\n\t        this._tasks.push(task);\n\t        progress.watch(function () {\n\t          task.progressText = formatter(progress);\n\t          task.progress = progress.progress;\n\t          _this.emit(\"progress\");\n\t        });\n\t        return progress;\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return GameLoader;\n\t})(EventEmitter);\n\t\n\t\n\tfunction loadEngineModule(progress) {\n\t  return new Promise(function (resolve) {\n\t    var context = new LoadingContext(progress);\n\t    context.use(function () {\n\t      __webpack_require__.e/*nsure*/(6, function (require) {\n\t        return resolve(__webpack_require__(44));\n\t      }, 0);\n\t    });\n\t  });\n\t}\n\t\n\tfunction readBMS(buffer) {\n\t  buffer = new Buffer(new Uint8Array(buffer));\n\t  return Promise.promisify(BMS.Reader.readAsync)(buffer);\n\t}\n\t\n\texports[\"default\"] = GameLoader;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).Buffer))\n\n/***/ },\n\n/***/ 194:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tmodule.exports = LoadingScene;\n\tvar View = _interopRequire(__webpack_require__(369));\n\t\n\t__webpack_require__(276);\n\t\n\tfunction LoadingScene(_ref) {\n\t  var loader = _ref.loader;\n\t  var song = _ref.song;\n\t  function getData() {\n\t    return {\n\t      song: song,\n\t      items: loader.tasks.map(function (_ref2) {\n\t        var text = _ref2.text;\n\t        var progressText = _ref2.progressText;\n\t        var progress = _ref2.progress;\n\t        return {\n\t          text: text,\n\t          progress: progressText ? \" (\" + progressText + \")\" : \"\",\n\t          width: Math.round(progress * 100 || 0) + \"%\" };\n\t      }) };\n\t  }\n\t  return function (container) {\n\t    var data = getData();\n\t    var view = new View({ el: container, data: data });\n\t    loader.on(\"progress\", function () {\n\t      return view.set(getData());\n\t    });\n\t    return function () {\n\t      container.classList.add(\"is-exiting\");\n\t      return Promise.delay(500);\n\t    };\n\t  };\n\t}\n\n/***/ },\n\n/***/ 196:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\tvar download = _interopRequire(__webpack_require__(39));\n\t\n\tvar basename = __webpack_require__(364).basename;\n\tvar URLResource = exports.URLResource = (function () {\n\t  function URLResource(url) {\n\t    _classCallCheck(this, URLResource);\n\t\n\t    this._url = url;\n\t  }\n\t\n\t  _prototypeProperties(URLResource, null, {\n\t    read: {\n\t      value: function read(progress) {\n\t        return download(this._url).as(\"arraybuffer\", progress);\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    },\n\t    name: {\n\t      get: function () {\n\t        return basename(this._url);\n\t      },\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return URLResource;\n\t})();\n\texports[\"default\"] = URLResource;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 197:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\tvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\t\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\t\n\t__webpack_require__(24);\n\t\n\tvar co = _interopRequire(__webpack_require__(11));\n\t\n\tvar SceneManager = exports.SceneManager = (function () {\n\t  function SceneManager() {\n\t    _classCallCheck(this, SceneManager);\n\t  }\n\t\n\t  _prototypeProperties(SceneManager, null, {\n\t    display: {\n\t      value: function display(scene) {\n\t        return co(regeneratorRuntime.mark(function callee$2$0() {\n\t          var _this = this;\n\t          var element;\n\t          return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n\t            while (1) switch (context$3$0.prev = context$3$0.next) {\n\t              case 0:\n\t                if (!_this.exit) {\n\t                  context$3$0.next = 4;\n\t                  break;\n\t                }\n\t                context$3$0.next = 3;\n\t                return Promise.resolve(_this.exit());\n\t              case 3:\n\t                detach(_this.currentElement);\n\t              case 4:\n\t                element = document.createElement(\"div\");\n\t                element.className = \"scene\";\n\t                document.body.appendChild(element);\n\t                _this.exit = scene(element);\n\t              case 8:\n\t              case \"end\":\n\t                return context$3$0.stop();\n\t            }\n\t          }, callee$2$0, this);\n\t        }));\n\t      },\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t\n\t  return SceneManager;\n\t})();\n\t\n\t\n\tfunction detach(element) {\n\t  if (element && element.parentNode === document.body) {\n\t    document.body.removeChild(element);\n\t  }\n\t}\n\t\n\tvar instance = exports.instance = new SceneManager();\n\texports[\"default\"] = instance;\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 198:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\t\n\texports.View = View;\n\tvar Ractive = _interopRequire(__webpack_require__(255));\n\t\n\tfunction View(template) {\n\t  return function ViewInstance(options) {\n\t    return new Ractive(Object.assign({ template: template }, options));\n\t  };\n\t}\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n/***/ },\n\n/***/ 199:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\texports.Reader          = __webpack_require__(208)\n\texports.Compiler        = __webpack_require__(132)\n\t\n\texports.BMSChart        = __webpack_require__(112)\n\texports.BMSHeaders      = __webpack_require__(113)\n\texports.BMSObjects      = __webpack_require__(114)\n\t\n\texports.Speedcore       = __webpack_require__(115)\n\texports.TimeSignatures  = __webpack_require__(116)\n\texports.Notes           = __webpack_require__(133)\n\texports.Timing          = __webpack_require__(136)\n\texports.SongInfo        = __webpack_require__(209)\n\texports.Keysounds       = __webpack_require__(200)\n\n\n/***/ },\n\n/***/ 200:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar _ = __webpack_require__(207)\n\t\n\tfunction Keysounds(map) {\n\t  this._map = map\n\t}\n\t\n\tKeysounds.prototype.get = function(id) {\n\t  return this._map[id.toLowerCase()]\n\t}\n\t\n\tKeysounds.prototype.files = function() {\n\t  return _.uniq(_.values(this._map))\n\t}\n\t\n\tKeysounds.fromBMSChart = function(chart) {\n\t  var map = {}\n\t  chart.headers.each(function(name, value) {\n\t    var match = name.match(/^wav(\\S\\S)$/i)\n\t    if (!match) return\n\t    map[match[1].toLowerCase()] = value\n\t  })\n\t  return new Keysounds(map)\n\t}\n\t\n\tmodule.exports = Keysounds\n\n\n/***/ },\n\n/***/ 201:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar utf8  = __webpack_require__(206),\n\t  unicode = __webpack_require__(205),\n\t  mbcs    = __webpack_require__(203),\n\t  sbcs    = __webpack_require__(204),\n\t  iso2022 = __webpack_require__(202);\n\t\n\tvar self = this;\n\t\n\tvar recognisers = [\n\t  new utf8,\n\t  new unicode.UTF_16BE,\n\t  new unicode.UTF_16LE,\n\t  new mbcs.sjis,\n\t  new mbcs.euc_kr\n\t];\n\t\n\tmodule.exports.detect = function(buffer) {\n\t\n\t  // Tally up the byte occurence statistics.\n\t  var fByteStats = [];\n\t  for (var i = 0; i < 256; i++)\n\t    fByteStats[i] = 0;\n\t\n\t  for (var i = buffer.length - 1; i >= 0; i--)\n\t    fByteStats[buffer[i] & 0x00ff]++;\n\t\n\t  var fC1Bytes = false;\n\t  for (var i = 0x80; i <= 0x9F; i += 1) {\n\t    if (fByteStats[i] != 0) {\n\t      fC1Bytes = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var context = {\n\t    fByteStats:  fByteStats,\n\t    fC1Bytes:    fC1Bytes,\n\t    fRawInput:   buffer,\n\t    fRawLength:  buffer.length,\n\t    fInputBytes: buffer,\n\t    fInputLen:   buffer.length\n\t  };\n\t\n\t  var match = recognisers.map(function(rec) {\n\t    return rec.match(context);\n\t  }).filter(function(match) {\n\t    return !!match;\n\t  }).sort(function(a, b) {\n\t    return a.confidence - b.confidence;\n\t  }).pop();\n\t\n\t  return match ? match.name : null;\n\t};\n\n\n/***/ },\n\n/***/ 202:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(128),\n\t  Match = __webpack_require__ (56);\n\t\n\t\n\t/**\n\t * This is a superclass for the individual detectors for\n\t * each of the detectable members of the ISO 2022 family\n\t * of encodings.\n\t */\n\t\n\tfunction ISO_2022() {}\n\t\n\tISO_2022.prototype.match = function(det) {\n\t\n\t  /**\n\t   * Matching function shared among the 2022 detectors JP, CN and KR\n\t   * Counts up the number of legal an unrecognized escape sequences in\n\t   * the sample of text, and computes a score based on the total number &\n\t   * the proportion that fit the encoding.\n\t   *\n\t   *\n\t   * @param text the byte buffer containing text to analyse\n\t   * @param textLen  the size of the text in the byte.\n\t   * @param escapeSequences the byte escape sequences to test for.\n\t   * @return match quality, in the range of 0-100.\n\t   */\n\t\n\t  var i, j;\n\t  var escN;\n\t  var hits   = 0;\n\t  var misses = 0;\n\t  var shifts = 0;\n\t  var quality;\n\t\n\t  // TODO: refactor me\n\t  var text = det.fInputBytes;\n\t  var textLen = det.fInputLen;\n\t\n\t  scanInput:\n\t    for (i = 0; i < textLen; i++) {\n\t      if (text[i] == 0x1b) {\n\t        checkEscapes:\n\t          for (escN = 0; escN < this.escapeSequences.length; escN++) {\n\t            var seq = this.escapeSequences[escN];\n\t\n\t            if ((textLen - i) < seq.length)\n\t              continue checkEscapes;\n\t\n\t            for (j = 1; j < seq.length; j++)\n\t              if (seq[j] != text[i + j])\n\t                continue checkEscapes;\n\t\n\t\n\t            hits++;\n\t            i += seq.length - 1;\n\t            continue scanInput;\n\t          }\n\t\n\t          misses++;\n\t      }\n\t\n\t      // Shift in/out\n\t      if (text[i] == 0x0e || text[i] == 0x0f)\n\t        shifts++;\n\t\n\t    }\n\t\n\t  if (hits == 0)\n\t    return null;\n\t\n\t  //\n\t  // Initial quality is based on relative proportion of recongized vs.\n\t  //   unrecognized escape sequences.\n\t  //   All good:  quality = 100;\n\t  //   half or less good: quality = 0;\n\t  //   linear inbetween.\n\t  quality = (100 * hits - 100 * misses) / (hits + misses);\n\t\n\t  // Back off quality if there were too few escape sequences seen.\n\t  //   Include shifts in this computation, so that KR does not get penalized\n\t  //   for having only a single Escape sequence, but many shifts.\n\t  if (hits + shifts < 5)\n\t    quality -= (5 - (hits + shifts)) * 10;\n\t\n\t  return quality <= 0 ? null : new Match(det, this, quality);\n\t};\n\t\n\tmodule.exports.ISO_2022_JP = function() {\n\t  this.name = function() {\n\t    return 'ISO-2022-JP';\n\t  };\n\t  this.escapeSequences = [\n\t    [ 0x1b, 0x24, 0x28, 0x43 ],   // KS X 1001:1992\n\t    [ 0x1b, 0x24, 0x28, 0x44 ],   // JIS X 212-1990\n\t    [ 0x1b, 0x24, 0x40 ],         // JIS C 6226-1978\n\t    [ 0x1b, 0x24, 0x41 ],         // GB 2312-80\n\t    [ 0x1b, 0x24, 0x42 ],         // JIS X 208-1983\n\t    [ 0x1b, 0x26, 0x40 ],         // JIS X 208 1990, 1997\n\t    [ 0x1b, 0x28, 0x42 ],         // ASCII\n\t    [ 0x1b, 0x28, 0x48 ],         // JIS-Roman\n\t    [ 0x1b, 0x28, 0x49 ],         // Half-width katakana\n\t    [ 0x1b, 0x28, 0x4a ],         // JIS-Roman\n\t    [ 0x1b, 0x2e, 0x41 ],         // ISO 8859-1\n\t    [ 0x1b, 0x2e, 0x46 ]          // ISO 8859-7\n\t  ];\n\t};\n\tutil.inherits(module.exports.ISO_2022_JP, ISO_2022);\n\t\n\t\n\t\n\tmodule.exports.ISO_2022_KR = function() {\n\t  this.name = function() {\n\t    return 'ISO-2022-KR';\n\t  };\n\t  this.escapeSequences = [\n\t    [ 0x1b, 0x24, 0x29, 0x43 ]\n\t  ];\n\t};\n\tutil.inherits(module.exports.ISO_2022_KR, ISO_2022);\n\t\n\t\n\t\n\tmodule.exports.ISO_2022_CN = function() {\n\t  this.name = function() {\n\t    return 'ISO-2022-CN';\n\t  };\n\t  this.escapeSequences = [\n\t    [ 0x1b, 0x24, 0x29, 0x41 ],   // GB 2312-80\n\t    [ 0x1b, 0x24, 0x29, 0x47 ],   // CNS 11643-1992 Plane 1\n\t    [ 0x1b, 0x24, 0x2A, 0x48 ],   // CNS 11643-1992 Plane 2\n\t    [ 0x1b, 0x24, 0x29, 0x45 ],   // ISO-IR-165\n\t    [ 0x1b, 0x24, 0x2B, 0x49 ],   // CNS 11643-1992 Plane 3\n\t    [ 0x1b, 0x24, 0x2B, 0x4A ],   // CNS 11643-1992 Plane 4\n\t    [ 0x1b, 0x24, 0x2B, 0x4B ],   // CNS 11643-1992 Plane 5\n\t    [ 0x1b, 0x24, 0x2B, 0x4C ],   // CNS 11643-1992 Plane 6\n\t    [ 0x1b, 0x24, 0x2B, 0x4D ],   // CNS 11643-1992 Plane 7\n\t    [ 0x1b, 0x4e ],               // SS2\n\t    [ 0x1b, 0x4f ]                // SS3\n\t  ];\n\t};\n\tutil.inherits(module.exports.ISO_2022_CN, ISO_2022);\n\n\n/***/ },\n\n/***/ 203:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(128),\n\t  Match = __webpack_require__ (56);\n\t\n\t/**\n\t * Binary search implementation (recursive)\n\t */\n\tfunction binarySearch(arr, searchValue) {\n\t  function find(arr, searchValue, left, right) {\n\t    if (right < left)\n\t      return -1;\n\t\n\t    /*\n\t    int mid = mid = (left + right) / 2;\n\t    There is a bug in the above line;\n\t    Joshua Bloch suggests the following replacement:\n\t    */\n\t    var mid = Math.floor((left + right) >>> 1);\n\t    if (searchValue > arr[mid])\n\t      return find(arr, searchValue, mid + 1, right);\n\t\n\t    if (searchValue < arr[mid])\n\t      return find(arr, searchValue, left, mid - 1);\n\t\n\t    return mid;\n\t  };\n\t\n\t  return find(arr, searchValue, 0, arr.length - 1);\n\t};\n\t\n\t// 'Character'  iterated character class.\n\t//    Recognizers for specific mbcs encodings make their 'characters' available\n\t//    by providing a nextChar() function that fills in an instance of iteratedChar\n\t//    with the next char from the input.\n\t//    The returned characters are not converted to Unicode, but remain as the raw\n\t//    bytes (concatenated into an int) from the codepage data.\n\t//\n\t//  For Asian charsets, use the raw input rather than the input that has been\n\t//   stripped of markup.  Detection only considers multi-byte chars, effectively\n\t//   stripping markup anyway, and double byte chars do occur in markup too.\n\t//\n\tfunction IteratedChar() {\n\t\n\t  this.charValue = 0; // 1-4 bytes from the raw input data\n\t  this.index     = 0;\n\t  this.nextIndex = 0;\n\t  this.error     = false;\n\t  this.done      = false;\n\t\n\t  this.reset = function() {\n\t    this.charValue = 0;\n\t    this.index     = -1;\n\t    this.nextIndex = 0;\n\t    this.error     = false;\n\t    this.done      = false;\n\t  };\n\t\n\t  this.nextByte = function(det) {\n\t    if (this.nextIndex >= det.fRawLength) {\n\t      this.done = true;\n\t      return -1;\n\t    }\n\t    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n\t    return byteValue;\n\t  };\n\t};\n\t\n\t\n\t\n\t/**\n\t * Asian double or multi-byte - charsets.\n\t * Match is determined mostly by the input data adhering to the\n\t * encoding scheme for the charset, and, optionally,\n\t * frequency-of-occurence of characters.\n\t */\n\t\n\tfunction mbcs() {};\n\t\n\t/**\n\t * Test the match of this charset with the input text data\n\t *      which is obtained via the CharsetDetector object.\n\t *\n\t * @param det  The CharsetDetector, which contains the input text\n\t *             to be checked for being in this charset.\n\t * @return     Two values packed into one int  (Damn java, anyhow)\n\t *             bits 0-7:  the match confidence, ranging from 0-100\n\t *             bits 8-15: The match reason, an enum-like value.\n\t */\n\tmbcs.prototype.match = function(det) {\n\t\n\t  var singleByteCharCount = 0,  //TODO Do we really need this?\n\t    doubleByteCharCount = 0,\n\t    commonCharCount     = 0,\n\t    badCharCount        = 0,\n\t    totalCharCount      = 0,\n\t    confidence          = 0;\n\t\n\t  var iter = new IteratedChar();\n\t\n\t  detectBlock: {\n\t    for (iter.reset(); this.nextChar(iter, det);) {\n\t      totalCharCount++;\n\t      if (iter.error) {\n\t        badCharCount++;\n\t      } else {\n\t        var cv = iter.charValue & 0xFFFFFFFF;\n\t\n\t        if (cv <= 0xff) {\n\t          singleByteCharCount++;\n\t        } else {\n\t          doubleByteCharCount++;\n\t          if (this.commonChars != null) {\n\t            // NOTE: This assumes that there are no 4-byte common chars.\n\t            if (binarySearch(this.commonChars, cv) >= 0) {\n\t              commonCharCount++;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n\t        // console.log('its here!')\n\t        // Bail out early if the byte data is not matching the encoding scheme.\n\t        break detectBlock;\n\t      }\n\t    }\n\t\n\t    if (doubleByteCharCount <= 10 && badCharCount== 0) {\n\t      // Not many multi-byte chars.\n\t      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n\t        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n\t        // We don't have enough data to have any confidence.\n\t        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n\t        confidence = 0;\n\t      }\n\t      else {\n\t        //   ASCII or ISO file?  It's probably not our encoding,\n\t        //   but is not incompatible with our encoding, so don't give it a zero.\n\t        confidence = 10;\n\t      }\n\t      break detectBlock;\n\t    }\n\t\n\t    //\n\t    //  No match if there are too many characters that don't fit the encoding scheme.\n\t    //    (should we have zero tolerance for these?)\n\t    //\n\t    if (doubleByteCharCount < 20 * badCharCount) {\n\t      confidence = 0;\n\t      break detectBlock;\n\t    }\n\t\n\t    if (this.commonChars == null) {\n\t      // We have no statistics on frequently occuring characters.\n\t      //  Assess confidence purely on having a reasonable number of\n\t      //  multi-byte characters (the more the better\n\t      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n\t      if (confidence > 100) {\n\t        confidence = 100;\n\t      }\n\t    } else {\n\t      //\n\t      // Frequency of occurence statistics exist.\n\t      //\n\t      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n\t      var scaleFactor = 90.0 / maxVal;\n\t      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n\t      confidence = Math.min(confidence, 100);\n\t    }\n\t  }   // end of detectBlock:\n\t\n\t  return confidence == 0 ? null : new Match(det, this, confidence);\n\t};\n\t\n\t/**\n\t * Get the next character (however many bytes it is) from the input data\n\t *    Subclasses for specific charset encodings must implement this function\n\t *    to get characters according to the rules of their encoding scheme.\n\t *\n\t *  This function is not a method of class iteratedChar only because\n\t *   that would require a lot of extra derived classes, which is awkward.\n\t * @param it  The iteratedChar 'struct' into which the returned char is placed.\n\t * @param det The charset detector, which is needed to get at the input byte data\n\t *            being iterated over.\n\t * @return    True if a character was returned, false at end of input.\n\t */\n\t\n\tmbcs.prototype.nextChar = function(iter, det) {};\n\t\n\t\n\t\n\t/**\n\t * Shift-JIS charset recognizer.\n\t */\n\tmodule.exports.sjis = function() {\n\t  this.name = function() {\n\t    return 'Shift-JIS';\n\t  };\n\t  this.language = function() {\n\t    return 'ja';\n\t  };\n\t\n\t  // TODO:  This set of data comes from the character frequency-\n\t  //        of-occurence analysis tool.  The data needs to be moved\n\t  //        into a resource and loaded from there.\n\t  this.commonChars = [\n\t    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,\n\t    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,\n\t    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,\n\t    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,\n\t    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,\n\t    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa\n\t  ];\n\t\n\t  this.nextChar = function(iter, det) {\n\t    iter.index = iter.nextIndex;\n\t    iter.error = false;\n\t\n\t    var firstByte;\n\t    firstByte = iter.charValue = iter.nextByte(det);\n\t    if (firstByte < 0)\n\t      return false;\n\t\n\t    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))\n\t      return true;\n\t\n\t    var secondByte = iter.nextByte(det);\n\t    if (secondByte < 0)\n\t      return false;\n\t\n\t    iter.charValue = (firstByte << 8) | secondByte;\n\t    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {\n\t      // Illegal second byte value.\n\t      iter.error = true;\n\t    }\n\t    return true;\n\t  };\n\t};\n\tutil.inherits(module.exports.sjis, mbcs);\n\t\n\t\n\t\n\t/**\n\t *   Big5 charset recognizer.\n\t */\n\tmodule.exports.big5 = function() {\n\t  this.name = function() {\n\t    return 'Big5';\n\t  };\n\t  this.language = function() {\n\t    return 'zh';\n\t  };\n\t  // TODO:  This set of data comes from the character frequency-\n\t  //        of-occurence analysis tool.  The data needs to be moved\n\t  //        into a resource and loaded from there.\n\t  this.commonChars = [\n\t    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,\n\t    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,\n\t    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,\n\t    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,\n\t    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,\n\t    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,\n\t    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,\n\t    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,\n\t    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,\n\t    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f\n\t  ];\n\t  this.nextChar = function(iter, det) {\n\t    iter.index = iter.nextIndex;\n\t    iter.error = false;\n\t\n\t    var firstByte = iter.charValue = iter.nextByte(det);\n\t\n\t    if (firstByte < 0)\n\t      return false;\n\t\n\t    // single byte character.\n\t    if (firstByte <= 0x7f || firstByte == 0xff)\n\t      return true;\n\t\n\t    var secondByte = iter.nextByte(det);\n\t\n\t    if (secondByte < 0)\n\t      return false;\n\t\n\t    iter.charValue = (iter.charValue << 8) | secondByte;\n\t\n\t    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)\n\t      iter.error = true;\n\t\n\t    return true;\n\t  };\n\t};\n\tutil.inherits(module.exports.big5, mbcs);\n\t\n\t\n\t\n\t/**\n\t *  EUC charset recognizers.  One abstract class that provides the common function\n\t *  for getting the next character according to the EUC encoding scheme,\n\t *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n\t *\n\t *  Get the next character value for EUC based encodings.\n\t *  Character 'value' is simply the raw bytes that make up the character\n\t *     packed into an int.\n\t */\n\tfunction eucNextChar(iter, det) {\n\t  iter.index = iter.nextIndex;\n\t  iter.error = false;\n\t  var firstByte  = 0;\n\t  var secondByte = 0;\n\t  var thirdByte  = 0;\n\t  //int fourthByte = 0;\n\t  buildChar: {\n\t    firstByte = iter.charValue = iter.nextByte(det);\n\t    if (firstByte < 0) {\n\t      // Ran off the end of the input data\n\t      iter.done = true;\n\t      break buildChar;\n\t    }\n\t    if (firstByte <= 0x8d) {\n\t      // single byte char\n\t      break buildChar;\n\t    }\n\t    secondByte = iter.nextByte(det);\n\t    iter.charValue = (iter.charValue << 8) | secondByte;\n\t    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n\t      // Two byte Char\n\t      if (secondByte < 0xa1) {\n\t        iter.error = true;\n\t      }\n\t      break buildChar;\n\t    }\n\t    if (firstByte == 0x8e) {\n\t      // Code Set 2.\n\t      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n\t      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n\t      // We don't know which we've got.\n\t      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n\t      //   bytes will look like a well formed 2 byte char.\n\t      if (secondByte < 0xa1) {\n\t        iter.error = true;\n\t      }\n\t      break buildChar;\n\t    }\n\t    if (firstByte == 0x8f) {\n\t      // Code set 3.\n\t      // Three byte total char size, two bytes of actual char value.\n\t      thirdByte = iter.nextByte(det);\n\t      iter.charValue = (iter.charValue << 8) | thirdByte;\n\t      if (thirdByte < 0xa1) {\n\t        iter.error = true;\n\t      }\n\t    }\n\t  }\n\t  return iter.done == false;\n\t};\n\t\n\t\n\t\n\t/**\n\t * The charset recognize for EUC-JP.  A singleton instance of this class\n\t *    is created and kept by the public CharsetDetector class\n\t */\n\tmodule.exports.euc_jp = function() {\n\t  this.name = function() {\n\t    return 'EUC-JP';\n\t  };\n\t  this.language = function() {\n\t    return 'ja';\n\t  };\n\t\n\t  // TODO:  This set of data comes from the character frequency-\n\t  //        of-occurence analysis tool.  The data needs to be moved\n\t  //        into a resource and loaded from there.\n\t  this.commonChars = [\n\t    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,\n\t    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,\n\t    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,\n\t    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,\n\t    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,\n\t    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,\n\t    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,\n\t    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,\n\t    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,\n\t    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1\n\t  ];\n\t\n\t  this.nextChar = eucNextChar;\n\t};\n\tutil.inherits(module.exports.euc_jp, mbcs);\n\t\n\t\n\t\n\t/**\n\t * The charset recognize for EUC-KR.  A singleton instance of this class\n\t *    is created and kept by the public CharsetDetector class\n\t */\n\tmodule.exports.euc_kr = function() {\n\t  this.name = function() {\n\t    return 'EUC-KR';\n\t  };\n\t  this.language = function() {\n\t    return 'ko';\n\t  };\n\t\n\t  // TODO:  This set of data comes from the character frequency-\n\t  //        of-occurence analysis tool.  The data needs to be moved\n\t  //        into a resource and loaded from there.\n\t  this.commonChars = [\n\t    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,\n\t    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,\n\t    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,\n\t    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,\n\t    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,\n\t    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,\n\t    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,\n\t    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,\n\t    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,\n\t    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad\n\t  ];\n\t\n\t  this.nextChar = eucNextChar;\n\t};\n\tutil.inherits(module.exports.euc_kr, mbcs);\n\t\n\t\n\t\n\t/**\n\t *   GB-18030 recognizer. Uses simplified Chinese statistics.\n\t */\n\tmodule.exports.gb_18030 = function() {\n\t  this.name = function() {\n\t    return 'GB18030';\n\t  };\n\t  this.language = function() {\n\t    return 'zh';\n\t  };\n\t\n\t  /*\n\t   *  Get the next character value for EUC based encodings.\n\t   *  Character 'value' is simply the raw bytes that make up the character\n\t   *     packed into an int.\n\t   */\n\t  this.nextChar = function(iter, det) {\n\t    iter.index = iter.nextIndex;\n\t    iter.error = false;\n\t    var firstByte  = 0;\n\t    var secondByte = 0;\n\t    var thirdByte  = 0;\n\t    var fourthByte = 0;\n\t    buildChar: {\n\t      firstByte = iter.charValue = iter.nextByte(det);\n\t      if (firstByte < 0) {\n\t        // Ran off the end of the input data\n\t        iter.done = true;\n\t        break buildChar;\n\t      }\n\t      if (firstByte <= 0x80) {\n\t        // single byte char\n\t        break buildChar;\n\t      }\n\t      secondByte = iter.nextByte(det);\n\t      iter.charValue = (iter.charValue << 8) | secondByte;\n\t      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n\t        // Two byte Char\n\t        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {\n\t          break buildChar;\n\t        }\n\t        // Four byte char\n\t        if (secondByte >= 0x30 && secondByte <= 0x39) {\n\t          thirdByte = iter.nextByte(det);\n\t          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n\t            fourthByte = iter.nextByte(det);\n\t            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n\t              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;\n\t              break buildChar;\n\t            }\n\t          }\n\t        }\n\t        iter.error = true;\n\t        break buildChar;\n\t      }\n\t    }\n\t    return iter.done == false;\n\t  };\n\t\n\t  // TODO:  This set of data comes from the character frequency-\n\t  //        of-occurence analysis tool.  The data needs to be moved\n\t  //        into a resource and loaded from there.\n\t  this.commonChars = [\n\t    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,\n\t    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,\n\t    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,\n\t    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,\n\t    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,\n\t    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,\n\t    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,\n\t    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,\n\t    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,\n\t    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0\n\t  ];\n\t};\n\tutil.inherits(module.exports.gb_18030, mbcs);\n\n\n/***/ },\n\n/***/ 204:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(128),\n\t  Match = __webpack_require__ (56);\n\t\n\t/**\n\t * This class recognizes single-byte encodings. Because the encoding scheme is so\n\t * simple, language statistics are used to do the matching.\n\t */\n\t\n\tfunction NGramParser(theNgramList, theByteMap) {\n\t  var N_GRAM_MASK = 0xFFFFFF;\n\t\n\t  this.byteIndex = 0;\n\t  this.ngram = 0;\n\t\n\t  this.ngramList = theNgramList;\n\t  this.byteMap = theByteMap;\n\t\n\t  this.ngramCount = 0;\n\t  this.hitCount = 0;\n\t\n\t  this.spaceChar;\n\t\n\t  /*\n\t   * Binary search for value in table, which must have exactly 64 entries.\n\t   */\n\t  this.search = function(table, value) {\n\t    var index = 0;\n\t\n\t    if (table[index + 32] <= value) index += 32;\n\t    if (table[index + 16] <= value) index += 16;\n\t    if (table[index + 8]  <= value) index += 8;\n\t    if (table[index + 4]  <= value) index += 4;\n\t    if (table[index + 2]  <= value) index += 2;\n\t    if (table[index + 1]  <= value) index += 1;\n\t    if (table[index]      > value)  index -= 1;\n\t\n\t    if (index < 0 || table[index] != value)\n\t      return -1;\n\t\n\t    return index;\n\t  };\n\t\n\t  this.lookup = function(thisNgram) {\n\t    this.ngramCount += 1;\n\t    if (this.search(this.ngramList, thisNgram) >= 0) {\n\t      this.hitCount += 1;\n\t    }\n\t  };\n\t\n\t  this.addByte = function(b) {\n\t    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;\n\t    this.lookup(this.ngram);\n\t  }\n\t\n\t  this.nextByte = function(det) {\n\t    if (this.byteIndex >= det.fInputLen)\n\t      return -1;\n\t\n\t    return det.fInputBytes[this.byteIndex++] & 0xFF;\n\t  }\n\t\n\t  this.parse = function(det, spaceCh) {\n\t    var b, ignoreSpace = false;\n\t    this.spaceChar = spaceCh;\n\t\n\t    while ((b = this.nextByte(det)) >= 0) {\n\t      var mb = this.byteMap[b];\n\t\n\t      // TODO: 0x20 might not be a space in all character sets...\n\t      if (mb != 0) {\n\t        if (!(mb == this.spaceChar && ignoreSpace)) {\n\t          this.addByte(mb);\n\t        }\n\t\n\t        ignoreSpace = (mb == this.spaceChar);\n\t      }\n\t    }\n\t\n\t    // TODO: Is this OK? The buffer could have ended in the middle of a word...\n\t    this.addByte(this.spaceChar);\n\t\n\t    var rawPercent = this.hitCount / this.ngramCount;\n\t\n\t    // TODO - This is a bit of a hack to take care of a case\n\t    // were we were getting a confidence of 135...\n\t    if (rawPercent > 0.33)\n\t      return 98;\n\t\n\t    return Math.floor(rawPercent * 300.0);\n\t  };\n\t};\n\t\n\tfunction NGramsPlusLang(la, ng) {\n\t  this.fLang = la;\n\t  this.fNGrams = ng;\n\t};\n\t\n\tfunction sbcs() {};\n\tsbcs.prototype.spaceChar = 0x20;\n\tsbcs.prototype.ngrams = function() {};\n\tsbcs.prototype.byteMap = function() {};\n\tsbcs.prototype.match = function(det) {\n\t\n\t  var ngrams = this.ngrams();\n\t  var multiple = (Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang);\n\t\n\t  if (!multiple) {\n\t    var parser = new NGramParser(ngrams, this.byteMap());\n\t    var confidence = parser.parse(det, this.spaceChar);\n\t    return confidence <= 0 ? null : new Match(det, this, confidence);\n\t  }\n\t\n\t  var bestConfidenceSoFar = -1;\n\t  var lang = null;\n\t\n\t  for (var i = ngrams.length - 1; i >= 0; i--) {\n\t    var ngl = ngrams[i];\n\t\n\t    var parser = new NGramParser(ngl.fNGrams, this.byteMap());\n\t    var confidence = parser.parse(det, this.spaceChar);\n\t    if (confidence > bestConfidenceSoFar) {\n\t      bestConfidenceSoFar = confidence;\n\t      lang = ngl.fLang;\n\t    }\n\t  }\n\t\n\t  var name = this.name(det);\n\t  return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);\n\t};\n\t\n\t\n\tmodule.exports.ISO_8859_1 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n\t      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      new NGramsPlusLang('da', [\n\t        0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,\n\t        0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,\n\t        0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574,\n\t        0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,\n\t        0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67,\n\t        0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,\n\t        0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065,\n\t        0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572\n\t      ]),\n\t      new NGramsPlusLang('de', [\n\t        0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765,\n\t        0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,\n\t        0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E,\n\t        0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,\n\t        0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65,\n\t        0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,\n\t        0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368,\n\t        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572\n\t      ]),\n\t      new NGramsPlusLang('en', [\n\t        0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E,\n\t        0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,\n\t        0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465,\n\t        0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,\n\t        0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20,\n\t        0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,\n\t        0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,\n\t        0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320\n\t      ]),\n\t      new NGramsPlusLang('es', [\n\t        0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E,\n\t        0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n\t        0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369,\n\t        0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,\n\t        0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320,\n\t        0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,\n\t        0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573,\n\t        0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20\n\t      ]),\n\t      new NGramsPlusLang('fr', [\n\t        0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61,\n\t        0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,\n\t        0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520,\n\t        0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,\n\t        0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420,\n\t        0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,\n\t        0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064,\n\t        0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220\n\t      ]),\n\t      new NGramsPlusLang('it', [\n\t        0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E,\n\t        0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,\n\t        0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064,\n\t        0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,\n\t        0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20,\n\t        0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,\n\t        0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572,\n\t        0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F\n\t      ]),\n\t      new NGramsPlusLang('nl', [\n\t        0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765,\n\t        0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,\n\t        0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220,\n\t        0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,\n\t        0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520,\n\t        0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,\n\t        0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368,\n\t        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F\n\t      ]),\n\t      new NGramsPlusLang('no', [\n\t        0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,\n\t        0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,\n\t        0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574,\n\t        0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,\n\t        0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520,\n\t        0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,\n\t        0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465,\n\t        0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572\n\t      ]),\n\t      new NGramsPlusLang('pt', [\n\t        0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61,\n\t        0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n\t        0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20,\n\t        0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,\n\t        0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120,\n\t        0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,\n\t        0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,\n\t        0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F\n\t      ]),\n\t      new NGramsPlusLang('sv', [\n\t        0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E,\n\t        0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,\n\t        0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474,\n\t        0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,\n\t        0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564,\n\t        0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,\n\t        0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073,\n\t        0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,\n\t      ])\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return (det && det.fC1Bytes) ? 'windows-1252' : 'ISO-8859-1';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_1, sbcs);\n\t\n\t\n\tmodule.exports.ISO_8859_2 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20,\n\t      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,\n\t      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7,\n\t      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20\n\t    ];\n\t  }\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      new NGramsPlusLang('cs', [\n\t        0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64,\n\t        0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,\n\t        0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073,\n\t        0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,\n\t        0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E,\n\t        0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,\n\t        0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20,\n\t        0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,\n\t      ]),\n\t      new NGramsPlusLang('hu', [\n\t        0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F,\n\t        0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,\n\t        0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073,\n\t        0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,\n\t        0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920,\n\t        0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,\n\t        0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74,\n\t        0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,\n\t      ]),\n\t      new NGramsPlusLang('pl', [\n\t        0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61,\n\t        0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,\n\t        0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79,\n\t        0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,\n\t        0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920,\n\t        0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,\n\t        0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69,\n\t        0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,\n\t      ]),\n\t      new NGramsPlusLang('ro', [\n\t        0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469,\n\t        0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,\n\t        0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172,\n\t        0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,\n\t        0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063,\n\t        0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,\n\t        0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520,\n\t        0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,\n\t      ])\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return (det && det.fC1Bytes) ? 'windows-1250' : 'ISO-8859-2';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_2, sbcs);\n\t\n\t\n\tmodule.exports.ISO_8859_5 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n\t      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n\t      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0,\n\t      0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,\n\t      0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2,\n\t      0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,\n\t      0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF,\n\t      0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,\n\t      0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2,\n\t      0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return 'ISO-8859-5';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'ru';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_5, sbcs);\n\t\n\t\n\tmodule.exports.ISO_8859_6 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n\t      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n\t      0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7,\n\t      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,\n\t      0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5,\n\t      0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,\n\t      0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,\n\t      0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,\n\t      0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4,\n\t      0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return 'ISO-8859-6';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'ar';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_6, sbcs);\n\t\n\t\n\tmodule.exports.ISO_8859_7 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20,\n\t      0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE,\n\t      0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5,\n\t      0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,\n\t      0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220,\n\t      0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,\n\t      0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0,\n\t      0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,\n\t      0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9,\n\t      0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return (det && det.fC1Bytes) ? 'windows-1253' : 'ISO-8859-7';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'el';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_7, sbcs);\n\t\n\tmodule.exports.ISO_8859_8 = function() {\n\t\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      new NGramsPlusLang('he', [\n\t        0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5,\n\t        0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,\n\t        0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE,\n\t        0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,\n\t        0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0,\n\t        0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,\n\t        0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4,\n\t        0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,\n\t      ]),\n\t      new NGramsPlusLang('he', [\n\t        0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2,\n\t        0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,\n\t        0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4,\n\t        0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,\n\t        0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020,\n\t        0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,\n\t        0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420,\n\t        0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,\n\t      ])\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return (det && det.fC1Bytes) ? 'windows-1255' : 'ISO-8859-8';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'he';\n\t  };\n\t\n\t};\n\tutil.inherits(module.exports.ISO_8859_8, sbcs);\n\t\n\t\n\tmodule.exports.ISO_8859_9 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n\t      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C,\n\t      0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,\n\t      0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261,\n\t      0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,\n\t      0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20,\n\t      0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,\n\t      0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E,\n\t      0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return (det && det.fC1Bytes) ? 'windows-1254' : 'ISO-8859-9';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'tr';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_9, sbcs);\n\t\n\t\n\tmodule.exports.windows_1251 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,\n\t      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,\n\t      0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20,\n\t      0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF,\n\t      0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20,\n\t      0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n\t      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0,\n\t      0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,\n\t      0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2,\n\t      0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,\n\t      0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF,\n\t      0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,\n\t      0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2,\n\t      0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return 'windows-1251';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'ru';\n\t  };\n\t};\n\tutil.inherits(module.exports.windows_1251, sbcs);\n\t\n\t\n\tmodule.exports.windows_1256 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,\n\t      0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F,\n\t      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n\t      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20,\n\t      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n\t      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n\t      0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20,\n\t      0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7,\n\t      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,\n\t      0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3,\n\t      0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,\n\t      0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,\n\t      0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,\n\t      0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1,\n\t      0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return 'windows-1256';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'ar';\n\t  };\n\t};\n\tutil.inherits(module.exports.windows_1256, sbcs);\n\t\n\t\n\tmodule.exports.KOI8_R = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n\t      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,\n\t      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n\t      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n\t      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n\t      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n\t      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n\t      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n\t      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t      0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF,\n\t      0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,\n\t      0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420,\n\t      0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,\n\t      0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3,\n\t      0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,\n\t      0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1,\n\t      0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    return 'KOI8-R';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'ru';\n\t  };\n\t};\n\tutil.inherits(module.exports.KOI8_R, sbcs);\n\t\n\t\n\t/*\n\tmodule.exports.ISO_8859_7 = function() {\n\t  this.byteMap = function() {\n\t    return [\n\t\n\t    ];\n\t  };\n\t\n\t  this.ngrams = function() {\n\t    return [\n\t\n\t    ];\n\t  };\n\t\n\t  this.name = function(det) {\n\t    if (typeof det == 'undefined')\n\t      return 'ISO-8859-7';\n\t    return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';\n\t  };\n\t\n\t  this.language = function() {\n\t    return 'el';\n\t  };\n\t};\n\tutil.inherits(module.exports.ISO_8859_7, sbcs);\n\t*/\n\t\n\n\n/***/ },\n\n/***/ 205:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(128),\n\t  Match = __webpack_require__ (56);\n\t\n\t/**\n\t * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n\t * BOM will be used if it is present.\n\t */\n\tmodule.exports.UTF_16BE = function() {\n\t  this.name = function() {\n\t    return 'UTF-16BE';\n\t  };\n\t  this.match = function(det) {\n\t    var input = det.fRawInput;\n\t\n\t    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff))\n\t      return new Match(det, this, confidence = 100);\n\t\n\t    // TODO: Do some statistics to check for unsigned UTF-16BE\n\t    return null;\n\t  };\n\t};\n\t\n\tmodule.exports.UTF_16LE = function() {\n\t  this.name = function() {\n\t    return 'UTF-16LE';\n\t  };\n\t  this.match = function(det) {\n\t    var input = det.fRawInput;\n\t\n\t    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {\n\t       // An LE BOM is present.\n\t       if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00)\n\t         // It is probably UTF-32 LE, not UTF-16\n\t         return null;\n\t\n\t       return new Match(det, this, confidence = 100);\n\t    }\n\t\n\t    // TODO: Do some statistics to check for unsigned UTF-16LE\n\t    return null;\n\t  }\n\t};\n\t\n\tfunction UTF_32() {};\n\tUTF_32.prototype.match = function(det) {\n\t  var input      = det.fRawInput,\n\t    limit      = (det.fRawLength / 4) * 4,\n\t    numValid   = 0,\n\t    numInvalid = 0,\n\t    hasBOM     = false,\n\t    confidence = 0;\n\t\n\t  if (limit == 0)\n\t    return null;\n\t\n\t  if (this.getChar(input, 0) == 0x0000FEFF)\n\t    hasBOM = true;\n\t\n\t  for (var i = 0; i < limit; i += 4) {\n\t    var ch = this.getChar(input, i);\n\t\n\t    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF))\n\t      numInvalid += 1;\n\t    else\n\t      numValid += 1;\n\t  }\n\t\n\t  // Cook up some sort of confidence score, based on presence of a BOM\n\t  //    and the existence of valid and/or invalid multi-byte sequences.\n\t  if (hasBOM && numInvalid == 0) {\n\t    confidence = 100;\n\t  } else if (hasBOM && numValid > numInvalid * 10) {\n\t    confidence = 80;\n\t  } else if (numValid > 3 && numInvalid == 0) {\n\t    confidence = 100;\n\t  } else if (numValid > 0 && numInvalid == 0) {\n\t    confidence = 80;\n\t  } else if (numValid > numInvalid * 10) {\n\t    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n\t    confidence = 25;\n\t  }\n\t\n\t  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n\t  return confidence == 0 ? null : new Match(det, this, confidence);\n\t};\n\t\n\tmodule.exports.UTF_32BE = function() {\n\t  this.name = function() {\n\t    return 'UTF-32BE';\n\t  };\n\t  this.getChar = function(input, index) {\n\t    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |\n\t         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);\n\t  };\n\t};\n\tutil.inherits(module.exports.UTF_32BE, UTF_32);\n\t\n\tmodule.exports.UTF_32LE = function() {\n\t  this.name = function() {\n\t    return 'UTF-32LE';\n\t  };\n\t  this.getChar = function(input, index) {\n\t    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |\n\t         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);\n\t  };\n\t};\n\tutil.inherits(module.exports.UTF_32LE, UTF_32);\n\n\n/***/ },\n\n/***/ 206:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar Match = __webpack_require__ (56);\n\t\n\t/**\n\t * Charset recognizer for UTF-8\n\t */\n\tmodule.exports = function() {\n\t  this.name = function() {\n\t    return 'UTF-8';\n\t  };\n\t  this.match = function(det) {\n\t\n\t    var hasBOM = false,\n\t      numValid = 0,\n\t      numInvalid = 0,\n\t      input = det.fRawInput,\n\t      trailBytes = 0,\n\t      confidence;\n\t\n\t    if (det.fRawLength >= 3 &&\n\t      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n\t      hasBOM = true;\n\t    }\n\t\n\t    // Scan for multi-byte sequences\n\t    for (var i = 0; i < det.fRawLength; i++) {\n\t      var b = input[i];\n\t      if ((b & 0x80) == 0)\n\t        continue; // ASCII\n\t\n\t      // Hi bit on char found.  Figure out how long the sequence should be\n\t      if ((b & 0x0e0) == 0x0c0) {\n\t        trailBytes = 1;\n\t      } else if ((b & 0x0f0) == 0x0e0) {\n\t        trailBytes = 2;\n\t      } else if ((b & 0x0f8) == 0xf0) {\n\t        trailBytes = 3;\n\t      } else {\n\t        numInvalid++;\n\t        if (numInvalid > 5)\n\t          break;\n\t        trailBytes = 0;\n\t      }\n\t\n\t      // Verify that we've got the right number of trail bytes in the sequence\n\t      for (;;) {\n\t        i++;\n\t        if (i >= det.fRawLength)\n\t          break;\n\t\n\t        if ((input[i] & 0xc0) != 0x080) {\n\t          numInvalid++;\n\t          break;\n\t        }\n\t        if (--trailBytes == 0) {\n\t          numValid++;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    // Cook up some sort of confidence score, based on presense of a BOM\n\t    //    and the existence of valid and/or invalid multi-byte sequences.\n\t    confidence = 0;\n\t    if (hasBOM && numInvalid == 0)\n\t      confidence = 100;\n\t    else if (hasBOM && numValid > numInvalid * 10)\n\t      confidence = 80;\n\t    else if (numValid > 3 && numInvalid == 0)\n\t      confidence = 100;\n\t    else if (numValid > 0 && numInvalid == 0)\n\t      confidence = 80;\n\t    else if (numValid == 0 && numInvalid == 0)\n\t      // Plain ASCII.\n\t      confidence = 10;\n\t    else if (numValid > numInvalid * 10)\n\t      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n\t      confidence = 25;\n\t    else\n\t      return null\n\t\n\t    return new Match(det, this, confidence);\n\t  };\n\t};\n\n\n/***/ },\n\n/***/ 207:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n\t * @license\n\t * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern -d -o ./index.js`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t;(function() {\n\t\n\t  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n\t  var undefined;\n\t\n\t  /** Used as the semantic version number. */\n\t  var VERSION = '3.2.0';\n\t\n\t  /** Used to compose bitmasks for wrapper metadata. */\n\t  var BIND_FLAG = 1,\n\t      BIND_KEY_FLAG = 2,\n\t      CURRY_BOUND_FLAG = 4,\n\t      CURRY_FLAG = 8,\n\t      CURRY_RIGHT_FLAG = 16,\n\t      PARTIAL_FLAG = 32,\n\t      PARTIAL_RIGHT_FLAG = 64,\n\t      REARG_FLAG = 128,\n\t      ARY_FLAG = 256;\n\t\n\t  /** Used as default options for `_.trunc`. */\n\t  var DEFAULT_TRUNC_LENGTH = 30,\n\t      DEFAULT_TRUNC_OMISSION = '...';\n\t\n\t  /** Used to detect when a function becomes hot. */\n\t  var HOT_COUNT = 150,\n\t      HOT_SPAN = 16;\n\t\n\t  /** Used to indicate the type of lazy iteratees. */\n\t  var LAZY_FILTER_FLAG = 0,\n\t      LAZY_MAP_FLAG = 1,\n\t      LAZY_WHILE_FLAG = 2;\n\t\n\t  /** Used as the `TypeError` message for \"Functions\" methods. */\n\t  var FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t  /** Used as the internal argument placeholder. */\n\t  var PLACEHOLDER = '__lodash_placeholder__';\n\t\n\t  /** `Object#toString` result references. */\n\t  var argsTag = '[object Arguments]',\n\t      arrayTag = '[object Array]',\n\t      boolTag = '[object Boolean]',\n\t      dateTag = '[object Date]',\n\t      errorTag = '[object Error]',\n\t      funcTag = '[object Function]',\n\t      mapTag = '[object Map]',\n\t      numberTag = '[object Number]',\n\t      objectTag = '[object Object]',\n\t      regexpTag = '[object RegExp]',\n\t      setTag = '[object Set]',\n\t      stringTag = '[object String]',\n\t      weakMapTag = '[object WeakMap]';\n\t\n\t  var arrayBufferTag = '[object ArrayBuffer]',\n\t      float32Tag = '[object Float32Array]',\n\t      float64Tag = '[object Float64Array]',\n\t      int8Tag = '[object Int8Array]',\n\t      int16Tag = '[object Int16Array]',\n\t      int32Tag = '[object Int32Array]',\n\t      uint8Tag = '[object Uint8Array]',\n\t      uint8ClampedTag = '[object Uint8ClampedArray]',\n\t      uint16Tag = '[object Uint16Array]',\n\t      uint32Tag = '[object Uint32Array]';\n\t\n\t  /** Used to match empty string literals in compiled template source. */\n\t  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n\t      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n\t      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\t\n\t  /** Used to match HTML entities and HTML characters. */\n\t  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n\t      reUnescapedHtml = /[&<>\"'`]/g,\n\t      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n\t      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\t\n\t  /** Used to match template delimiters. */\n\t  var reEscape = /<%-([\\s\\S]+?)%>/g,\n\t      reEvaluate = /<%([\\s\\S]+?)%>/g,\n\t      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\t\n\t  /**\n\t   * Used to match ES template delimiters.\n\t   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)\n\t   * for more details.\n\t   */\n\t  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\t\n\t  /** Used to match `RegExp` flags from their coerced string values. */\n\t  var reFlags = /\\w*$/;\n\t\n\t  /** Used to detect named functions. */\n\t  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\t\n\t  /** Used to detect hexadecimal string values. */\n\t  var reHexPrefix = /^0[xX]/;\n\t\n\t  /** Used to detect host constructors (Safari > 5). */\n\t  var reHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n\t  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\t\n\t  /** Used to ensure capturing order of template delimiters. */\n\t  var reNoMatch = /($^)/;\n\t\n\t  /**\n\t   * Used to match `RegExp` special characters.\n\t   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n\t   * for more details.\n\t   */\n\t  var reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n\t      reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t  /** Used to detect functions containing a `this` reference. */\n\t  var reThis = /\\bthis\\b/;\n\t\n\t  /** Used to match unescaped characters in compiled string literals. */\n\t  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\t\n\t  /** Used to match words to create compound words. */\n\t  var reWords = (function() {\n\t    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n\t        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\t\n\t    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n\t  }());\n\t\n\t  /** Used to detect and test for whitespace. */\n\t  var whitespace = (\n\t    // Basic whitespace characters.\n\t    ' \\t\\x0b\\f\\xa0\\ufeff' +\n\t\n\t    // Line terminators.\n\t    '\\n\\r\\u2028\\u2029' +\n\t\n\t    // Unicode category \"Zs\" space separators.\n\t    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n\t  );\n\t\n\t  /** Used to assign default `context` object properties. */\n\t  var contextProps = [\n\t    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n\t    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n\t    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',\n\t    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n\t    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n\t    'window', 'WinRTError'\n\t  ];\n\t\n\t  /** Used to make template sourceURLs easier to identify. */\n\t  var templateCounter = -1;\n\t\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n\t  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n\t  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n\t  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n\t  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\t\n\t  /** Used to identify `toStringTag` values supported by `_.clone`. */\n\t  var cloneableTags = {};\n\t  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n\t  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n\t  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n\t  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n\t  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n\t  cloneableTags[numberTag] = cloneableTags[objectTag] =\n\t  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n\t  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\t  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\t  cloneableTags[errorTag] = cloneableTags[funcTag] =\n\t  cloneableTags[mapTag] = cloneableTags[setTag] =\n\t  cloneableTags[weakMapTag] = false;\n\t\n\t  /** Used as an internal `_.debounce` options object by `_.throttle`. */\n\t  var debounceOptions = {\n\t    'leading': false,\n\t    'maxWait': 0,\n\t    'trailing': false\n\t  };\n\t\n\t  /** Used to map latin-1 supplementary letters to basic latin letters. */\n\t  var deburredLetters = {\n\t    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n\t    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n\t    '\\xc7': 'C',  '\\xe7': 'c',\n\t    '\\xd0': 'D',  '\\xf0': 'd',\n\t    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n\t    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n\t    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n\t    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n\t    '\\xd1': 'N',  '\\xf1': 'n',\n\t    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n\t    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n\t    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n\t    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n\t    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n\t    '\\xc6': 'Ae', '\\xe6': 'ae',\n\t    '\\xde': 'Th', '\\xfe': 'th',\n\t    '\\xdf': 'ss'\n\t  };\n\t\n\t  /** Used to map characters to HTML entities. */\n\t  var htmlEscapes = {\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;',\n\t    '`': '&#96;'\n\t  };\n\t\n\t  /** Used to map HTML entities to characters. */\n\t  var htmlUnescapes = {\n\t    '&amp;': '&',\n\t    '&lt;': '<',\n\t    '&gt;': '>',\n\t    '&quot;': '\"',\n\t    '&#39;': \"'\",\n\t    '&#96;': '`'\n\t  };\n\t\n\t  /** Used to determine if values are of the language type `Object`. */\n\t  var objectTypes = {\n\t    'function': true,\n\t    'object': true\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled string literals. */\n\t  var stringEscapes = {\n\t    '\\\\': '\\\\',\n\t    \"'\": \"'\",\n\t    '\\n': 'n',\n\t    '\\r': 'r',\n\t    '\\u2028': 'u2028',\n\t    '\\u2029': 'u2029'\n\t  };\n\t\n\t  /**\n\t   * Used as a reference to the global object.\n\t   *\n\t   * The `this` value is used if it is the global object to avoid Greasemonkey's\n\t   * restricted `window` object, otherwise the `window` object is used.\n\t   */\n\t  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;\n\t\n\t  /** Detect free variable `exports`. */\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  /** Detect free variable `module`. */\n\t  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\t\n\t  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */\n\t  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n\t  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n\t    root = freeGlobal;\n\t  }\n\t\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * The base implementation of `compareAscending` which compares values and\n\t   * sorts them in ascending order without guaranteeing a stable sort.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to compare to `other`.\n\t   * @param {*} other The value to compare to `value`.\n\t   * @returns {number} Returns the sort order indicator for `value`.\n\t   */\n\t  function baseCompareAscending(value, other) {\n\t    if (value !== other) {\n\t      var valIsReflexive = value === value,\n\t          othIsReflexive = other === other;\n\t\n\t      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {\n\t        return 1;\n\t      }\n\t      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {\n\t        return -1;\n\t      }\n\t    }\n\t    return 0;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.indexOf` without support for binary searches.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} [fromIndex=0] The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOf(array, value, fromIndex) {\n\t    if (value !== value) {\n\t      return indexOfNaN(array, fromIndex);\n\t    }\n\t    var index = (fromIndex || 0) - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`\n\t   * to define the sort order of `array` and replaces criteria objects with their\n\t   * corresponding values.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to sort.\n\t   * @param {Function} comparer The function to define sort order.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function baseSortBy(array, comparer) {\n\t    var length = array.length;\n\t\n\t    array.sort(comparer);\n\t    while (length--) {\n\t      array[length] = array[length].value;\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to a string if it is not one. An empty string is returned\n\t   * for `null` or `undefined` values.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {string} Returns the string.\n\t   */\n\t  function baseToString(value) {\n\t    if (typeof value == 'string') {\n\t      return value;\n\t    }\n\t    return value == null ? '' : (value + '');\n\t  }\n\t\n\t  /**\n\t   * Used by `_.max` and `_.min` as the default callback for string values.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the code unit of the first character of the string.\n\t   */\n\t  function charAtCallback(string) {\n\t    return string.charCodeAt(0);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n\t   * of `string` that is not found in `chars`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @param {string} chars The characters to find.\n\t   * @returns {number} Returns the index of the first character not found in `chars`.\n\t   */\n\t  function charsLeftIndex(string, chars) {\n\t    var index = -1,\n\t        length = string.length;\n\t\n\t    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n\t   * of `string` that is not found in `chars`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @param {string} chars The characters to find.\n\t   * @returns {number} Returns the index of the last character not found in `chars`.\n\t   */\n\t  function charsRightIndex(string, chars) {\n\t    var index = string.length;\n\t\n\t    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n\t   * sort them in ascending order.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare to `other`.\n\t   * @param {Object} other The object to compare to `object`.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareAscending(object, other) {\n\t    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.sortByAll` to compare multiple properties of each element\n\t   * in a collection and stable sort them in ascending order.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare to `other`.\n\t   * @param {Object} other The object to compare to `object`.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareMultipleAscending(object, other) {\n\t    var index = -1,\n\t        objCriteria = object.criteria,\n\t        othCriteria = other.criteria,\n\t        length = objCriteria.length;\n\t\n\t    while (++index < length) {\n\t      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n\t      if (result) {\n\t        return result;\n\t      }\n\t    }\n\t    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n\t    // that causes it, under certain circumstances, to provide the same value for\n\t    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n\t    // for more details.\n\t    //\n\t    // This also ensures a stable sort in V8 and other engines.\n\t    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n\t    return object.index - other.index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n\t   *\n\t   * @private\n\t   * @param {string} letter The matched letter to deburr.\n\t   * @returns {string} Returns the deburred letter.\n\t   */\n\t  function deburrLetter(letter) {\n\t    return deburredLetters[letter];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.escape` to convert characters to HTML entities.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeHtmlChar(chr) {\n\t    return htmlEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.template` to escape characters for inclusion in compiled\n\t   * string literals.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeStringChar(chr) {\n\t    return '\\\\' + stringEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n\t   * If `fromRight` is provided elements of `array` are iterated from right to left.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {number} [fromIndex] The index to search from.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n\t   */\n\t  function indexOfNaN(array, fromIndex, fromRight) {\n\t    var length = array.length,\n\t        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      var other = array[index];\n\t      if (other !== other) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is object-like.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t   */\n\t  function isObjectLike(value) {\n\t    return (value && typeof value == 'object') || false;\n\t  }\n\t\n\t  /**\n\t   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n\t   * character code is whitespace.\n\t   *\n\t   * @private\n\t   * @param {number} charCode The character code to inspect.\n\t   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n\t   */\n\t  function isSpace(charCode) {\n\t    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n\t      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n\t  }\n\t\n\t  /**\n\t   * Replaces all `placeholder` elements in `array` with an internal placeholder\n\t   * and returns an array of their indexes.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {*} placeholder The placeholder to replace.\n\t   * @returns {Array} Returns the new array of placeholder indexes.\n\t   */\n\t  function replaceHolders(array, placeholder) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      if (array[index] === placeholder) {\n\t        array[index] = PLACEHOLDER;\n\t        result[++resIndex] = index;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * An implementation of `_.uniq` optimized for sorted arrays without support\n\t   * for callback shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Function} [iteratee] The function invoked per iteration.\n\t   * @returns {Array} Returns the new duplicate-value-free array.\n\t   */\n\t  function sortedUniq(array, iteratee) {\n\t    var seen,\n\t        index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t      if (!index || seen !== computed) {\n\t        seen = computed;\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n\t   * character of `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the index of the first non-whitespace character.\n\t   */\n\t  function trimmedLeftIndex(string) {\n\t    var index = -1,\n\t        length = string.length;\n\t\n\t    while (++index < length && isSpace(string.charCodeAt(index))) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n\t   * character of `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the index of the last non-whitespace character.\n\t   */\n\t  function trimmedRightIndex(string) {\n\t    var index = string.length;\n\t\n\t    while (index-- && isSpace(string.charCodeAt(index))) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.unescape` to convert HTML entities to characters.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to unescape.\n\t   * @returns {string} Returns the unescaped character.\n\t   */\n\t  function unescapeHtmlChar(chr) {\n\t    return htmlUnescapes[chr];\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Create a new pristine `lodash` function using the given `context` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {Object} [context=root] The context object.\n\t   * @returns {Function} Returns a new `lodash` function.\n\t   * @example\n\t   *\n\t   * _.mixin({ 'add': function(a, b) { return a + b; } });\n\t   *\n\t   * var lodash = _.runInContext();\n\t   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });\n\t   *\n\t   * _.isFunction(_.add);\n\t   * // => true\n\t   * _.isFunction(_.sub);\n\t   * // => false\n\t   *\n\t   * lodash.isFunction(lodash.add);\n\t   * // => false\n\t   * lodash.isFunction(lodash.sub);\n\t   * // => true\n\t   *\n\t   * // using `context` to mock `Date#getTime` use in `_.now`\n\t   * var mock = _.runInContext({\n\t   *   'Date': function() {\n\t   *     return { 'getTime': getTimeMock };\n\t   *   }\n\t   * });\n\t   *\n\t   * // or creating a suped-up `defer` in Node.js\n\t   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\t   */\n\t  function runInContext(context) {\n\t    // Avoid issues with some ES3 environments that attempt to use values, named\n\t    // after built-in constructors like `Object`, for the creation of literals.\n\t    // ES5 clears this up by stating that literals must use built-in constructors.\n\t    // See https://es5.github.io/#x11.1.5 for more details.\n\t    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\t\n\t    /** Native constructor references. */\n\t    var Array = context.Array,\n\t        Date = context.Date,\n\t        Error = context.Error,\n\t        Function = context.Function,\n\t        Math = context.Math,\n\t        Number = context.Number,\n\t        Object = context.Object,\n\t        RegExp = context.RegExp,\n\t        String = context.String,\n\t        TypeError = context.TypeError;\n\t\n\t    /** Used for native method references. */\n\t    var arrayProto = Array.prototype,\n\t        objectProto = Object.prototype;\n\t\n\t    /** Used to detect DOM support. */\n\t    var document = (document = context.window) && document.document;\n\t\n\t    /** Used to resolve the decompiled source of functions. */\n\t    var fnToString = Function.prototype.toString;\n\t\n\t    /** Used to the length of n-tuples for `_.unzip`. */\n\t    var getLength = baseProperty('length');\n\t\n\t    /** Used to check objects for own properties. */\n\t    var hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t    /** Used to generate unique IDs. */\n\t    var idCounter = 0;\n\t\n\t    /**\n\t     * Used to resolve the `toStringTag` of values.\n\t     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t     * for more details.\n\t     */\n\t    var objToString = objectProto.toString;\n\t\n\t    /** Used to restore the original `_` reference in `_.noConflict`. */\n\t    var oldDash = context._;\n\t\n\t    /** Used to detect if a method is native. */\n\t    var reNative = RegExp('^' +\n\t      escapeRegExp(objToString)\n\t      .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t    );\n\t\n\t    /** Native method references. */\n\t    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,\n\t        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,\n\t        ceil = Math.ceil,\n\t        clearTimeout = context.clearTimeout,\n\t        floor = Math.floor,\n\t        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n\t        push = arrayProto.push,\n\t        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n\t        Set = isNative(Set = context.Set) && Set,\n\t        setTimeout = context.setTimeout,\n\t        splice = arrayProto.splice,\n\t        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,\n\t        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;\n\t\n\t    /** Used to clone array buffers. */\n\t    var Float64Array = (function() {\n\t      // Safari 5 errors when using an array buffer to initialize a typed array\n\t      // where the array buffer's `byteLength` is not a multiple of the typed\n\t      // array's `BYTES_PER_ELEMENT`.\n\t      try {\n\t        var func = isNative(func = context.Float64Array) && func,\n\t            result = new func(new ArrayBuffer(10), 0, 1) && func;\n\t      } catch(e) {}\n\t      return result;\n\t    }());\n\t\n\t    /* Native method references for those with the same name as other `lodash` methods. */\n\t    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n\t        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n\t        nativeIsFinite = context.isFinite,\n\t        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n\t        nativeMax = Math.max,\n\t        nativeMin = Math.min,\n\t        nativeNow = isNative(nativeNow = Date.now) && nativeNow,\n\t        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,\n\t        nativeParseInt = context.parseInt,\n\t        nativeRandom = Math.random;\n\t\n\t    /** Used as references for `-Infinity` and `Infinity`. */\n\t    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n\t        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\t\n\t    /** Used as references for the maximum length and index of an array. */\n\t    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,\n\t        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,\n\t        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\t\n\t    /** Used as the size, in bytes, of each `Float64Array` element. */\n\t    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;\n\t\n\t    /**\n\t     * Used as the maximum length of an array-like value.\n\t     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t     * for more details.\n\t     */\n\t    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t    /** Used to store function metadata. */\n\t    var metaMap = WeakMap && new WeakMap;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n\t     * Methods that operate on and return arrays, collections, and functions can\n\t     * be chained together. Methods that return a boolean or single value will\n\t     * automatically end the chain returning the unwrapped value. Explicit chaining\n\t     * may be enabled using `_.chain`. The execution of chained methods is lazy,\n\t     * that is, execution is deferred until `_#value` is implicitly or explicitly\n\t     * called.\n\t     *\n\t     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n\t     * fusion is an optimization that merges iteratees to avoid creating intermediate\n\t     * arrays and reduce the number of iteratee executions.\n\t     *\n\t     * Chaining is supported in custom builds as long as the `_#value` method is\n\t     * directly or indirectly included in the build.\n\t     *\n\t     * In addition to lodash methods, wrappers also have the following `Array` methods:\n\t     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n\t     * and `unshift`\n\t     *\n\t     * The wrapper methods that support shortcut fusion are:\n\t     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n\t     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n\t     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n\t     * and `where`\n\t     *\n\t     * The chainable wrapper methods are:\n\t     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n\t     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n\t     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,\n\t     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,\n\t     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,\n\t     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,\n\t     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,\n\t     * `keysIn`, `map`, `mapValues`, `matches`, `memoize`, `merge`, `mixin`,\n\t     * `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n\t     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n\t     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,\n\t     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,\n\t     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,\n\t     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,\n\t     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,\n\t     * `zip`, and `zipObject`\n\t     *\n\t     * The wrapper methods that are **not** chainable by default are:\n\t     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,\n\t     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,\n\t     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,\n\t     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,\n\t     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,\n\t     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,\n\t     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,\n\t     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,\n\t     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,\n\t     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,\n\t     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,\n\t     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,\n\t     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`\n\t     *\n\t     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n\t     * otherwise an unwrapped value is returned.\n\t     *\n\t     * @name _\n\t     * @constructor\n\t     * @category Chain\n\t     * @param {*} value The value to wrap in a `lodash` instance.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2, 3]);\n\t     *\n\t     * // returns an unwrapped value\n\t     * wrapped.reduce(function(sum, n) { return sum + n; });\n\t     * // => 6\n\t     *\n\t     * // returns a wrapped value\n\t     * var squares = wrapped.map(function(n) { return n * n; });\n\t     *\n\t     * _.isArray(squares);\n\t     * // => false\n\t     *\n\t     * _.isArray(squares.value());\n\t     * // => true\n\t     */\n\t    function lodash(value) {\n\t      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n\t        if (value instanceof LodashWrapper) {\n\t          return value;\n\t        }\n\t        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n\t          return wrapperClone(value);\n\t        }\n\t      }\n\t      return new LodashWrapper(value);\n\t    }\n\t\n\t    /**\n\t     * The base constructor for creating `lodash` wrapper objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n\t     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n\t     */\n\t    function LodashWrapper(value, chainAll, actions) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = actions || [];\n\t      this.__chain__ = !!chainAll;\n\t    }\n\t\n\t    /**\n\t     * An object environment feature flags.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Object\n\t     */\n\t    var support = lodash.support = {};\n\t\n\t    (function(x) {\n\t\n\t      /**\n\t       * Detect if functions can be decompiled by `Function#toString`\n\t       * (all but Firefox OS certified apps, older Opera mobile browsers, and\n\t       * the PlayStation 3; forced `false` for Windows 8 apps).\n\t       *\n\t       * @memberOf _.support\n\t       * @type boolean\n\t       */\n\t      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\t\n\t      /**\n\t       * Detect if `Function#name` is supported (all but IE).\n\t       *\n\t       * @memberOf _.support\n\t       * @type boolean\n\t       */\n\t      support.funcNames = typeof Function.name == 'string';\n\t\n\t      /**\n\t       * Detect if the DOM is supported.\n\t       *\n\t       * @memberOf _.support\n\t       * @type boolean\n\t       */\n\t      try {\n\t        support.dom = document.createDocumentFragment().nodeType === 11;\n\t      } catch(e) {\n\t        support.dom = false;\n\t      }\n\t\n\t      /**\n\t       * Detect if `arguments` object indexes are non-enumerable.\n\t       *\n\t       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n\t       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n\t       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n\t       * checks for indexes that exceed their function's formal parameters with\n\t       * associated values of `0`.\n\t       *\n\t       * @memberOf _.support\n\t       * @type boolean\n\t       */\n\t      try {\n\t        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n\t      } catch(e) {\n\t        support.nonEnumArgs = true;\n\t      }\n\t    }(0, 0));\n\t\n\t    /**\n\t     * By default, the template delimiters used by lodash are like those in\n\t     * embedded Ruby (ERB). Change the following template settings to use\n\t     * alternative delimiters.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Object\n\t     */\n\t    lodash.templateSettings = {\n\t\n\t      /**\n\t       * Used to detect `data` property values to be HTML-escaped.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'escape': reEscape,\n\t\n\t      /**\n\t       * Used to detect code to be evaluated.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'evaluate': reEvaluate,\n\t\n\t      /**\n\t       * Used to detect `data` property values to inject.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'interpolate': reInterpolate,\n\t\n\t      /**\n\t       * Used to reference the data object in the template text.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type string\n\t       */\n\t      'variable': '',\n\t\n\t      /**\n\t       * Used to import variables into the compiled template.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type Object\n\t       */\n\t      'imports': {\n\t\n\t        /**\n\t         * A reference to the `lodash` function.\n\t         *\n\t         * @memberOf _.templateSettings.imports\n\t         * @type Function\n\t         */\n\t        '_': lodash\n\t      }\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     */\n\t    function LazyWrapper(value) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = null;\n\t      this.__dir__ = 1;\n\t      this.__dropCount__ = 0;\n\t      this.__filtered__ = false;\n\t      this.__iteratees__ = null;\n\t      this.__takeCount__ = POSITIVE_INFINITY;\n\t      this.__views__ = null;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the lazy wrapper object.\n\t     *\n\t     * @private\n\t     * @name clone\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the cloned `LazyWrapper` object.\n\t     */\n\t    function lazyClone() {\n\t      var actions = this.__actions__,\n\t          iteratees = this.__iteratees__,\n\t          views = this.__views__,\n\t          result = new LazyWrapper(this.__wrapped__);\n\t\n\t      result.__actions__ = actions ? arrayCopy(actions) : null;\n\t      result.__dir__ = this.__dir__;\n\t      result.__dropCount__ = this.__dropCount__;\n\t      result.__filtered__ = this.__filtered__;\n\t      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;\n\t      result.__takeCount__ = this.__takeCount__;\n\t      result.__views__ = views ? arrayCopy(views) : null;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the direction of lazy iteration.\n\t     *\n\t     * @private\n\t     * @name reverse\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n\t     */\n\t    function lazyReverse() {\n\t      if (this.__filtered__) {\n\t        var result = new LazyWrapper(this);\n\t        result.__dir__ = -1;\n\t        result.__filtered__ = true;\n\t      } else {\n\t        result = this.clone();\n\t        result.__dir__ *= -1;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Extracts the unwrapped value from its lazy wrapper.\n\t     *\n\t     * @private\n\t     * @name value\n\t     * @memberOf LazyWrapper\n\t     * @returns {*} Returns the unwrapped value.\n\t     */\n\t    function lazyValue() {\n\t      var array = this.__wrapped__.value();\n\t      if (!isArray(array)) {\n\t        return baseWrapperValue(array, this.__actions__);\n\t      }\n\t      var dir = this.__dir__,\n\t          isRight = dir < 0,\n\t          view = getView(0, array.length, this.__views__),\n\t          start = view.start,\n\t          end = view.end,\n\t          length = end - start,\n\t          dropCount = this.__dropCount__,\n\t          takeCount = nativeMin(length, this.__takeCount__),\n\t          index = isRight ? end : start - 1,\n\t          iteratees = this.__iteratees__,\n\t          iterLength = iteratees ? iteratees.length : 0,\n\t          resIndex = 0,\n\t          result = [];\n\t\n\t      outer:\n\t      while (length-- && resIndex < takeCount) {\n\t        index += dir;\n\t\n\t        var iterIndex = -1,\n\t            value = array[index];\n\t\n\t        while (++iterIndex < iterLength) {\n\t          var data = iteratees[iterIndex],\n\t              iteratee = data.iteratee,\n\t              computed = iteratee(value, index, array),\n\t              type = data.type;\n\t\n\t          if (type == LAZY_MAP_FLAG) {\n\t            value = computed;\n\t          } else if (!computed) {\n\t            if (type == LAZY_FILTER_FLAG) {\n\t              continue outer;\n\t            } else {\n\t              break outer;\n\t            }\n\t          }\n\t        }\n\t        if (dropCount) {\n\t          dropCount--;\n\t        } else {\n\t          result[resIndex++] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a cache object to store key/value pairs.\n\t     *\n\t     * @private\n\t     * @static\n\t     * @name Cache\n\t     * @memberOf _.memoize\n\t     */\n\t    function MapCache() {\n\t      this.__data__ = {};\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the cache.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n\t     */\n\t    function mapDelete(key) {\n\t      return this.has(key) && delete this.__data__[key];\n\t    }\n\t\n\t    /**\n\t     * Gets the cached value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the cached value.\n\t     */\n\t    function mapGet(key) {\n\t      return key == '__proto__' ? undefined : this.__data__[key];\n\t    }\n\t\n\t    /**\n\t     * Checks if a cached value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function mapHas(key) {\n\t      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n\t    }\n\t\n\t    /**\n\t     * Adds `value` to `key` of the cache.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to cache.\n\t     * @param {*} value The value to cache.\n\t     * @returns {Object} Returns the cache object.\n\t     */\n\t    function mapSet(key, value) {\n\t      if (key != '__proto__') {\n\t        this.__data__[key] = value;\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     *\n\t     * Creates a cache object to store unique values.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function SetCache(values) {\n\t      var length = values ? values.length : 0;\n\t\n\t      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n\t      while (length--) {\n\t        this.push(values[length]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is in `cache` mimicking the return signature of\n\t     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n\t     *\n\t     * @private\n\t     * @param {Object} cache The cache to search.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns `0` if `value` is found, else `-1`.\n\t     */\n\t    function cacheIndexOf(cache, value) {\n\t      var data = cache.data,\n\t          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\t\n\t      return result ? 0 : -1;\n\t    }\n\t\n\t    /**\n\t     * Adds `value` to the cache.\n\t     *\n\t     * @private\n\t     * @name push\n\t     * @memberOf SetCache\n\t     * @param {*} value The value to cache.\n\t     */\n\t    function cachePush(value) {\n\t      var data = this.data;\n\t      if (typeof value == 'string' || isObject(value)) {\n\t        data.set.add(value);\n\t      } else {\n\t        data.hash[value] = true;\n\t      }\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Copies the values of `source` to `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} source The array to copy values from.\n\t     * @param {Array} [array=[]] The array to copy values to.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayCopy(source, array) {\n\t      var index = -1,\n\t          length = source.length;\n\t\n\t      array || (array = Array(length));\n\t      while (++index < length) {\n\t        array[index] = source[index];\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.forEach` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayEach(array, iteratee) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (iteratee(array[index], index, array) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.forEachRight` for arrays without support for\n\t     * callback shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayEachRight(array, iteratee) {\n\t      var length = array.length;\n\t\n\t      while (length--) {\n\t        if (iteratee(array[length], length, array) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.every` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function arrayEvery(array, predicate) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (!predicate(array[index], index, array)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.filter` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function arrayFilter(array, predicate) {\n\t      var index = -1,\n\t          length = array.length,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.map` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function arrayMap(array, iteratee) {\n\t      var index = -1,\n\t          length = array.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = iteratee(array[index], index, array);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.max` for arrays without support for iteratees.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the maximum value.\n\t     */\n\t    function arrayMax(array) {\n\t      var index = -1,\n\t          length = array.length,\n\t          result = NEGATIVE_INFINITY;\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value > result) {\n\t          result = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.min` for arrays without support for iteratees.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the minimum value.\n\t     */\n\t    function arrayMin(array) {\n\t      var index = -1,\n\t          length = array.length,\n\t          result = POSITIVE_INFINITY;\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value < result) {\n\t          result = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.reduce` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {boolean} [initFromArray] Specify using the first element of `array`\n\t     *  as the initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      if (initFromArray && length) {\n\t        accumulator = array[++index];\n\t      }\n\t      while (++index < length) {\n\t        accumulator = iteratee(accumulator, array[index], index, array);\n\t      }\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.reduceRight` for arrays without support for\n\t     * callback shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {boolean} [initFromArray] Specify using the last element of `array`\n\t     *  as the initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n\t      var length = array.length;\n\t      if (initFromArray && length) {\n\t        accumulator = array[--length];\n\t      }\n\t      while (length--) {\n\t        accumulator = iteratee(accumulator, array[length], length, array);\n\t      }\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.some` for arrays without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function arraySome(array, predicate) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (predicate(array[index], index, array)) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaults` to customize its `_.assign` use.\n\t     *\n\t     * @private\n\t     * @param {*} objectValue The destination object property value.\n\t     * @param {*} sourceValue The source object property value.\n\t     * @returns {*} Returns the value to assign to the destination object.\n\t     */\n\t    function assignDefaults(objectValue, sourceValue) {\n\t      return typeof objectValue == 'undefined' ? sourceValue : objectValue;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.template` to customize its `_.assign` use.\n\t     *\n\t     * **Note:** This method is like `assignDefaults` except that it ignores\n\t     * inherited property values when checking if a property is `undefined`.\n\t     *\n\t     * @private\n\t     * @param {*} objectValue The destination object property value.\n\t     * @param {*} sourceValue The source object property value.\n\t     * @param {string} key The key associated with the object and source values.\n\t     * @param {Object} object The destination object.\n\t     * @returns {*} Returns the value to assign to the destination object.\n\t     */\n\t    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n\t      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))\n\t        ? sourceValue\n\t        : objectValue;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.assign` without support for argument juggling,\n\t     * multiple sources, and `this` binding `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {Function} [customizer] The function to customize assigning values.\n\t     * @returns {Object} Returns the destination object.\n\t     */\n\t    function baseAssign(object, source, customizer) {\n\t      var props = keys(source);\n\t      if (!customizer) {\n\t        return baseCopy(source, object, props);\n\t      }\n\t      var index = -1,\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index],\n\t            value = object[key],\n\t            result = customizer(value, source[key], key, object, source);\n\t\n\t        if ((result === result ? result !== value : value === value) ||\n\t            (typeof value == 'undefined' && !(key in object))) {\n\t          object[key] = result;\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.at` without support for strings and individual\n\t     * key arguments.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     */\n\t    function baseAt(collection, props) {\n\t      var index = -1,\n\t          length = collection.length,\n\t          isArr = isLength(length),\n\t          propsLength = props.length,\n\t          result = Array(propsLength);\n\t\n\t      while(++index < propsLength) {\n\t        var key = props[index];\n\t        if (isArr) {\n\t          key = parseFloat(key);\n\t          result[index] = isIndex(key, length) ? collection[key] : undefined;\n\t        } else {\n\t          result[index] = collection[key];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Copies the properties of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy properties from.\n\t     * @param {Object} [object={}] The object to copy properties to.\n\t     * @param {Array} props The property names to copy.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseCopy(source, object, props) {\n\t      if (!props) {\n\t        props = object;\n\t        object = {};\n\t      }\n\t      var index = -1,\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        object[key] = source[key];\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.bindAll` without support for individual\n\t     * method name arguments.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to bind and assign the bound methods to.\n\t     * @param {string[]} methodNames The object method names to bind.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseBindAll(object, methodNames) {\n\t      var index = -1,\n\t          length = methodNames.length;\n\t\n\t      while (++index < length) {\n\t        var key = methodNames[index];\n\t        object[key] = createWrapper(object[key], BIND_FLAG, object);\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.callback` which supports specifying the\n\t     * number of arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {number} [argCount] The number of arguments to provide to `func`.\n\t     * @returns {Function} Returns the callback.\n\t     */\n\t    function baseCallback(func, thisArg, argCount) {\n\t      var type = typeof func;\n\t      if (type == 'function') {\n\t        return (typeof thisArg != 'undefined' && isBindable(func))\n\t          ? bindCallback(func, thisArg, argCount)\n\t          : func;\n\t      }\n\t      if (func == null) {\n\t        return identity;\n\t      }\n\t      if (type == 'object') {\n\t        return baseMatches(func);\n\t      }\n\t      return typeof thisArg == 'undefined'\n\t        ? baseProperty(func + '')\n\t        : baseMatchesProperty(func + '', thisArg);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clone` without support for argument juggling\n\t     * and `this` binding `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {string} [key] The key of `value`.\n\t     * @param {Object} [object] The object `value` belongs to.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n\t     * @returns {*} Returns the cloned value.\n\t     */\n\t    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n\t      var result;\n\t      if (customizer) {\n\t        result = object ? customizer(value, key, object) : customizer(value);\n\t      }\n\t      if (typeof result != 'undefined') {\n\t        return result;\n\t      }\n\t      if (!isObject(value)) {\n\t        return value;\n\t      }\n\t      var isArr = isArray(value);\n\t      if (isArr) {\n\t        result = initCloneArray(value);\n\t        if (!isDeep) {\n\t          return arrayCopy(value, result);\n\t        }\n\t      } else {\n\t        var tag = objToString.call(value),\n\t            isFunc = tag == funcTag;\n\t\n\t        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t          result = initCloneObject(isFunc ? {} : value);\n\t          if (!isDeep) {\n\t            return baseCopy(value, result, keys(value));\n\t          }\n\t        } else {\n\t          return cloneableTags[tag]\n\t            ? initCloneByTag(value, tag, isDeep)\n\t            : (object ? value : {});\n\t        }\n\t      }\n\t      // Check for circular references and return corresponding clone.\n\t      stackA || (stackA = []);\n\t      stackB || (stackB = []);\n\t\n\t      var length = stackA.length;\n\t      while (length--) {\n\t        if (stackA[length] == value) {\n\t          return stackB[length];\n\t        }\n\t      }\n\t      // Add the source value to the stack of traversed objects and associate it with its clone.\n\t      stackA.push(value);\n\t      stackB.push(result);\n\t\n\t      // Recursively populate clone (susceptible to call stack limits).\n\t      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n\t        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.create` without support for assigning\n\t     * properties to the created object.\n\t     *\n\t     * @private\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    var baseCreate = (function() {\n\t      function Object() {}\n\t      return function(prototype) {\n\t        if (isObject(prototype)) {\n\t          Object.prototype = prototype;\n\t          var result = new Object;\n\t          Object.prototype = null;\n\t        }\n\t        return result || context.Object();\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * The base implementation of `_.delay` and `_.defer` which accepts an index\n\t     * of where to slice the arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {Object} args The `arguments` object to slice and provide to `func`.\n\t     * @returns {number} Returns the timer id.\n\t     */\n\t    function baseDelay(func, wait, args, fromIndex) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.difference` which accepts a single array\n\t     * of values to exclude.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Array} values The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     */\n\t    function baseDifference(array, values) {\n\t      var length = array ? array.length : 0,\n\t          result = [];\n\t\n\t      if (!length) {\n\t        return result;\n\t      }\n\t      var index = -1,\n\t          indexOf = getIndexOf(),\n\t          isCommon = indexOf == baseIndexOf,\n\t          cache = isCommon && values.length >= 200 && createCache(values),\n\t          valuesLength = values.length;\n\t\n\t      if (cache) {\n\t        indexOf = cacheIndexOf;\n\t        isCommon = false;\n\t        values = cache;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index];\n\t\n\t        if (isCommon && value === value) {\n\t          var valuesIndex = valuesLength;\n\t          while (valuesIndex--) {\n\t            if (values[valuesIndex] === value) {\n\t              continue outer;\n\t            }\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (indexOf(values, value) < 0) {\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forEach` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     */\n\t    function baseEach(collection, iteratee) {\n\t      var length = collection ? collection.length : 0;\n\t      if (!isLength(length)) {\n\t        return baseForOwn(collection, iteratee);\n\t      }\n\t      var index = -1,\n\t          iterable = toObject(collection);\n\t\n\t      while (++index < length) {\n\t        if (iteratee(iterable[index], index, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return collection;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forEachRight` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     */\n\t    function baseEachRight(collection, iteratee) {\n\t      var length = collection ? collection.length : 0;\n\t      if (!isLength(length)) {\n\t        return baseForOwnRight(collection, iteratee);\n\t      }\n\t      var iterable = toObject(collection);\n\t      while (length--) {\n\t        if (iteratee(iterable[length], length, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return collection;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.every` without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`\n\t     */\n\t    function baseEvery(collection, predicate) {\n\t      var result = true;\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = !!predicate(value, index, collection);\n\t        return result;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.fill` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function baseFill(array, value, start, end) {\n\t      var length = array.length;\n\t\n\t      start = start == null ? 0 : (+start || 0);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : end >>> 0;\n\t      start >>>= 0;\n\t\n\t      while (start < length) {\n\t        array[start++] = value;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.filter` without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function baseFilter(collection, predicate) {\n\t      var result = [];\n\t      baseEach(collection, function(value, index, collection) {\n\t        if (predicate(value, index, collection)) {\n\t          result.push(value);\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n\t     * without support for callback shorthands and `this` binding, which iterates\n\t     * over `collection` using the provided `eachFunc`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @param {Function} eachFunc The function to iterate over `collection`.\n\t     * @param {boolean} [retKey] Specify returning the key of the found element\n\t     *  instead of the element itself.\n\t     * @returns {*} Returns the found element or its key, else `undefined`.\n\t     */\n\t    function baseFind(collection, predicate, eachFunc, retKey) {\n\t      var result;\n\t      eachFunc(collection, function(value, key, collection) {\n\t        if (predicate(value, key, collection)) {\n\t          result = retKey ? key : value;\n\t          return false;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.flatten` with added support for restricting\n\t     * flattening and specifying the start index.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to flatten.\n\t     * @param {boolean} [isDeep] Specify a deep flatten.\n\t     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.\n\t     * @param {number} [fromIndex=0] The index to start from.\n\t     * @returns {Array} Returns the new flattened array.\n\t     */\n\t    function baseFlatten(array, isDeep, isStrict, fromIndex) {\n\t      var index = (fromIndex || 0) - 1,\n\t          length = array.length,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t\n\t        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {\n\t          if (isDeep) {\n\t            // Recursively flatten arrays (susceptible to call stack limits).\n\t            value = baseFlatten(value, isDeep, isStrict);\n\t          }\n\t          var valIndex = -1,\n\t              valLength = value.length;\n\t\n\t          result.length += valLength;\n\t          while (++valIndex < valLength) {\n\t            result[++resIndex] = value[valIndex];\n\t          }\n\t        } else if (!isStrict) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n\t     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n\t     * each property. Iterator functions may exit iteration early by explicitly\n\t     * returning `false`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseFor(object, iteratee, keysFunc) {\n\t      var index = -1,\n\t          iterable = toObject(object),\n\t          props = keysFunc(object),\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * This function is like `baseFor` except that it iterates over properties\n\t     * in the opposite order.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForRight(object, iteratee, keysFunc) {\n\t      var iterable = toObject(object),\n\t          props = keysFunc(object),\n\t          length = props.length;\n\t\n\t      while (length--) {\n\t        var key = props[length];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forIn` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForIn(object, iteratee) {\n\t      return baseFor(object, iteratee, keysIn);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwn` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwn(object, iteratee) {\n\t      return baseFor(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwnRight` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwnRight(object, iteratee) {\n\t      return baseForRight(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.functions` which creates an array of\n\t     * `object` function property names filtered from those provided.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} props The property names to filter.\n\t     * @returns {Array} Returns the new array of filtered property names.\n\t     */\n\t    function baseFunctions(object, props) {\n\t      var index = -1,\n\t          length = props.length,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (isFunction(object[key])) {\n\t          result[++resIndex] = key;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.invoke` which requires additional arguments\n\t     * to be provided as an array of arguments rather than individually.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|string} methodName The name of the method to invoke or\n\t     *  the function invoked per iteration.\n\t     * @param {Array} [args] The arguments to invoke the method with.\n\t     * @returns {Array} Returns the array of results.\n\t     */\n\t    function baseInvoke(collection, methodName, args) {\n\t      var index = -1,\n\t          isFunc = typeof methodName == 'function',\n\t          length = collection ? collection.length : 0,\n\t          result = isLength(length) ? Array(length) : [];\n\t\n\t      baseEach(collection, function(value) {\n\t        var func = isFunc ? methodName : (value != null && value[methodName]);\n\t        result[++index] = func ? func.apply(value, args) : undefined;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isEqual` without support for `this` binding\n\t     * `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {boolean} [isWhere] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     */\n\t    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {\n\t      // Exit early for identical values.\n\t      if (value === other) {\n\t        // Treat `+0` vs. `-0` as not equal.\n\t        return value !== 0 || (1 / value == 1 / other);\n\t      }\n\t      var valType = typeof value,\n\t          othType = typeof other;\n\t\n\t      // Exit early for unlike primitive values.\n\t      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||\n\t          value == null || other == null) {\n\t        // Return `false` unless both values are `NaN`.\n\t        return value !== value && other !== other;\n\t      }\n\t      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t     * deep comparisons and tracks traversed objects enabling objects with circular\n\t     * references to be compared.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing objects.\n\t     * @param {boolean} [isWhere] Specify performing partial comparisons.\n\t     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n\t      var objIsArr = isArray(object),\n\t          othIsArr = isArray(other),\n\t          objTag = arrayTag,\n\t          othTag = arrayTag;\n\t\n\t      if (!objIsArr) {\n\t        objTag = objToString.call(object);\n\t        if (objTag == argsTag) {\n\t          objTag = objectTag;\n\t        } else if (objTag != objectTag) {\n\t          objIsArr = isTypedArray(object);\n\t        }\n\t      }\n\t      if (!othIsArr) {\n\t        othTag = objToString.call(other);\n\t        if (othTag == argsTag) {\n\t          othTag = objectTag;\n\t        } else if (othTag != objectTag) {\n\t          othIsArr = isTypedArray(other);\n\t        }\n\t      }\n\t      var objIsObj = objTag == objectTag,\n\t          othIsObj = othTag == objectTag,\n\t          isSameTag = objTag == othTag;\n\t\n\t      if (isSameTag && !(objIsArr || objIsObj)) {\n\t        return equalByTag(object, other, objTag);\n\t      }\n\t      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t      if (valWrapped || othWrapped) {\n\t        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);\n\t      }\n\t      if (!isSameTag) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      // For more information on detecting circular references see https://es5.github.io/#JO.\n\t      stackA || (stackA = []);\n\t      stackB || (stackB = []);\n\t\n\t      var length = stackA.length;\n\t      while (length--) {\n\t        if (stackA[length] == object) {\n\t          return stackB[length] == other;\n\t        }\n\t      }\n\t      // Add `object` and `other` to the stack of traversed objects.\n\t      stackA.push(object);\n\t      stackB.push(other);\n\t\n\t      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);\n\t\n\t      stackA.pop();\n\t      stackB.pop();\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isMatch` without support for callback\n\t     * shorthands or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} props The source property names to match.\n\t     * @param {Array} values The source values to match.\n\t     * @param {Array} strictCompareFlags Strict comparison flags for source values.\n\t     * @param {Function} [customizer] The function to customize comparing objects.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     */\n\t    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {\n\t      var length = props.length;\n\t      if (object == null) {\n\t        return !length;\n\t      }\n\t      var index = -1,\n\t          noCustomizer = !customizer;\n\t\n\t      while (++index < length) {\n\t        if ((noCustomizer && strictCompareFlags[index])\n\t              ? values[index] !== object[props[index]]\n\t              : !hasOwnProperty.call(object, props[index])\n\t            ) {\n\t          return false;\n\t        }\n\t      }\n\t      index = -1;\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (noCustomizer && strictCompareFlags[index]) {\n\t          var result = hasOwnProperty.call(object, key);\n\t        } else {\n\t          var objValue = object[key],\n\t              srcValue = values[index];\n\t\n\t          result = customizer ? customizer(objValue, srcValue, key) : undefined;\n\t          if (typeof result == 'undefined') {\n\t            result = baseIsEqual(srcValue, objValue, customizer, true);\n\t          }\n\t        }\n\t        if (!result) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.map` without support for callback shorthands\n\t     * or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function baseMap(collection, iteratee) {\n\t      var result = [];\n\t      baseEach(collection, function(value, key, collection) {\n\t        result.push(iteratee(value, key, collection));\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matches` which does not clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatches(source) {\n\t      var props = keys(source),\n\t          length = props.length;\n\t\n\t      if (length == 1) {\n\t        var key = props[0],\n\t            value = source[key];\n\t\n\t        if (isStrictComparable(value)) {\n\t          return function(object) {\n\t            return object != null && value === object[key] && hasOwnProperty.call(object, key);\n\t          };\n\t        }\n\t      }\n\t      var values = Array(length),\n\t          strictCompareFlags = Array(length);\n\t\n\t      while (length--) {\n\t        value = source[props[length]];\n\t        values[length] = value;\n\t        strictCompareFlags[length] = isStrictComparable(value);\n\t      }\n\t      return function(object) {\n\t        return baseIsMatch(object, props, values, strictCompareFlags);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matchesProperty` which does not coerce `key`\n\t     * to a string.\n\t     *\n\t     * @private\n\t     * @param {string} key The key of the property to get.\n\t     * @param {*} value The value to compare.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatchesProperty(key, value) {\n\t      if (isStrictComparable(value)) {\n\t        return function(object) {\n\t          return object != null && object[key] === value;\n\t        };\n\t      }\n\t      return function(object) {\n\t        return object != null && baseIsEqual(value, object[key], null, true);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.merge` without support for argument juggling,\n\t     * multiple sources, and `this` binding `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {Function} [customizer] The function to customize merging properties.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t     * @returns {Object} Returns the destination object.\n\t     */\n\t    function baseMerge(object, source, customizer, stackA, stackB) {\n\t      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));\n\t\n\t      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {\n\t        if (isObjectLike(srcValue)) {\n\t          stackA || (stackA = []);\n\t          stackB || (stackB = []);\n\t          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n\t        }\n\t        var value = object[key],\n\t            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t            isCommon = typeof result == 'undefined';\n\t\n\t        if (isCommon) {\n\t          result = srcValue;\n\t        }\n\t        if ((isSrcArr || typeof result != 'undefined') &&\n\t            (isCommon || (result === result ? result !== value : value === value))) {\n\t          object[key] = result;\n\t        }\n\t      });\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseMerge` for arrays and objects which performs\n\t     * deep merges and tracks traversed objects enabling objects with circular\n\t     * references to be merged.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {string} key The key of the value to merge.\n\t     * @param {Function} mergeFunc The function to merge values.\n\t     * @param {Function} [customizer] The function to customize merging properties.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n\t      var length = stackA.length,\n\t          srcValue = source[key];\n\t\n\t      while (length--) {\n\t        if (stackA[length] == srcValue) {\n\t          object[key] = stackB[length];\n\t          return;\n\t        }\n\t      }\n\t      var value = object[key],\n\t          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t          isCommon = typeof result == 'undefined';\n\t\n\t      if (isCommon) {\n\t        result = srcValue;\n\t        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {\n\t          result = isArray(value)\n\t            ? value\n\t            : (value ? arrayCopy(value) : []);\n\t        }\n\t        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t          result = isArguments(value)\n\t            ? toPlainObject(value)\n\t            : (isPlainObject(value) ? value : {});\n\t        }\n\t        else {\n\t          isCommon = false;\n\t        }\n\t      }\n\t      // Add the source value to the stack of traversed objects and associate\n\t      // it with its merged value.\n\t      stackA.push(srcValue);\n\t      stackB.push(result);\n\t\n\t      if (isCommon) {\n\t        // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n\t      } else if (result === result ? result !== value : value === value) {\n\t        object[key] = result;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.property` which does not coerce `key` to a string.\n\t     *\n\t     * @private\n\t     * @param {string} key The key of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseProperty(key) {\n\t      return function(object) {\n\t        return object == null ? undefined : object[key];\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAt` without support for individual\n\t     * index arguments.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {number[]} indexes The indexes of elements to remove.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     */\n\t    function basePullAt(array, indexes) {\n\t      var length = indexes.length,\n\t          result = baseAt(array, indexes);\n\t\n\t      indexes.sort(baseCompareAscending);\n\t      while (length--) {\n\t        var index = parseFloat(indexes[length]);\n\t        if (index != previous && isIndex(index)) {\n\t          var previous = index;\n\t          splice.call(array, index, 1);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.random` without support for argument juggling\n\t     * and returning floating-point numbers.\n\t     *\n\t     * @private\n\t     * @param {number} min The minimum possible value.\n\t     * @param {number} max The maximum possible value.\n\t     * @returns {number} Returns the random number.\n\t     */\n\t    function baseRandom(min, max) {\n\t      return min + floor(nativeRandom() * (max - min + 1));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.reduce` and `_.reduceRight` without support\n\t     * for callback shorthands or `this` binding, which iterates over `collection`\n\t     * using the provided `eachFunc`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} accumulator The initial value.\n\t     * @param {boolean} initFromCollection Specify using the first or last element\n\t     *  of `collection` as the initial value.\n\t     * @param {Function} eachFunc The function to iterate over `collection`.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n\t      eachFunc(collection, function(value, index, collection) {\n\t        accumulator = initFromCollection\n\t          ? (initFromCollection = false, value)\n\t          : iteratee(accumulator, value, index, collection);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `setData` without support for hot loop detection.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var baseSetData = !metaMap ? identity : function(func, data) {\n\t      metaMap.set(func, data);\n\t      return func;\n\t    };\n\t\n\t    /**\n\t     * The base implementation of `_.slice` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseSlice(array, start, end) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      start = start == null ? 0 : (+start || 0);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : (end - start) >>> 0;\n\t      start >>>= 0;\n\t\n\t      var result = Array(length);\n\t      while (++index < length) {\n\t        result[index] = array[index + start];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.some` without support for callback shorthands\n\t     * or `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function baseSome(collection, predicate) {\n\t      var result;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = predicate(value, index, collection);\n\t        return !result;\n\t      });\n\t      return !!result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.uniq` without support for callback shorthands\n\t     * and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The function invoked per iteration.\n\t     * @returns {Array} Returns the new duplicate-value-free array.\n\t     */\n\t    function baseUniq(array, iteratee) {\n\t      var index = -1,\n\t          indexOf = getIndexOf(),\n\t          length = array.length,\n\t          isCommon = indexOf == baseIndexOf,\n\t          isLarge = isCommon && length >= 200,\n\t          seen = isLarge && createCache(),\n\t          result = [];\n\t\n\t      if (seen) {\n\t        indexOf = cacheIndexOf;\n\t        isCommon = false;\n\t      } else {\n\t        isLarge = false;\n\t        seen = iteratee ? [] : result;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t        if (isCommon && value === value) {\n\t          var seenIndex = seen.length;\n\t          while (seenIndex--) {\n\t            if (seen[seenIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (iteratee) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (indexOf(seen, computed) < 0) {\n\t          if (iteratee || isLarge) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.values` and `_.valuesIn` which creates an\n\t     * array of `object` property values corresponding to the property names\n\t     * returned by `keysFunc`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array} props The property names to get values for.\n\t     * @returns {Object} Returns the array of property values.\n\t     */\n\t    function baseValues(object, props) {\n\t      var index = -1,\n\t          length = props.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = object[props[index]];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `wrapperValue` which returns the result of\n\t     * performing a sequence of actions on the unwrapped `value`, where each\n\t     * successive action is supplied the return value of the previous.\n\t     *\n\t     * @private\n\t     * @param {*} value The unwrapped value.\n\t     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n\t     * @returns {*} Returns the resolved unwrapped value.\n\t     */\n\t    function baseWrapperValue(value, actions) {\n\t      var result = value;\n\t      if (result instanceof LazyWrapper) {\n\t        result = result.value();\n\t      }\n\t      var index = -1,\n\t          length = actions.length;\n\t\n\t      while (++index < length) {\n\t        var args = [result],\n\t            action = actions[index];\n\t\n\t        push.apply(args, action.args);\n\t        result = action.func.apply(action.thisArg, args);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Performs a binary search of `array` to determine the index at which `value`\n\t     * should be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {boolean} [retHighest] Specify returning the highest, instead\n\t     *  of the lowest, index at which a value should be inserted into `array`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function binaryIndex(array, value, retHighest) {\n\t      var low = 0,\n\t          high = array ? array.length : low;\n\t\n\t      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n\t        while (low < high) {\n\t          var mid = (low + high) >>> 1,\n\t              computed = array[mid];\n\t\n\t          if (retHighest ? (computed <= value) : (computed < value)) {\n\t            low = mid + 1;\n\t          } else {\n\t            high = mid;\n\t          }\n\t        }\n\t        return high;\n\t      }\n\t      return binaryIndexBy(array, value, identity, retHighest);\n\t    }\n\t\n\t    /**\n\t     * This function is like `binaryIndex` except that it invokes `iteratee` for\n\t     * `value` and each element of `array` to compute their sort ranking. The\n\t     * iteratee is invoked with one argument; (value).\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {boolean} [retHighest] Specify returning the highest, instead\n\t     *  of the lowest, index at which a value should be inserted into `array`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function binaryIndexBy(array, value, iteratee, retHighest) {\n\t      value = iteratee(value);\n\t\n\t      var low = 0,\n\t          high = array ? array.length : 0,\n\t          valIsNaN = value !== value,\n\t          valIsUndef = typeof value == 'undefined';\n\t\n\t      while (low < high) {\n\t        var mid = floor((low + high) / 2),\n\t            computed = iteratee(array[mid]),\n\t            isReflexive = computed === computed;\n\t\n\t        if (valIsNaN) {\n\t          var setLow = isReflexive || retHighest;\n\t        } else if (valIsUndef) {\n\t          setLow = isReflexive && (retHighest || typeof computed != 'undefined');\n\t        } else {\n\t          setLow = retHighest ? (computed <= value) : (computed < value);\n\t        }\n\t        if (setLow) {\n\t          low = mid + 1;\n\t        } else {\n\t          high = mid;\n\t        }\n\t      }\n\t      return nativeMin(high, MAX_ARRAY_INDEX);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseCallback` which only supports `this` binding\n\t     * and specifying the number of arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {number} [argCount] The number of arguments to provide to `func`.\n\t     * @returns {Function} Returns the callback.\n\t     */\n\t    function bindCallback(func, thisArg, argCount) {\n\t      if (typeof func != 'function') {\n\t        return identity;\n\t      }\n\t      if (typeof thisArg == 'undefined') {\n\t        return func;\n\t      }\n\t      switch (argCount) {\n\t        case 1: return function(value) {\n\t          return func.call(thisArg, value);\n\t        };\n\t        case 3: return function(value, index, collection) {\n\t          return func.call(thisArg, value, index, collection);\n\t        };\n\t        case 4: return function(accumulator, value, index, collection) {\n\t          return func.call(thisArg, accumulator, value, index, collection);\n\t        };\n\t        case 5: return function(value, other, key, object, source) {\n\t          return func.call(thisArg, value, other, key, object, source);\n\t        };\n\t      }\n\t      return function() {\n\t        return func.apply(thisArg, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the given array buffer.\n\t     *\n\t     * @private\n\t     * @param {ArrayBuffer} buffer The array buffer to clone.\n\t     * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t     */\n\t    function bufferClone(buffer) {\n\t      return bufferSlice.call(buffer, 0);\n\t    }\n\t    if (!bufferSlice) {\n\t      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.\n\t      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {\n\t        var byteLength = buffer.byteLength,\n\t            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,\n\t            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,\n\t            result = new ArrayBuffer(byteLength);\n\t\n\t        if (floatLength) {\n\t          var view = new Float64Array(result, 0, floatLength);\n\t          view.set(new Float64Array(buffer, 0, floatLength));\n\t        }\n\t        if (byteLength != offset) {\n\t          view = new Uint8Array(result, offset);\n\t          view.set(new Uint8Array(buffer, offset));\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates an array that is the composition of partially applied arguments,\n\t     * placeholders, and provided arguments into a single array of arguments.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to prepend to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgs(args, partials, holders) {\n\t      var holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          leftIndex = -1,\n\t          leftLength = partials.length,\n\t          result = Array(argsLength + leftLength);\n\t\n\t      while (++leftIndex < leftLength) {\n\t        result[leftIndex] = partials[leftIndex];\n\t      }\n\t      while (++argsIndex < holdersLength) {\n\t        result[holders[argsIndex]] = args[argsIndex];\n\t      }\n\t      while (argsLength--) {\n\t        result[leftIndex++] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This function is like `composeArgs` except that the arguments composition\n\t     * is tailored for `_.partialRight`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to append to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgsRight(args, partials, holders) {\n\t      var holdersIndex = -1,\n\t          holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          rightIndex = -1,\n\t          rightLength = partials.length,\n\t          result = Array(argsLength + rightLength);\n\t\n\t      while (++argsIndex < argsLength) {\n\t        result[argsIndex] = args[argsIndex];\n\t      }\n\t      var pad = argsIndex;\n\t      while (++rightIndex < rightLength) {\n\t        result[pad + rightIndex] = partials[rightIndex];\n\t      }\n\t      while (++holdersIndex < holdersLength) {\n\t        result[pad + holders[holdersIndex]] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that aggregates a collection, creating an accumulator\n\t     * object composed from the results of running each element in the collection\n\t     * through an iteratee.\n\t     *\n\t     * @private\n\t     * @param {Function} setter The function to set keys and values of the accumulator object.\n\t     * @param {Function} [initializer] The function to initialize the accumulator object.\n\t     * @returns {Function} Returns the new aggregator function.\n\t     */\n\t    function createAggregator(setter, initializer) {\n\t      return function(collection, iteratee, thisArg) {\n\t        var result = initializer ? initializer() : {};\n\t        iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t        if (isArray(collection)) {\n\t          var index = -1,\n\t              length = collection.length;\n\t\n\t          while (++index < length) {\n\t            var value = collection[index];\n\t            setter(result, value, iteratee(value, index, collection), collection);\n\t          }\n\t        } else {\n\t          baseEach(collection, function(value, key, collection) {\n\t            setter(result, value, iteratee(value, key, collection), collection);\n\t          });\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that assigns properties of source object(s) to a given\n\t     * destination object.\n\t     *\n\t     * @private\n\t     * @param {Function} assigner The function to assign values.\n\t     * @returns {Function} Returns the new assigner function.\n\t     */\n\t    function createAssigner(assigner) {\n\t      return function() {\n\t        var length = arguments.length,\n\t            object = arguments[0];\n\t\n\t        if (length < 2 || object == null) {\n\t          return object;\n\t        }\n\t        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {\n\t          length = 2;\n\t        }\n\t        // Juggle arguments.\n\t        if (length > 3 && typeof arguments[length - 2] == 'function') {\n\t          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);\n\t        } else if (length > 2 && typeof arguments[length - 1] == 'function') {\n\t          customizer = arguments[--length];\n\t        }\n\t        var index = 0;\n\t        while (++index < length) {\n\t          var source = arguments[index];\n\t          if (source) {\n\t            assigner(object, source, customizer);\n\t          }\n\t        }\n\t        return object;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with the `this`\n\t     * binding of `thisArg`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @returns {Function} Returns the new bound function.\n\t     */\n\t    function createBindWrapper(func, thisArg) {\n\t      var Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `Set` cache object to optimize linear searches of large arrays.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n\t     */\n\t    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {\n\t      return new SetCache(values);\n\t    };\n\t\n\t    /**\n\t     * Creates a function that produces compound words out of the words in a\n\t     * given string.\n\t     *\n\t     * @private\n\t     * @param {Function} callback The function to combine each word.\n\t     * @returns {Function} Returns the new compounder function.\n\t     */\n\t    function createCompounder(callback) {\n\t      return function(string) {\n\t        var index = -1,\n\t            array = words(deburr(string)),\n\t            length = array.length,\n\t            result = '';\n\t\n\t        while (++index < length) {\n\t          result = callback(result, array[index], index);\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that produces an instance of `Ctor` regardless of\n\t     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n\t     *\n\t     * @private\n\t     * @param {Function} Ctor The constructor to wrap.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCtorWrapper(Ctor) {\n\t      return function() {\n\t        var thisBinding = baseCreate(Ctor.prototype),\n\t            result = Ctor.apply(thisBinding, arguments);\n\t\n\t        // Mimic the constructor's `return` behavior.\n\t        // See https://es5.github.io/#x13.2.2 for more details.\n\t        return isObject(result) ? result : thisBinding;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that gets the extremum value of a collection.\n\t     *\n\t     * @private\n\t     * @param {Function} arrayFunc The function to get the extremum value from an array.\n\t     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,\n\t     *  extremum value.\n\t     * @returns {Function} Returns the new extremum function.\n\t     */\n\t    function createExtremum(arrayFunc, isMin) {\n\t      return function(collection, iteratee, thisArg) {\n\t        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t          iteratee = null;\n\t        }\n\t        var func = getCallback(),\n\t            noIteratee = iteratee == null;\n\t\n\t        if (!(func === baseCallback && noIteratee)) {\n\t          noIteratee = false;\n\t          iteratee = func(iteratee, thisArg, 3);\n\t        }\n\t        if (noIteratee) {\n\t          var isArr = isArray(collection);\n\t          if (!isArr && isString(collection)) {\n\t            iteratee = charAtCallback;\n\t          } else {\n\t            return arrayFunc(isArr ? collection : toIterable(collection));\n\t          }\n\t        }\n\t        return extremumBy(collection, iteratee, isMin);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with optional `this`\n\t     * binding of, partial application, and currying.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to reference.\n\t     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n\t     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n\t      var isAry = bitmask & ARY_FLAG,\n\t          isBind = bitmask & BIND_FLAG,\n\t          isBindKey = bitmask & BIND_KEY_FLAG,\n\t          isCurry = bitmask & CURRY_FLAG,\n\t          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n\t          isCurryRight = bitmask & CURRY_RIGHT_FLAG;\n\t\n\t      var Ctor = !isBindKey && createCtorWrapper(func),\n\t          key = func;\n\t\n\t      function wrapper() {\n\t        // Avoid `arguments` object use disqualifying optimizations by\n\t        // converting it to an array before providing it to other functions.\n\t        var length = arguments.length,\n\t            index = length,\n\t            args = Array(length);\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        if (partials) {\n\t          args = composeArgs(args, partials, holders);\n\t        }\n\t        if (partialsRight) {\n\t          args = composeArgsRight(args, partialsRight, holdersRight);\n\t        }\n\t        if (isCurry || isCurryRight) {\n\t          var placeholder = wrapper.placeholder,\n\t              argsHolders = replaceHolders(args, placeholder);\n\t\n\t          length -= argsHolders.length;\n\t          if (length < arity) {\n\t            var newArgPos = argPos ? arrayCopy(argPos) : null,\n\t                newArity = nativeMax(arity - length, 0),\n\t                newsHolders = isCurry ? argsHolders : null,\n\t                newHoldersRight = isCurry ? null : argsHolders,\n\t                newPartials = isCurry ? args : null,\n\t                newPartialsRight = isCurry ? null : args;\n\t\n\t            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n\t            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\t\n\t            if (!isCurryBound) {\n\t              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n\t            }\n\t            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);\n\t            result.placeholder = placeholder;\n\t            return result;\n\t          }\n\t        }\n\t        var thisBinding = isBind ? thisArg : this;\n\t        if (isBindKey) {\n\t          func = thisBinding[key];\n\t        }\n\t        if (argPos) {\n\t          args = reorder(args, argPos);\n\t        }\n\t        if (isAry && ary < args.length) {\n\t          args.length = ary;\n\t        }\n\t        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates the pad required for `string` based on the given padding length.\n\t     * The `chars` string may be truncated if the number of padding characters\n\t     * exceeds the padding length.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to create padding for.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the pad for `string`.\n\t     */\n\t    function createPad(string, length, chars) {\n\t      var strLength = string.length;\n\t      length = +length;\n\t\n\t      if (strLength >= length || !nativeIsFinite(length)) {\n\t        return '';\n\t      }\n\t      var padLength = length - strLength;\n\t      chars = chars == null ? ' ' : (chars + '');\n\t      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with the optional `this`\n\t     * binding of `thisArg` and the `partials` prepended to those provided to\n\t     * the wrapper.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {Array} partials The arguments to prepend to those provided to the new function.\n\t     * @returns {Function} Returns the new bound function.\n\t     */\n\t    function createPartialWrapper(func, bitmask, thisArg, partials) {\n\t      var isBind = bitmask & BIND_FLAG,\n\t          Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        // Avoid `arguments` object use disqualifying optimizations by\n\t        // converting it to an array before providing it `func`.\n\t        var argsIndex = -1,\n\t            argsLength = arguments.length,\n\t            leftIndex = -1,\n\t            leftLength = partials.length,\n\t            args = Array(argsLength + leftLength);\n\t\n\t        while (++leftIndex < leftLength) {\n\t          args[leftIndex] = partials[leftIndex];\n\t        }\n\t        while (argsLength--) {\n\t          args[leftIndex++] = arguments[++argsIndex];\n\t        }\n\t        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that either curries or invokes `func` with optional\n\t     * `this` binding and partially applied arguments.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to reference.\n\t     * @param {number} bitmask The bitmask of flags.\n\t     *  The bitmask may be composed of the following flags:\n\t     *     1 - `_.bind`\n\t     *     2 - `_.bindKey`\n\t     *     4 - `_.curry` or `_.curryRight` of a bound function\n\t     *     8 - `_.curry`\n\t     *    16 - `_.curryRight`\n\t     *    32 - `_.partial`\n\t     *    64 - `_.partialRight`\n\t     *   128 - `_.rearg`\n\t     *   256 - `_.ary`\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to be partially applied.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isBindKey = bitmask & BIND_KEY_FLAG;\n\t      if (!isBindKey && typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var length = partials ? partials.length : 0;\n\t      if (!length) {\n\t        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n\t        partials = holders = null;\n\t      }\n\t      length -= (holders ? holders.length : 0);\n\t      if (bitmask & PARTIAL_RIGHT_FLAG) {\n\t        var partialsRight = partials,\n\t            holdersRight = holders;\n\t\n\t        partials = holders = null;\n\t      }\n\t      var data = !isBindKey && getData(func),\n\t          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\t\n\t      if (data && data !== true) {\n\t        mergeData(newData, data);\n\t        bitmask = newData[1];\n\t        arity = newData[9];\n\t      }\n\t      newData[9] = arity == null\n\t        ? (isBindKey ? 0 : func.length)\n\t        : (nativeMax(arity - length, 0) || 0);\n\t\n\t      if (bitmask == BIND_FLAG) {\n\t        var result = createBindWrapper(newData[0], newData[2]);\n\t      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n\t        result = createPartialWrapper.apply(undefined, newData);\n\t      } else {\n\t        result = createHybridWrapper.apply(undefined, newData);\n\t      }\n\t      var setter = data ? baseSetData : setData;\n\t      return setter(result, newData);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to compare.\n\t     * @param {Array} other The other array to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing arrays.\n\t     * @param {boolean} [isWhere] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t     */\n\t    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {\n\t      var index = -1,\n\t          arrLength = array.length,\n\t          othLength = other.length,\n\t          result = true;\n\t\n\t      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {\n\t        return false;\n\t      }\n\t      // Deep compare the contents, ignoring non-numeric properties.\n\t      while (result && ++index < arrLength) {\n\t        var arrValue = array[index],\n\t            othValue = other[index];\n\t\n\t        result = undefined;\n\t        if (customizer) {\n\t          result = isWhere\n\t            ? customizer(othValue, arrValue, index)\n\t            : customizer(arrValue, othValue, index);\n\t        }\n\t        if (typeof result == 'undefined') {\n\t          // Recursively compare arrays (susceptible to call stack limits).\n\t          if (isWhere) {\n\t            var othIndex = othLength;\n\t            while (othIndex--) {\n\t              othValue = other[othIndex];\n\t              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n\t              if (result) {\n\t                break;\n\t              }\n\t            }\n\t          } else {\n\t            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n\t          }\n\t        }\n\t      }\n\t      return !!result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t     * the same `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports comparing values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} value The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {string} tag The `toStringTag` of the objects to compare.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalByTag(object, other, tag) {\n\t      switch (tag) {\n\t        case boolTag:\n\t        case dateTag:\n\t          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n\t          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n\t          return +object == +other;\n\t\n\t        case errorTag:\n\t          return object.name == other.name && object.message == other.message;\n\t\n\t        case numberTag:\n\t          // Treat `NaN` vs. `NaN` as equal.\n\t          return (object != +object)\n\t            ? other != +other\n\t            // But, treat `-0` vs. `+0` as not equal.\n\t            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);\n\t\n\t        case regexpTag:\n\t        case stringTag:\n\t          // Coerce regexes to strings and treat strings primitives and string\n\t          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n\t          return object == (other + '');\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for objects with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {boolean} [isWhere] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n\t      var objProps = keys(object),\n\t          objLength = objProps.length,\n\t          othProps = keys(other),\n\t          othLength = othProps.length;\n\t\n\t      if (objLength != othLength && !isWhere) {\n\t        return false;\n\t      }\n\t      var hasCtor,\n\t          index = -1;\n\t\n\t      while (++index < objLength) {\n\t        var key = objProps[index],\n\t            result = hasOwnProperty.call(other, key);\n\t\n\t        if (result) {\n\t          var objValue = object[key],\n\t              othValue = other[key];\n\t\n\t          result = undefined;\n\t          if (customizer) {\n\t            result = isWhere\n\t              ? customizer(othValue, objValue, key)\n\t              : customizer(objValue, othValue, key);\n\t          }\n\t          if (typeof result == 'undefined') {\n\t            // Recursively compare objects (susceptible to call stack limits).\n\t            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);\n\t          }\n\t        }\n\t        if (!result) {\n\t          return false;\n\t        }\n\t        hasCtor || (hasCtor = key == 'constructor');\n\t      }\n\t      if (!hasCtor) {\n\t        var objCtor = object.constructor,\n\t            othCtor = other.constructor;\n\t\n\t        // Non `Object` object instances with different constructors are not equal.\n\t        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&\n\t            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Gets the extremum value of `collection` invoking `iteratee` for each value\n\t     * in `collection` to generate the criterion by which the value is ranked.\n\t     * The `iteratee` is invoked with three arguments; (value, index, collection).\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {boolean} [isMin] Specify returning the minimum, instead of the\n\t     *  maximum, extremum value.\n\t     * @returns {*} Returns the extremum value.\n\t     */\n\t    function extremumBy(collection, iteratee, isMin) {\n\t      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,\n\t          computed = exValue,\n\t          result = computed;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        var current = iteratee(value, index, collection);\n\t        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {\n\t          computed = current;\n\t          result = value;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n\t     * customized this function returns the custom method, otherwise it returns\n\t     * the `baseCallback` function. If arguments are provided the chosen function\n\t     * is invoked with them and its result is returned.\n\t     *\n\t     * @private\n\t     * @returns {Function} Returns the chosen function or its result.\n\t     */\n\t    function getCallback(func, thisArg, argCount) {\n\t      var result = lodash.callback || callback;\n\t      result = result === callback ? baseCallback : result;\n\t      return argCount ? result(func, thisArg, argCount) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets metadata for `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {*} Returns the metadata for `func`.\n\t     */\n\t    var getData = !metaMap ? noop : function(func) {\n\t      return metaMap.get(func);\n\t    };\n\t\n\t    /**\n\t     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n\t     * customized this function returns the custom method, otherwise it returns\n\t     * the `baseIndexOf` function. If arguments are provided the chosen function\n\t     * is invoked with them and its result is returned.\n\t     *\n\t     * @private\n\t     * @returns {Function|number} Returns the chosen function or its result.\n\t     */\n\t    function getIndexOf(collection, target, fromIndex) {\n\t      var result = lodash.indexOf || indexOf;\n\t      result = result === indexOf ? baseIndexOf : result;\n\t      return collection ? result(collection, target, fromIndex) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the view.\n\t     * @param {number} end The end of the view.\n\t     * @param {Array} [transforms] The transformations to apply to the view.\n\t     * @returns {Object} Returns an object containing the `start` and `end`\n\t     *  positions of the view.\n\t     */\n\t    function getView(start, end, transforms) {\n\t      var index = -1,\n\t          length = transforms ? transforms.length : 0;\n\t\n\t      while (++index < length) {\n\t        var data = transforms[index],\n\t            size = data.size;\n\t\n\t        switch (data.type) {\n\t          case 'drop':      start += size; break;\n\t          case 'dropRight': end -= size; break;\n\t          case 'take':      end = nativeMin(end, start + size); break;\n\t          case 'takeRight': start = nativeMax(start, end - size); break;\n\t        }\n\t      }\n\t      return { 'start': start, 'end': end };\n\t    }\n\t\n\t    /**\n\t     * Initializes an array clone.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to clone.\n\t     * @returns {Array} Returns the initialized clone.\n\t     */\n\t    function initCloneArray(array) {\n\t      var length = array.length,\n\t          result = new array.constructor(length);\n\t\n\t      // Add array properties assigned by `RegExp#exec`.\n\t      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t        result.index = array.index;\n\t        result.input = array.input;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneObject(object) {\n\t      var Ctor = object.constructor;\n\t      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n\t        Ctor = Object;\n\t      }\n\t      return new Ctor;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone based on its `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports cloning values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @param {string} tag The `toStringTag` of the object to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneByTag(object, tag, isDeep) {\n\t      var Ctor = object.constructor;\n\t      switch (tag) {\n\t        case arrayBufferTag:\n\t          return bufferClone(object);\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t          return new Ctor(+object);\n\t\n\t        case float32Tag: case float64Tag:\n\t        case int8Tag: case int16Tag: case int32Tag:\n\t        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t          var buffer = object.buffer;\n\t          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\t\n\t        case numberTag:\n\t        case stringTag:\n\t          return new Ctor(object);\n\t\n\t        case regexpTag:\n\t          var result = new Ctor(object.source, reFlags.exec(object));\n\t          result.lastIndex = object.lastIndex;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` is eligible for `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to check.\n\t     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.\n\t     */\n\t    function isBindable(func) {\n\t      var support = lodash.support,\n\t          result = !(support.funcNames ? func.name : support.funcDecomp);\n\t\n\t      if (!result) {\n\t        var source = fnToString.call(func);\n\t        if (!support.funcNames) {\n\t          result = !reFuncName.test(source);\n\t        }\n\t        if (!result) {\n\t          // Check if `func` references the `this` keyword and store the result.\n\t          result = reThis.test(source) || isNative(func);\n\t          baseSetData(func, result);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like index.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t     */\n\t    function isIndex(value, length) {\n\t      value = +value;\n\t      length = length == null ? MAX_SAFE_INTEGER : length;\n\t      return value > -1 && value % 1 == 0 && value < length;\n\t    }\n\t\n\t    /**\n\t     * Checks if the provided arguments are from an iteratee call.\n\t     *\n\t     * @private\n\t     * @param {*} value The potential iteratee value argument.\n\t     * @param {*} index The potential iteratee index or key argument.\n\t     * @param {*} object The potential iteratee object argument.\n\t     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t     */\n\t    function isIterateeCall(value, index, object) {\n\t      if (!isObject(object)) {\n\t        return false;\n\t      }\n\t      var type = typeof index;\n\t      if (type == 'number') {\n\t        var length = object.length,\n\t            prereq = isLength(length) && isIndex(index, length);\n\t      } else {\n\t        prereq = type == 'string' && index in object;\n\t      }\n\t      return prereq && object[index] === value;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like length.\n\t     *\n\t     * **Note:** This function is based on ES `ToLength`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n\t     * for more details.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t     */\n\t    function isLength(value) {\n\t      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t     *  equality comparisons, else `false`.\n\t     */\n\t    function isStrictComparable(value) {\n\t      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));\n\t    }\n\t\n\t    /**\n\t     * Merges the function metadata of `source` into `data`.\n\t     *\n\t     * Merging metadata reduces the number of wrappers required to invoke a function.\n\t     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n\t     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n\t     * augment function arguments, making the order in which they are executed important,\n\t     * preventing the merging of metadata. However, we make an exception for a safe\n\t     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n\t     *\n\t     * @private\n\t     * @param {Array} data The destination metadata.\n\t     * @param {Array} source The source metadata.\n\t     * @returns {Array} Returns `data`.\n\t     */\n\t    function mergeData(data, source) {\n\t      var bitmask = data[1],\n\t          srcBitmask = source[1],\n\t          newBitmask = bitmask | srcBitmask;\n\t\n\t      var arityFlags = ARY_FLAG | REARG_FLAG,\n\t          bindFlags = BIND_FLAG | BIND_KEY_FLAG,\n\t          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;\n\t\n\t      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),\n\t          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),\n\t          argPos = (isRearg ? data : source)[7],\n\t          ary = (isAry ? data : source)[8];\n\t\n\t      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&\n\t        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);\n\t\n\t      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&\n\t        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));\n\t\n\t      // Exit early if metadata can't be merged.\n\t      if (!(isCommon || isCombo)) {\n\t        return data;\n\t      }\n\t      // Use source `thisArg` if available.\n\t      if (srcBitmask & BIND_FLAG) {\n\t        data[2] = source[2];\n\t        // Set when currying a bound function.\n\t        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n\t      }\n\t      // Compose partial arguments.\n\t      var value = source[3];\n\t      if (value) {\n\t        var partials = data[3];\n\t        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n\t        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n\t      }\n\t      // Compose partial right arguments.\n\t      value = source[5];\n\t      if (value) {\n\t        partials = data[5];\n\t        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n\t        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n\t      }\n\t      // Use source `argPos` if available.\n\t      value = source[7];\n\t      if (value) {\n\t        data[7] = arrayCopy(value);\n\t      }\n\t      // Use source `ary` if it's smaller.\n\t      if (srcBitmask & ARY_FLAG) {\n\t        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n\t      }\n\t      // Use source `arity` if one is not provided.\n\t      if (data[9] == null) {\n\t        data[9] = source[9];\n\t      }\n\t      // Use source `func` and merge bitmasks.\n\t      data[0] = source[0];\n\t      data[1] = newBitmask;\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.pick` that picks `object` properties specified\n\t     * by the `props` array.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {string[]} props The property names to pick.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function pickByArray(object, props) {\n\t      object = toObject(object);\n\t\n\t      var index = -1,\n\t          length = props.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (key in object) {\n\t          result[key] = object[key];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.pick` that picks `object` properties `predicate`\n\t     * returns truthy for.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function pickByCallback(object, predicate) {\n\t      var result = {};\n\t      baseForIn(object, function(value, key, object) {\n\t        if (predicate(value, key, object)) {\n\t          result[key] = value;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reorder `array` according to the specified indexes where the element at\n\t     * the first index is assigned as the first element, the element at\n\t     * the second index is assigned as the second element, and so on.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to reorder.\n\t     * @param {Array} indexes The arranged array indexes.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function reorder(array, indexes) {\n\t      var arrLength = array.length,\n\t          length = nativeMin(indexes.length, arrLength),\n\t          oldArray = arrayCopy(array);\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Sets metadata for `func`.\n\t     *\n\t     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n\t     * period of time, it will trip its breaker and transition to an identity function\n\t     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n\t     * for more details.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var setData = (function() {\n\t      var count = 0,\n\t          lastCalled = 0;\n\t\n\t      return function(key, value) {\n\t        var stamp = now(),\n\t            remaining = HOT_SPAN - (stamp - lastCalled);\n\t\n\t        lastCalled = stamp;\n\t        if (remaining > 0) {\n\t          if (++count >= HOT_COUNT) {\n\t            return key;\n\t          }\n\t        } else {\n\t          count = 0;\n\t        }\n\t        return baseSetData(key, value);\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * A fallback implementation of `_.isPlainObject` which checks if `value`\n\t     * is an object created by the `Object` constructor or has a `[[Prototype]]`\n\t     * of `null`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t     */\n\t    function shimIsPlainObject(value) {\n\t      var Ctor,\n\t          support = lodash.support;\n\t\n\t      // Exit early for non `Object` objects.\n\t      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||\n\t          (!hasOwnProperty.call(value, 'constructor') &&\n\t            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n\t        return false;\n\t      }\n\t      // IE < 9 iterates inherited properties before own properties. If the first\n\t      // iterated property is an object's own property then there are no inherited\n\t      // enumerable properties.\n\t      var result;\n\t      // In most environments an object's own properties are iterated before\n\t      // its inherited properties. If the last iterated property is an object's\n\t      // own property then there are no inherited enumerable properties.\n\t      baseForIn(value, function(subValue, key) {\n\t        result = key;\n\t      });\n\t      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n\t    }\n\t\n\t    /**\n\t     * A fallback implementation of `Object.keys` which creates an array of the\n\t     * own enumerable property names of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function shimKeys(object) {\n\t      var props = keysIn(object),\n\t          propsLength = props.length,\n\t          length = propsLength && object.length,\n\t          support = lodash.support;\n\t\n\t      var allowIndexes = length && isLength(length) &&\n\t        (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\t\n\t      var index = -1,\n\t          result = [];\n\t\n\t      while (++index < propsLength) {\n\t        var key = props[index];\n\t        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array-like object if it is not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Array|Object} Returns the array-like object.\n\t     */\n\t    function toIterable(value) {\n\t      if (value == null) {\n\t        return [];\n\t      }\n\t      if (!isLength(value.length)) {\n\t        return values(value);\n\t      }\n\t      return isObject(value) ? value : Object(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an object if it is not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Object} Returns the object.\n\t     */\n\t    function toObject(value) {\n\t      return isObject(value) ? value : Object(value);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `wrapper`.\n\t     *\n\t     * @private\n\t     * @param {Object} wrapper The wrapper to clone.\n\t     * @returns {Object} Returns the cloned wrapper.\n\t     */\n\t    function wrapperClone(wrapper) {\n\t      return wrapper instanceof LazyWrapper\n\t        ? wrapper.clone()\n\t        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements split into groups the length of `size`.\n\t     * If `collection` can't be split evenly, the final chunk will be the remaining\n\t     * elements.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to process.\n\t     * @param {number} [size=1] The length of each chunk.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the new array containing chunks.\n\t     * @example\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 2);\n\t     * // => [['a', 'b'], ['c', 'd']]\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 3);\n\t     * // => [['a', 'b', 'c'], ['d']]\n\t     */\n\t    function chunk(array, size, guard) {\n\t      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n\t        size = 1;\n\t      } else {\n\t        size = nativeMax(+size || 1, 1);\n\t      }\n\t      var index = 0,\n\t          length = array ? array.length : 0,\n\t          resIndex = -1,\n\t          result = Array(ceil(length / size));\n\t\n\t      while (index < length) {\n\t        result[++resIndex] = baseSlice(array, index, (index += size));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array with all falsey values removed. The values `false`, `null`,\n\t     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to compact.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.compact([0, 1, false, 2, '', 3]);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function compact(array) {\n\t      var index = -1,\n\t          length = array ? array.length : 0,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array excluding all values of the provided arrays using\n\t     * `SameValueZero` for equality comparisons.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The arrays of values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.difference([1, 2, 3], [5, 2, 10]);\n\t     * // => [1, 3]\n\t     */\n\t    function difference() {\n\t      var index = -1,\n\t          length = arguments.length;\n\t\n\t      while (++index < length) {\n\t        var value = arguments[index];\n\t        if (isArray(value) || isArguments(value)) {\n\t          break;\n\t        }\n\t      }\n\t      return baseDifference(value, baseFlatten(arguments, false, true, ++index));\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.drop([1, 2, 3]);\n\t     * // => [2, 3]\n\t     *\n\t     * _.drop([1, 2, 3], 2);\n\t     * // => [3]\n\t     *\n\t     * _.drop([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.drop([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function drop(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      return baseSlice(array, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRight([1, 2, 3]);\n\t     * // => [1, 2]\n\t     *\n\t     * _.dropRight([1, 2, 3], 2);\n\t     * // => [1]\n\t     *\n\t     * _.dropRight([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.dropRight([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function dropRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      n = length - (+n || 0);\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the end.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that match the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per element.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRightWhile([1, 2, 3], function(n) { return n > 1; });\n\t     * // => [1]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, { 'age': 1, 'active': false }), 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropRightWhile(array, predicate, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (length-- && predicate(array[length], length, array)) {}\n\t      return baseSlice(array, 0, length + 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the beginning.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per element.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropWhile([1, 2, 3], function(n) { return n < 3; });\n\t     * // => [3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.dropWhile(users, { 'age': 36, 'active': false }), 'user');\n\t     * // => ['fred', 'pebbles']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n\t     * // => ['pebbles']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.dropWhile(users, 'active'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropWhile(array, predicate, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      var index = -1;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (++index < length && predicate(array[index], index, array)) {}\n\t      return baseSlice(array, index);\n\t    }\n\t\n\t    /**\n\t     * Fills elements of `array` with `value` from `start` up to, but not\n\t     * including, `end`.\n\t     *\n\t     * **Note:** This method mutates `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function fill(array, value, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseFill(array, value, start, end);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the index of the first\n\t     * element `predicate` returns truthy for, instead of the element itself.\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': true },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * _.findIndex(users, function(chr) { return chr.age < 40; });\n\t     * // => 0\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.findIndex(users, { 'age': 40, 'active': true });\n\t     * // => 1\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.findIndex(users, 'age', 1);\n\t     * // => 2\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.findIndex(users, 'active');\n\t     * // => 1\n\t     */\n\t    function findIndex(array, predicate, thisArg) {\n\t      var index = -1,\n\t          length = array ? array.length : 0;\n\t\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (++index < length) {\n\t        if (predicate(array[index], index, array)) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findIndex` except that it iterates over elements\n\t     * of `collection` from right to left.\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * _.findLastIndex(users, function(chr) { return chr.age < 40; });\n\t     * // => 2\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.findLastIndex(users, { 'age': 36, 'active': true });\n\t     * // => 0\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.findLastIndex(users, 'age', 40);\n\t     * // => 1\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.findLastIndex(users, 'active');\n\t     * // => 0\n\t     */\n\t    function findLastIndex(array, predicate, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (length--) {\n\t        if (predicate(array[length], length, array)) {\n\t          return length;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Gets the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias head\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the first element of `array`.\n\t     * @example\n\t     *\n\t     * _.first([1, 2, 3]);\n\t     * // => 1\n\t     *\n\t     * _.first([]);\n\t     * // => undefined\n\t     */\n\t    function first(array) {\n\t      return array ? array[0] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n\t     * flattened, otherwise it is only flattened a single level.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @param {boolean} [isDeep] Specify a deep flatten.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flatten([1, [2], [3, [[4]]]]);\n\t     * // => [1, 2, 3, [[4]]];\n\t     *\n\t     * // using `isDeep`\n\t     * _.flatten([1, [2], [3, [[4]]]], true);\n\t     * // => [1, 2, 3, 4];\n\t     */\n\t    function flatten(array, isDeep, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (guard && isIterateeCall(array, isDeep, guard)) {\n\t        isDeep = false;\n\t      }\n\t      return length ? baseFlatten(array, isDeep) : [];\n\t    }\n\t\n\t    /**\n\t     * Recursively flattens a nested array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to recursively flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flattenDeep([1, [2], [3, [[4]]]]);\n\t     * // => [1, 2, 3, 4];\n\t     */\n\t    function flattenDeep(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? baseFlatten(array, true) : [];\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the first occurrence of `value` is found in `array`\n\t     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,\n\t     * it is used as the offset from the end of `array`. If `array` is sorted\n\t     * providing `true` for `fromIndex` performs a faster binary search.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n\t     *  to perform a binary search on a sorted array.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n\t     * // => 1\n\t     *\n\t     * // using `fromIndex`\n\t     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n\t     * // => 4\n\t     *\n\t     * // performing a binary search\n\t     * _.indexOf([4, 4, 5, 5, 6, 6], 5, true);\n\t     * // => 2\n\t     */\n\t    function indexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      if (typeof fromIndex == 'number') {\n\t        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n\t      } else if (fromIndex) {\n\t        var index = binaryIndex(array, value),\n\t            other = array[index];\n\t\n\t        return (value === value ? value === other : other !== other) ? index : -1;\n\t      }\n\t      return baseIndexOf(array, value, fromIndex);\n\t    }\n\t\n\t    /**\n\t     * Gets all but the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.initial([1, 2, 3]);\n\t     * // => [1, 2]\n\t     */\n\t    function initial(array) {\n\t      return dropRight(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values in all provided arrays using `SameValueZero`\n\t     * for equality comparisons.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     * @example\n\t     *\n\t     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n\t     * // => [1, 2]\n\t     */\n\t    function intersection() {\n\t      var args = [],\n\t          argsIndex = -1,\n\t          argsLength = arguments.length,\n\t          caches = [],\n\t          indexOf = getIndexOf(),\n\t          isCommon = indexOf == baseIndexOf;\n\t\n\t      while (++argsIndex < argsLength) {\n\t        var value = arguments[argsIndex];\n\t        if (isArray(value) || isArguments(value)) {\n\t          args.push(value);\n\t          caches.push(isCommon && value.length >= 120 && createCache(argsIndex && value));\n\t        }\n\t      }\n\t      argsLength = args.length;\n\t      var array = args[0],\n\t          index = -1,\n\t          length = array ? array.length : 0,\n\t          result = [],\n\t          seen = caches[0];\n\t\n\t      outer:\n\t      while (++index < length) {\n\t        value = array[index];\n\t        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {\n\t          argsIndex = argsLength;\n\t          while (--argsIndex) {\n\t            var cache = caches[argsIndex];\n\t            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (seen) {\n\t            seen.push(value);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the last element of `array`.\n\t     * @example\n\t     *\n\t     * _.last([1, 2, 3]);\n\t     * // => 3\n\t     */\n\t    function last(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? array[length - 1] : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it iterates over elements of\n\t     * `array` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n\t     *  or `true` to perform a binary search on a sorted array.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n\t     * // => 4\n\t     *\n\t     * // using `fromIndex`\n\t     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n\t     * // => 1\n\t     *\n\t     * // performing a binary search\n\t     * _.lastIndexOf([4, 4, 5, 5, 6, 6], 5, true);\n\t     * // => 3\n\t     */\n\t    function lastIndexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = length;\n\t      if (typeof fromIndex == 'number') {\n\t        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n\t      } else if (fromIndex) {\n\t        index = binaryIndex(array, value, true) - 1;\n\t        var other = array[index];\n\t        return (value === value ? value === other : other !== other) ? index : -1;\n\t      }\n\t      if (value !== value) {\n\t        return indexOfNaN(array, index, true);\n\t      }\n\t      while (index--) {\n\t        if (array[index] === value) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Removes all provided values from `array` using `SameValueZero` for equality\n\t     * comparisons.\n\t     *\n\t     * **Notes:**\n\t     *  - Unlike `_.without`, this method mutates `array`.\n\t     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,\n\t     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     *    for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...*} [values] The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 1, 2, 3];\n\t     * _.pull(array, 2, 3);\n\t     * console.log(array);\n\t     * // => [1, 1]\n\t     */\n\t    function pull() {\n\t      var array = arguments[0];\n\t      if (!(array && array.length)) {\n\t        return array;\n\t      }\n\t      var index = 0,\n\t          indexOf = getIndexOf(),\n\t          length = arguments.length;\n\t\n\t      while (++index < length) {\n\t        var fromIndex = 0,\n\t            value = arguments[index];\n\t\n\t        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n\t          splice.call(array, fromIndex, 1);\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Removes elements from `array` corresponding to the given indexes and returns\n\t     * an array of the removed elements. Indexes may be specified as an array of\n\t     * indexes or as individual arguments.\n\t     *\n\t     * **Note:** Unlike `_.at`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n\t     *  specified as individual indexes or arrays of indexes.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [5, 10, 15, 20];\n\t     * var evens = _.pullAt(array, [1, 3]);\n\t     *\n\t     * console.log(array);\n\t     * // => [5, 15]\n\t     *\n\t     * console.log(evens);\n\t     * // => [10, 20]\n\t     */\n\t    function pullAt(array) {\n\t      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));\n\t    }\n\t\n\t    /**\n\t     * Removes all elements from `array` that `predicate` returns truthy for\n\t     * and returns an array of the removed elements. The predicate is bound to\n\t     * `thisArg` and invoked with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * **Note:** Unlike `_.filter`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 4];\n\t     * var evens = _.remove(array, function(n) { return n % 2 == 0; });\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 3]\n\t     *\n\t     * console.log(evens);\n\t     * // => [2, 4]\n\t     */\n\t    function remove(array, predicate, thisArg) {\n\t      var index = -1,\n\t          length = array ? array.length : 0,\n\t          result = [];\n\t\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result.push(value);\n\t          splice.call(array, index--, 1);\n\t          length--;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets all but the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias tail\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.rest([1, 2, 3]);\n\t     * // => [2, 3]\n\t     */\n\t    function rest(array) {\n\t      return drop(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` from `start` up to, but not including, `end`.\n\t     *\n\t     * **Note:** This function is used instead of `Array#slice` to support node\n\t     * lists in IE < 9 and to ensure dense arrays are returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function slice(array, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseSlice(array, start, end);\n\t    }\n\t\n\t    /**\n\t     * Uses a binary search to determine the lowest index at which `value` should\n\t     * be inserted into `array` in order to maintain its sort order. If an iteratee\n\t     * function is provided it is invoked for `value` and each element of `array`\n\t     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n\t     * invoked with one argument; (value).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedIndex([30, 50], 40);\n\t     * // => 1\n\t     *\n\t     * _.sortedIndex([4, 4, 5, 5, 6, 6], 5);\n\t     * // => 2\n\t     *\n\t     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n\t     *\n\t     * // using an iteratee function\n\t     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n\t     *   return this.data[word];\n\t     * }, dict);\n\t     * // => 1\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n\t     * // => 1\n\t     */\n\t    function sortedIndex(array, value, iteratee, thisArg) {\n\t      var func = getCallback(iteratee);\n\t      return (func === baseCallback && iteratee == null)\n\t        ? binaryIndex(array, value)\n\t        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it returns the highest\n\t     * index at which `value` should be inserted into `array` in order to\n\t     * maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndex([4, 4, 5, 5, 6, 6], 5);\n\t     * // => 4\n\t     */\n\t    function sortedLastIndex(array, value, iteratee, thisArg) {\n\t      var func = getCallback(iteratee);\n\t      return (func === baseCallback && iteratee == null)\n\t        ? binaryIndex(array, value, true)\n\t        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.take([1, 2, 3]);\n\t     * // => [1]\n\t     *\n\t     * _.take([1, 2, 3], 2);\n\t     * // => [1, 2]\n\t     *\n\t     * _.take([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.take([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function take(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRight([1, 2, 3]);\n\t     * // => [3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 2);\n\t     * // => [2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function takeRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      n = length - (+n || 0);\n\t      return baseSlice(array, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the end. Elements are\n\t     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n\t     * and invoked with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per element.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRightWhile([1, 2, 3], function(n) { return n > 1; });\n\t     * // => [2, 3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, { 'age': 1, 'active': true }), 'user');\n\t     * // => ['pebbles']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n\t     * // => ['fred', 'pebbles']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n\t     * // => []\n\t     */\n\t    function takeRightWhile(array, predicate, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (length-- && predicate(array[length], length, array)) {}\n\t      return baseSlice(array, length + 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the beginning. Elements\n\t     * are taken until `predicate` returns falsey. The predicate is bound to\n\t     * `thisArg` and invoked with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per element.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeWhile([1, 2, 3], function(n) { return n < 3; });\n\t     * // => [1, 2]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.takeWhile(users, { 'age': 36, 'active': true }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.takeWhile(users, 'active'), 'user');\n\t     * // => []\n\t     */\n\t    function takeWhile(array, predicate, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      var index = -1;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (++index < length && predicate(array[index], index, array)) {}\n\t      return baseSlice(array, 0, index);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values, in order, of the provided arrays using\n\t     * `SameValueZero` for equality comparisons.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n\t     * // => [1, 2, 3, 5, 4]\n\t     */\n\t    function union() {\n\t      return baseUniq(baseFlatten(arguments, false, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a duplicate-value-free version of an array using `SameValueZero`\n\t     * for equality comparisons. Providing `true` for `isSorted` performs a faster\n\t     * search algorithm for sorted arrays. If an iteratee function is provided it\n\t     * is invoked for each value in the array to generate the criterion by which\n\t     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked\n\t     * with three arguments; (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias unique\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {boolean} [isSorted] Specify the array is sorted.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     *  If a property name or object is provided it is used to create a \"_.property\"\n\t     *  or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new duplicate-value-free array.\n\t     * @example\n\t     *\n\t     * _.uniq([1, 2, 1]);\n\t     * // => [1, 2]\n\t     *\n\t     * // using `isSorted`\n\t     * _.uniq([1, 1, 2], true);\n\t     * // => [1, 2]\n\t     *\n\t     * // using an iteratee function\n\t     * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);\n\t     * // => [1, 2.5]\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    function uniq(array, isSorted, iteratee, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      // Juggle arguments.\n\t      if (typeof isSorted != 'boolean' && isSorted != null) {\n\t        thisArg = iteratee;\n\t        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;\n\t        isSorted = false;\n\t      }\n\t      var func = getCallback();\n\t      if (!(func === baseCallback && iteratee == null)) {\n\t        iteratee = func(iteratee, thisArg, 3);\n\t      }\n\t      return (isSorted && getIndexOf() == baseIndexOf)\n\t        ? sortedUniq(array, iteratee)\n\t        : baseUniq(array, iteratee);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts an array of grouped\n\t     * elements and creates an array regrouping the elements to their pre-`_.zip`\n\t     * configuration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     *\n\t     * _.unzip(zipped);\n\t     * // => [['fred', 'barney'], [30, 40], [true, false]]\n\t     */\n\t    function unzip(array) {\n\t      var index = -1,\n\t          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = arrayMap(array, baseProperty(index));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array excluding all provided values using `SameValueZero` for\n\t     * equality comparisons.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to filter.\n\t     * @param {...*} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n\t     * // => [2, 3, 4]\n\t     */\n\t    function without(array) {\n\t      return baseDifference(array, baseSlice(arguments, 1));\n\t    }\n\t\n\t    /**\n\t     * Creates an array that is the symmetric difference of the provided arrays.\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for\n\t     * more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of values.\n\t     * @example\n\t     *\n\t     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n\t     * // => [3, 5, 4]\n\t     *\n\t     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n\t     * // => [1, 4, 5]\n\t     */\n\t    function xor() {\n\t      var index = -1,\n\t          length = arguments.length;\n\t\n\t      while (++index < length) {\n\t        var array = arguments[index];\n\t        if (isArray(array) || isArguments(array)) {\n\t          var result = result\n\t            ? baseDifference(result, array).concat(baseDifference(array, result))\n\t            : array;\n\t        }\n\t      }\n\t      return result ? baseUniq(result) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of grouped elements, the first of which contains the first\n\t     * elements of the given arrays, the second of which contains the second elements\n\t     * of the given arrays, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     */\n\t    function zip() {\n\t      var length = arguments.length,\n\t          array = Array(length);\n\t\n\t      while (length--) {\n\t        array[length] = arguments[length];\n\t      }\n\t      return unzip(array);\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed from arrays of property names and values. Provide\n\t     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`\n\t     * or two arrays, one of property names and one of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias object\n\t     * @category Array\n\t     * @param {Array} props The property names.\n\t     * @param {Array} [values=[]] The property values.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.zipObject(['fred', 'barney'], [30, 40]);\n\t     * // => { 'fred': 30, 'barney': 40 }\n\t     */\n\t    function zipObject(props, values) {\n\t      var index = -1,\n\t          length = props ? props.length : 0,\n\t          result = {};\n\t\n\t      if (length && !values && !isArray(props[0])) {\n\t        values = [];\n\t      }\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (values) {\n\t          result[key] = values[index];\n\t        } else if (key) {\n\t          result[key[0]] = key[1];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object that wraps `value` with explicit method\n\t     * chaining enabled.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to wrap.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36 },\n\t     *   { 'user': 'fred',    'age': 40 },\n\t     *   { 'user': 'pebbles', 'age': 1 }\n\t     * ];\n\t     *\n\t     * var youngest = _.chain(users)\n\t     *   .sortBy('age')\n\t     *   .map(function(chr) { return chr.user + ' is ' + chr.age; })\n\t     *   .first()\n\t     *   .value();\n\t     * // => 'pebbles is 1'\n\t     */\n\t    function chain(value) {\n\t      var result = lodash(value);\n\t      result.__chain__ = true;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method invokes `interceptor` and returns `value`. The interceptor is\n\t     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n\t     * this method is to \"tap into\" a method chain in order to perform operations\n\t     * on intermediate results within the chain.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @param {*} [thisArg] The `this` binding of `interceptor`.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3])\n\t     *  .tap(function(array) { array.pop(); })\n\t     *  .reverse()\n\t     *  .value();\n\t     * // => [2, 1]\n\t     */\n\t    function tap(value, interceptor, thisArg) {\n\t      interceptor.call(thisArg, value);\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.tap` except that it returns the result of `interceptor`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @param {*} [thisArg] The `this` binding of `interceptor`.\n\t     * @returns {*} Returns the result of `interceptor`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3])\n\t     *  .last()\n\t     *  .thru(function(value) { return [value]; })\n\t     *  .value();\n\t     * // => [3]\n\t     */\n\t    function thru(value, interceptor, thisArg) {\n\t      return interceptor.call(thisArg, value);\n\t    }\n\t\n\t    /**\n\t     * Enables explicit method chaining on the wrapper object.\n\t     *\n\t     * @name chain\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // without explicit chaining\n\t     * _(users).first();\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     *\n\t     * // with explicit chaining\n\t     * _(users).chain()\n\t     *   .first()\n\t     *   .pick('user')\n\t     *   .value();\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function wrapperChain() {\n\t      return chain(this);\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence and returns the wrapped result.\n\t     *\n\t     * @name commit\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapper = _(array).push(3);\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2]\n\t     *\n\t     * wrapper = wrapper.commit();\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * wrapper.last();\n\t     * // => 3\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperCommit() {\n\t      return new LodashWrapper(this.value(), this.__chain__);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n\t     *\n\t     * @name plant\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapper = _(array).map(_.partial(Math.pow, _, 2));\n\t     *\n\t     * var other = [3, 4];\n\t     * var otherWrapper = wrapper.plant(other);\n\t     *\n\t     * otherWrapper.value();\n\t     * // => [9, 16]\n\t     *\n\t     * wrapper.value();\n\t     * // => [1, 4]\n\t     */\n\t    function wrapperPlant(value) {\n\t      var result,\n\t          parent = this;\n\t\n\t      while (parent instanceof LodashWrapper) {\n\t        var clone = wrapperClone(parent);\n\t        if (result) {\n\t          previous.__wrapped__ = clone;\n\t        } else {\n\t          result = clone;\n\t        }\n\t        var previous = clone;\n\t        parent = parent.__wrapped__;\n\t      }\n\t      previous.__wrapped__ = value;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the wrapped array so the first element becomes the last, the\n\t     * second element becomes the second to last, and so on.\n\t     *\n\t     * **Note:** This method mutates the wrapped array.\n\t     *\n\t     * @name reverse\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _(array).reverse().value()\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function wrapperReverse() {\n\t      var value = this.__wrapped__;\n\t      if (value instanceof LazyWrapper) {\n\t        if (this.__actions__.length) {\n\t          value = new LazyWrapper(this);\n\t        }\n\t        return new LodashWrapper(value.reverse(), this.__chain__);\n\t      }\n\t      return this.thru(function(value) {\n\t        return value.reverse();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Produces the result of coercing the unwrapped value to a string.\n\t     *\n\t     * @name toString\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {string} Returns the coerced string value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).toString();\n\t     * // => '1,2,3'\n\t     */\n\t    function wrapperToString() {\n\t      return (this.value() + '');\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence to extract the unwrapped value.\n\t     *\n\t     * @name value\n\t     * @memberOf _\n\t     * @alias run, toJSON, valueOf\n\t     * @category Chain\n\t     * @returns {*} Returns the resolved unwrapped value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).value();\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperValue() {\n\t      return baseWrapperValue(this.__wrapped__, this.__actions__);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements corresponding to the given keys, or indexes,\n\t     * of `collection`. Keys may be specified as individual arguments or as arrays\n\t     * of keys.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {...(number|number[]|string|string[])} [props] The property names\n\t     *  or indexes of elements to pick, specified individually or in arrays.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     * @example\n\t     *\n\t     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n\t     * // => ['a', 'c', 'e']\n\t     *\n\t     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n\t     * // => ['fred', 'pebbles']\n\t     */\n\t    function at(collection) {\n\t      var length = collection ? collection.length : 0;\n\t      if (isLength(length)) {\n\t        collection = toIterable(collection);\n\t      }\n\t      return baseAt(collection, baseFlatten(arguments, false, false, 1));\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is in `collection` using `SameValueZero` for equality\n\t     * comparisons. If `fromIndex` is negative, it is used as the offset from\n\t     * the end of `collection`.\n\t     *\n\t     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n\t     * e.g. `===`, except that `NaN` matches `NaN`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias contains, include\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {*} target The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n\t     * @example\n\t     *\n\t     * _.includes([1, 2, 3], 1);\n\t     * // => true\n\t     *\n\t     * _.includes([1, 2, 3], 1, 2);\n\t     * // => false\n\t     *\n\t     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n\t     * // => true\n\t     *\n\t     * _.includes('pebbles', 'eb');\n\t     * // => true\n\t     */\n\t    function includes(collection, target, fromIndex) {\n\t      var length = collection ? collection.length : 0;\n\t      if (!isLength(length)) {\n\t        collection = values(collection);\n\t        length = collection.length;\n\t      }\n\t      if (!length) {\n\t        return false;\n\t      }\n\t      if (typeof fromIndex == 'number') {\n\t        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n\t      } else {\n\t        fromIndex = 0;\n\t      }\n\t      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n\t        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)\n\t        : (getIndexOf(collection, target, fromIndex) > -1);\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the number of times the key was returned by `iteratee`.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.countBy([4.3, 6.1, 6.4], function(n) { return Math.floor(n); });\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * _.countBy([4.3, 6.1, 6.4], function(n) { return this.floor(n); }, Math);\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * _.countBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': 2, '5': 1 }\n\t     */\n\t    var countBy = createAggregator(function(result, value, key) {\n\t      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n\t    });\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n\t     * The predicate is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias all\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.every([true, 1, null, 'yes']);\n\t     * // => false\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.every(users, { 'age': 36, 'active': false });\n\t     * // => false\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.every(users, 'active', false);\n\t     * // => true\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.every(users, 'active');\n\t     * // => false\n\t     */\n\t    function every(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayEvery : baseEvery;\n\t      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t      }\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning an array of all elements\n\t     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t     * invoked with three arguments; (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias select\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var evens = _.filter([1, 2, 3, 4], function(n) { return n % 2 == 0; });\n\t     * // => [2, 4]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.filter(users, 'active', false), 'user');\n\t     * // => ['fred']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.filter(users, 'active'), 'user');\n\t     * // => ['barney']\n\t     */\n\t    function filter(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning the first element\n\t     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t     * invoked with three arguments; (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias detect\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * _.result(_.find(users, function(chr) { return chr.age < 40; }), 'user');\n\t     * // => 'barney'\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n\t     * // => 'pebbles'\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.result(_.find(users, 'active', false), 'user');\n\t     * // => 'fred'\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.result(_.find(users, 'active'), 'user');\n\t     * // => 'barney'\n\t     */\n\t    function find(collection, predicate, thisArg) {\n\t      if (isArray(collection)) {\n\t        var index = findIndex(collection, predicate, thisArg);\n\t        return index > -1 ? collection[index] : undefined;\n\t      }\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return baseFind(collection, predicate, baseEach);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * _.findLast([1, 2, 3, 4], function(n) { return n % 2 == 1; });\n\t     * // => 3\n\t     */\n\t    function findLast(collection, predicate, thisArg) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return baseFind(collection, predicate, baseEachRight);\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between each element in `collection` and the\n\t     * source object, returning the first element that has equivalent property\n\t     * values.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n\t     * // => 'barney'\n\t     *\n\t     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n\t     * // => 'fred'\n\t     */\n\t    function findWhere(collection, source) {\n\t      return find(collection, baseMatches(source));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection` invoking `iteratee` for each element.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection). Iterator functions may exit iteration early\n\t     * by explicitly returning `false`.\n\t     *\n\t     * **Note:** As with other \"Collections\" methods, objects with a `length` property\n\t     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n\t     * may be used for object iteration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias each\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();\n\t     * // => logs each value from left to right and returns the array\n\t     *\n\t     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });\n\t     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n\t     */\n\t    function forEach(collection, iteratee, thisArg) {\n\t      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))\n\t        ? arrayEach(collection, iteratee)\n\t        : baseEach(collection, bindCallback(iteratee, thisArg, 3));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forEach` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias eachRight\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).forEachRight(function(n) { console.log(n); }).join(',');\n\t     * // => logs each value from right to left and returns the array\n\t     */\n\t    function forEachRight(collection, iteratee, thisArg) {\n\t      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))\n\t        ? arrayEachRight(collection, iteratee)\n\t        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is an array of the elements responsible for generating the key.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });\n\t     * // => { '4': [4.2], '6': [6.1, 6.4] }\n\t     *\n\t     * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);\n\t     * // => { '4': [4.2], '6': [6.1, 6.4] }\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.groupBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': ['one', 'two'], '5': ['three'] }\n\t     */\n\t    var groupBy = createAggregator(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, key)) {\n\t        result[key].push(value);\n\t      } else {\n\t        result[key] = [value];\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the last element responsible for generating the key. The\n\t     * iteratee function is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * var keyData = [\n\t     *   { 'dir': 'left', 'code': 97 },\n\t     *   { 'dir': 'right', 'code': 100 }\n\t     * ];\n\t     *\n\t     * _.indexBy(keyData, 'dir');\n\t     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     */\n\t    var indexBy = createAggregator(function(result, value, key) {\n\t      result[key] = value;\n\t    });\n\t\n\t    /**\n\t     * Invokes the method named by `methodName` on each element in `collection`,\n\t     * returning an array of the results of each invoked method. Any additional\n\t     * arguments are provided to each invoked method. If `methodName` is a function\n\t     * it is invoked for, and `this` bound to, each element in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|string} methodName The name of the method to invoke or\n\t     *  the function invoked per iteration.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n\t     * // => [[1, 5, 7], [1, 2, 3]]\n\t     *\n\t     * _.invoke([123, 456], String.prototype.split, '');\n\t     * // => [['1', '2', '3'], ['4', '5', '6']]\n\t     */\n\t    function invoke(collection, methodName) {\n\t      return baseInvoke(collection, methodName, baseSlice(arguments, 2));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of values by running each element in `collection` through\n\t     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments; (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * Many lodash methods are guarded to work as interatees for methods like\n\t     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t     *\n\t     * The guarded methods are:\n\t     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,\n\t     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,\n\t     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,\n\t     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias collect\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new mapped array.\n\t     * @example\n\t     *\n\t     * _.map([1, 2, 3], function(n) { return n * 3; });\n\t     * // => [3, 6, 9]\n\t     *\n\t     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });\n\t     * // => [3, 6, 9] (iteration order is not guaranteed)\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.map(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     */\n\t    function map(collection, iteratee, thisArg) {\n\t      var func = isArray(collection) ? arrayMap : baseMap;\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      return func(collection, iteratee);\n\t    }\n\t\n\t    /**\n\t     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n\t     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n\t     * for each value in `collection` to generate the criterion by which the value\n\t     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments; (value, index, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     *  If a property name or object is provided it is used to create a \"_.property\"\n\t     *  or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * _.max([4, 2, 8, 6]);\n\t     * // => 8\n\t     *\n\t     * _.max([]);\n\t     * // => -Infinity\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.max(users, function(chr) { return chr.age; });\n\t     * // => { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.max(users, 'age');\n\t     * // => { 'user': 'fred', 'age': 40 };\n\t     */\n\t    var max = createExtremum(arrayMax);\n\t\n\t    /**\n\t     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n\t     * `Infinity` is returned. If an iteratee function is provided it is invoked\n\t     * for each value in `collection` to generate the criterion by which the value\n\t     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments; (value, index, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     *  If a property name or object is provided it is used to create a \"_.property\"\n\t     *  or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * _.min([4, 2, 8, 6]);\n\t     * // => 2\n\t     *\n\t     * _.min([]);\n\t     * // => Infinity\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.min(users, function(chr) { return chr.age; });\n\t     * // => { 'user': 'barney', 'age': 36 };\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.min(users, 'age');\n\t     * // => { 'user': 'barney', 'age': 36 };\n\t     */\n\t    var min = createExtremum(arrayMin, true);\n\t\n\t    /**\n\t     * Creates an array of elements split into two groups, the first of which\n\t     * contains elements `predicate` returns truthy for, while the second of which\n\t     * contains elements `predicate` returns falsey for. The predicate is bound\n\t     * to `thisArg` and invoked with three arguments; (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.partition([1, 2, 3], function(n) { return n % 2; });\n\t     * // => [[1, 3], [2]]\n\t     *\n\t     * _.partition([1.2, 2.3, 3.4], function(n) { return this.floor(n) % 2; }, Math);\n\t     * // => [[1, 3], [2]]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': true },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * var mapper = function(array) { return _.pluck(array, 'user'); };\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n\t     * // => [['pebbles'], ['barney', 'fred']]\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.map(_.partition(users, 'active', false), mapper);\n\t     * // => [['barney', 'pebbles'], ['fred']]\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.map(_.partition(users, 'active'), mapper);\n\t     * // => [['fred'], ['barney', 'pebbles']]\n\t     */\n\t    var partition = createAggregator(function(result, value, key) {\n\t      result[key ? 0 : 1].push(value);\n\t    }, function() { return [[], []]; });\n\t\n\t    /**\n\t     * Gets the value of `key` from all elements in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {string} key The key of the property to pluck.\n\t     * @returns {Array} Returns the property values.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.pluck(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * var userIndex = _.indexBy(users, 'user');\n\t     * _.pluck(userIndex, 'age');\n\t     * // => [36, 40] (iteration order is not guaranteed)\n\t     */\n\t    function pluck(collection, key) {\n\t      return map(collection, baseProperty(key));\n\t    }\n\t\n\t    /**\n\t     * Reduces `collection` to a value which is the accumulated result of running\n\t     * each element in `collection` through `iteratee`, where each successive\n\t     * invocation is supplied the return value of the previous. If `accumulator`\n\t     * is not provided the first element of `collection` is used as the initial\n\t     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;\n\t     * (accumulator, value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as interatees for methods like\n\t     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t     *\n\t     * The guarded methods are:\n\t     * `assign`, `defaults`, `merge`, and `sortAllBy`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias foldl, inject\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * var sum = _.reduce([1, 2, 3], function(sum, n) { return sum + n; });\n\t     * // => 6\n\t     *\n\t     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {\n\t     *   result[key] = n * 3;\n\t     *   return result;\n\t     * }, {});\n\t     * // => { 'a': 3, 'b': 6, 'c': 9 } (iteration order is not guaranteed)\n\t     */\n\t    function reduce(collection, iteratee, accumulator, thisArg) {\n\t      var func = isArray(collection) ? arrayReduce : baseReduce;\n\t      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.reduce` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias foldr\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * var array = [[0, 1], [2, 3], [4, 5]];\n\t     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);\n\t     * // => [4, 5, 2, 3, 0, 1]\n\t     */\n\t    function reduceRight(collection, iteratee, accumulator, thisArg) {\n\t      var func = isArray(collection) ? arrayReduceRight : baseReduce;\n\t      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.filter`; this method returns the elements of `collection`\n\t     * that `predicate` does **not** return truthy for.\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var odds = _.reject([1, 2, 3, 4], function(n) { return n % 2 == 0; });\n\t     * // => [1, 3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.pluck(_.reject(users, 'active', false), 'user');\n\t     * // => ['fred']\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.reject(users, 'active'), 'user');\n\t     * // => ['barney']\n\t     */\n\t    function reject(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return func(collection, function(value, index, collection) {\n\t        return !predicate(value, index, collection);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets a random element or `n` random elements from a collection.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to sample.\n\t     * @param {number} [n] The number of elements to sample.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {*} Returns the random sample(s).\n\t     * @example\n\t     *\n\t     * _.sample([1, 2, 3, 4]);\n\t     * // => 2\n\t     *\n\t     * _.sample([1, 2, 3, 4], 2);\n\t     * // => [3, 1]\n\t     */\n\t    function sample(collection, n, guard) {\n\t      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n\t        collection = toIterable(collection);\n\t        var length = collection.length;\n\t        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n\t      }\n\t      var result = shuffle(collection);\n\t      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of shuffled values, using a version of the Fisher-Yates\n\t     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     * @example\n\t     *\n\t     * _.shuffle([1, 2, 3, 4]);\n\t     * // => [4, 1, 3, 2]\n\t     */\n\t    function shuffle(collection) {\n\t      collection = toIterable(collection);\n\t\n\t      var index = -1,\n\t          length = collection.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        var rand = baseRandom(0, index);\n\t        if (index != rand) {\n\t          result[index] = result[rand];\n\t        }\n\t        result[rand] = collection[index];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the size of `collection` by returning `collection.length` for\n\t     * array-like values or the number of own enumerable properties for objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to inspect.\n\t     * @returns {number} Returns the size of `collection`.\n\t     * @example\n\t     *\n\t     * _.size([1, 2]);\n\t     * // => 2\n\t     *\n\t     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n\t     * // => 3\n\t     *\n\t     * _.size('pebbles');\n\t     * // => 7\n\t     */\n\t    function size(collection) {\n\t      var length = collection ? collection.length : 0;\n\t      return isLength(length) ? length : keys(collection).length;\n\t    }\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **any** element of `collection`.\n\t     * The function returns as soon as it finds a passing value and does not iterate\n\t     * over the entire collection. The predicate is bound to `thisArg` and invoked\n\t     * with three arguments; (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias any\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.some([null, 0, 'yes', false], Boolean);\n\t     * // => true\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true }\n\t     * ];\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.some(users, { 'age': 1, 'active': true });\n\t     * // => false\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.some(users, 'active', false);\n\t     * // => true\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.some(users, 'active');\n\t     * // => true\n\t     */\n\t    function some(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arraySome : baseSome;\n\t      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t      }\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements, sorted in ascending order by the results of\n\t     * running each element in a collection through `iteratee`. This method performs\n\t     * a stable sort, that is, it preserves the original sort order of equal elements.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Array|Function|Object|string} [iteratee=_.identity] The function\n\t     *  invoked per iteration. If a property name or an object is provided it is\n\t     *  used to create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });\n\t     * // => [3, 1, 2]\n\t     *\n\t     * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);\n\t     * // => [3, 1, 2]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred' },\n\t     *   { 'user': 'pebbles' },\n\t     *   { 'user': 'barney' }\n\t     * ];\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.pluck(_.sortBy(users, 'user'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function sortBy(collection, iteratee, thisArg) {\n\t      var index = -1,\n\t          length = collection ? collection.length : 0,\n\t          result = isLength(length) ? Array(length) : [];\n\t\n\t      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t        iteratee = null;\n\t      }\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      baseEach(collection, function(value, key, collection) {\n\t        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };\n\t      });\n\t      return baseSortBy(result, compareAscending);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortBy` except that it sorts by property names\n\t     * instead of an iteratee function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {...(string|string[])} props The property names to sort by,\n\t     *  specified as individual property names or arrays of property names.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 },\n\t     *   { 'user': 'barney', 'age': 26 },\n\t     *   { 'user': 'fred',   'age': 30 }\n\t     * ];\n\t     *\n\t     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n\t     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n\t     */\n\t    function sortByAll(collection) {\n\t      var args = arguments;\n\t      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {\n\t        args = [collection, args[1]];\n\t      }\n\t      var index = -1,\n\t          length = collection ? collection.length : 0,\n\t          props = baseFlatten(args, false, false, 1),\n\t          result = isLength(length) ? Array(length) : [];\n\t\n\t      baseEach(collection, function(value) {\n\t        var length = props.length,\n\t            criteria = Array(length);\n\t\n\t        while (length--) {\n\t          criteria[length] = value == null ? undefined : value[props[length]];\n\t        }\n\t        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };\n\t      });\n\t      return baseSortBy(result, compareMultipleAscending);\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between each element in `collection` and the\n\t     * source object, returning an array of all elements that have equivalent\n\t     * property values.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n\t     * ];\n\t     *\n\t     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n\t     * // => ['fred']\n\t     */\n\t    function where(collection, source) {\n\t      return filter(collection, baseMatches(source));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Gets the number of milliseconds that have elapsed since the Unix epoch\n\t     * (1 January 1970 00:00:00 UTC).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Date\n\t     * @example\n\t     *\n\t     * _.defer(function(stamp) { console.log(_.now() - stamp); }, _.now());\n\t     * // => logs the number of milliseconds it took for the deferred function to be invoked\n\t     */\n\t    var now = nativeNow || function() {\n\t      return new Date().getTime();\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The opposite of `_.before`; this method creates a function that invokes\n\t     * `func` once it is called `n` or more times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls before `func` is invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var saves = ['profile', 'settings'];\n\t     *\n\t     * var done = _.after(saves.length, function() {\n\t     *   console.log('done saving!');\n\t     * });\n\t     *\n\t     * _.forEach(saves, function(type) {\n\t     *   asyncSave({ 'type': type, 'complete': done });\n\t     * });\n\t     * // => logs 'done saving!' after the two async saves have completed\n\t     */\n\t    function after(n, func) {\n\t      if (typeof func != 'function') {\n\t        if (typeof n == 'function') {\n\t          var temp = n;\n\t          n = func;\n\t          func = temp;\n\t        } else {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t      }\n\t      n = nativeIsFinite(n = +n) ? n : 0;\n\t      return function() {\n\t        if (--n < 1) {\n\t          return func.apply(this, arguments);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts up to `n` arguments ignoring any\n\t     * additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @param {number} [n=func.length] The arity cap.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function ary(func, n, guard) {\n\t      if (guard && isIterateeCall(func, n, guard)) {\n\t        n = null;\n\t      }\n\t      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n\t      return createWrapper(func, ARY_FLAG, null, null, null, null, n);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func`, with the `this` binding and arguments\n\t     * of the created function, while it is called less than `n` times. Subsequent\n\t     * calls to the created function return the result of the last `func` invocation.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls at which `func` is no longer invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * jQuery('#add').on('click', _.before(5, addContactToList));\n\t     * // => allows adding up to 4 contacts to the list\n\t     */\n\t    function before(n, func) {\n\t      var result;\n\t      if (typeof func != 'function') {\n\t        if (typeof n == 'function') {\n\t          var temp = n;\n\t          n = func;\n\t          func = temp;\n\t        } else {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t      }\n\t      return function() {\n\t        if (--n > 0) {\n\t          result = func.apply(this, arguments);\n\t        } else {\n\t          func = null;\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and prepends any additional `_.bind` arguments to those provided to the\n\t     * bound function.\n\t     *\n\t     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** Unlike native `Function#bind` this method does not set the `length`\n\t     * property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {...*} [args] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, punctuation) {\n\t     *   return greeting + ' ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * var bound = _.bind(greet, object, 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bind(greet, object, _, '!');\n\t     * bound('hi');\n\t     * // => 'hi fred!'\n\t     */\n\t    function bind(func, thisArg) {\n\t      var bitmask = BIND_FLAG;\n\t      if (arguments.length > 2) {\n\t        var partials = baseSlice(arguments, 2),\n\t            holders = replaceHolders(partials, bind.placeholder);\n\t\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(func, bitmask, thisArg, partials, holders);\n\t    }\n\t\n\t    /**\n\t     * Binds methods of an object to the object itself, overwriting the existing\n\t     * method. Method names may be specified as individual arguments or as arrays\n\t     * of method names. If no method names are provided all enumerable function\n\t     * properties, own and inherited, of `object` are bound.\n\t     *\n\t     * **Note:** This method does not set the `length` property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Object} object The object to bind and assign the bound methods to.\n\t     * @param {...(string|string[])} [methodNames] The object method names to bind,\n\t     *  specified as individual method names or arrays of method names.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var view = {\n\t     *   'label': 'docs',\n\t     *   'onClick': function() { console.log('clicked ' + this.label); }\n\t     * };\n\t     *\n\t     * _.bindAll(view);\n\t     * jQuery('#docs').on('click', view.onClick);\n\t     * // => logs 'clicked docs' when the element is clicked\n\t     */\n\t    function bindAll(object) {\n\t      return baseBindAll(object,\n\t        arguments.length > 1\n\t          ? baseFlatten(arguments, false, false, 1)\n\t          : functions(object)\n\t      );\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `object[key]` and prepends\n\t     * any additional `_.bindKey` arguments to those provided to the bound function.\n\t     *\n\t     * This method differs from `_.bind` by allowing bound functions to reference\n\t     * methods that may be redefined or don't yet exist.\n\t     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)\n\t     * for more details.\n\t     *\n\t     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Object} object The object the method belongs to.\n\t     * @param {string} key The key of the method.\n\t     * @param {...*} [args] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var object = {\n\t     *   'user': 'fred',\n\t     *   'greet': function(greeting, punctuation) {\n\t     *     return greeting + ' ' + this.user + punctuation;\n\t     *   }\n\t     * };\n\t     *\n\t     * var bound = _.bindKey(object, 'greet', 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * object.greet = function(greeting, punctuation) {\n\t     *   return greeting + 'ya ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * bound('!');\n\t     * // => 'hiya fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bindKey(object, 'greet', _, '!');\n\t     * bound('hi');\n\t     * // => 'hiya fred!'\n\t     */\n\t    function bindKey(object, key) {\n\t      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n\t      if (arguments.length > 2) {\n\t        var partials = baseSlice(arguments, 2),\n\t            holders = replaceHolders(partials, bindKey.placeholder);\n\t\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(key, bitmask, object, partials, holders);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts one or more arguments of `func` that when\n\t     * called either invokes `func` returning its result, if all `func` arguments\n\t     * have been provided, or returns a function that accepts one or more of the\n\t     * remaining `func` arguments, and so on. The arity of `func` may be specified\n\t     * if `func.length` is not sufficient.\n\t     *\n\t     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method does not set the `length` property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curry(abc);\n\t     *\n\t     * curried(1)(2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(1)(_, 3)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curry(func, arity, guard) {\n\t      if (guard && isIterateeCall(func, arity, guard)) {\n\t        arity = null;\n\t      }\n\t      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);\n\t      result.placeholder = curry.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.curry` except that arguments are applied to `func`\n\t     * in the manner of `_.partialRight` instead of `_.partial`.\n\t     *\n\t     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method does not set the `length` property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curryRight(abc);\n\t     *\n\t     * curried(3)(2)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(2, 3)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(3)(1, _)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curryRight(func, arity, guard) {\n\t      if (guard && isIterateeCall(func, arity, guard)) {\n\t        arity = null;\n\t      }\n\t      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);\n\t      result.placeholder = curryRight.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that delays invoking `func` until after `wait` milliseconds\n\t     * have elapsed since the last time it was invoked. The created function comes\n\t     * with a `cancel` method to cancel delayed invocations. Provide an options\n\t     * object to indicate that `func` should be invoked on the leading and/or\n\t     * trailing edge of the `wait` timeout. Subsequent calls to the debounced\n\t     * function return the result of the last `func` invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the debounced function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.debounce` and `_.throttle`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to debounce.\n\t     * @param {number} wait The number of milliseconds to delay.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=false] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n\t     *  delayed before it is invoked.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new debounced function.\n\t     * @example\n\t     *\n\t     * // avoid costly calculations while the window size is in flux\n\t     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t     *\n\t     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n\t     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n\t     *   'leading': true,\n\t     *   'trailing': false\n\t     * }));\n\t     *\n\t     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n\t     * var source = new EventSource('/stream');\n\t     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n\t     *   'maxWait': 1000\n\t     * }));\n\t     *\n\t     * // cancel a debounced call\n\t     * var todoChanges = _.debounce(batchLog, 1000);\n\t     * Object.observe(models.todo, todoChanges);\n\t     *\n\t     * Object.observe(models, function(changes) {\n\t     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n\t     *     todoChanges.cancel();\n\t     *   }\n\t     * }, ['delete']);\n\t     *\n\t     * // ...at some point `models.todo` is changed\n\t     * models.todo.completed = true;\n\t     *\n\t     * // ...before 1 second has passed `models.todo` is deleted\n\t     * // which cancels the debounced `todoChanges` call\n\t     * delete models.todo;\n\t     */\n\t    function debounce(func, wait, options) {\n\t      var args,\n\t          maxTimeoutId,\n\t          result,\n\t          stamp,\n\t          thisArg,\n\t          timeoutId,\n\t          trailingCall,\n\t          lastCalled = 0,\n\t          maxWait = false,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      wait = wait < 0 ? 0 : wait;\n\t      if (options === true) {\n\t        var leading = true;\n\t        trailing = false;\n\t      } else if (isObject(options)) {\n\t        leading = options.leading;\n\t        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n\t        trailing = 'trailing' in options ? options.trailing : trailing;\n\t      }\n\t\n\t      function cancel() {\n\t        if (timeoutId) {\n\t          clearTimeout(timeoutId);\n\t        }\n\t        if (maxTimeoutId) {\n\t          clearTimeout(maxTimeoutId);\n\t        }\n\t        maxTimeoutId = timeoutId = trailingCall = undefined;\n\t      }\n\t\n\t      function delayed() {\n\t        var remaining = wait - (now() - stamp);\n\t        if (remaining <= 0 || remaining > wait) {\n\t          if (maxTimeoutId) {\n\t            clearTimeout(maxTimeoutId);\n\t          }\n\t          var isCalled = trailingCall;\n\t          maxTimeoutId = timeoutId = trailingCall = undefined;\n\t          if (isCalled) {\n\t            lastCalled = now();\n\t            result = func.apply(thisArg, args);\n\t            if (!timeoutId && !maxTimeoutId) {\n\t              args = thisArg = null;\n\t            }\n\t          }\n\t        } else {\n\t          timeoutId = setTimeout(delayed, remaining);\n\t        }\n\t      }\n\t\n\t      function maxDelayed() {\n\t        if (timeoutId) {\n\t          clearTimeout(timeoutId);\n\t        }\n\t        maxTimeoutId = timeoutId = trailingCall = undefined;\n\t        if (trailing || (maxWait !== wait)) {\n\t          lastCalled = now();\n\t          result = func.apply(thisArg, args);\n\t          if (!timeoutId && !maxTimeoutId) {\n\t            args = thisArg = null;\n\t          }\n\t        }\n\t      }\n\t\n\t      function debounced() {\n\t        args = arguments;\n\t        stamp = now();\n\t        thisArg = this;\n\t        trailingCall = trailing && (timeoutId || !leading);\n\t\n\t        if (maxWait === false) {\n\t          var leadingCall = leading && !timeoutId;\n\t        } else {\n\t          if (!maxTimeoutId && !leading) {\n\t            lastCalled = stamp;\n\t          }\n\t          var remaining = maxWait - (stamp - lastCalled),\n\t              isCalled = remaining <= 0 || remaining > maxWait;\n\t\n\t          if (isCalled) {\n\t            if (maxTimeoutId) {\n\t              maxTimeoutId = clearTimeout(maxTimeoutId);\n\t            }\n\t            lastCalled = stamp;\n\t            result = func.apply(thisArg, args);\n\t          }\n\t          else if (!maxTimeoutId) {\n\t            maxTimeoutId = setTimeout(maxDelayed, remaining);\n\t          }\n\t        }\n\t        if (isCalled && timeoutId) {\n\t          timeoutId = clearTimeout(timeoutId);\n\t        }\n\t        else if (!timeoutId && wait !== maxWait) {\n\t          timeoutId = setTimeout(delayed, wait);\n\t        }\n\t        if (leadingCall) {\n\t          isCalled = true;\n\t          result = func.apply(thisArg, args);\n\t        }\n\t        if (isCalled && !timeoutId && !maxTimeoutId) {\n\t          args = thisArg = null;\n\t        }\n\t        return result;\n\t      }\n\t      debounced.cancel = cancel;\n\t      return debounced;\n\t    }\n\t\n\t    /**\n\t     * Defers invoking the `func` until the current call stack has cleared. Any\n\t     * additional arguments are provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to defer.\n\t     * @param {...*} [args] The arguments to invoke the function with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.defer(function(text) { console.log(text); }, 'deferred');\n\t     * // logs 'deferred' after one or more milliseconds\n\t     */\n\t    function defer(func) {\n\t      return baseDelay(func, 1, arguments, 1);\n\t    }\n\t\n\t    /**\n\t     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n\t     * provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {...*} [args] The arguments to invoke the function with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n\t     * // => logs 'later' after one second\n\t     */\n\t    function delay(func, wait) {\n\t      return baseDelay(func, wait, arguments, 2);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns the result of invoking the provided\n\t     * functions with the `this` binding of the created function, where each\n\t     * successive invocation is supplied the return value of the previous.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {...Function} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function add(x, y) {\n\t     *   return x + y;\n\t     * }\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flow(add, square);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    function flow() {\n\t      var funcs = arguments,\n\t          length = funcs.length;\n\t\n\t      if (!length) {\n\t        return function() { return arguments[0]; };\n\t      }\n\t      if (!arrayEvery(funcs, isFunction)) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        var index = 0,\n\t            result = funcs[index].apply(this, arguments);\n\t\n\t        while (++index < length) {\n\t          result = funcs[index].call(this, result);\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.flow` except that it creates a function that\n\t     * invokes the provided functions from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias backflow, compose\n\t     * @category Function\n\t     * @param {...Function} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function add(x, y) {\n\t     *   return x + y;\n\t     * }\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flowRight(square, add);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    function flowRight() {\n\t      var funcs = arguments,\n\t          fromIndex = funcs.length - 1;\n\t\n\t      if (fromIndex < 0) {\n\t        return function() { return arguments[0]; };\n\t      }\n\t      if (!arrayEvery(funcs, isFunction)) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        var index = fromIndex,\n\t            result = funcs[index].apply(this, arguments);\n\t\n\t        while (index--) {\n\t          result = funcs[index].call(this, result);\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that memoizes the result of `func`. If `resolver` is\n\t     * provided it determines the cache key for storing the result based on the\n\t     * arguments provided to the memoized function. By default, the first argument\n\t     * provided to the memoized function is coerced to a string and used as the\n\t     * cache key. The `func` is invoked with the `this` binding of the memoized\n\t     * function.\n\t     *\n\t     * **Note:** The cache is exposed as the `cache` property on the memoized\n\t     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t     * constructor with one whose instances implement the ES `Map` method interface\n\t     * of `get`, `has`, and `set`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to have its output memoized.\n\t     * @param {Function} [resolver] The function to resolve the cache key.\n\t     * @returns {Function} Returns the new memoizing function.\n\t     * @example\n\t     *\n\t     * var upperCase = _.memoize(function(string) {\n\t     *   return string.toUpperCase();\n\t     * });\n\t     *\n\t     * upperCase('fred');\n\t     * // => 'FRED'\n\t     *\n\t     * // modifying the result cache\n\t     * upperCase.cache.set('fred', 'BARNEY');\n\t     * upperCase('fred');\n\t     * // => 'BARNEY'\n\t     *\n\t     * // replacing `_.memoize.Cache`\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'barney' };\n\t     * var identity = _.memoize(_.identity);\n\t     *\n\t     * identity(object);\n\t     * // => { 'user': 'fred' }\n\t     * identity(other);\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.memoize.Cache = WeakMap;\n\t     * var identity = _.memoize(_.identity);\n\t     *\n\t     * identity(object);\n\t     * // => { 'user': 'fred' }\n\t     * identity(other);\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function memoize(func, resolver) {\n\t      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var memoized = function() {\n\t        var cache = memoized.cache,\n\t            key = resolver ? resolver.apply(this, arguments) : arguments[0];\n\t\n\t        if (cache.has(key)) {\n\t          return cache.get(key);\n\t        }\n\t        var result = func.apply(this, arguments);\n\t        cache.set(key, result);\n\t        return result;\n\t      };\n\t      memoized.cache = new memoize.Cache;\n\t      return memoized;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that negates the result of the predicate `func`. The\n\t     * `func` predicate is invoked with the `this` binding and arguments of the\n\t     * created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} predicate The predicate to negate.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function isEven(n) {\n\t     *   return n % 2 == 0;\n\t     * }\n\t     *\n\t     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n\t     * // => [1, 3, 5]\n\t     */\n\t    function negate(predicate) {\n\t      if (typeof predicate != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        return !predicate.apply(this, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that is restricted to invoking `func` once. Repeat calls\n\t     * to the function return the value of the first call. The `func` is invoked\n\t     * with the `this` binding of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var initialize = _.once(createApplication);\n\t     * initialize();\n\t     * initialize();\n\t     * // `initialize` invokes `createApplication` once\n\t     */\n\t    function once(func) {\n\t      return before(func, 2);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with `partial` arguments prepended\n\t     * to those provided to the new function. This method is like `_.bind` except\n\t     * it does **not** alter the `this` binding.\n\t     *\n\t     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method does not set the `length` property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [args] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var sayHelloTo = _.partial(greet, 'hello');\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     *\n\t     * // using placeholders\n\t     * var greetFred = _.partial(greet, _, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     */\n\t    function partial(func) {\n\t      var partials = baseSlice(arguments, 1),\n\t          holders = replaceHolders(partials, partial.placeholder);\n\t\n\t      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.partial` except that partially applied arguments\n\t     * are appended to those provided to the new function.\n\t     *\n\t     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method does not set the `length` property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [args] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var greetFred = _.partialRight(greet, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     *\n\t     * // using placeholders\n\t     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     */\n\t    function partialRight(func) {\n\t      var partials = baseSlice(arguments, 1),\n\t          holders = replaceHolders(partials, partialRight.placeholder);\n\t\n\t      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments arranged according\n\t     * to the specified indexes where the argument value at the first index is\n\t     * provided as the first argument, the argument value at the second index is\n\t     * provided as the second argument, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to rearrange arguments for.\n\t     * @param {...(number|number[])} indexes The arranged argument indexes,\n\t     *  specified as individual indexes or arrays of indexes.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var rearged = _.rearg(function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * }, 2, 0, 1);\n\t     *\n\t     * rearged('b', 'c', 'a')\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * var map = _.rearg(_.map, [1, 0]);\n\t     * map(function(n) { return n * 3; }, [1, 2, 3]);\n\t     * // => [3, 6, 9]\n\t     */\n\t    function rearg(func) {\n\t      var indexes = baseFlatten(arguments, false, false, 1);\n\t      return createWrapper(func, REARG_FLAG, null, null, null, indexes);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the\n\t     * created function and the array of arguments provided to the created\n\t     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to spread arguments over.\n\t     * @returns {*} Returns the new function.\n\t     * @example\n\t     *\n\t     * var spread = _.spread(function(who, what) {\n\t     *   return who + ' says ' + what;\n\t     * });\n\t     *\n\t     * spread(['Fred', 'hello']);\n\t     * // => 'Fred says hello'\n\t     *\n\t     * // with a Promise\n\t     * var numbers = Promise.all([\n\t     *   Promise.resolve(40),\n\t     *   Promise.resolve(36)\n\t     * ]);\n\t     *\n\t     * var add = function(x, y) {\n\t     *   return x + y;\n\t     * };\n\t     *\n\t     * numbers.then(_.spread(add));\n\t     * // => a Promise of 76\n\t     */\n\t    function spread(func) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function(array) {\n\t        return func.apply(this, array);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that only invokes `func` at most once per every `wait`\n\t     * milliseconds. The created function comes with a `cancel` method to cancel\n\t     * delayed invocations. Provide an options object to indicate that `func`\n\t     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n\t     * Subsequent calls to the throttled function return the result of the last\n\t     * `func` call.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the throttled function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.throttle` and `_.debounce`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to throttle.\n\t     * @param {number} wait The number of milliseconds to throttle invocations to.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=true] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new throttled function.\n\t     * @example\n\t     *\n\t     * // avoid excessively updating the position while scrolling\n\t     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t     *\n\t     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n\t     * var throttled =  _.throttle(renewToken, 300000, { 'trailing': false })\n\t     * jQuery('.interactive').on('click', throttled);\n\t     *\n\t     * // cancel a trailing throttled call\n\t     * jQuery(window).on('popstate', throttled.cancel);\n\t     */\n\t    function throttle(func, wait, options) {\n\t      var leading = true,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      if (options === false) {\n\t        leading = false;\n\t      } else if (isObject(options)) {\n\t        leading = 'leading' in options ? !!options.leading : leading;\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t      debounceOptions.leading = leading;\n\t      debounceOptions.maxWait = +wait;\n\t      debounceOptions.trailing = trailing;\n\t      return debounce(func, wait, debounceOptions);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that provides `value` to the wrapper function as its\n\t     * first argument. Any additional arguments provided to the function are\n\t     * appended to those provided to the wrapper function. The wrapper is invoked\n\t     * with the `this` binding of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {*} value The value to wrap.\n\t     * @param {Function} wrapper The wrapper function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var p = _.wrap(_.escape, function(func, text) {\n\t     *   return '<p>' + func(text) + '</p>';\n\t     * });\n\t     *\n\t     * p('fred, barney, & pebbles');\n\t     * // => '<p>fred, barney, &amp; pebbles</p>'\n\t     */\n\t    function wrap(value, wrapper) {\n\t      wrapper = wrapper == null ? identity : wrapper;\n\t      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n\t     * otherwise they are assigned by reference. If `customizer` is provided it is\n\t     * invoked to produce the cloned values. If `customizer` returns `undefined`\n\t     * cloning is handled by the method instead. The `customizer` is bound to\n\t     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n\t     *\n\t     * **Note:** This method is loosely based on the structured clone algorithm.\n\t     * The enumerable properties of `arguments` objects and objects created by\n\t     * constructors other than `Object` are cloned to plain `Object` objects. An\n\t     * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {*} Returns the cloned value.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * var shallow = _.clone(users);\n\t     * shallow[0] === users[0];\n\t     * // => true\n\t     *\n\t     * var deep = _.clone(users, true);\n\t     * deep[0] === users[0];\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var body = _.clone(document.body, function(value) {\n\t     *   return _.isElement(value) ? value.cloneNode(false) : undefined;\n\t     * });\n\t     *\n\t     * body === document.body\n\t     * // => false\n\t     * body.nodeName\n\t     * // => BODY\n\t     * body.childNodes.length;\n\t     * // => 0\n\t     */\n\t    function clone(value, isDeep, customizer, thisArg) {\n\t      // Juggle arguments.\n\t      if (typeof isDeep != 'boolean' && isDeep != null) {\n\t        thisArg = customizer;\n\t        customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;\n\t        isDeep = false;\n\t      }\n\t      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n\t      return baseClone(value, isDeep, customizer);\n\t    }\n\t\n\t    /**\n\t     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n\t     * to produce the cloned values. If `customizer` returns `undefined` cloning\n\t     * is handled by the method instead. The `customizer` is bound to `thisArg`\n\t     * and invoked with two argument; (value [, index|key, object]).\n\t     *\n\t     * **Note:** This method is loosely based on the structured clone algorithm.\n\t     * The enumerable properties of `arguments` objects and objects created by\n\t     * constructors other than `Object` are cloned to plain `Object` objects. An\n\t     * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * var deep = _.cloneDeep(users);\n\t     * deep[0] === users[0];\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var el = _.cloneDeep(document.body, function(value) {\n\t     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n\t     * });\n\t     *\n\t     * body === document.body\n\t     * // => false\n\t     * body.nodeName\n\t     * // => BODY\n\t     * body.childNodes.length;\n\t     * // => 20\n\t     */\n\t    function cloneDeep(value, customizer, thisArg) {\n\t      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n\t      return baseClone(value, true, customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `arguments` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * (function() { return _.isArguments(arguments); })();\n\t     * // => true\n\t     *\n\t     * _.isArguments([1, 2, 3]);\n\t     * // => false\n\t     */\n\t    function isArguments(value) {\n\t      var length = isObjectLike(value) ? value.length : undefined;\n\t      return (isLength(length) && objToString.call(value) == argsTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `Array` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArray([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * (function() { return _.isArray(arguments); })();\n\t     * // => false\n\t     */\n\t    var isArray = nativeIsArray || function(value) {\n\t      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;\n\t    };\n\t\n\t    /**\n\t     * Checks if `value` is classified as a boolean primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isBoolean(false);\n\t     * // => true\n\t     *\n\t     * _.isBoolean(null);\n\t     * // => false\n\t     */\n\t    function isBoolean(value) {\n\t      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Date` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isDate(new Date);\n\t     * // => true\n\t     *\n\t     * _.isDate('Mon April 23 2012');\n\t     * // => false\n\t     */\n\t    function isDate(value) {\n\t      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a DOM element.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n\t     * @example\n\t     *\n\t     * _.isElement(document.body);\n\t     * // => true\n\t     *\n\t     * _.isElement('<body>');\n\t     * // => false\n\t     */\n\t    function isElement(value) {\n\t      return (value && value.nodeType === 1 && isObjectLike(value) &&\n\t        objToString.call(value).indexOf('Element') > -1) || false;\n\t    }\n\t    // Fallback for environments without DOM support.\n\t    if (!support.dom) {\n\t      isElement = function(value) {\n\t        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Checks if a value is empty. A value is considered empty unless it is an\n\t     * `arguments` object, array, string, or jQuery-like collection with a length\n\t     * greater than `0` or an object with own enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Array|Object|string} value The value to inspect.\n\t     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t     * @example\n\t     *\n\t     * _.isEmpty(null);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(true);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(1);\n\t     * // => true\n\t     *\n\t     * _.isEmpty([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isEmpty({ 'a': 1 });\n\t     * // => false\n\t     */\n\t    function isEmpty(value) {\n\t      if (value == null) {\n\t        return true;\n\t      }\n\t      var length = value.length;\n\t      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||\n\t          (isObjectLike(value) && isFunction(value.splice)))) {\n\t        return !length;\n\t      }\n\t      return !keys(value).length;\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between two values to determine if they are\n\t     * equivalent. If `customizer` is provided it is invoked to compare values.\n\t     * If `customizer` returns `undefined` comparisons are handled by the method\n\t     * instead. The `customizer` is bound to `thisArg` and invoked with three\n\t     * arguments; (value, other [, index|key]).\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. Functions and DOM nodes\n\t     * are **not** supported. Provide a customizer function to extend support\n\t     * for comparing other values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'fred' };\n\t     *\n\t     * object == other;\n\t     * // => false\n\t     *\n\t     * _.isEqual(object, other);\n\t     * // => true\n\t     *\n\t     * // using a customizer callback\n\t     * var array = ['hello', 'goodbye'];\n\t     * var other = ['hi', 'goodbye'];\n\t     *\n\t     * _.isEqual(array, other, function(value, other) {\n\t     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n\t     * });\n\t     * // => true\n\t     */\n\t    function isEqual(value, other, customizer, thisArg) {\n\t      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n\t      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {\n\t        return value === other;\n\t      }\n\t      var result = customizer ? customizer(value, other) : undefined;\n\t      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n\t     * `SyntaxError`, `TypeError`, or `URIError` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isError(new Error);\n\t     * // => true\n\t     *\n\t     * _.isError(Error);\n\t     * // => false\n\t     */\n\t    function isError(value) {\n\t      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a finite primitive number.\n\t     *\n\t     * **Note:** This method is based on ES `Number.isFinite`. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFinite(10);\n\t     * // => true\n\t     *\n\t     * _.isFinite('10');\n\t     * // => false\n\t     *\n\t     * _.isFinite(true);\n\t     * // => false\n\t     *\n\t     * _.isFinite(Object(10));\n\t     * // => false\n\t     *\n\t     * _.isFinite(Infinity);\n\t     * // => false\n\t     */\n\t    var isFinite = nativeNumIsFinite || function(value) {\n\t      return typeof value == 'number' && nativeIsFinite(value);\n\t    };\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Function` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFunction(_);\n\t     * // => true\n\t     *\n\t     * _.isFunction(/abc/);\n\t     * // => false\n\t     */\n\t    function isFunction(value) {\n\t      // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n\t      // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n\t      return typeof value == 'function' || false;\n\t    }\n\t    // Fallback for environments that return incorrect `typeof` operator results.\n\t    if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {\n\t      isFunction = function(value) {\n\t        // The use of `Object#toString` avoids issues with the `typeof` operator\n\t        // in older versions of Chrome and Safari which return 'function' for regexes\n\t        // and Safari 8 equivalents which return 'object' for typed array constructors.\n\t        return objToString.call(value) == funcTag;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is the language type of `Object`.\n\t     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t     *\n\t     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObject({});\n\t     * // => true\n\t     *\n\t     * _.isObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObject(1);\n\t     * // => false\n\t     */\n\t    function isObject(value) {\n\t      // Avoid a V8 JIT bug in Chrome 19-20.\n\t      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t      var type = typeof value;\n\t      return type == 'function' || (value && type == 'object') || false;\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between `object` and `source` to determine if\n\t     * `object` contains equivalent property values. If `customizer` is provided\n\t     * it is invoked to compare values. If `customizer` returns `undefined`\n\t     * comparisons are handled by the method instead. The `customizer` is bound\n\t     * to `thisArg` and invoked with three arguments; (value, other, index|key).\n\t     *\n\t     * **Note:** This method supports comparing properties of arrays, booleans,\n\t     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n\t     * and DOM nodes are **not** supported. Provide a customizer function to extend\n\t     * support for comparing other values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.isMatch(object, { 'age': 40 });\n\t     * // => true\n\t     *\n\t     * _.isMatch(object, { 'age': 36 });\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var object = { 'greeting': 'hello' };\n\t     * var source = { 'greeting': 'hi' };\n\t     *\n\t     * _.isMatch(object, source, function(value, other) {\n\t     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n\t     * });\n\t     * // => true\n\t     */\n\t    function isMatch(object, source, customizer, thisArg) {\n\t      var props = keys(source),\n\t          length = props.length;\n\t\n\t      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n\t      if (!customizer && length == 1) {\n\t        var key = props[0],\n\t            value = source[key];\n\t\n\t        if (isStrictComparable(value)) {\n\t          return object != null && value === object[key] && hasOwnProperty.call(object, key);\n\t        }\n\t      }\n\t      var values = Array(length),\n\t          strictCompareFlags = Array(length);\n\t\n\t      while (length--) {\n\t        value = values[length] = source[props[length]];\n\t        strictCompareFlags[length] = isStrictComparable(value);\n\t      }\n\t      return baseIsMatch(object, props, values, strictCompareFlags, customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `NaN`.\n\t     *\n\t     * **Note:** This method is not the same as native `isNaN` which returns `true`\n\t     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNaN(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNaN(new Number(NaN));\n\t     * // => true\n\t     *\n\t     * isNaN(undefined);\n\t     * // => true\n\t     *\n\t     * _.isNaN(undefined);\n\t     * // => false\n\t     */\n\t    function isNaN(value) {\n\t      // An `NaN` primitive is the only value that is not equal to itself.\n\t      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n\t      return isNumber(value) && value != +value;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a native function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNative(Array.prototype.push);\n\t     * // => true\n\t     *\n\t     * _.isNative(_);\n\t     * // => false\n\t     */\n\t    function isNative(value) {\n\t      if (value == null) {\n\t        return false;\n\t      }\n\t      if (objToString.call(value) == funcTag) {\n\t        return reNative.test(fnToString.call(value));\n\t      }\n\t      return (isObjectLike(value) && reHostCtor.test(value)) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNull(null);\n\t     * // => true\n\t     *\n\t     * _.isNull(void 0);\n\t     * // => false\n\t     */\n\t    function isNull(value) {\n\t      return value === null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Number` primitive or object.\n\t     *\n\t     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n\t     * as numbers, use the `_.isFinite` method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNumber(8.4);\n\t     * // => true\n\t     *\n\t     * _.isNumber(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNumber('8.4');\n\t     * // => false\n\t     */\n\t    function isNumber(value) {\n\t      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a plain object, that is, an object created by the\n\t     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t     *\n\t     * **Note:** This method assumes objects created by the `Object` constructor\n\t     * have no inherited enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * _.isPlainObject(new Foo);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t     * // => true\n\t     *\n\t     * _.isPlainObject(Object.create(null));\n\t     * // => true\n\t     */\n\t    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n\t      if (!(value && objToString.call(value) == objectTag)) {\n\t        return false;\n\t      }\n\t      var valueOf = value.valueOf,\n\t          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\t\n\t      return objProto\n\t        ? (value == objProto || getPrototypeOf(value) == objProto)\n\t        : shimIsPlainObject(value);\n\t    };\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `RegExp` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isRegExp(/abc/);\n\t     * // => true\n\t     *\n\t     * _.isRegExp('/abc/');\n\t     * // => false\n\t     */\n\t    function isRegExp(value) {\n\t      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `String` primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isString('abc');\n\t     * // => true\n\t     *\n\t     * _.isString(1);\n\t     * // => false\n\t     */\n\t    function isString(value) {\n\t      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a typed array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isTypedArray(new Uint8Array);\n\t     * // => true\n\t     *\n\t     * _.isTypedArray([]);\n\t     * // => false\n\t     */\n\t    function isTypedArray(value) {\n\t      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isUndefined(void 0);\n\t     * // => true\n\t     *\n\t     * _.isUndefined(null);\n\t     * // => false\n\t     */\n\t    function isUndefined(value) {\n\t      return typeof value == 'undefined';\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the converted array.\n\t     * @example\n\t     *\n\t     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3);\n\t     * // => [2, 3]\n\t     */\n\t    function toArray(value) {\n\t      var length = value ? value.length : 0;\n\t      if (!isLength(length)) {\n\t        return values(value);\n\t      }\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      return arrayCopy(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a plain object flattening inherited enumerable\n\t     * properties of `value` to own properties of the plain object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Object} Returns the converted plain object.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.assign({ 'a': 1 }, new Foo);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     *\n\t     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n\t     * // => { 'a': 1, 'b': 2, 'c': 3 }\n\t     */\n\t    function toPlainObject(value) {\n\t      return baseCopy(value, keysIn(value));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Assigns own enumerable properties of source object(s) to the destination\n\t     * object. Subsequent sources overwrite property assignments of previous sources.\n\t     * If `customizer` is provided it is invoked to produce the assigned values.\n\t     * The `customizer` is bound to `thisArg` and invoked with five arguments;\n\t     * (objectValue, sourceValue, key, object, source).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias extend\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @param {Function} [customizer] The function to customize assigning values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n\t     * // => { 'user': 'fred', 'age': 40 }\n\t     *\n\t     * // using a customizer callback\n\t     * var defaults = _.partialRight(_.assign, function(value, other) {\n\t     *   return typeof value == 'undefined' ? other : value;\n\t     * });\n\t     *\n\t     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    var assign = createAssigner(baseAssign);\n\t\n\t    /**\n\t     * Creates an object that inherits from the given `prototype` object. If a\n\t     * `properties` object is provided its own enumerable properties are assigned\n\t     * to the created object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @param {Object} [properties] The properties to assign to the object.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * function Shape() {\n\t     *   this.x = 0;\n\t     *   this.y = 0;\n\t     * }\n\t     *\n\t     * function Circle() {\n\t     *   Shape.call(this);\n\t     * }\n\t     *\n\t     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n\t     *\n\t     * var circle = new Circle;\n\t     * circle instanceof Circle;\n\t     * // => true\n\t     *\n\t     * circle instanceof Shape;\n\t     * // => true\n\t     */\n\t    function create(prototype, properties, guard) {\n\t      var result = baseCreate(prototype);\n\t      if (guard && isIterateeCall(prototype, properties, guard)) {\n\t        properties = null;\n\t      }\n\t      return properties ? baseCopy(properties, result, keys(properties)) : result;\n\t    }\n\t\n\t    /**\n\t     * Assigns own enumerable properties of source object(s) to the destination\n\t     * object for all destination properties that resolve to `undefined`. Once a\n\t     * property is set, additional defaults of the same property are ignored.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    function defaults(object) {\n\t      if (object == null) {\n\t        return object;\n\t      }\n\t      var args = arrayCopy(arguments);\n\t      args.push(assignDefaults);\n\t      return assign.apply(undefined, args);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findIndex` except that it returns the key of the\n\t     * first element `predicate` returns truthy for, instead of the element itself.\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findKey(users, function(chr) { return chr.age < 40; });\n\t     * // => 'barney' (iteration order is not guaranteed)\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.findKey(users, { 'age': 1, 'active': true });\n\t     * // => 'pebbles'\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.findKey(users, 'active', false);\n\t     * // => 'fred'\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.findKey(users, 'active');\n\t     * // => 'barney'\n\t     */\n\t    function findKey(object, predicate, thisArg) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return baseFind(object, predicate, baseForOwn, true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findKey` except that it iterates over elements of\n\t     * a collection in the opposite order.\n\t     *\n\t     * If a property name is provided for `predicate` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findLastKey(users, function(chr) { return chr.age < 40; });\n\t     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n\t     *\n\t     * // using the \"_.matches\" callback shorthand\n\t     * _.findLastKey(users, { 'age': 36, 'active': true });\n\t     * // => 'barney'\n\t     *\n\t     * // using the \"_.matchesProperty\" callback shorthand\n\t     * _.findLastKey(users, 'active', false);\n\t     * // => 'fred'\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.findLastKey(users, 'active');\n\t     * // => 'pebbles'\n\t     */\n\t    function findLastKey(object, predicate, thisArg) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return baseFind(object, predicate, baseForOwnRight, true);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own and inherited enumerable properties of an object invoking\n\t     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n\t     * with three arguments; (value, key, object). Iterator functions may exit\n\t     * iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forIn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n\t     */\n\t    function forIn(object, iteratee, thisArg) {\n\t      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {\n\t        iteratee = bindCallback(iteratee, thisArg, 3);\n\t      }\n\t      return baseFor(object, iteratee, keysIn);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forIn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forInRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n\t     */\n\t    function forInRight(object, iteratee, thisArg) {\n\t      iteratee = bindCallback(iteratee, thisArg, 3);\n\t      return baseForRight(object, iteratee, keysIn);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own enumerable properties of an object invoking `iteratee`\n\t     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n\t     * three arguments; (value, key, object). Iterator functions may exit iteration\n\t     * early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs '0', '1', and 'length' (iteration order is not guaranteed)\n\t     */\n\t    function forOwn(object, iteratee, thisArg) {\n\t      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {\n\t        iteratee = bindCallback(iteratee, thisArg, 3);\n\t      }\n\t      return baseForOwn(object, iteratee);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forOwn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n\t     */\n\t    function forOwnRight(object, iteratee, thisArg) {\n\t      iteratee = bindCallback(iteratee, thisArg, 3);\n\t      return baseForRight(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of function property names from all enumerable properties,\n\t     * own and inherited, of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias methods\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the new array of property names.\n\t     * @example\n\t     *\n\t     * _.functions(_);\n\t     * // => ['all', 'any', 'bind', ...]\n\t     */\n\t    function functions(object) {\n\t      return baseFunctions(object, keysIn(object));\n\t    }\n\t\n\t    /**\n\t     * Checks if `key` exists as a direct property of `object` instead of an\n\t     * inherited property.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @param {string} key The key to check.\n\t     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.\n\t     * @example\n\t     *\n\t     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n\t     * // => true\n\t     */\n\t    function has(object, key) {\n\t      return object ? hasOwnProperty.call(object, key) : false;\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the inverted keys and values of `object`.\n\t     * If `object` contains duplicate values, subsequent values overwrite property\n\t     * assignments of previous values unless `multiValue` is `true`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to invert.\n\t     * @param {boolean} [multiValue] Allow multiple values per key.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Object} Returns the new inverted object.\n\t     * @example\n\t     *\n\t     * _.invert({ 'first': 'fred', 'second': 'barney' });\n\t     * // => { 'fred': 'first', 'barney': 'second' }\n\t     *\n\t     * // without `multiValue`\n\t     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });\n\t     * // => { 'fred': 'third', 'barney': 'second' }\n\t     *\n\t     * // with `multiValue`\n\t     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);\n\t     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }\n\t     */\n\t    function invert(object, multiValue, guard) {\n\t      if (guard && isIterateeCall(object, multiValue, guard)) {\n\t        multiValue = null;\n\t      }\n\t      var index = -1,\n\t          props = keys(object),\n\t          length = props.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var key = props[index],\n\t            value = object[key];\n\t\n\t        if (multiValue) {\n\t          if (hasOwnProperty.call(result, value)) {\n\t            result[value].push(key);\n\t          } else {\n\t            result[value] = [key];\n\t          }\n\t        }\n\t        else {\n\t          result[value] = key;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects. See the\n\t     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keys(new Foo);\n\t     * // => ['a', 'b'] (iteration order is not guaranteed)\n\t     *\n\t     * _.keys('hi');\n\t     * // => ['0', '1']\n\t     */\n\t    var keys = !nativeKeys ? shimKeys : function(object) {\n\t      if (object) {\n\t        var Ctor = object.constructor,\n\t            length = object.length;\n\t      }\n\t      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n\t         (typeof object != 'function' && (length && isLength(length)))) {\n\t        return shimKeys(object);\n\t      }\n\t      return isObject(object) ? nativeKeys(object) : [];\n\t    };\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keysIn(new Foo);\n\t     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t     */\n\t    function keysIn(object) {\n\t      if (object == null) {\n\t        return [];\n\t      }\n\t      if (!isObject(object)) {\n\t        object = Object(object);\n\t      }\n\t      var length = object.length;\n\t      length = (length && isLength(length) &&\n\t        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\t\n\t      var Ctor = object.constructor,\n\t          index = -1,\n\t          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n\t          result = Array(length),\n\t          skipIndexes = length > 0;\n\t\n\t      while (++index < length) {\n\t        result[index] = (index + '');\n\t      }\n\t      for (var key in object) {\n\t        if (!(skipIndexes && isIndex(key, length)) &&\n\t            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an object with the same keys as `object` and values generated by\n\t     * running each own enumerable property of `object` through `iteratee`. The\n\t     * iteratee function is bound to `thisArg` and invoked with three arguments;\n\t     * (value, key, object).\n\t     *\n\t     * If a property name is provided for `iteratee` the created \"_.property\"\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created \"_.matches\" style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration. If a property name or object is provided it is used to\n\t     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @example\n\t     *\n\t     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(n) { return n * 3; });\n\t     * // => { 'a': 3, 'b': 6, 'c': 9 }\n\t     *\n\t     * var users = {\n\t     *   'fred':    { 'user': 'fred',    'age': 40 },\n\t     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n\t     * };\n\t     *\n\t     * // using the \"_.property\" callback shorthand\n\t     * _.mapValues(users, 'age');\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     */\n\t    function mapValues(object, iteratee, thisArg) {\n\t      var result = {};\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        result[key] = iteratee(value, key, object);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Recursively merges own enumerable properties of the source object(s), that\n\t     * don't resolve to `undefined` into the destination object. Subsequent sources\n\t     * overwrite property assignments of previous sources. If `customizer` is\n\t     * provided it is invoked to produce the merged values of the destination and\n\t     * source properties. If `customizer` returns `undefined` merging is handled\n\t     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n\t     * with five arguments; (objectValue, sourceValue, key, object, source).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @param {Function} [customizer] The function to customize merging properties.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n\t     * };\n\t     *\n\t     * var ages = {\n\t     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n\t     * };\n\t     *\n\t     * _.merge(users, ages);\n\t     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n\t     *\n\t     * // using a customizer callback\n\t     * var object = {\n\t     *   'fruits': ['apple'],\n\t     *   'vegetables': ['beet']\n\t     * };\n\t     *\n\t     * var other = {\n\t     *   'fruits': ['banana'],\n\t     *   'vegetables': ['carrot']\n\t     * };\n\t     *\n\t     * _.merge(object, other, function(a, b) {\n\t     *   return _.isArray(a) ? a.concat(b) : undefined;\n\t     * });\n\t     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n\t     */\n\t    var merge = createAssigner(baseMerge);\n\t\n\t    /**\n\t     * The opposite of `_.pick`; this method creates an object composed of the\n\t     * own and inherited enumerable properties of `object` that are not omitted.\n\t     * Property names may be specified as individual arguments or as arrays of\n\t     * property names. If `predicate` is provided it is invoked for each property\n\t     * of `object` omitting the properties `predicate` returns truthy for. The\n\t     * predicate is bound to `thisArg` and invoked with three arguments;\n\t     * (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t     *  iteration or property names to omit, specified as individual property\n\t     *  names or arrays of property names.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.omit(object, 'age');\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.omit(object, _.isNumber);\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    function omit(object, predicate, thisArg) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      if (typeof predicate != 'function') {\n\t        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);\n\t        return pickByArray(object, baseDifference(keysIn(object), props));\n\t      }\n\t      predicate = bindCallback(predicate, thisArg, 3);\n\t      return pickByCallback(object, function(value, key, object) {\n\t        return !predicate(value, key, object);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a two dimensional array of the key-value pairs for `object`,\n\t     * e.g. `[[key1, value1], [key2, value2]]`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the new array of key-value pairs.\n\t     * @example\n\t     *\n\t     * _.pairs({ 'barney': 36, 'fred': 40 });\n\t     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n\t     */\n\t    function pairs(object) {\n\t      var index = -1,\n\t          props = keys(object),\n\t          length = props.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        result[index] = [key, object[key]];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the picked `object` properties. Property\n\t     * names may be specified as individual arguments or as arrays of property\n\t     * names. If `predicate` is provided it is invoked for each property of `object`\n\t     * picking the properties `predicate` returns truthy for. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments; (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t     *  iteration or property names to pick, specified as individual property\n\t     *  names or arrays of property names.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.pick(object, 'user');\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.pick(object, _.isString);\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    function pick(object, predicate, thisArg) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      return typeof predicate == 'function'\n\t        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))\n\t        : pickByArray(object, baseFlatten(arguments, false, false, 1));\n\t    }\n\t\n\t    /**\n\t     * Resolves the value of property `key` on `object`. If the value of `key` is\n\t     * a function it is invoked with the `this` binding of `object` and its result\n\t     * is returned, else the property value is returned. If the property value is\n\t     * `undefined` the `defaultValue` is used in its place.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {string} key The key of the property to resolve.\n\t     * @param {*} [defaultValue] The value returned if the property value\n\t     *  resolves to `undefined`.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': _.constant(40) };\n\t     *\n\t     * _.result(object, 'user');\n\t     * // => 'fred'\n\t     *\n\t     * _.result(object, 'age');\n\t     * // => 40\n\t     *\n\t     * _.result(object, 'status', 'busy');\n\t     * // => 'busy'\n\t     *\n\t     * _.result(object, 'status', _.constant('busy'));\n\t     * // => 'busy'\n\t     */\n\t    function result(object, key, defaultValue) {\n\t      var value = object == null ? undefined : object[key];\n\t      if (typeof value == 'undefined') {\n\t        value = defaultValue;\n\t      }\n\t      return isFunction(value) ? value.call(object) : value;\n\t    }\n\t\n\t    /**\n\t     * An alternative to `_.reduce`; this method transforms `object` to a new\n\t     * `accumulator` object which is the result of running each of its own enumerable\n\t     * properties through `iteratee`, with each invocation potentially mutating\n\t     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n\t     * with four arguments; (accumulator, value, key, object). Iterator functions\n\t     * may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Array|Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The custom accumulator value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * var squares = _.transform([1, 2, 3, 4, 5, 6], function(result, n) {\n\t     *   n *= n;\n\t     *   if (n % 2) {\n\t     *     return result.push(n) < 3;\n\t     *   }\n\t     * });\n\t     * // => [1, 9, 25]\n\t     *\n\t     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {\n\t     *   result[key] = n * 3;\n\t     * });\n\t     * // => { 'a': 3, 'b': 6, 'c': 9 }\n\t     */\n\t    function transform(object, iteratee, accumulator, thisArg) {\n\t      var isArr = isArray(object) || isTypedArray(object);\n\t      iteratee = getCallback(iteratee, thisArg, 4);\n\t\n\t      if (accumulator == null) {\n\t        if (isArr || isObject(object)) {\n\t          var Ctor = object.constructor;\n\t          if (isArr) {\n\t            accumulator = isArray(object) ? new Ctor : [];\n\t          } else {\n\t            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);\n\t          }\n\t        } else {\n\t          accumulator = {};\n\t        }\n\t      }\n\t      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n\t        return iteratee(accumulator, value, index, object);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.values(new Foo);\n\t     * // => [1, 2] (iteration order is not guaranteed)\n\t     *\n\t     * _.values('hi');\n\t     * // => ['h', 'i']\n\t     */\n\t    function values(object) {\n\t      return baseValues(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property values\n\t     * of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.valuesIn(new Foo);\n\t     * // => [1, 2, 3] (iteration order is not guaranteed)\n\t     */\n\t    function valuesIn(object) {\n\t      return baseValues(object, keysIn(object));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Produces a random number between `min` and `max` (inclusive). If only one\n\t     * argument is provided a number between `0` and the given number is returned.\n\t     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n\t     * number is returned instead of an integer.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} [min=0] The minimum possible value.\n\t     * @param {number} [max=1] The maximum possible value.\n\t     * @param {boolean} [floating] Specify returning a floating-point number.\n\t     * @returns {number} Returns the random number.\n\t     * @example\n\t     *\n\t     * _.random(0, 5);\n\t     * // => an integer between 0 and 5\n\t     *\n\t     * _.random(5);\n\t     * // => also an integer between 0 and 5\n\t     *\n\t     * _.random(5, true);\n\t     * // => a floating-point number between 0 and 5\n\t     *\n\t     * _.random(1.2, 5.2);\n\t     * // => a floating-point number between 1.2 and 5.2\n\t     */\n\t    function random(min, max, floating) {\n\t      if (floating && isIterateeCall(min, max, floating)) {\n\t        max = floating = null;\n\t      }\n\t      var noMin = min == null,\n\t          noMax = max == null;\n\t\n\t      if (floating == null) {\n\t        if (noMax && typeof min == 'boolean') {\n\t          floating = min;\n\t          min = 1;\n\t        }\n\t        else if (typeof max == 'boolean') {\n\t          floating = max;\n\t          noMax = true;\n\t        }\n\t      }\n\t      if (noMin && noMax) {\n\t        max = 1;\n\t        noMax = false;\n\t      }\n\t      min = +min || 0;\n\t      if (noMax) {\n\t        max = min;\n\t        min = 0;\n\t      } else {\n\t        max = +max || 0;\n\t      }\n\t      if (floating || min % 1 || max % 1) {\n\t        var rand = nativeRandom();\n\t        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n\t      }\n\t      return baseRandom(min, max);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Converts `string` to camel case.\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the camel cased string.\n\t     * @example\n\t     *\n\t     * _.camelCase('Foo Bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('--foo-bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('__foo_bar__');\n\t     * // => 'fooBar'\n\t     */\n\t    var camelCase = createCompounder(function(result, word, index) {\n\t      word = word.toLowerCase();\n\t      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n\t    });\n\t\n\t    /**\n\t     * Capitalizes the first character of `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to capitalize.\n\t     * @returns {string} Returns the capitalized string.\n\t     * @example\n\t     *\n\t     * _.capitalize('fred');\n\t     * // => 'Fred'\n\t     */\n\t    function capitalize(string) {\n\t      string = baseToString(string);\n\t      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n\t    }\n\t\n\t    /**\n\t     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to deburr.\n\t     * @returns {string} Returns the deburred string.\n\t     * @example\n\t     *\n\t     * _.deburr('déjà vu');\n\t     * // => 'deja vu'\n\t     */\n\t    function deburr(string) {\n\t      string = baseToString(string);\n\t      return string && string.replace(reLatin1, deburrLetter);\n\t    }\n\t\n\t    /**\n\t     * Checks if `string` ends with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=string.length] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.endsWith('abc', 'c');\n\t     * // => true\n\t     *\n\t     * _.endsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.endsWith('abc', 'b', 2);\n\t     * // => true\n\t     */\n\t    function endsWith(string, target, position) {\n\t      string = baseToString(string);\n\t      target = (target + '');\n\t\n\t      var length = string.length;\n\t      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;\n\t      return position >= 0 && string.indexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and '`', in `string` to\n\t     * their corresponding HTML entities.\n\t     *\n\t     * **Note:** No other characters are escaped. To escape additional characters\n\t     * use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * Though the \">\" character is escaped for symmetry, characters like\n\t     * \">\" and \"/\" don't require escaping in HTML and have no special meaning\n\t     * unless they're part of a tag or unquoted attribute value.\n\t     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n\t     * (under \"semi-related fun fact\") for more details.\n\t     *\n\t     * Backticks are escaped because in Internet Explorer < 9, they can break out\n\t     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),\n\t     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of\n\t     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.\n\t     *\n\t     * When working with HTML you should always quote attribute values to reduce\n\t     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escape('fred, barney, & pebbles');\n\t     * // => 'fred, barney, &amp; pebbles'\n\t     */\n\t    function escape(string) {\n\t      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n\t      string = baseToString(string);\n\t      return (string && reHasUnescapedHtml.test(string))\n\t        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n\t     * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\t     */\n\t    function escapeRegExp(string) {\n\t      string = baseToString(string);\n\t      return (string && reHasRegExpChars.test(string))\n\t        ? string.replace(reRegExpChars, '\\\\$&')\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to kebab case (a.k.a. spinal case).\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for\n\t     * more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the kebab cased string.\n\t     * @example\n\t     *\n\t     * _.kebabCase('Foo Bar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('fooBar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('__foo_bar__');\n\t     * // => 'foo-bar'\n\t     */\n\t    var kebabCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '-' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Pads `string` on the left and right sides if it is shorter then the given\n\t     * padding length. The `chars` string may be truncated if the number of padding\n\t     * characters can't be evenly divided by the padding length.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.pad('abc', 8);\n\t     * // => '  abc   '\n\t     *\n\t     * _.pad('abc', 8, '_-');\n\t     * // => '_-abc_-_'\n\t     *\n\t     * _.pad('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function pad(string, length, chars) {\n\t      string = baseToString(string);\n\t      length = +length;\n\t\n\t      var strLength = string.length;\n\t      if (strLength >= length || !nativeIsFinite(length)) {\n\t        return string;\n\t      }\n\t      var mid = (length - strLength) / 2,\n\t          leftLength = floor(mid),\n\t          rightLength = ceil(mid);\n\t\n\t      chars = createPad('', rightLength, chars);\n\t      return chars.slice(0, leftLength) + string + chars;\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the left side if it is shorter then the given padding\n\t     * length. The `chars` string may be truncated if the number of padding\n\t     * characters exceeds the padding length.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padLeft('abc', 6);\n\t     * // => '   abc'\n\t     *\n\t     * _.padLeft('abc', 6, '_-');\n\t     * // => '_-_abc'\n\t     *\n\t     * _.padLeft('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padLeft(string, length, chars) {\n\t      string = baseToString(string);\n\t      return string && (createPad(string, length, chars) + string);\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the right side if it is shorter then the given padding\n\t     * length. The `chars` string may be truncated if the number of padding\n\t     * characters exceeds the padding length.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padRight('abc', 6);\n\t     * // => 'abc   '\n\t     *\n\t     * _.padRight('abc', 6, '_-');\n\t     * // => 'abc_-_'\n\t     *\n\t     * _.padRight('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padRight(string, length, chars) {\n\t      string = baseToString(string);\n\t      return string && (string + createPad(string, length, chars));\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to an integer of the specified radix. If `radix` is\n\t     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n\t     * in which case a `radix` of `16` is used.\n\t     *\n\t     * **Note:** This method aligns with the ES5 implementation of `parseInt`.\n\t     * See the [ES5 spec](https://es5.github.io/#E) for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} string The string to convert.\n\t     * @param {number} [radix] The radix to interpret `value` by.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.parseInt('08');\n\t     * // => 8\n\t     *\n\t     * _.map(['6', '08', '10'], _.parseInt);\n\t     * // => [6, 8, 10]\n\t     */\n\t    function parseInt(string, radix, guard) {\n\t      if (guard && isIterateeCall(string, radix, guard)) {\n\t        radix = 0;\n\t      }\n\t      return nativeParseInt(string, radix);\n\t    }\n\t    // Fallback for environments with pre-ES5 implementations.\n\t    if (nativeParseInt(whitespace + '08') != 8) {\n\t      parseInt = function(string, radix, guard) {\n\t        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n\t        // Chrome fails to trim leading <BOM> whitespace characters.\n\t        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n\t        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n\t          radix = 0;\n\t        } else if (radix) {\n\t          radix = +radix;\n\t        }\n\t        string = trim(string);\n\t        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Repeats the given string `n` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to repeat.\n\t     * @param {number} [n=0] The number of times to repeat the string.\n\t     * @returns {string} Returns the repeated string.\n\t     * @example\n\t     *\n\t     * _.repeat('*', 3);\n\t     * // => '***'\n\t     *\n\t     * _.repeat('abc', 2);\n\t     * // => 'abcabc'\n\t     *\n\t     * _.repeat('abc', 0);\n\t     * // => ''\n\t     */\n\t    function repeat(string, n) {\n\t      var result = '';\n\t      string = baseToString(string);\n\t      n = +n;\n\t      if (n < 1 || !string || !nativeIsFinite(n)) {\n\t        return result;\n\t      }\n\t      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n\t      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n\t      do {\n\t        if (n % 2) {\n\t          result += string;\n\t        }\n\t        n = floor(n / 2);\n\t        string += string;\n\t      } while (n);\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to snake case.\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the snake cased string.\n\t     * @example\n\t     *\n\t     * _.snakeCase('Foo Bar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('fooBar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('--foo-bar');\n\t     * // => 'foo_bar'\n\t     */\n\t    var snakeCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '_' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts `string` to start case.\n\t     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the start cased string.\n\t     * @example\n\t     *\n\t     * _.startCase('--foo-bar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('fooBar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('__foo_bar__');\n\t     * // => 'Foo Bar'\n\t     */\n\t    var startCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n\t    });\n\t\n\t    /**\n\t     * Checks if `string` starts with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=0] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.startsWith('abc', 'a');\n\t     * // => true\n\t     *\n\t     * _.startsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.startsWith('abc', 'b', 1);\n\t     * // => true\n\t     */\n\t    function startsWith(string, target, position) {\n\t      string = baseToString(string);\n\t      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\t      return string.lastIndexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Creates a compiled template function that can interpolate data properties\n\t     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n\t     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n\t     * properties may be accessed as free variables in the template. If a setting\n\t     * object is provided it takes precedence over `_.templateSettings` values.\n\t     *\n\t     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.\n\t     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n\t     * for more details.\n\t     *\n\t     * For more information on precompiling templates see\n\t     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n\t     *\n\t     * For more information on Chrome extension sandboxes see\n\t     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The template string.\n\t     * @param {Object} [options] The options object.\n\t     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n\t     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n\t     * @param {Object} [options.imports] An object to import into the template as free variables.\n\t     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n\t     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n\t     * @param {string} [options.variable] The data object variable name.\n\t     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n\t     * @returns {Function} Returns the compiled template function.\n\t     * @example\n\t     *\n\t     * // using the \"interpolate\" delimiter to create a compiled template\n\t     * var compiled = _.template('hello <%= user %>!');\n\t     * compiled({ 'user': 'fred' });\n\t     * // => 'hello fred!'\n\t     *\n\t     * // using the HTML \"escape\" delimiter to escape data property values\n\t     * var compiled = _.template('<b><%- value %></b>');\n\t     * compiled({ 'value': '<script>' });\n\t     * // => '<b>&lt;script&gt;</b>'\n\t     *\n\t     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n\t     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the internal `print` function in \"evaluate\" delimiters\n\t     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n\t     * compiled({ 'user': 'barney' });\n\t     * // => 'hello barney!'\n\t     *\n\t     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n\t     * var compiled = _.template('hello ${ user }!');\n\t     * compiled({ 'user': 'pebbles' });\n\t     * // => 'hello pebbles!'\n\t     *\n\t     * // using custom template delimiters\n\t     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n\t     * var compiled = _.template('hello {{ user }}!');\n\t     * compiled({ 'user': 'mustache' });\n\t     * // => 'hello mustache!'\n\t     *\n\t     * // using backslashes to treat delimiters as plain text\n\t     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n\t     * compiled({ 'value': 'ignored' });\n\t     * // => '<%- value %>'\n\t     *\n\t     * // using the `imports` option to import `jQuery` as `jq`\n\t     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n\t     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the `sourceURL` option to specify a custom sourceURL for the template\n\t     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n\t     * compiled(data);\n\t     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n\t     *\n\t     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n\t     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n\t     * compiled.source;\n\t     * // => function(data) {\n\t     *   var __t, __p = '';\n\t     *   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n\t     *   return __p;\n\t     * }\n\t     *\n\t     * // using the `source` property to inline compiled templates for meaningful\n\t     * // line numbers in error messages and a stack trace\n\t     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n\t     *   var JST = {\\\n\t     *     \"main\": ' + _.template(mainText).source + '\\\n\t     *   };\\\n\t     * ');\n\t     */\n\t    function template(string, options, otherOptions) {\n\t      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n\t      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n\t      var settings = lodash.templateSettings;\n\t\n\t      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n\t        options = otherOptions = null;\n\t      }\n\t      string = baseToString(string);\n\t      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\t\n\t      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n\t          importsKeys = keys(imports),\n\t          importsValues = baseValues(imports, importsKeys);\n\t\n\t      var isEscaping,\n\t          isEvaluating,\n\t          index = 0,\n\t          interpolate = options.interpolate || reNoMatch,\n\t          source = \"__p += '\";\n\t\n\t      // Compile the regexp to match each delimiter.\n\t      var reDelimiters = RegExp(\n\t        (options.escape || reNoMatch).source + '|' +\n\t        interpolate.source + '|' +\n\t        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n\t        (options.evaluate || reNoMatch).source + '|$'\n\t      , 'g');\n\t\n\t      // Use a sourceURL for easier debugging.\n\t      var sourceURL = '//# sourceURL=' +\n\t        ('sourceURL' in options\n\t          ? options.sourceURL\n\t          : ('lodash.templateSources[' + (++templateCounter) + ']')\n\t        ) + '\\n';\n\t\n\t      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n\t        interpolateValue || (interpolateValue = esTemplateValue);\n\t\n\t        // Escape characters that can't be included in string literals.\n\t        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\t\n\t        // Replace delimiters with snippets.\n\t        if (escapeValue) {\n\t          isEscaping = true;\n\t          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n\t        }\n\t        if (evaluateValue) {\n\t          isEvaluating = true;\n\t          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n\t        }\n\t        if (interpolateValue) {\n\t          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n\t        }\n\t        index = offset + match.length;\n\t\n\t        // The JS engine embedded in Adobe products requires returning the `match`\n\t        // string in order to produce the correct `offset` value.\n\t        return match;\n\t      });\n\t\n\t      source += \"';\\n\";\n\t\n\t      // If `variable` is not specified wrap a with-statement around the generated\n\t      // code to add the data object to the top of the scope chain.\n\t      var variable = options.variable;\n\t      if (!variable) {\n\t        source = 'with (obj) {\\n' + source + '\\n}\\n';\n\t      }\n\t      // Cleanup code by stripping empty strings.\n\t      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n\t        .replace(reEmptyStringMiddle, '$1')\n\t        .replace(reEmptyStringTrailing, '$1;');\n\t\n\t      // Frame code as the function body.\n\t      source = 'function(' + (variable || 'obj') + ') {\\n' +\n\t        (variable\n\t          ? ''\n\t          : 'obj || (obj = {});\\n'\n\t        ) +\n\t        \"var __t, __p = ''\" +\n\t        (isEscaping\n\t           ? ', __e = _.escape'\n\t           : ''\n\t        ) +\n\t        (isEvaluating\n\t          ? ', __j = Array.prototype.join;\\n' +\n\t            \"function print() { __p += __j.call(arguments, '') }\\n\"\n\t          : ';\\n'\n\t        ) +\n\t        source +\n\t        'return __p\\n}';\n\t\n\t      var result = attempt(function() {\n\t        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n\t      });\n\t\n\t      // Provide the compiled function's source by its `toString` method or\n\t      // the `source` property as a convenience for inlining compiled templates.\n\t      result.source = source;\n\t      if (isError(result)) {\n\t        throw result;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Removes leading and trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trim('  abc  ');\n\t     * // => 'abc'\n\t     *\n\t     * _.trim('-_-abc-_-', '_-');\n\t     * // => 'abc'\n\t     *\n\t     * _.map(['  foo  ', '  bar  '], _.trim);\n\t     * // => ['foo', 'bar]\n\t     */\n\t    function trim(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n\t      }\n\t      chars = (chars + '');\n\t      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n\t    }\n\t\n\t    /**\n\t     * Removes leading whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimLeft('  abc  ');\n\t     * // => 'abc  '\n\t     *\n\t     * _.trimLeft('-_-abc-_-', '_-');\n\t     * // => 'abc-_-'\n\t     */\n\t    function trimLeft(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(trimmedLeftIndex(string));\n\t      }\n\t      return string.slice(charsLeftIndex(string, (chars + '')));\n\t    }\n\t\n\t    /**\n\t     * Removes trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimRight('  abc  ');\n\t     * // => '  abc'\n\t     *\n\t     * _.trimRight('-_-abc-_-', '_-');\n\t     * // => '-_-abc'\n\t     */\n\t    function trimRight(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(0, trimmedRightIndex(string) + 1);\n\t      }\n\t      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n\t    }\n\t\n\t    /**\n\t     * Truncates `string` if it is longer than the given maximum string length.\n\t     * The last characters of the truncated string are replaced with the omission\n\t     * string which defaults to \"...\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to truncate.\n\t     * @param {Object|number} [options] The options object or maximum string length.\n\t     * @param {number} [options.length=30] The maximum string length.\n\t     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n\t     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the truncated string.\n\t     * @example\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino');\n\t     * // => 'hi-diddly-ho there, neighbo...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', 24);\n\t     * // => 'hi-diddly-ho there, n...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });\n\t     * // => 'hi-diddly-ho there,...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });\n\t     * //=> 'hi-diddly-ho there...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });\n\t     * // => 'hi-diddly-ho there, neig [...]'\n\t     */\n\t    function trunc(string, options, guard) {\n\t      if (guard && isIterateeCall(string, options, guard)) {\n\t        options = null;\n\t      }\n\t      var length = DEFAULT_TRUNC_LENGTH,\n\t          omission = DEFAULT_TRUNC_OMISSION;\n\t\n\t      if (options != null) {\n\t        if (isObject(options)) {\n\t          var separator = 'separator' in options ? options.separator : separator;\n\t          length = 'length' in options ? +options.length || 0 : length;\n\t          omission = 'omission' in options ? baseToString(options.omission) : omission;\n\t        } else {\n\t          length = +options || 0;\n\t        }\n\t      }\n\t      string = baseToString(string);\n\t      if (length >= string.length) {\n\t        return string;\n\t      }\n\t      var end = length - omission.length;\n\t      if (end < 1) {\n\t        return omission;\n\t      }\n\t      var result = string.slice(0, end);\n\t      if (separator == null) {\n\t        return result + omission;\n\t      }\n\t      if (isRegExp(separator)) {\n\t        if (string.slice(end).search(separator)) {\n\t          var match,\n\t              newEnd,\n\t              substring = string.slice(0, end);\n\t\n\t          if (!separator.global) {\n\t            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n\t          }\n\t          separator.lastIndex = 0;\n\t          while ((match = separator.exec(substring))) {\n\t            newEnd = match.index;\n\t          }\n\t          result = result.slice(0, newEnd == null ? end : newEnd);\n\t        }\n\t      } else if (string.indexOf(separator, end) != end) {\n\t        var index = result.lastIndexOf(separator);\n\t        if (index > -1) {\n\t          result = result.slice(0, index);\n\t        }\n\t      }\n\t      return result + omission;\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.escape`; this method converts the HTML entities\n\t     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n\t     * corresponding characters.\n\t     *\n\t     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n\t     * entities use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to unescape.\n\t     * @returns {string} Returns the unescaped string.\n\t     * @example\n\t     *\n\t     * _.unescape('fred, barney, &amp; pebbles');\n\t     * // => 'fred, barney, & pebbles'\n\t     */\n\t    function unescape(string) {\n\t      string = baseToString(string);\n\t      return (string && reHasEscapedHtml.test(string))\n\t        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Splits `string` into an array of its words.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {RegExp|string} [pattern] The pattern to match words.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the words of `string`.\n\t     * @example\n\t     *\n\t     * _.words('fred, barney, & pebbles');\n\t     * // => ['fred', 'barney', 'pebbles']\n\t     *\n\t     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n\t     * // => ['fred', 'barney', '&', 'pebbles']\n\t     */\n\t    function words(string, pattern, guard) {\n\t      if (guard && isIterateeCall(string, pattern, guard)) {\n\t        pattern = null;\n\t      }\n\t      string = baseToString(string);\n\t      return string.match(pattern || reWords) || [];\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Attempts to invoke `func`, returning either the result or the caught error\n\t     * object. Any additional arguments are provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {*} func The function to attempt.\n\t     * @returns {*} Returns the `func` result or error object.\n\t     * @example\n\t     *\n\t     * // avoid throwing errors for invalid selectors\n\t     * var elements = _.attempt(function(selector) {\n\t     *   return document.querySelectorAll(selector);\n\t     * }, '>_>');\n\t     *\n\t     * if (_.isError(elements)) {\n\t     *   elements = [];\n\t     * }\n\t     */\n\t    function attempt(func) {\n\t      try {\n\t        return func.apply(undefined, baseSlice(arguments, 1));\n\t      } catch(e) {\n\t        return isError(e) ? e : new Error(e);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and arguments of the created function. If `func` is a property name the\n\t     * created callback returns the property value for a given element. If `func`\n\t     * is an object the created callback returns `true` for elements that contain\n\t     * the equivalent object properties, otherwise it returns `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias iteratee\n\t     * @category Utility\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the callback.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // wrap to create custom callback shorthands\n\t     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n\t     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n\t     *   if (!match) {\n\t     *     return callback(func, thisArg);\n\t     *   }\n\t     *   return function(object) {\n\t     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n\t     *   };\n\t     * });\n\t     *\n\t     * _.filter(users, 'age__gt36');\n\t     * // => [{ 'user': 'fred', 'age': 40 }]\n\t     */\n\t    function callback(func, thisArg, guard) {\n\t      if (guard && isIterateeCall(func, thisArg, guard)) {\n\t        thisArg = null;\n\t      }\n\t      return isObjectLike(func)\n\t        ? matches(func)\n\t        : baseCallback(func, thisArg);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {*} value The value to return from the new function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var getter = _.constant(object);\n\t     * getter() === object;\n\t     * // => true\n\t     */\n\t    function constant(value) {\n\t      return function() {\n\t        return value;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * This method returns the first argument provided to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {*} value Any value.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * _.identity(object) === object;\n\t     * // => true\n\t     */\n\t    function identity(value) {\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * Creates a function which performs a deep comparison between a given object\n\t     * and `source`, returning `true` if the given object has equivalent property\n\t     * values, else `false`.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n\t     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n\t     */\n\t    function matches(source) {\n\t      return baseMatches(baseClone(source, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function which compares the property value of `key` on a given\n\t     * object to `value`.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {string} key The key of the property to get.\n\t     * @param {*} value The value to compare.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36 },\n\t     *   { 'user': 'fred',    'age': 40 },\n\t     *   { 'user': 'pebbles', 'age': 1 }\n\t     * ];\n\t     *\n\t     * var matchFred = _.matchesProperty('user', 'fred');\n\t     *\n\t     * _.find(users, matchFred);\n\t     * // => { 'user': 'fred', 'age': 40 }\n\t     */\n\t    function matchesProperty(key, value) {\n\t      return baseMatchesProperty(key + '', baseClone(value, true));\n\t    }\n\t\n\t    /**\n\t     * Adds all own enumerable function properties of a source object to the\n\t     * destination object. If `object` is a function then methods are added to\n\t     * its prototype as well.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Function|Object} [object=this] object The destination object.\n\t     * @param {Object} source The object of functions to add.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.chain=true] Specify whether the functions added\n\t     *  are chainable.\n\t     * @returns {Function|Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function vowels(string) {\n\t     *   return _.filter(string, function(v) {\n\t     *     return /[aeiou]/i.test(v);\n\t     *   });\n\t     * }\n\t     *\n\t     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)\n\t     * var _ = require('lodash').runInContext();\n\t     *\n\t     * _.mixin({ 'vowels': vowels });\n\t     * _.vowels('fred');\n\t     * // => ['e']\n\t     *\n\t     * _('fred').vowels().value();\n\t     * // => ['e']\n\t     *\n\t     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n\t     * _('fred').vowels();\n\t     * // => ['e']\n\t     */\n\t    function mixin(object, source, options) {\n\t      if (options == null) {\n\t        var isObj = isObject(source),\n\t            props = isObj && keys(source),\n\t            methodNames = props && props.length && baseFunctions(source, props);\n\t\n\t        if (!(methodNames ? methodNames.length : isObj)) {\n\t          methodNames = false;\n\t          options = source;\n\t          source = object;\n\t          object = this;\n\t        }\n\t      }\n\t      if (!methodNames) {\n\t        methodNames = baseFunctions(source, keys(source));\n\t      }\n\t      var chain = true,\n\t          index = -1,\n\t          isFunc = isFunction(object),\n\t          length = methodNames.length;\n\t\n\t      if (options === false) {\n\t        chain = false;\n\t      } else if (isObject(options) && 'chain' in options) {\n\t        chain = options.chain;\n\t      }\n\t      while (++index < length) {\n\t        var methodName = methodNames[index],\n\t            func = source[methodName];\n\t\n\t        object[methodName] = func;\n\t        if (isFunc) {\n\t          object.prototype[methodName] = (function(func) {\n\t            return function() {\n\t              var chainAll = this.__chain__;\n\t              if (chain || chainAll) {\n\t                var result = object(this.__wrapped__);\n\t                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });\n\t                result.__chain__ = chainAll;\n\t                return result;\n\t              }\n\t              var args = [this.value()];\n\t              push.apply(args, arguments);\n\t              return func.apply(object, args);\n\t            };\n\t          }(func));\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Reverts the `_` variable to its previous value and returns a reference to\n\t     * the `lodash` function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @returns {Function} Returns the `lodash` function.\n\t     * @example\n\t     *\n\t     * var lodash = _.noConflict();\n\t     */\n\t    function noConflict() {\n\t      context._ = oldDash;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * A no-operation function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * _.noop(object) === undefined;\n\t     * // => true\n\t     */\n\t    function noop() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * Creates a function which returns the property value of `key` on a given object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {string} key The key of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred' },\n\t     *   { 'user': 'barney' }\n\t     * ];\n\t     *\n\t     * var getName = _.property('user');\n\t     *\n\t     * _.map(users, getName);\n\t     * // => ['fred', barney']\n\t     *\n\t     * _.pluck(_.sortBy(users, getName), 'user');\n\t     * // => ['barney', 'fred']\n\t     */\n\t    function property(key) {\n\t      return baseProperty(key + '');\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.property`; this method creates a function which returns\n\t     * the property value of a given key on `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40, 'active': true };\n\t     * _.map(['active', 'user'], _.propertyOf(object));\n\t     * // => [true, 'fred']\n\t     *\n\t     * var object = { 'a': 3, 'b': 1, 'c': 2 };\n\t     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));\n\t     * // => ['b', 'c', 'a']\n\t     */\n\t    function propertyOf(object) {\n\t      return function(key) {\n\t        return object == null ? undefined : object[key];\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates an array of numbers (positive and/or negative) progressing from\n\t     * `start` up to, but not including, `end`. If `start` is less than `end` a\n\t     * zero-length range is created unless a negative `step` is specified.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the new array of numbers.\n\t     * @example\n\t     *\n\t     * _.range(4);\n\t     * // => [0, 1, 2, 3]\n\t     *\n\t     * _.range(1, 5);\n\t     * // => [1, 2, 3, 4]\n\t     *\n\t     * _.range(0, 20, 5);\n\t     * // => [0, 5, 10, 15]\n\t     *\n\t     * _.range(0, -4, -1);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.range(0);\n\t     * // => []\n\t     */\n\t    function range(start, end, step) {\n\t      if (step && isIterateeCall(start, end, step)) {\n\t        end = step = null;\n\t      }\n\t      start = +start || 0;\n\t      step = step == null ? 1 : (+step || 0);\n\t\n\t      if (end == null) {\n\t        end = start;\n\t        start = 0;\n\t      } else {\n\t        end = +end || 0;\n\t      }\n\t      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n\t      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n\t      var index = -1,\n\t          length = nativeMax(ceil((end - start) / (step || 1)), 0),\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = start;\n\t        start += step;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Invokes the iteratee function `n` times, returning an array of the results\n\t     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n\t     * one argument; (index).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {number} n The number of times to invoke `iteratee`.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n\t     * // => [3, 6, 4]\n\t     *\n\t     * _.times(3, function(n) { mage.castSpell(n); });\n\t     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively\n\t     *\n\t     * _.times(3, function(n) { this.cast(n); }, mage);\n\t     * // => also invokes `mage.castSpell(n)` three times\n\t     */\n\t    function times(n, iteratee, thisArg) {\n\t      n = +n;\n\t\n\t      // Exit early to avoid a JSC JIT bug in Safari 8\n\t      // where `Array(0)` is treated as `Array(1)`.\n\t      if (n < 1 || !nativeIsFinite(n)) {\n\t        return [];\n\t      }\n\t      var index = -1,\n\t          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\t\n\t      iteratee = bindCallback(iteratee, thisArg, 1);\n\t      while (++index < n) {\n\t        if (index < MAX_ARRAY_LENGTH) {\n\t          result[index] = iteratee(index);\n\t        } else {\n\t          iteratee(index);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {string} [prefix] The value to prefix the ID with.\n\t     * @returns {string} Returns the unique ID.\n\t     * @example\n\t     *\n\t     * _.uniqueId('contact_');\n\t     * // => 'contact_104'\n\t     *\n\t     * _.uniqueId();\n\t     * // => '105'\n\t     */\n\t    function uniqueId(prefix) {\n\t      var id = ++idCounter;\n\t      return baseToString(prefix) + id;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Ensure `new LodashWrapper` is an instance of `lodash`.\n\t    LodashWrapper.prototype = baseCreate(lodash.prototype);\n\t\n\t    // Ensure `new LazyWraper` is an instance of `LodashWrapper`\n\t    LazyWrapper.prototype = baseCreate(LodashWrapper.prototype);\n\t    LazyWrapper.prototype.constructor = LazyWrapper;\n\t\n\t    // Add functions to the `Map` cache.\n\t    MapCache.prototype['delete'] = mapDelete;\n\t    MapCache.prototype.get = mapGet;\n\t    MapCache.prototype.has = mapHas;\n\t    MapCache.prototype.set = mapSet;\n\t\n\t    // Add functions to the `Set` cache.\n\t    SetCache.prototype.push = cachePush;\n\t\n\t    // Assign cache to `_.memoize`.\n\t    memoize.Cache = MapCache;\n\t\n\t    // Add functions that return wrapped values when chaining.\n\t    lodash.after = after;\n\t    lodash.ary = ary;\n\t    lodash.assign = assign;\n\t    lodash.at = at;\n\t    lodash.before = before;\n\t    lodash.bind = bind;\n\t    lodash.bindAll = bindAll;\n\t    lodash.bindKey = bindKey;\n\t    lodash.callback = callback;\n\t    lodash.chain = chain;\n\t    lodash.chunk = chunk;\n\t    lodash.compact = compact;\n\t    lodash.constant = constant;\n\t    lodash.countBy = countBy;\n\t    lodash.create = create;\n\t    lodash.curry = curry;\n\t    lodash.curryRight = curryRight;\n\t    lodash.debounce = debounce;\n\t    lodash.defaults = defaults;\n\t    lodash.defer = defer;\n\t    lodash.delay = delay;\n\t    lodash.difference = difference;\n\t    lodash.drop = drop;\n\t    lodash.dropRight = dropRight;\n\t    lodash.dropRightWhile = dropRightWhile;\n\t    lodash.dropWhile = dropWhile;\n\t    lodash.fill = fill;\n\t    lodash.filter = filter;\n\t    lodash.flatten = flatten;\n\t    lodash.flattenDeep = flattenDeep;\n\t    lodash.flow = flow;\n\t    lodash.flowRight = flowRight;\n\t    lodash.forEach = forEach;\n\t    lodash.forEachRight = forEachRight;\n\t    lodash.forIn = forIn;\n\t    lodash.forInRight = forInRight;\n\t    lodash.forOwn = forOwn;\n\t    lodash.forOwnRight = forOwnRight;\n\t    lodash.functions = functions;\n\t    lodash.groupBy = groupBy;\n\t    lodash.indexBy = indexBy;\n\t    lodash.initial = initial;\n\t    lodash.intersection = intersection;\n\t    lodash.invert = invert;\n\t    lodash.invoke = invoke;\n\t    lodash.keys = keys;\n\t    lodash.keysIn = keysIn;\n\t    lodash.map = map;\n\t    lodash.mapValues = mapValues;\n\t    lodash.matches = matches;\n\t    lodash.matchesProperty = matchesProperty;\n\t    lodash.memoize = memoize;\n\t    lodash.merge = merge;\n\t    lodash.mixin = mixin;\n\t    lodash.negate = negate;\n\t    lodash.omit = omit;\n\t    lodash.once = once;\n\t    lodash.pairs = pairs;\n\t    lodash.partial = partial;\n\t    lodash.partialRight = partialRight;\n\t    lodash.partition = partition;\n\t    lodash.pick = pick;\n\t    lodash.pluck = pluck;\n\t    lodash.property = property;\n\t    lodash.propertyOf = propertyOf;\n\t    lodash.pull = pull;\n\t    lodash.pullAt = pullAt;\n\t    lodash.range = range;\n\t    lodash.rearg = rearg;\n\t    lodash.reject = reject;\n\t    lodash.remove = remove;\n\t    lodash.rest = rest;\n\t    lodash.shuffle = shuffle;\n\t    lodash.slice = slice;\n\t    lodash.sortBy = sortBy;\n\t    lodash.sortByAll = sortByAll;\n\t    lodash.spread = spread;\n\t    lodash.take = take;\n\t    lodash.takeRight = takeRight;\n\t    lodash.takeRightWhile = takeRightWhile;\n\t    lodash.takeWhile = takeWhile;\n\t    lodash.tap = tap;\n\t    lodash.throttle = throttle;\n\t    lodash.thru = thru;\n\t    lodash.times = times;\n\t    lodash.toArray = toArray;\n\t    lodash.toPlainObject = toPlainObject;\n\t    lodash.transform = transform;\n\t    lodash.union = union;\n\t    lodash.uniq = uniq;\n\t    lodash.unzip = unzip;\n\t    lodash.values = values;\n\t    lodash.valuesIn = valuesIn;\n\t    lodash.where = where;\n\t    lodash.without = without;\n\t    lodash.wrap = wrap;\n\t    lodash.xor = xor;\n\t    lodash.zip = zip;\n\t    lodash.zipObject = zipObject;\n\t\n\t    // Add aliases.\n\t    lodash.backflow = flowRight;\n\t    lodash.collect = map;\n\t    lodash.compose = flowRight;\n\t    lodash.each = forEach;\n\t    lodash.eachRight = forEachRight;\n\t    lodash.extend = assign;\n\t    lodash.iteratee = callback;\n\t    lodash.methods = functions;\n\t    lodash.object = zipObject;\n\t    lodash.select = filter;\n\t    lodash.tail = rest;\n\t    lodash.unique = uniq;\n\t\n\t    // Add functions to `lodash.prototype`.\n\t    mixin(lodash, lodash);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add functions that return unwrapped values when chaining.\n\t    lodash.attempt = attempt;\n\t    lodash.camelCase = camelCase;\n\t    lodash.capitalize = capitalize;\n\t    lodash.clone = clone;\n\t    lodash.cloneDeep = cloneDeep;\n\t    lodash.deburr = deburr;\n\t    lodash.endsWith = endsWith;\n\t    lodash.escape = escape;\n\t    lodash.escapeRegExp = escapeRegExp;\n\t    lodash.every = every;\n\t    lodash.find = find;\n\t    lodash.findIndex = findIndex;\n\t    lodash.findKey = findKey;\n\t    lodash.findLast = findLast;\n\t    lodash.findLastIndex = findLastIndex;\n\t    lodash.findLastKey = findLastKey;\n\t    lodash.findWhere = findWhere;\n\t    lodash.first = first;\n\t    lodash.has = has;\n\t    lodash.identity = identity;\n\t    lodash.includes = includes;\n\t    lodash.indexOf = indexOf;\n\t    lodash.isArguments = isArguments;\n\t    lodash.isArray = isArray;\n\t    lodash.isBoolean = isBoolean;\n\t    lodash.isDate = isDate;\n\t    lodash.isElement = isElement;\n\t    lodash.isEmpty = isEmpty;\n\t    lodash.isEqual = isEqual;\n\t    lodash.isError = isError;\n\t    lodash.isFinite = isFinite;\n\t    lodash.isFunction = isFunction;\n\t    lodash.isMatch = isMatch;\n\t    lodash.isNaN = isNaN;\n\t    lodash.isNative = isNative;\n\t    lodash.isNull = isNull;\n\t    lodash.isNumber = isNumber;\n\t    lodash.isObject = isObject;\n\t    lodash.isPlainObject = isPlainObject;\n\t    lodash.isRegExp = isRegExp;\n\t    lodash.isString = isString;\n\t    lodash.isTypedArray = isTypedArray;\n\t    lodash.isUndefined = isUndefined;\n\t    lodash.kebabCase = kebabCase;\n\t    lodash.last = last;\n\t    lodash.lastIndexOf = lastIndexOf;\n\t    lodash.max = max;\n\t    lodash.min = min;\n\t    lodash.noConflict = noConflict;\n\t    lodash.noop = noop;\n\t    lodash.now = now;\n\t    lodash.pad = pad;\n\t    lodash.padLeft = padLeft;\n\t    lodash.padRight = padRight;\n\t    lodash.parseInt = parseInt;\n\t    lodash.random = random;\n\t    lodash.reduce = reduce;\n\t    lodash.reduceRight = reduceRight;\n\t    lodash.repeat = repeat;\n\t    lodash.result = result;\n\t    lodash.runInContext = runInContext;\n\t    lodash.size = size;\n\t    lodash.snakeCase = snakeCase;\n\t    lodash.some = some;\n\t    lodash.sortedIndex = sortedIndex;\n\t    lodash.sortedLastIndex = sortedLastIndex;\n\t    lodash.startCase = startCase;\n\t    lodash.startsWith = startsWith;\n\t    lodash.template = template;\n\t    lodash.trim = trim;\n\t    lodash.trimLeft = trimLeft;\n\t    lodash.trimRight = trimRight;\n\t    lodash.trunc = trunc;\n\t    lodash.unescape = unescape;\n\t    lodash.uniqueId = uniqueId;\n\t    lodash.words = words;\n\t\n\t    // Add aliases.\n\t    lodash.all = every;\n\t    lodash.any = some;\n\t    lodash.contains = includes;\n\t    lodash.detect = find;\n\t    lodash.foldl = reduce;\n\t    lodash.foldr = reduceRight;\n\t    lodash.head = first;\n\t    lodash.include = includes;\n\t    lodash.inject = reduce;\n\t\n\t    mixin(lodash, (function() {\n\t      var source = {};\n\t      baseForOwn(lodash, function(func, methodName) {\n\t        if (!lodash.prototype[methodName]) {\n\t          source[methodName] = func;\n\t        }\n\t      });\n\t      return source;\n\t    }()), false);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add functions capable of returning wrapped and unwrapped values when chaining.\n\t    lodash.sample = sample;\n\t\n\t    lodash.prototype.sample = function(n) {\n\t      if (!this.__chain__ && n == null) {\n\t        return sample(this.value());\n\t      }\n\t      return this.thru(function(value) {\n\t        return sample(value, n);\n\t      });\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The semantic version number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type string\n\t     */\n\t    lodash.VERSION = VERSION;\n\t\n\t    // Assign default placeholders.\n\t    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n\t      lodash[methodName].placeholder = lodash;\n\t    });\n\t\n\t    // Add `LazyWrapper` methods that accept an `iteratee` value.\n\t    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n\t      var isFilter = index == LAZY_FILTER_FLAG,\n\t          isWhile = index == LAZY_WHILE_FLAG;\n\t\n\t      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n\t        var result = this.clone(),\n\t            filtered = result.__filtered__,\n\t            iteratees = result.__iteratees__ || (result.__iteratees__ = []);\n\t\n\t        result.__filtered__ = filtered || isFilter || (isWhile && result.__dir__ < 0);\n\t        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });\n\t        return result;\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n\t    arrayEach(['drop', 'take'], function(methodName, index) {\n\t      var countName = '__' + methodName + 'Count__',\n\t          whileName = methodName + 'While';\n\t\n\t      LazyWrapper.prototype[methodName] = function(n) {\n\t        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);\n\t\n\t        var result = this.clone();\n\t        if (result.__filtered__) {\n\t          var value = result[countName];\n\t          result[countName] = index ? nativeMin(value, n) : (value + n);\n\t        } else {\n\t          var views = result.__views__ || (result.__views__ = []);\n\t          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n\t        }\n\t        return result;\n\t      };\n\t\n\t      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n\t        return this.reverse()[methodName](n).reverse();\n\t      };\n\t\n\t      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {\n\t        return this.reverse()[whileName](predicate, thisArg).reverse();\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n\t    arrayEach(['first', 'last'], function(methodName, index) {\n\t      var takeName = 'take' + (index ? 'Right' : '');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this[takeName](1).value()[0];\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n\t    arrayEach(['initial', 'rest'], function(methodName, index) {\n\t      var dropName = 'drop' + (index ? '' : 'Right');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this[dropName](1);\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n\t    arrayEach(['pluck', 'where'], function(methodName, index) {\n\t      var operationName = index ? 'filter' : 'map',\n\t          createCallback = index ? baseMatches : baseProperty;\n\t\n\t      LazyWrapper.prototype[methodName] = function(value) {\n\t        return this[operationName](createCallback(value));\n\t      };\n\t    });\n\t\n\t    LazyWrapper.prototype.compact = function() {\n\t      return this.filter(identity);\n\t    };\n\t\n\t    LazyWrapper.prototype.dropWhile = function(iteratee, thisArg) {\n\t      var done;\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      return this.filter(function(value, index, array) {\n\t        return done || (done = !iteratee(value, index, array));\n\t      });\n\t    };\n\t\n\t    LazyWrapper.prototype.reject = function(iteratee, thisArg) {\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      return this.filter(function(value, index, array) {\n\t        return !iteratee(value, index, array);\n\t      });\n\t    };\n\t\n\t    LazyWrapper.prototype.slice = function(start, end) {\n\t      start = start == null ? 0 : (+start || 0);\n\t      var result = start < 0 ? this.takeRight(-start) : this.drop(start);\n\t\n\t      if (typeof end != 'undefined') {\n\t        end = (+end || 0);\n\t        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n\t      }\n\t      return result;\n\t    };\n\t\n\t    LazyWrapper.prototype.toArray = function() {\n\t      return this.drop(0);\n\t    };\n\t\n\t    // Add `LazyWrapper` methods to `lodash.prototype`.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var lodashFunc = lodash[methodName],\n\t          retUnwrapped = /^(?:first|last)$/.test(methodName);\n\t\n\t      lodash.prototype[methodName] = function() {\n\t        var value = this.__wrapped__,\n\t            args = arguments,\n\t            chainAll = this.__chain__,\n\t            isHybrid = !!this.__actions__.length,\n\t            isLazy = value instanceof LazyWrapper,\n\t            onlyLazy = isLazy && !isHybrid;\n\t\n\t        if (retUnwrapped && !chainAll) {\n\t          return onlyLazy\n\t            ? func.call(value)\n\t            : lodashFunc.call(lodash, this.value());\n\t        }\n\t        var interceptor = function(value) {\n\t          var otherArgs = [value];\n\t          push.apply(otherArgs, args);\n\t          return lodashFunc.apply(lodash, otherArgs);\n\t        };\n\t        if (isLazy || isArray(value)) {\n\t          var wrapper = onlyLazy ? value : new LazyWrapper(this),\n\t              result = func.apply(wrapper, args);\n\t\n\t          if (!retUnwrapped && (isHybrid || result.__actions__)) {\n\t            var actions = result.__actions__ || (result.__actions__ = []);\n\t            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });\n\t          }\n\t          return new LodashWrapper(result, chainAll);\n\t        }\n\t        return this.thru(interceptor);\n\t      };\n\t    });\n\t\n\t    // Add `Array.prototype` functions to `lodash.prototype`.\n\t    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n\t      var func = arrayProto[methodName],\n\t          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n\t          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);\n\t\n\t      lodash.prototype[methodName] = function() {\n\t        var args = arguments;\n\t        if (retUnwrapped && !this.__chain__) {\n\t          return func.apply(this.value(), args);\n\t        }\n\t        return this[chainName](function(value) {\n\t          return func.apply(value, args);\n\t        });\n\t      };\n\t    });\n\t\n\t    // Add functions to the lazy wrapper.\n\t    LazyWrapper.prototype.clone = lazyClone;\n\t    LazyWrapper.prototype.reverse = lazyReverse;\n\t    LazyWrapper.prototype.value = lazyValue;\n\t\n\t    // Add chaining functions to the lodash wrapper.\n\t    lodash.prototype.chain = wrapperChain;\n\t    lodash.prototype.commit = wrapperCommit;\n\t    lodash.prototype.plant = wrapperPlant;\n\t    lodash.prototype.reverse = wrapperReverse;\n\t    lodash.prototype.toString = wrapperToString;\n\t    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\t\n\t    // Add function aliases to the lodash wrapper.\n\t    lodash.prototype.collect = lodash.prototype.map;\n\t    lodash.prototype.head = lodash.prototype.first;\n\t    lodash.prototype.select = lodash.prototype.filter;\n\t    lodash.prototype.tail = lodash.prototype.rest;\n\t\n\t    return lodash;\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  // Export lodash.\n\t  var _ = runInContext();\n\t\n\t  // Some AMD build optimizers like r.js check for condition patterns like the following:\n\t  if (true) {\n\t    // Expose lodash to the global object when an AMD loader is present to avoid\n\t    // errors in cases where lodash is loaded by a script tag and not intended\n\t    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n\t    // more details.\n\t    root._ = _;\n\t\n\t    // Define as an anonymous module so, through path mapping, it can be\n\t    // referenced as the \"underscore\" module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return _;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n\t  else if (freeExports && freeModule) {\n\t    // Export for Node.js or RingoJS.\n\t    if (moduleExports) {\n\t      (freeModule.exports = _)._ = _;\n\t    }\n\t    // Export for Narwhal or Rhino -require.\n\t    else {\n\t      freeExports._ = _;\n\t    }\n\t  }\n\t  else {\n\t    // Export for a browser or Rhino.\n\t    root._ = _;\n\t  }\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module), (function() { return this; }())))\n\n/***/ },\n\n/***/ 208:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar chardet = __webpack_require__(201)\n\t\n\texports.read = function read(buffer) {\n\t  throw new Error('Synchronous read unsupported in browser!')\n\t}\n\t\n\texports.readAsync = function read(buffer, callback) {\n\t  var charset = chardet.detect(buffer)\n\t  var reader = new FileReader()\n\t  reader.onload = function() {\n\t    callback(null, reader.result)\n\t  }\n\t  reader.onerror = function() {\n\t    callback(new Error('cannot read it'))\n\t  }\n\t  reader.readAsText(new Blob([buffer]), charset)\n\t}\n\t\n\n\n/***/ },\n\n/***/ 209:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar match = __webpack_require__(117)\n\tmodule.exports = SongInfo\n\t\n\tfunction SongInfo() {\n\t  this.title      = 'NO TITLE'\n\t  this.artist     = 'NO ARTIST'\n\t  this.genre      = 'NO GENRE'\n\t  this.subtitles  = []\n\t  this.subartists = []\n\t  this.difficulty = 0\n\t  this.level      = 0\n\t}\n\t\n\tSongInfo.fromBMSChart = function(chart) {\n\t  var info = new SongInfo()\n\t  var title      = chart.headers.get('title')\n\t  var artist     = chart.headers.get('artist')\n\t  var genre      = chart.headers.get('genre')\n\t  var difficulty = +chart.headers.get('difficulty')\n\t  var level      = +chart.headers.get('playlevel')\n\t  var subtitles  = chart.headers.getAll('subtitle')\n\t  var subartists = chart.headers.getAll('subartist')\n\t  if (typeof title === 'string' && !subtitles) {\n\t    var extractSubtitle = function(m) {\n\t      title = m[1]\n\t      subtitles = [m[2]]\n\t    }\n\t    match(title)\n\t    .when(/^(.*\\S)\\s*-(.+?)-$/,   extractSubtitle)\n\t    .when(/^(.*\\S)\\s*～(.+?)～$/, extractSubtitle)\n\t    .when(/^(.*\\S)\\s*\\((.+?)\\)$/, extractSubtitle)\n\t    .when(/^(.*\\S)\\s*\\[(.+?)\\]$/, extractSubtitle)\n\t    .when(/^(.*\\S)\\s*<(.+?)>$/,   extractSubtitle)\n\t  }\n\t  if (title)      info.title      = title\n\t  if (artist)     info.artist     = artist\n\t  if (genre)      info.genre      = genre\n\t  if (subtitles)  info.subtitles  = subtitles\n\t  if (subartists) info.subartists = subartists\n\t  if (difficulty) info.difficulty = difficulty\n\t  if (level)      info.level      = level\n\t  return info\n\t}\n\t\n\n\n/***/ },\n\n/***/ 210:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Parse byte `size` string.\n\t *\n\t * @param {String} size\n\t * @return {Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(size) {\n\t  if ('number' == typeof size) return convert(size);\n\t  var parts = size.match(/^(\\d+(?:\\.\\d+)?) *(kb|mb|gb|tb)$/)\n\t    , n = parseFloat(parts[1])\n\t    , type = parts[2];\n\t\n\t  var map = {\n\t      kb: 1 << 10\n\t    , mb: 1 << 20\n\t    , gb: 1 << 30\n\t    , tb: ((1 << 30) * 1024)\n\t  };\n\t\n\t  return map[type] * n;\n\t};\n\t\n\t/**\n\t * convert bytes into string.\n\t *\n\t * @param {Number} b - bytes to convert\n\t * @return {String}\n\t * @api public\n\t */\n\t\n\tfunction convert (b) {\n\t  var tb = ((1 << 30) * 1024), gb = 1 << 30, mb = 1 << 20, kb = 1 << 10, abs = Math.abs(b);\n\t  if (abs >= tb) return (Math.round(b / tb * 100) / 100) + 'tb';\n\t  if (abs >= gb) return (Math.round(b / gb * 100) / 100) + 'gb';\n\t  if (abs >= mb) return (Math.round(b / mb * 100) / 100) + 'mb';\n\t  if (abs >= kb) return (Math.round(b / kb * 100) / 100) + 'kb';\n\t  return b + 'b';\n\t}\n\n\n/***/ },\n\n/***/ 244:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(32)();\n\texports.push([module.id, \".loading-scene{position:absolute;top:0;right:0;bottom:0;left:0;overflow:hidden;background:url(\"+__webpack_require__(246)+\") center no-repeat;background-size:cover}.loading-scene--info{position:absolute;top:40%;left:0;right:0;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.loading-scene .loading-scene-song-info{-webkit-animation:loading-scene-song-info-animation 1s ease;animation:loading-scene-song-info-animation 1s ease}.loading-scene .loading-scene-progress{position:absolute;bottom:10px;left:10px}.loading-scene--flash{background:#fff;-webkit-animation:loading-scene--flash-animation .8s ease-out;animation:loading-scene--flash-animation .8s ease-out}.loading-scene--flash,.loading-scene--cover{position:absolute;top:0;right:0;bottom:0;left:0;opacity:0;pointer-events:none}.loading-scene--cover{background:#000}.scene.is-exiting .loading-scene--info{-webkit-animation:loading-scene--info-exit .3s linear;animation:loading-scene--info-exit .3s linear}.scene.is-exiting .loading-scene--flash{-webkit-animation:loading-scene--flash-exit .3s ease;animation:loading-scene--flash-exit .3s ease}.scene.is-exiting .loading-scene--cover{-webkit-animation:loading-scene--cover-exit .3s linear;animation:loading-scene--cover-exit .3s linear;opacity:1}@-webkit-keyframes loading-scene-song-info-animation{0%{-webkit-transform:scale(1.5,.02);transform:scale(1.5,.02)}100%{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes loading-scene-song-info-animation{0%{-webkit-transform:scale(1.5,.02);transform:scale(1.5,.02)}100%{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes loading-scene--info-exit{0%{-webkit-transform:translateY(-50%)scale(1,1);transform:translateY(-50%)scale(1,1)}100%{-webkit-transform:translateY(-50%)scale(2,2);transform:translateY(-50%)scale(2,2)}}@keyframes loading-scene--info-exit{0%{-webkit-transform:translateY(-50%)scale(1,1);transform:translateY(-50%)scale(1,1)}100%{-webkit-transform:translateY(-50%)scale(2,2);transform:translateY(-50%)scale(2,2)}}@-webkit-keyframes loading-scene--cover-exit{0%{opacity:0}100%{opacity:1}}@keyframes loading-scene--cover-exit{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes loading-scene--flash-animation{0%{opacity:1}100%{opacity:0}}@keyframes loading-scene--flash-animation{0%{opacity:1}100%{opacity:0}}@-webkit-keyframes loading-scene--flash-exit{0%{opacity:.5}100%{opacity:0}}@keyframes loading-scene--flash-exit{0%{opacity:.5}100%{opacity:0}}.loading-scene-song-info{background:rgba(255,255,255,.96);color:#191817;text-align:center;padding:25px 0;box-shadow:0 2px 18px rgba(0,0,0,.2)}.loading-scene-song-info--genre{font-size:3vmin}.loading-scene-song-info--title{font-size:8vmin;font-weight:700}.loading-scene-song-info--subtitle{font-size:6vmin}.loading-scene-song-info--artist{font-size:4vmin;margin-top:.8ex}.loading-scene-song-info--subartist{font-size:2.5vmin}.loading-scene-progress{color:#333;font-size:11px}.loading-scene-progress .loading-scene-progress-bar{display:inline-block;vertical-align:middle;width:48px;margin-right:4px;position:relative;top:-1px}.loading-scene-progress-bar{border:1px solid rgba(0,0,0,.6);padding:1px}.loading-scene-progress-bar--bar{height:8px;background:rgba(0,0,0,.6);width:0%}.loading-scene-progress-bar--progress{font-size:83%;opacity:.7}\", \"\"]);\n\n/***/ },\n\n/***/ 246:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"7d6d69a86d70e4e52079c5ce873435c6.jpg\"\n\n/***/ },\n\n/***/ 254:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports={\"v\":1,\"t\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--info\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--genre\"},\"f\":[{\"t\":2,\"r\":\"song.genre\"}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--title\"},\"f\":[{\"t\":2,\"r\":\"song.title\"}]},{\"t\":4,\"r\":\"song.subtitles\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--subtitle\"},\"f\":[{\"t\":2,\"r\":\".\"}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--artist\"},\"f\":[{\"t\":2,\"r\":\"song.artist\"}]},{\"t\":4,\"r\":\"song.subartists\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--subartist\"},\"f\":[{\"t\":2,\"r\":\".\"}]}]}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress\"},\"f\":[{\"t\":4,\"r\":\"items\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress--item\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress-bar\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"style\":[\"width:\",{\"t\":2,\"r\":\"width\"}],\"class\":\"loading-scene-progress-bar--bar\"}}]},{\"t\":2,\"r\":\"text\"},{\"t\":7,\"e\":\"span\",\"a\":{\"class\":\"loading-scene-progress-bar--progress\"},\"f\":[{\"t\":2,\"r\":\"progress\"}]}]}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--flash\"}},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--cover\"}}]}]};\n\n/***/ },\n\n/***/ 255:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t\tractive.js v0.6.1\n\t\t2014-10-25 - commit 3a576eb3 \n\t\n\t\thttp://ractivejs.org\n\t\thttp://twitter.com/RactiveJS\n\t\n\t\tReleased under the MIT License.\n\t*/\n\t\n\t( function( global ) {\n\t\n\t\t'use strict';\n\t\n\t\tvar noConflict = global.Ractive;\n\t\n\t\t/* config/defaults/options.js */\n\t\tvar options = function() {\n\t\n\t\t\tvar defaultOptions = {\n\t\t\t\t// render placement:\n\t\t\t\tel: void 0,\n\t\t\t\tappend: false,\n\t\t\t\t// template:\n\t\t\t\ttemplate: {\n\t\t\t\t\tv: 1,\n\t\t\t\t\tt: []\n\t\t\t\t},\n\t\t\t\tyield: null,\n\t\t\t\t// parse:\n\t\t\t\tpreserveWhitespace: false,\n\t\t\t\tsanitize: false,\n\t\t\t\tstripComments: true,\n\t\t\t\t// data & binding:\n\t\t\t\tdata: {},\n\t\t\t\tcomputed: {},\n\t\t\t\tmagic: false,\n\t\t\t\tmodifyArrays: true,\n\t\t\t\tadapt: [],\n\t\t\t\tisolated: false,\n\t\t\t\ttwoway: true,\n\t\t\t\tlazy: false,\n\t\t\t\t// transitions:\n\t\t\t\tnoIntro: false,\n\t\t\t\ttransitionsEnabled: true,\n\t\t\t\tcomplete: void 0,\n\t\t\t\t// css:\n\t\t\t\tnoCssTransform: false,\n\t\t\t\t// debug:\n\t\t\t\tdebug: false\n\t\t\t};\n\t\t\treturn defaultOptions;\n\t\t}();\n\t\n\t\t/* config/defaults/easing.js */\n\t\tvar easing = {\n\t\t\tlinear: function( pos ) {\n\t\t\t\treturn pos;\n\t\t\t},\n\t\t\teaseIn: function( pos ) {\n\t\t\t\treturn Math.pow( pos, 3 );\n\t\t\t},\n\t\t\teaseOut: function( pos ) {\n\t\t\t\treturn Math.pow( pos - 1, 3 ) + 1;\n\t\t\t},\n\t\t\teaseInOut: function( pos ) {\n\t\t\t\tif ( ( pos /= 0.5 ) < 1 ) {\n\t\t\t\t\treturn 0.5 * Math.pow( pos, 3 );\n\t\t\t\t}\n\t\t\t\treturn 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );\n\t\t\t}\n\t\t};\n\t\n\t\t/* circular.js */\n\t\tvar circular = [];\n\t\n\t\t/* utils/hasOwnProperty.js */\n\t\tvar hasOwn = Object.prototype.hasOwnProperty;\n\t\n\t\t/* utils/isArray.js */\n\t\tvar isArray = function() {\n\t\n\t\t\tvar toString = Object.prototype.toString;\n\t\t\t// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\t\t\treturn function( thing ) {\n\t\t\t\treturn toString.call( thing ) === '[object Array]';\n\t\t\t};\n\t\t}();\n\t\n\t\t/* utils/isObject.js */\n\t\tvar isObject = function() {\n\t\n\t\t\tvar toString = Object.prototype.toString;\n\t\t\treturn function( thing ) {\n\t\t\t\treturn thing && toString.call( thing ) === '[object Object]';\n\t\t\t};\n\t\t}();\n\t\n\t\t/* utils/isNumeric.js */\n\t\tvar isNumeric = function( thing ) {\n\t\t\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t\t};\n\t\n\t\t/* config/defaults/interpolators.js */\n\t\tvar interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {\n\t\n\t\t\tvar interpolators, interpolate, cssLengthPattern;\n\t\t\tcircular.push( function() {\n\t\t\t\tinterpolate = circular.interpolate;\n\t\t\t} );\n\t\t\tcssLengthPattern = /^([+-]?[0-9]+\\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;\n\t\t\tinterpolators = {\n\t\t\t\tnumber: function( from, to ) {\n\t\t\t\t\tvar delta;\n\t\t\t\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tfrom = +from;\n\t\t\t\t\tto = +to;\n\t\t\t\t\tdelta = to - from;\n\t\t\t\t\tif ( !delta ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\treturn from;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn function( t ) {\n\t\t\t\t\t\treturn from + t * delta;\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tarray: function( from, to ) {\n\t\t\t\t\tvar intermediate, interpolators, len, i;\n\t\t\t\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tintermediate = [];\n\t\t\t\t\tinterpolators = [];\n\t\t\t\t\ti = len = Math.min( from.length, to.length );\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tinterpolators[ i ] = interpolate( from[ i ], to[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\t\t\t\tfor ( i = len; i < from.length; i += 1 ) {\n\t\t\t\t\t\tintermediate[ i ] = from[ i ];\n\t\t\t\t\t}\n\t\t\t\t\tfor ( i = len; i < to.length; i += 1 ) {\n\t\t\t\t\t\tintermediate[ i ] = to[ i ];\n\t\t\t\t\t}\n\t\t\t\t\treturn function( t ) {\n\t\t\t\t\t\tvar i = len;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tintermediate[ i ] = interpolators[ i ]( t );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn intermediate;\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tobject: function( from, to ) {\n\t\t\t\t\tvar properties, len, interpolators, intermediate, prop;\n\t\t\t\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tproperties = [];\n\t\t\t\t\tintermediate = {};\n\t\t\t\t\tinterpolators = {};\n\t\t\t\t\tfor ( prop in from ) {\n\t\t\t\t\t\tif ( hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) ) {\n\t\t\t\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor ( prop in to ) {\n\t\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlen = properties.length;\n\t\t\t\t\treturn function( t ) {\n\t\t\t\t\t\tvar i = len,\n\t\t\t\t\t\t\tprop;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprop = properties[ i ];\n\t\t\t\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn intermediate;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn interpolators;\n\t\t}( circular, hasOwn, isArray, isObject, isNumeric );\n\t\n\t\t/* config/svg.js */\n\t\tvar svg = function() {\n\t\n\t\t\tvar svg;\n\t\t\tif ( typeof document === 'undefined' ) {\n\t\t\t\tsvg = false;\n\t\t\t} else {\n\t\t\t\tsvg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );\n\t\t\t}\n\t\t\treturn svg;\n\t\t}();\n\t\n\t\t/* utils/warn.js */\n\t\tvar warn = function() {\n\t\n\t\t\t/* global console */\n\t\t\tvar warn, warned = {};\n\t\t\tif ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {\n\t\t\t\twarn = function( message, allowDuplicates ) {\n\t\t\t\t\tif ( !allowDuplicates ) {\n\t\t\t\t\t\tif ( warned[ message ] ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twarned[ message ] = true;\n\t\t\t\t\t}\n\t\t\t\t\tconsole.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\twarn = function() {};\n\t\t\t}\n\t\t\treturn warn;\n\t\t}();\n\t\n\t\t/* config/errors.js */\n\t\tvar errors = {\n\t\t\tmissingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',\n\t\t\tmergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',\n\t\t\tnoComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',\n\t\t\tnoTemplateForPartial: 'Could not find template for partial \"{name}\"',\n\t\t\tnoNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',\n\t\t\tevaluationError: 'Error evaluating \"{uniqueString}\": {err}',\n\t\t\tbadArguments: 'Bad arguments \"{arguments}\". I\\'m not allowed to argue unless you\\'ve paid.',\n\t\t\tfailedComputation: 'Failed to compute \"{key}\": {err}',\n\t\t\tmissingPlugin: 'Missing \"{name}\" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',\n\t\t\tbadRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n\t\t\tnoRegistryFunctionReturn: 'A function was specified for \"{name}\" {registry}, but no {registry} was returned',\n\t\t\tdefaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',\n\t\t\tnoElementProxyEventWildcards: 'Only component proxy-events may contain \"*\" wildcards, <{element} on-{event}/> is not valid.',\n\t\t\tmethodDeprecated: 'The method \"{deprecated}\" has been deprecated in favor of \"{replacement}\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'\n\t\t};\n\t\n\t\t/* utils/log.js */\n\t\tvar log = function( consolewarn, errors ) {\n\t\n\t\t\tvar log = {\n\t\t\t\twarn: function( options, passthru ) {\n\t\t\t\t\tif ( !options.debug && !passthru ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.warnAlways( options );\n\t\t\t\t},\n\t\t\t\twarnAlways: function( options ) {\n\t\t\t\t\tthis.logger( getMessage( options ), options.allowDuplicates );\n\t\t\t\t},\n\t\t\t\terror: function( options ) {\n\t\t\t\t\tthis.errorOnly( options );\n\t\t\t\t\tif ( !options.debug ) {\n\t\t\t\t\t\tthis.warn( options, true );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terrorOnly: function( options ) {\n\t\t\t\t\tif ( options.debug ) {\n\t\t\t\t\t\tthis.critical( options );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcritical: function( options ) {\n\t\t\t\t\tvar err = options.err || new Error( getMessage( options ) );\n\t\t\t\t\tthis.thrower( err );\n\t\t\t\t},\n\t\t\t\tlogger: consolewarn,\n\t\t\t\tthrower: function( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction getMessage( options ) {\n\t\t\t\tvar message = errors[ options.message ] || options.message || '';\n\t\t\t\treturn interpolate( message, options.args );\n\t\t\t}\n\t\t\t// simple interpolation. probably quicker (and better) out there,\n\t\t\t// but log is not in golden path of execution, only exceptions\n\t\t\tfunction interpolate( message, args ) {\n\t\t\t\treturn message.replace( /{([^{}]*)}/g, function( a, b ) {\n\t\t\t\t\treturn args[ b ];\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn log;\n\t\t}( warn, errors );\n\t\n\t\t/* Ractive/prototype/shared/hooks/Hook.js */\n\t\tvar Ractive$shared_hooks_Hook = function( log ) {\n\t\n\t\t\tvar deprecations = {\n\t\t\t\tconstruct: {\n\t\t\t\t\tdeprecated: 'beforeInit',\n\t\t\t\t\treplacement: 'onconstruct'\n\t\t\t\t},\n\t\t\t\trender: {\n\t\t\t\t\tdeprecated: 'init',\n\t\t\t\t\tmessage: 'The \"init\" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the \"oninit\" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use \"onrender\" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t\t\t\t},\n\t\t\t\tcomplete: {\n\t\t\t\t\tdeprecated: 'complete',\n\t\t\t\t\treplacement: 'oncomplete'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction Hook( event ) {\n\t\t\t\tthis.event = event;\n\t\t\t\tthis.method = 'on' + event;\n\t\t\t\tthis.deprecate = deprecations[ event ];\n\t\t\t}\n\t\t\tHook.prototype.fire = function( ractive, arg ) {\n\t\t\t\tfunction call( method ) {\n\t\t\t\t\tif ( ractive[ method ] ) {\n\t\t\t\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcall( this.method );\n\t\t\t\tif ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {\n\t\t\t\t\tlog.warnAlways( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: this.deprecate.message || 'methodDeprecated',\n\t\t\t\t\t\targs: this.deprecate\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t\t\t};\n\t\t\treturn Hook;\n\t\t}( log );\n\t\n\t\t/* utils/removeFromArray.js */\n\t\tvar removeFromArray = function( array, member ) {\n\t\t\tvar index = array.indexOf( member );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tarray.splice( index, 1 );\n\t\t\t}\n\t\t};\n\t\n\t\t/* utils/Promise.js */\n\t\tvar Promise = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar _Promise, PENDING = {},\n\t\t\t\tFULFILLED = {},\n\t\t\t\tREJECTED = {};\n\t\t\tif ( typeof Promise === 'function' ) {\n\t\t\t\t// use native Promise\n\t\t\t\t_Promise = Promise;\n\t\t\t} else {\n\t\t\t\t_Promise = function( callback ) {\n\t\t\t\t\tvar fulfilledHandlers = [],\n\t\t\t\t\t\trejectedHandlers = [],\n\t\t\t\t\t\tstate = PENDING,\n\t\t\t\t\t\tresult, dispatchHandlers, makeResolver, fulfil, reject, promise;\n\t\t\t\t\tmakeResolver = function( newState ) {\n\t\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult = value;\n\t\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t\t\tdispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );\n\t\t\t\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t\tfulfil = makeResolver( FULFILLED );\n\t\t\t\t\treject = makeResolver( REJECTED );\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcallback( fulfil, reject );\n\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t}\n\t\t\t\t\tpromise = {\n\t\t\t\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\t\t\t\tthen: function( onFulfilled, onRejected ) {\n\t\t\t\t\t\t\tvar promise2 = new _Promise( function( fulfil, reject ) {\n\t\t\t\t\t\t\t\tvar processResolutionHandler = function( handler, handlers, forward ) {\n\t\t\t\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\t\t\t\thandlers.push( function( p1result ) {\n\t\t\t\t\t\t\t\t\t\t\tvar x;\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// 2.2\n\t\t\t\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\t\t\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\treturn promise2;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tpromise[ 'catch' ] = function( onRejected ) {\n\t\t\t\t\t\treturn this.then( null, onRejected );\n\t\t\t\t\t};\n\t\t\t\t\treturn promise;\n\t\t\t\t};\n\t\t\t\t_Promise.all = function( promises ) {\n\t\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\t\tvar result = [],\n\t\t\t\t\t\t\tpending, i, processPromise;\n\t\t\t\t\t\tif ( !promises.length ) {\n\t\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocessPromise = function( i ) {\n\t\t\t\t\t\t\tpromises[ i ].then( function( value ) {\n\t\t\t\t\t\t\t\tresult[ i ] = value;\n\t\t\t\t\t\t\t\tif ( !--pending ) {\n\t\t\t\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, reject );\n\t\t\t\t\t\t};\n\t\t\t\t\t\tpending = i = promises.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprocessPromise( i );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t};\n\t\t\t\t_Promise.resolve = function( value ) {\n\t\t\t\t\treturn new _Promise( function( fulfil ) {\n\t\t\t\t\t\tfulfil( value );\n\t\t\t\t\t} );\n\t\t\t\t};\n\t\t\t\t_Promise.reject = function( reason ) {\n\t\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\t\treject( reason );\n\t\t\t\t\t} );\n\t\t\t\t};\n\t\t\t}\n\t\t\t__export = _Promise;\n\t\t\t// TODO use MutationObservers or something to simulate setImmediate\n\t\t\tfunction wait( callback ) {\n\t\t\t\tsetTimeout( callback, 0 );\n\t\t\t}\n\t\n\t\t\tfunction makeDispatcher( handlers, result ) {\n\t\t\t\treturn function() {\n\t\t\t\t\tvar handler;\n\t\t\t\t\twhile ( handler = handlers.shift() ) {\n\t\t\t\t\t\thandler( result );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tfunction resolve( promise, x, fulfil, reject ) {\n\t\t\t\t// Promise Resolution Procedure\n\t\t\t\tvar then;\n\t\t\t\t// 2.3.1\n\t\t\t\tif ( x === promise ) {\n\t\t\t\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t\t\t\t}\n\t\t\t\t// 2.3.2\n\t\t\t\tif ( x instanceof _Promise ) {\n\t\t\t\t\tx.then( fulfil, reject );\n\t\t\t\t} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthen = x.then;\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\treject( e );\n\t\t\t\t\t\t// 2.3.3.2\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 2.3.3.3\n\t\t\t\t\tif ( typeof then === 'function' ) {\n\t\t\t\t\t\tvar called, resolvePromise, rejectPromise;\n\t\t\t\t\t\tresolvePromise = function( y ) {\n\t\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t\t\t\t};\n\t\t\t\t\t\trejectPromise = function( r ) {\n\t\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\treject( r );\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\tif ( !called ) {\n\t\t\t\t\t\t\t\t// 2.3.3.3.4.1\n\t\t\t\t\t\t\t\treject( e );\n\t\t\t\t\t\t\t\t// 2.3.3.3.4.2\n\t\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfulfil( x );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( x );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* utils/normaliseRef.js */\n\t\tvar normaliseRef = function() {\n\t\n\t\t\tvar regex = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\t\t\treturn function normaliseRef( ref ) {\n\t\t\t\treturn ( ref || '' ).replace( regex, '.$1' );\n\t\t\t};\n\t\t}();\n\t\n\t\t/* shared/getInnerContext.js */\n\t\tvar getInnerContext = function( fragment ) {\n\t\t\tdo {\n\t\t\t\tif ( fragment.context !== undefined ) {\n\t\t\t\t\treturn fragment.context;\n\t\t\t\t}\n\t\t\t} while ( fragment = fragment.parent );\n\t\t\treturn '';\n\t\t};\n\t\n\t\t/* utils/isEqual.js */\n\t\tvar isEqual = function( a, b ) {\n\t\t\tif ( a === null && b === null ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn a === b;\n\t\t};\n\t\n\t\t/* shared/createComponentBinding.js */\n\t\tvar createComponentBinding = function( circular, isEqual ) {\n\t\n\t\t\tvar runloop;\n\t\t\tcircular.push( function() {\n\t\t\t\treturn runloop = circular.runloop;\n\t\t\t} );\n\t\t\tvar Binding = function( ractive, keypath, otherInstance, otherKeypath ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tthis.root = ractive;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.otherInstance = otherInstance;\n\t\t\t\tthis.otherKeypath = otherKeypath;\n\t\t\t\tthis.lock = function() {\n\t\t\t\t\treturn this$0.updating = true;\n\t\t\t\t};\n\t\t\t\tthis.unlock = function() {\n\t\t\t\t\treturn this$0.updating = false;\n\t\t\t\t};\n\t\t\t\tthis.bind();\n\t\t\t\tthis.value = this.root.viewmodel.get( this.keypath );\n\t\t\t};\n\t\t\tBinding.prototype = {\n\t\t\t\tisLocked: function() {\n\t\t\t\t\treturn this.updating || this.counterpart && this.counterpart.updating;\n\t\t\t\t},\n\t\t\t\tshuffle: function( newIndices, value ) {\n\t\t\t\t\tthis.propagateChange( value, newIndices );\n\t\t\t\t},\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\tthis.propagateChange( value );\n\t\t\t\t},\n\t\t\t\tpropagateChange: function( value, newIndices ) {\n\t\t\t\t\tvar other;\n\t\t\t\t\t// Only *you* can prevent infinite loops\n\t\t\t\t\tif ( this.isLocked() ) {\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\t\tthis.lock();\n\t\t\t\t\t\t// TODO maybe the case that `value === this.value` - should that result\n\t\t\t\t\t\t// in an update rather than a set?\n\t\t\t\t\t\t// if the other viewmodel is already locked up, need to do a deferred update\n\t\t\t\t\t\tif ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {\n\t\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\t\treturn runloop.addViewmodel( other );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( newIndices ) {\n\t\t\t\t\t\t\tother.smartUpdate( this.otherKeypath, value, newIndices );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( isSettable( other, this.otherKeypath ) ) {\n\t\t\t\t\t\t\t\tother.set( this.otherKeypath, value );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\t// TODO will the counterpart update after this line, during\n\t\t\t\t\t\t// the runloop end cycle? may be a problem...\n\t\t\t\t\t\trunloop.scheduleTask( this.unlock );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trefineValue: function( keypaths ) {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar other;\n\t\t\t\t\tif ( this.isLocked() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.lock();\n\t\t\t\t\trunloop.addViewmodel( other = this.otherInstance.viewmodel );\n\t\t\t\t\tkeypaths.map( function( keypath ) {\n\t\t\t\t\t\treturn this$0.otherKeypath + keypath.substr( this$0.keypath.length );\n\t\t\t\t\t} ).forEach( function( keypath ) {\n\t\t\t\t\t\treturn other.mark( keypath );\n\t\t\t\t\t} );\n\t\t\t\t\trunloop.scheduleTask( this.unlock );\n\t\t\t\t},\n\t\t\t\tbind: function() {\n\t\t\t\t\tthis.root.viewmodel.register( this.keypath, this );\n\t\t\t\t},\n\t\t\t\trebind: function( newKeypath ) {\n\t\t\t\t\tthis.unbind();\n\t\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\t\tthis.counterpart.otherKeypath = newKeypath;\n\t\t\t\t\tthis.bind();\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction isSettable( viewmodel, keypath ) {\n\t\t\t\tvar computed = viewmodel.computations[ keypath ];\n\t\t\t\treturn !computed || computed.setter;\n\t\t\t}\n\t\t\treturn function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {\n\t\t\t\tvar hash, childInstance, bindings, parentToChildBinding, childToParentBinding;\n\t\t\t\thash = parentKeypath + '=' + childKeypath;\n\t\t\t\tbindings = component.bindings;\n\t\t\t\tif ( bindings[ hash ] ) {\n\t\t\t\t\t// TODO does this ever happen?\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchildInstance = component.instance;\n\t\t\t\tparentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );\n\t\t\t\tbindings.push( parentToChildBinding );\n\t\t\t\tif ( childInstance.twoway ) {\n\t\t\t\t\tchildToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );\n\t\t\t\t\tbindings.push( childToParentBinding );\n\t\t\t\t\tparentToChildBinding.counterpart = childToParentBinding;\n\t\t\t\t\tchildToParentBinding.counterpart = parentToChildBinding;\n\t\t\t\t}\n\t\t\t\tbindings[ hash ] = parentToChildBinding;\n\t\t\t};\n\t\t}( circular, isEqual );\n\t\n\t\t/* shared/resolveRef.js */\n\t\tvar resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar ancestorErrorMessage, getOptions;\n\t\t\tancestorErrorMessage = 'Could not resolve reference - too many \"../\" prefixes';\n\t\t\tgetOptions = {\n\t\t\t\tevaluateWrapped: true\n\t\t\t};\n\t\t\t__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {\n\t\t\t\tvar context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;\n\t\t\t\tref = normaliseRef( ref );\n\t\t\t\t// If a reference begins '~/', it's a top-level reference\n\t\t\t\tif ( ref.substr( 0, 2 ) === '~/' ) {\n\t\t\t\t\treturn ref.substring( 2 );\n\t\t\t\t}\n\t\t\t\t// If a reference begins with '.', it's either a restricted reference or\n\t\t\t\t// an ancestor reference...\n\t\t\t\tif ( ref.charAt( 0 ) === '.' ) {\n\t\t\t\t\treturn resolveAncestorReference( getInnerContext( fragment ), ref );\n\t\t\t\t}\n\t\t\t\t// ...otherwise we need to find the keypath\n\t\t\t\tkey = ref.split( '.' )[ 0 ];\n\t\t\t\t// get() in viewmodel creation means no fragment (yet)\n\t\t\t\tfragment = fragment || {};\n\t\t\t\tdo {\n\t\t\t\t\tcontext = fragment.context;\n\t\t\t\t\tif ( !context ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thasContextChain = true;\n\t\t\t\t\tparentValue = ractive.viewmodel.get( context, getOptions );\n\t\t\t\t\tif ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {\n\t\t\t\t\t\treturn context + '.' + ref;\n\t\t\t\t\t}\n\t\t\t\t} while ( fragment = fragment.parent );\n\t\t\t\t// Root/computed property?\n\t\t\t\tif ( key in ractive.data || key in ractive.viewmodel.computations ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t\t// If this is an inline component, and it's not isolated, we\n\t\t\t\t// can try going up the scope chain\n\t\t\t\tif ( ractive._parent && !ractive.isolated ) {\n\t\t\t\t\thasContextChain = true;\n\t\t\t\t\tfragment = ractive.component.parentFragment;\n\t\t\t\t\t// Special case - index refs\n\t\t\t\t\tif ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\t\t// Create an index ref binding, so that it can be rebound letter if necessary.\n\t\t\t\t\t\t// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`\n\t\t\t\t\t\tractive.component.indexRefBindings[ ref ] = ref;\n\t\t\t\t\t\tractive.viewmodel.set( ref, index, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tkeypath = resolveRef( ractive._parent, ref, fragment, true );\n\t\t\t\t\tif ( keypath ) {\n\t\t\t\t\t\t// We need to create an inter-component binding\n\t\t\t\t\t\t// If parent keypath is 'one.foo' and child is 'two.foo', we bind\n\t\t\t\t\t\t// 'one' to 'two' as it's more efficient and avoids edge cases\n\t\t\t\t\t\tparentKeys = keypath.split( '.' );\n\t\t\t\t\t\tchildKeys = ref.split( '.' );\n\t\t\t\t\t\twhile ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {\n\t\t\t\t\t\t\tparentKeys.pop();\n\t\t\t\t\t\t\tchildKeys.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparentKeypath = parentKeys.join( '.' );\n\t\t\t\t\t\tchildKeypath = childKeys.join( '.' );\n\t\t\t\t\t\tractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );\n\t\t\t\t\t\tcreateComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );\n\t\t\t\t\t\treturn ref;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If there's no context chain, and the instance is either a) isolated or\n\t\t\t\t// b) an orphan, then we know that the keypath is identical to the reference\n\t\t\t\tif ( !isParentLookup && !hasContextChain ) {\n\t\t\t\t\t// the data object needs to have a property by this name,\n\t\t\t\t\t// to prevent future failed lookups\n\t\t\t\t\tractive.viewmodel.set( ref, undefined );\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t\tif ( ractive.viewmodel.get( ref ) !== undefined ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction resolveAncestorReference( baseContext, ref ) {\n\t\t\t\tvar contextKeys;\n\t\t\t\t// {{.}} means 'current context'\n\t\t\t\tif ( ref === '.' )\n\t\t\t\t\treturn baseContext;\n\t\t\t\tcontextKeys = baseContext ? baseContext.split( '.' ) : [];\n\t\t\t\t// ancestor references (starting \"../\") go up the tree\n\t\t\t\tif ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\t\t\tif ( !contextKeys.length ) {\n\t\t\t\t\t\t\tthrow new Error( ancestorErrorMessage );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontextKeys.pop();\n\t\t\t\t\t\tref = ref.substring( 3 );\n\t\t\t\t\t}\n\t\t\t\t\tcontextKeys.push( ref );\n\t\t\t\t\treturn contextKeys.join( '.' );\n\t\t\t\t}\n\t\t\t\t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n\t\t\t\tif ( !baseContext ) {\n\t\t\t\t\treturn ref.replace( /^\\.\\/?/, '' );\n\t\t\t\t}\n\t\t\t\treturn baseContext + ref.replace( /^\\.\\//, '.' );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( normaliseRef, getInnerContext, createComponentBinding );\n\t\n\t\t/* global/TransitionManager.js */\n\t\tvar TransitionManager = function( removeFromArray ) {\n\t\n\t\t\tvar TransitionManager = function( callback, parent ) {\n\t\t\t\tthis.callback = callback;\n\t\t\t\tthis.parent = parent;\n\t\t\t\tthis.intros = [];\n\t\t\t\tthis.outros = [];\n\t\t\t\tthis.children = [];\n\t\t\t\tthis.totalChildren = this.outroChildren = 0;\n\t\t\t\tthis.detachQueue = [];\n\t\t\t\tthis.outrosComplete = false;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.addChild( this );\n\t\t\t\t}\n\t\t\t};\n\t\t\tTransitionManager.prototype = {\n\t\t\t\taddChild: function( child ) {\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.totalChildren += 1;\n\t\t\t\t\tthis.outroChildren += 1;\n\t\t\t\t},\n\t\t\t\tdecrementOutros: function() {\n\t\t\t\t\tthis.outroChildren -= 1;\n\t\t\t\t\tcheck( this );\n\t\t\t\t},\n\t\t\t\tdecrementTotal: function() {\n\t\t\t\t\tthis.totalChildren -= 1;\n\t\t\t\t\tcheck( this );\n\t\t\t\t},\n\t\t\t\tadd: function( transition ) {\n\t\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\t\tlist.push( transition );\n\t\t\t\t},\n\t\t\t\tremove: function( transition ) {\n\t\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\t\tremoveFromArray( list, transition );\n\t\t\t\t\tcheck( this );\n\t\t\t\t},\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.ready = true;\n\t\t\t\t\tcheck( this );\n\t\t\t\t},\n\t\t\t\tdetachNodes: function() {\n\t\t\t\t\tthis.detachQueue.forEach( detach );\n\t\t\t\t\tthis.children.forEach( detachNodes );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction detach( element ) {\n\t\t\t\telement.detach();\n\t\t\t}\n\t\n\t\t\tfunction detachNodes( tm ) {\n\t\t\t\ttm.detachNodes();\n\t\t\t}\n\t\n\t\t\tfunction check( tm ) {\n\t\t\t\tif ( !tm.ready || tm.outros.length || tm.outroChildren )\n\t\t\t\t\treturn;\n\t\t\t\t// If all outros are complete, and we haven't already done this,\n\t\t\t\t// we notify the parent if there is one, otherwise\n\t\t\t\t// start detaching nodes\n\t\t\t\tif ( !tm.outrosComplete ) {\n\t\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\t\ttm.parent.decrementOutros( tm );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttm.detachNodes();\n\t\t\t\t\t}\n\t\t\t\t\ttm.outrosComplete = true;\n\t\t\t\t}\n\t\t\t\t// Once everything is done, we can notify parent transition\n\t\t\t\t// manager and call the callback\n\t\t\t\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\t\t\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\t\t\t\ttm.callback();\n\t\t\t\t\t}\n\t\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\t\ttm.parent.decrementTotal();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn TransitionManager;\n\t\t}( removeFromArray );\n\t\n\t\t/* global/runloop.js */\n\t\tvar runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar batch, runloop, unresolved = [],\n\t\t\t\tchangeHook = new Hook( 'change' );\n\t\t\trunloop = {\n\t\t\t\tstart: function( instance, returnPromise ) {\n\t\t\t\t\tvar promise, fulfilPromise;\n\t\t\t\t\tif ( returnPromise ) {\n\t\t\t\t\t\tpromise = new Promise( function( f ) {\n\t\t\t\t\t\t\treturn fulfilPromise = f;\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tbatch = {\n\t\t\t\t\t\tpreviousBatch: batch,\n\t\t\t\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\t\t\t\tviews: [],\n\t\t\t\t\t\ttasks: [],\n\t\t\t\t\t\tviewmodels: [],\n\t\t\t\t\t\tinstance: instance\n\t\t\t\t\t};\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tbatch.viewmodels.push( instance.viewmodel );\n\t\t\t\t\t}\n\t\t\t\t\treturn promise;\n\t\t\t\t},\n\t\t\t\tend: function() {\n\t\t\t\t\tflushChanges();\n\t\t\t\t\tbatch.transitionManager.init();\n\t\t\t\t\tif ( !batch.previousBatch && !!batch.instance )\n\t\t\t\t\t\tbatch.instance.viewmodel.changes = [];\n\t\t\t\t\tbatch = batch.previousBatch;\n\t\t\t\t},\n\t\t\t\taddViewmodel: function( viewmodel ) {\n\t\t\t\t\tif ( batch ) {\n\t\t\t\t\t\tif ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {\n\t\t\t\t\t\t\tbatch.viewmodels.push( viewmodel );\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tviewmodel.applyChanges();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregisterTransition: function( transition ) {\n\t\t\t\t\ttransition._manager = batch.transitionManager;\n\t\t\t\t\tbatch.transitionManager.add( transition );\n\t\t\t\t},\n\t\t\t\taddView: function( view ) {\n\t\t\t\t\tbatch.views.push( view );\n\t\t\t\t},\n\t\t\t\taddUnresolved: function( thing ) {\n\t\t\t\t\tunresolved.push( thing );\n\t\t\t\t},\n\t\t\t\tremoveUnresolved: function( thing ) {\n\t\t\t\t\tremoveFromArray( unresolved, thing );\n\t\t\t\t},\n\t\t\t\t// synchronise node detachments with transition ends\n\t\t\t\tdetachWhenReady: function( thing ) {\n\t\t\t\t\tbatch.transitionManager.detachQueue.push( thing );\n\t\t\t\t},\n\t\t\t\tscheduleTask: function( task, postRender ) {\n\t\t\t\t\tvar _batch;\n\t\t\t\t\tif ( !batch ) {\n\t\t\t\t\t\ttask();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_batch = batch;\n\t\t\t\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_batch.tasks.push( task );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcircular.runloop = runloop;\n\t\t\t__export = runloop;\n\t\n\t\t\tfunction flushChanges() {\n\t\t\t\tvar i, thing, changeHash;\n\t\t\t\tfor ( i = 0; i < batch.viewmodels.length; i += 1 ) {\n\t\t\t\t\tthing = batch.viewmodels[ i ];\n\t\t\t\t\tchangeHash = thing.applyChanges();\n\t\t\t\t\tif ( changeHash ) {\n\t\t\t\t\t\tchangeHook.fire( thing.ractive, changeHash );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbatch.viewmodels.length = 0;\n\t\t\t\tattemptKeypathResolution();\n\t\t\t\t// Now that changes have been fully propagated, we can update the DOM\n\t\t\t\t// and complete other tasks\n\t\t\t\tfor ( i = 0; i < batch.views.length; i += 1 ) {\n\t\t\t\t\tbatch.views[ i ].update();\n\t\t\t\t}\n\t\t\t\tbatch.views.length = 0;\n\t\t\t\tfor ( i = 0; i < batch.tasks.length; i += 1 ) {\n\t\t\t\t\tbatch.tasks[ i ]();\n\t\t\t\t}\n\t\t\t\tbatch.tasks.length = 0;\n\t\t\t\t// If updating the view caused some model blowback - e.g. a triple\n\t\t\t\t// containing <option> elements caused the binding on the <select>\n\t\t\t\t// to update - then we start over\n\t\t\t\tif ( batch.viewmodels.length )\n\t\t\t\t\treturn flushChanges();\n\t\t\t}\n\t\n\t\t\tfunction attemptKeypathResolution() {\n\t\t\t\tvar i, item, keypath, resolved;\n\t\t\t\ti = unresolved.length;\n\t\t\t\t// see if we can resolve any unresolved references\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\titem = unresolved[ i ];\n\t\t\t\t\tif ( item.keypath ) {\n\t\t\t\t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n\t\t\t\t\t\t// weird that we'd still end up here\n\t\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {\n\t\t\t\t\t\t( resolved || ( resolved = [] ) ).push( {\n\t\t\t\t\t\t\titem: item,\n\t\t\t\t\t\t\tkeypath: keypath\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( resolved ) {\n\t\t\t\t\tresolved.forEach( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction resolve( resolved ) {\n\t\t\t\tresolved.item.resolve( resolved.keypath );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );\n\t\n\t\t/* utils/createBranch.js */\n\t\tvar createBranch = function() {\n\t\n\t\t\tvar numeric = /^\\s*[0-9]+\\s*$/;\n\t\t\treturn function( key ) {\n\t\t\t\treturn numeric.test( key ) ? [] : {};\n\t\t\t};\n\t\t}();\n\t\n\t\t/* viewmodel/prototype/get/magicAdaptor.js */\n\t\tvar viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar magicAdaptor, MagicWrapper;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\t\tvalue: 0\n\t\t\t\t} );\n\t\t\t\tmagicAdaptor = {\n\t\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\t\tvar keys, key, parentKeypath, parentWrapper, parentValue;\n\t\t\t\t\t\tif ( !keypath ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\t\t\tkey = keys.pop();\n\t\t\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t\t\t\t// we shouldn't wrap this property\n\t\t\t\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparentValue = ractive.get( parentKeypath );\n\t\t\t\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\t\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );\n\t\t\t\t\t},\n\t\t\t\t\twrap: function( ractive, property, keypath ) {\n\t\t\t\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tMagicWrapper = function( ractive, value, keypath ) {\n\t\t\t\t\tvar keys, objKeypath, template, siblings;\n\t\t\t\t\tthis.magic = true;\n\t\t\t\t\tthis.ractive = ractive;\n\t\t\t\t\tthis.keypath = keypath;\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\t\tthis.prop = keys.pop();\n\t\t\t\t\tobjKeypath = keys.join( '.' );\n\t\t\t\t\tthis.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;\n\t\t\t\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t\t// Has this property already been wrapped?\n\t\t\t\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\t\t\t\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\t\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\t\t\t\tsiblings.push( this );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// No, it hasn't been wrapped\n\t\t\t\t\tcreateAccessors( this, value, template );\n\t\t\t\t};\n\t\t\t\tMagicWrapper.prototype = {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn this.value;\n\t\t\t\t\t},\n\t\t\t\t\treset: function( value ) {\n\t\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.updating = true;\n\t\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t\t// trigger set() accessor\n\t\t\t\t\t\trunloop.addViewmodel( this.ractive.viewmodel );\n\t\t\t\t\t\tthis.ractive.viewmodel.mark( this.keypath );\n\t\t\t\t\t\tthis.updating = false;\n\t\t\t\t\t},\n\t\t\t\t\tset: function( key, value ) {\n\t\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\t\t\t\tthis.updating = true;\n\t\t\t\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\t\t\t\tthis.updating = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t\t\t\t},\n\t\t\t\t\tteardown: function() {\n\t\t\t\t\t\tvar template, set, value, wrappers, index;\n\t\t\t\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t\t\t\t// so that it doesn't get torn down\n\t\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t\t\tset = template && template.set;\n\t\t\t\t\t\tif ( !set ) {\n\t\t\t\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twrappers = set._ractiveWrappers;\n\t\t\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Last one out, turn off the lights\n\t\t\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\t\t\tvalue = this.obj[ this.prop ];\n\t\t\t\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} catch ( err ) {\n\t\t\t\tmagicAdaptor = false;\n\t\t\t}\n\t\t\t__export = magicAdaptor;\n\t\n\t\t\tfunction createAccessors( originalWrapper, value, template ) {\n\t\t\t\tvar object, property, oldGet, oldSet, get, set;\n\t\t\t\tobject = originalWrapper.obj;\n\t\t\t\tproperty = originalWrapper.prop;\n\t\t\t\t// Is this template configurable?\n\t\t\t\tif ( template && !template.configurable ) {\n\t\t\t\t\t// Special case - array length\n\t\t\t\t\tif ( property === 'length' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t\t\t\t}\n\t\t\t\t// Time to wrap this property\n\t\t\t\tif ( template ) {\n\t\t\t\t\toldGet = template.get;\n\t\t\t\t\toldSet = template.set;\n\t\t\t\t}\n\t\t\t\tget = oldGet || function() {\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t\tset = function( v ) {\n\t\t\t\t\tif ( oldSet ) {\n\t\t\t\t\t\toldSet( v );\n\t\t\t\t\t}\n\t\t\t\t\tvalue = oldGet ? oldGet() : v;\n\t\t\t\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t\t\t\t};\n\t\n\t\t\t\tfunction updateWrapper( wrapper ) {\n\t\t\t\t\tvar keypath, ractive;\n\t\t\t\t\twrapper.value = value;\n\t\t\t\t\tif ( wrapper.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tractive = wrapper.ractive;\n\t\t\t\t\tkeypath = wrapper.keypath;\n\t\t\t\t\twrapper.updating = true;\n\t\t\t\t\trunloop.start( ractive );\n\t\t\t\t\tractive.viewmodel.mark( keypath );\n\t\t\t\t\trunloop.end();\n\t\t\t\t\twrapper.updating = false;\n\t\t\t\t}\n\t\t\t\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t\t\t\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\t\t\t\tset._ractiveWrappers = [ originalWrapper ];\n\t\t\t\tObject.defineProperty( object, property, {\n\t\t\t\t\tget: get,\n\t\t\t\t\tset: set,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( runloop, createBranch, isArray );\n\t\n\t\t/* config/magic.js */\n\t\tvar magic = function( magicAdaptor ) {\n\t\n\t\t\treturn !!magicAdaptor;\n\t\t}( viewmodel$get_magicAdaptor );\n\t\n\t\t/* config/namespaces.js */\n\t\tvar namespaces = {\n\t\t\thtml: 'http://www.w3.org/1999/xhtml',\n\t\t\tmathml: 'http://www.w3.org/1998/Math/MathML',\n\t\t\tsvg: 'http://www.w3.org/2000/svg',\n\t\t\txlink: 'http://www.w3.org/1999/xlink',\n\t\t\txml: 'http://www.w3.org/XML/1998/namespace',\n\t\t\txmlns: 'http://www.w3.org/2000/xmlns/'\n\t\t};\n\t\n\t\t/* utils/createElement.js */\n\t\tvar createElement = function( svg, namespaces ) {\n\t\n\t\t\tvar createElement;\n\t\t\t// Test for SVG support\n\t\t\tif ( !svg ) {\n\t\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\t\tif ( ns && ns !== namespaces.html ) {\n\t\t\t\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t\t\t\t}\n\t\t\t\t\treturn document.createElement( type );\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\t\tif ( !ns || ns === namespaces.html ) {\n\t\t\t\t\t\treturn document.createElement( type );\n\t\t\t\t\t}\n\t\t\t\t\treturn document.createElementNS( ns, type );\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn createElement;\n\t\t}( svg, namespaces );\n\t\n\t\t/* config/isClient.js */\n\t\tvar isClient = function() {\n\t\n\t\t\tvar isClient = typeof document === 'object';\n\t\t\treturn isClient;\n\t\t}();\n\t\n\t\t/* utils/defineProperty.js */\n\t\tvar defineProperty = function( isClient ) {\n\t\n\t\t\tvar defineProperty;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\t\tvalue: 0\n\t\t\t\t} );\n\t\t\t\tif ( isClient ) {\n\t\t\t\t\tObject.defineProperty( document.createElement( 'div' ), 'test', {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tdefineProperty = Object.defineProperty;\n\t\t\t} catch ( err ) {\n\t\t\t\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t\t\t\t// only use it with DOM objects (what the fuck were you smoking, MSFT?)\n\t\t\t\tdefineProperty = function( obj, prop, desc ) {\n\t\t\t\t\tobj[ prop ] = desc.value;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn defineProperty;\n\t\t}( isClient );\n\t\n\t\t/* utils/defineProperties.js */\n\t\tvar defineProperties = function( createElement, defineProperty, isClient ) {\n\t\n\t\t\tvar defineProperties;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tObject.defineProperties( {}, {\n\t\t\t\t\t\ttest: {\n\t\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\t// TODO how do we account for this? noMagic = true;\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\tif ( isClient ) {\n\t\t\t\t\tObject.defineProperties( createElement( 'div' ), {\n\t\t\t\t\t\ttest: {\n\t\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tdefineProperties = Object.defineProperties;\n\t\t\t} catch ( err ) {\n\t\t\t\tdefineProperties = function( obj, props ) {\n\t\t\t\t\tvar prop;\n\t\t\t\t\tfor ( prop in props ) {\n\t\t\t\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn defineProperties;\n\t\t}( createElement, defineProperty, isClient );\n\t\n\t\t/* Ractive/prototype/shared/add.js */\n\t\tvar Ractive$shared_add = function( isNumeric ) {\n\t\n\t\t\treturn function add( root, keypath, d ) {\n\t\t\t\tvar value;\n\t\t\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\t\t\t\tthrow new Error( 'Bad arguments' );\n\t\t\t\t}\n\t\t\t\tvalue = +root.get( keypath ) || 0;\n\t\t\t\tif ( !isNumeric( value ) ) {\n\t\t\t\t\tthrow new Error( 'Cannot add to a non-numeric value' );\n\t\t\t\t}\n\t\t\t\treturn root.set( keypath, value + d );\n\t\t\t};\n\t\t}( isNumeric );\n\t\n\t\t/* Ractive/prototype/add.js */\n\t\tvar Ractive$add = function( add ) {\n\t\n\t\t\treturn function Ractive$add( keypath, d ) {\n\t\t\t\treturn add( this, keypath, d === undefined ? 1 : +d );\n\t\t\t};\n\t\t}( Ractive$shared_add );\n\t\n\t\t/* utils/normaliseKeypath.js */\n\t\tvar normaliseKeypath = function( normaliseRef ) {\n\t\n\t\t\tvar leadingDot = /^\\.+/;\n\t\t\treturn function normaliseKeypath( keypath ) {\n\t\t\t\treturn normaliseRef( keypath ).replace( leadingDot, '' );\n\t\t\t};\n\t\t}( normaliseRef );\n\t\n\t\t/* config/vendors.js */\n\t\tvar vendors = [\n\t\t\t'o',\n\t\t\t'ms',\n\t\t\t'moz',\n\t\t\t'webkit'\n\t\t];\n\t\n\t\t/* utils/requestAnimationFrame.js */\n\t\tvar requestAnimationFrame = function( vendors ) {\n\t\n\t\t\tvar requestAnimationFrame;\n\t\t\t// If window doesn't exist, we don't need requestAnimationFrame\n\t\t\tif ( typeof window === 'undefined' ) {\n\t\t\t\trequestAnimationFrame = null;\n\t\t\t} else {\n\t\t\t\t// https://gist.github.com/paulirish/1579671\n\t\t\t\t( function( vendors, lastTime, window ) {\n\t\t\t\t\tvar x, setTimeout;\n\t\t\t\t\tif ( window.requestAnimationFrame ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {\n\t\t\t\t\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\t\t\t\t}\n\t\t\t\t\tif ( !window.requestAnimationFrame ) {\n\t\t\t\t\t\tsetTimeout = window.setTimeout;\n\t\t\t\t\t\twindow.requestAnimationFrame = function( callback ) {\n\t\t\t\t\t\t\tvar currTime, timeToCall, id;\n\t\t\t\t\t\t\tcurrTime = Date.now();\n\t\t\t\t\t\t\ttimeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\t\t\t\t\tid = setTimeout( function() {\n\t\t\t\t\t\t\t\tcallback( currTime + timeToCall );\n\t\t\t\t\t\t\t}, timeToCall );\n\t\t\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\t\t\treturn id;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}( vendors, 0, window ) );\n\t\t\t\trequestAnimationFrame = window.requestAnimationFrame;\n\t\t\t}\n\t\t\treturn requestAnimationFrame;\n\t\t}( vendors );\n\t\n\t\t/* utils/getTime.js */\n\t\tvar getTime = function() {\n\t\n\t\t\tvar getTime;\n\t\t\tif ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {\n\t\t\t\tgetTime = function() {\n\t\t\t\t\treturn window.performance.now();\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tgetTime = function() {\n\t\t\t\t\treturn Date.now();\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn getTime;\n\t\t}();\n\t\n\t\t/* shared/animations.js */\n\t\tvar animations = function( rAF, getTime, runloop ) {\n\t\n\t\t\tvar queue = [];\n\t\t\tvar animations = {\n\t\t\t\ttick: function() {\n\t\t\t\t\tvar i, animation, now;\n\t\t\t\t\tnow = getTime();\n\t\t\t\t\trunloop.start();\n\t\t\t\t\tfor ( i = 0; i < queue.length; i += 1 ) {\n\t\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\t\tif ( !animation.tick( now ) ) {\n\t\t\t\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\t\t\t\tqueue.splice( i--, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trunloop.end();\n\t\t\t\t\tif ( queue.length ) {\n\t\t\t\t\t\trAF( animations.tick );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanimations.running = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadd: function( animation ) {\n\t\t\t\t\tqueue.push( animation );\n\t\t\t\t\tif ( !animations.running ) {\n\t\t\t\t\t\tanimations.running = true;\n\t\t\t\t\t\trAF( animations.tick );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// TODO optimise this\n\t\t\t\tabort: function( keypath, root ) {\n\t\t\t\t\tvar i = queue.length,\n\t\t\t\t\t\tanimation;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\n\t\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn animations;\n\t\t}( requestAnimationFrame, getTime, runloop );\n\t\n\t\t/* config/options/css/transform.js */\n\t\tvar transform = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n\t\t\t\tcommentsPattern = /\\/\\*.*?\\*\\//g,\n\t\t\t\tselectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~]+)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n\t\t\t\tmediaQueryPattern = /^@media/,\n\t\t\t\tdataRvcGuidPattern = /\\[data-rvcguid=\"[a-z0-9-]+\"]/g;\n\t\t\t__export = function transformCss( css, guid ) {\n\t\t\t\tvar transformed, addGuid;\n\t\t\t\taddGuid = function( selector ) {\n\t\t\t\t\tvar selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];\n\t\t\t\t\tselectorUnits = [];\n\t\t\t\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\t\t\t\tselectorUnits.push( {\n\t\t\t\t\t\t\tstr: match[ 0 ],\n\t\t\t\t\t\t\tbase: match[ 1 ],\n\t\t\t\t\t\t\tmodifiers: match[ 2 ]\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\t// For each simple selector within the selector, we need to create a version\n\t\t\t\t\t// that a) combines with the guid, and b) is inside the guid\n\t\t\t\t\tdataAttr = '[data-rvcguid=\"' + guid + '\"]';\n\t\t\t\t\tbase = selectorUnits.map( extractString );\n\t\t\t\t\ti = selectorUnits.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tappended = base.slice();\n\t\t\t\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\t\t\t\tunit = selectorUnits[ i ];\n\t\t\t\t\t\tappended[ i ] = unit.base + dataAttr + unit.modifiers || '';\n\t\t\t\t\t\tprepended = base.slice();\n\t\t\t\t\t\tprepended[ i ] = dataAttr + ' ' + prepended[ i ];\n\t\t\t\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t\t\t\t}\n\t\t\t\t\treturn transformed.join( ', ' );\n\t\t\t\t};\n\t\t\t\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\t\t\t\ttransformed = css.replace( dataRvcGuidPattern, '[data-rvcguid=\"' + guid + '\"]' );\n\t\t\t\t} else {\n\t\t\t\t\ttransformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {\n\t\t\t\t\t\tvar selectors, transformed;\n\t\t\t\t\t\t// don't transform media queries!\n\t\t\t\t\t\tif ( mediaQueryPattern.test( $1 ) )\n\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\tselectors = $1.split( ',' ).map( trim );\n\t\t\t\t\t\ttransformed = selectors.map( addGuid ).join( ', ' ) + ' ';\n\t\t\t\t\t\treturn match.replace( $1, transformed );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn transformed;\n\t\t\t};\n\t\n\t\t\tfunction trim( str ) {\n\t\t\t\tif ( str.trim ) {\n\t\t\t\t\treturn str.trim();\n\t\t\t\t}\n\t\t\t\treturn str.replace( /^\\s+/, '' ).replace( /\\s+$/, '' );\n\t\t\t}\n\t\n\t\t\tfunction extractString( unit ) {\n\t\t\t\treturn unit.str;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* config/options/css/css.js */\n\t\tvar css = function( transformCss ) {\n\t\n\t\t\tvar cssConfig = {\n\t\t\t\tname: 'css',\n\t\t\t\textend: extend,\n\t\t\t\tinit: function() {}\n\t\t\t};\n\t\n\t\t\tfunction extend( Parent, proto, options ) {\n\t\t\t\tvar guid = proto.constructor._guid,\n\t\t\t\t\tcss;\n\t\t\t\tif ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {\n\t\t\t\t\tproto.constructor.css = css;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction getCss( css, target, guid ) {\n\t\t\t\tif ( !css ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn target.noCssTransform ? css : transformCss( css, guid );\n\t\t\t}\n\t\t\treturn cssConfig;\n\t\t}( transform );\n\t\n\t\t/* utils/wrapMethod.js */\n\t\tvar wrapMethod = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function( method, superMethod, force ) {\n\t\t\t\tif ( force || needsSuper( method, superMethod ) ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tvar hasSuper = '_super' in this,\n\t\t\t\t\t\t\t_super = this._super,\n\t\t\t\t\t\t\tresult;\n\t\t\t\t\t\tthis._super = superMethod;\n\t\t\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\t\t\tthis._super = _super;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction needsSuper( method, superMethod ) {\n\t\t\t\treturn typeof superMethod === 'function' && /_super/.test( method );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* config/options/data.js */\n\t\tvar data = function( wrap ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar dataConfig = {\n\t\t\t\tname: 'data',\n\t\t\t\textend: extend,\n\t\t\t\tinit: init,\n\t\t\t\treset: reset\n\t\t\t};\n\t\t\t__export = dataConfig;\n\t\n\t\t\tfunction combine( Parent, target, options ) {\n\t\t\t\tvar value = options.data || {},\n\t\t\t\t\tparentValue = getAddedKeys( Parent.prototype.data );\n\t\t\t\tif ( typeof value !== 'object' && typeof value !== 'function' ) {\n\t\t\t\t\tthrow new TypeError( 'data option must be an object or a function, \"' + value + '\" is not valid' );\n\t\t\t\t}\n\t\t\t\treturn dispatch( parentValue, value );\n\t\t\t}\n\t\n\t\t\tfunction extend( Parent, proto, options ) {\n\t\t\t\tproto.data = combine( Parent, proto, options );\n\t\t\t}\n\t\n\t\t\tfunction init( Parent, ractive, options ) {\n\t\t\t\tvar value = options.data,\n\t\t\t\t\tresult = combine( Parent, ractive, options );\n\t\t\t\tif ( typeof result === 'function' ) {\n\t\t\t\t\tresult = result.call( ractive, value ) || value;\n\t\t\t\t}\n\t\t\t\treturn ractive.data = result || {};\n\t\t\t}\n\t\n\t\t\tfunction reset( ractive ) {\n\t\t\t\tvar result = this.init( ractive.constructor, ractive, ractive );\n\t\t\t\tif ( result ) {\n\t\t\t\t\tractive.data = result;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction getAddedKeys( parent ) {\n\t\t\t\t// only for functions that had keys added\n\t\t\t\tif ( typeof parent !== 'function' || !Object.keys( parent ).length ) {\n\t\t\t\t\treturn parent;\n\t\t\t\t}\n\t\t\t\t// copy the added keys to temp 'object', otherwise\n\t\t\t\t// parent would be interpreted as 'function' by dispatch\n\t\t\t\tvar temp = {};\n\t\t\t\tcopy( parent, temp );\n\t\t\t\t// roll in added keys\n\t\t\t\treturn dispatch( parent, temp );\n\t\t\t}\n\t\n\t\t\tfunction dispatch( parent, child ) {\n\t\t\t\tif ( typeof child === 'function' ) {\n\t\t\t\t\treturn extendFn( child, parent );\n\t\t\t\t} else if ( typeof parent === 'function' ) {\n\t\t\t\t\treturn fromFn( child, parent );\n\t\t\t\t} else {\n\t\t\t\t\treturn fromProperties( child, parent );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction copy( from, to, fillOnly ) {\n\t\t\t\tfor ( var key in from ) {\n\t\t\t\t\tif ( fillOnly && key in to ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tto[ key ] = from[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction fromProperties( child, parent ) {\n\t\t\t\tchild = child || {};\n\t\t\t\tif ( !parent ) {\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t\tcopy( parent, child, true );\n\t\t\t\treturn child;\n\t\t\t}\n\t\n\t\t\tfunction fromFn( child, parentFn ) {\n\t\t\t\treturn function( data ) {\n\t\t\t\t\tvar keys;\n\t\t\t\t\tif ( child ) {\n\t\t\t\t\t\t// Track the keys that our on the child,\n\t\t\t\t\t\t// but not on the data. We'll need to apply these\n\t\t\t\t\t\t// after the parent function returns.\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor ( var key in child ) {\n\t\t\t\t\t\t\tif ( !data || !( key in data ) ) {\n\t\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// call the parent fn, use data if no return value\n\t\t\t\t\tdata = parentFn.call( this, data ) || data;\n\t\t\t\t\t// Copy child keys back onto data. The child keys\n\t\t\t\t\t// should take precedence over whatever the\n\t\t\t\t\t// parent did with the data.\n\t\t\t\t\tif ( keys && keys.length ) {\n\t\t\t\t\t\tdata = data || {};\n\t\t\t\t\t\tkeys.forEach( function( key ) {\n\t\t\t\t\t\t\tdata[ key ] = child[ key ];\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\treturn data;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tfunction extendFn( childFn, parent ) {\n\t\t\t\tvar parentFn;\n\t\t\t\tif ( typeof parent !== 'function' ) {\n\t\t\t\t\t// copy props to data\n\t\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\t\tfromProperties( data, parent );\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\t\t// give parent function it's own this._super context,\n\t\t\t\t\t\t// otherwise this._super is from child and\n\t\t\t\t\t\t// causes infinite loop\n\t\t\t\t\t\tparent = wrap( parent, function() {}, true );\n\t\t\t\t\t\treturn parent.call( this, data ) || data;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn wrap( childFn, parentFn );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( wrapMethod );\n\t\n\t\t/* config/types.js */\n\t\tvar types = {\n\t\t\tTEXT: 1,\n\t\t\tINTERPOLATOR: 2,\n\t\t\tTRIPLE: 3,\n\t\t\tSECTION: 4,\n\t\t\tINVERTED: 5,\n\t\t\tCLOSING: 6,\n\t\t\tELEMENT: 7,\n\t\t\tPARTIAL: 8,\n\t\t\tCOMMENT: 9,\n\t\t\tDELIMCHANGE: 10,\n\t\t\tMUSTACHE: 11,\n\t\t\tTAG: 12,\n\t\t\tATTRIBUTE: 13,\n\t\t\tCLOSING_TAG: 14,\n\t\t\tCOMPONENT: 15,\n\t\t\tNUMBER_LITERAL: 20,\n\t\t\tSTRING_LITERAL: 21,\n\t\t\tARRAY_LITERAL: 22,\n\t\t\tOBJECT_LITERAL: 23,\n\t\t\tBOOLEAN_LITERAL: 24,\n\t\t\tGLOBAL: 26,\n\t\t\tKEY_VALUE_PAIR: 27,\n\t\t\tREFERENCE: 30,\n\t\t\tREFINEMENT: 31,\n\t\t\tMEMBER: 32,\n\t\t\tPREFIX_OPERATOR: 33,\n\t\t\tBRACKETED: 34,\n\t\t\tCONDITIONAL: 35,\n\t\t\tINFIX_OPERATOR: 36,\n\t\t\tINVOCATION: 40,\n\t\t\tSECTION_IF: 50,\n\t\t\tSECTION_UNLESS: 51,\n\t\t\tSECTION_EACH: 52,\n\t\t\tSECTION_WITH: 53,\n\t\t\tSECTION_IF_WITH: 54\n\t\t};\n\t\n\t\t/* utils/create.js */\n\t\tvar create = function() {\n\t\n\t\t\tvar create;\n\t\t\ttry {\n\t\t\t\tObject.create( null );\n\t\t\t\tcreate = Object.create;\n\t\t\t} catch ( err ) {\n\t\t\t\t// sigh\n\t\t\t\tcreate = function() {\n\t\t\t\t\tvar F = function() {};\n\t\t\t\t\treturn function( proto, props ) {\n\t\t\t\t\t\tvar obj;\n\t\t\t\t\t\tif ( proto === null ) {\n\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tF.prototype = proto;\n\t\t\t\t\t\tobj = new F();\n\t\t\t\t\t\tif ( props ) {\n\t\t\t\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}();\n\t\t\t}\n\t\t\treturn create;\n\t\t}();\n\t\n\t\t/* parse/Parser/expressions/shared/errors.js */\n\t\tvar parse_Parser_expressions_shared_errors = {\n\t\t\texpectedExpression: 'Expected a JavaScript expression',\n\t\t\texpectedParen: 'Expected closing paren'\n\t\t};\n\t\n\t\t/* parse/Parser/expressions/primary/literal/numberLiteral.js */\n\t\tvar numberLiteral = function( types ) {\n\t\n\t\t\tvar numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\t\treturn function( parser ) {\n\t\t\t\tvar result;\n\t\t\t\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.NUMBER_LITERAL,\n\t\t\t\t\t\tv: result\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/booleanLiteral.js */\n\t\tvar booleanLiteral = function( types ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar remaining = parser.remaining();\n\t\t\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\t\t\t\tparser.pos += 4;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\t\tv: 'true'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\t\t\t\tparser.pos += 5;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\t\tv: 'false'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */\n\t\tvar makeQuotedStringMatcher = function() {\n\t\n\t\t\tvar stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\t\t\t// Match one or more characters until: \", ', \\, or EOL/EOF.\n\t\t\t// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\t\t\tstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\t\t\t// Match one escape sequence, including the backslash.\n\t\t\tescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\t\t\t// Match one ES5 line continuation (backslash + line terminator).\n\t\t\tlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\t\t\t// Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\t\t\treturn function( okQuote ) {\n\t\t\t\treturn function( parser ) {\n\t\t\t\t\tvar start, literal, done, next;\n\t\t\t\t\tstart = parser.pos;\n\t\t\t\t\tliteral = '\"';\n\t\t\t\t\tdone = false;\n\t\t\t\t\twhile ( !done ) {\n\t\t\t\t\t\tnext = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );\n\t\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t\tif ( next === '\"' ) {\n\t\t\t\t\t\t\t\tliteral += '\\\\\"';\n\t\t\t\t\t\t\t} else if ( next === '\\\\\\'' ) {\n\t\t\t\t\t\t\t\tliteral += '\\'';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tliteral += next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tliteral += '\"';\n\t\t\t\t\t// use JSON.parse to interpret escapes\n\t\t\t\t\treturn JSON.parse( literal );\n\t\t\t\t};\n\t\t\t};\n\t\t}();\n\t\n\t\t/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */\n\t\tvar singleQuotedString = function( makeQuotedStringMatcher ) {\n\t\n\t\t\treturn makeQuotedStringMatcher( '\"' );\n\t\t}( makeQuotedStringMatcher );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */\n\t\tvar doubleQuotedString = function( makeQuotedStringMatcher ) {\n\t\n\t\t\treturn makeQuotedStringMatcher( '\\'' );\n\t\t}( makeQuotedStringMatcher );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */\n\t\tvar stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, string;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tif ( parser.matchString( '\"' ) ) {\n\t\t\t\t\tstring = getDoubleQuotedString( parser );\n\t\t\t\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\t\tv: string\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( parser.matchString( '\\'' ) ) {\n\t\t\t\t\tstring = getSingleQuotedString( parser );\n\t\t\t\t\tif ( !parser.matchString( '\\'' ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\t\tv: string\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}( types, singleQuotedString, doubleQuotedString );\n\t\n\t\t/* parse/Parser/expressions/shared/patterns.js */\n\t\tvar patterns = {\n\t\t\tname: /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\t\t};\n\t\n\t\t/* parse/Parser/expressions/shared/key.js */\n\t\tvar key = function( getStringLiteral, getNumberLiteral, patterns ) {\n\t\n\t\t\tvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\t\t\t// http://mathiasbynens.be/notes/javascript-properties\n\t\t\t// can be any name, string literal, or number literal\n\t\t\treturn function( parser ) {\n\t\t\t\tvar token;\n\t\t\t\tif ( token = getStringLiteral( parser ) ) {\n\t\t\t\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t\t\t\t}\n\t\t\t\tif ( token = getNumberLiteral( parser ) ) {\n\t\t\t\t\treturn token.v;\n\t\t\t\t}\n\t\t\t\tif ( token = parser.matchPattern( patterns.name ) ) {\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t};\n\t\t}( stringLiteral, numberLiteral, patterns );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */\n\t\tvar keyValuePair = function( types, getKey ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, key, value;\n\t\t\t\tstart = parser.pos;\n\t\t\t\t// allow whitespace between '{' and key\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tkey = getKey( parser );\n\t\t\t\tif ( key === null ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// allow whitespace between key and ':'\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// next character must be ':'\n\t\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// allow whitespace between ':' and value\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// next expression must be a, well... expression\n\t\t\t\tvalue = parser.readExpression();\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.KEY_VALUE_PAIR,\n\t\t\t\t\tk: key,\n\t\t\t\t\tv: value\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, key );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */\n\t\tvar keyValuePairs = function( getKeyValuePair ) {\n\t\n\t\t\treturn function getKeyValuePairs( parser ) {\n\t\t\t\tvar start, pairs, pair, keyValuePairs;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tpair = getKeyValuePair( parser );\n\t\t\t\tif ( pair === null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpairs = [ pair ];\n\t\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t\t\tif ( !keyValuePairs ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn pairs.concat( keyValuePairs );\n\t\t\t\t}\n\t\t\t\treturn pairs;\n\t\t\t};\n\t\t}( keyValuePair );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */\n\t\tvar objectLiteral = function( types, getKeyValuePairs ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, keyValuePairs;\n\t\t\t\tstart = parser.pos;\n\t\t\t\t// allow whitespace\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t\t// allow whitespace between final value and '}'\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '}' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.OBJECT_LITERAL,\n\t\t\t\t\tm: keyValuePairs\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, keyValuePairs );\n\t\n\t\t/* parse/Parser/expressions/shared/expressionList.js */\n\t\tvar expressionList = function( errors ) {\n\t\n\t\t\treturn function getExpressionList( parser ) {\n\t\t\t\tvar start, expressions, expr, next;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpr = parser.readExpression();\n\t\t\t\tif ( expr === null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\texpressions = [ expr ];\n\t\t\t\t// allow whitespace between expression and ','\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\t\tnext = getExpressionList( parser );\n\t\t\t\t\tif ( next === null ) {\n\t\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t\t}\n\t\t\t\t\tnext.forEach( append );\n\t\t\t\t}\n\t\n\t\t\t\tfunction append( expression ) {\n\t\t\t\t\texpressions.push( expression );\n\t\t\t\t}\n\t\t\t\treturn expressions;\n\t\t\t};\n\t\t}( parse_Parser_expressions_shared_errors );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/arrayLiteral.js */\n\t\tvar arrayLiteral = function( types, getExpressionList ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, expressionList;\n\t\t\t\tstart = parser.pos;\n\t\t\t\t// allow whitespace before '['\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\texpressionList = getExpressionList( parser );\n\t\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.ARRAY_LITERAL,\n\t\t\t\t\tm: expressionList\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, expressionList );\n\t\n\t\t/* parse/Parser/expressions/primary/literal/_literal.js */\n\t\tvar literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );\n\t\t\t\treturn literal;\n\t\t\t};\n\t\t}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );\n\t\n\t\t/* parse/Parser/expressions/primary/reference.js */\n\t\tvar reference = function( types, patterns ) {\n\t\n\t\t\tvar dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;\n\t\t\tdotRefinementPattern = /^\\.[a-zA-Z_$0-9]+/;\n\t\t\tgetArrayRefinement = function( parser ) {\n\t\t\t\tvar num = parser.matchPattern( arrayMemberPattern );\n\t\t\t\tif ( num ) {\n\t\t\t\t\treturn '.' + num;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t\tarrayMemberPattern = /^\\[(0|[1-9][0-9]*)\\]/;\n\t\t\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\n\t\t\tglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;\n\t\t\t// keywords are not valid references, with the exception of `this`\n\t\t\tkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\t\t\treturn function( parser ) {\n\t\t\t\tvar startPos, ancestor, name, dot, combo, refinement, lastDotIndex;\n\t\t\t\tstartPos = parser.pos;\n\t\t\t\t// we might have a root-level reference\n\t\t\t\tif ( parser.matchString( '~/' ) ) {\n\t\t\t\t\tancestor = '~/';\n\t\t\t\t} else {\n\t\t\t\t\t// we might have ancestor refs...\n\t\t\t\t\tancestor = '';\n\t\t\t\t\twhile ( parser.matchString( '../' ) ) {\n\t\t\t\t\t\tancestor += '../';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !ancestor ) {\n\t\t\t\t\t// we might have an implicit iterator or a restricted reference\n\t\t\t\t\tdot = parser.matchString( './' ) || parser.matchString( '.' ) || '';\n\t\t\t\t}\n\t\t\t\tname = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';\n\t\t\t\t// bug out if it's a keyword\n\t\t\t\tif ( keywords.test( name ) ) {\n\t\t\t\t\tparser.pos = startPos;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// if this is a browser global, stop here\n\t\t\t\tif ( !ancestor && !dot && globals.test( name ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.GLOBAL,\n\t\t\t\t\t\tv: name\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcombo = ( ancestor || dot ) + name;\n\t\t\t\tif ( !combo ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\twhile ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {\n\t\t\t\t\tcombo += refinement;\n\t\t\t\t}\n\t\t\t\tif ( parser.matchString( '(' ) ) {\n\t\t\t\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t\t\t\t// to strip the method name from the reference combo, else the context\n\t\t\t\t\t// will be wrong\n\t\t\t\t\tlastDotIndex = combo.lastIndexOf( '.' );\n\t\t\t\t\tif ( lastDotIndex !== -1 ) {\n\t\t\t\t\t\tcombo = combo.substr( 0, lastDotIndex );\n\t\t\t\t\t\tparser.pos = startPos + combo.length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.pos -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.REFERENCE,\n\t\t\t\t\tn: combo.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, patterns );\n\t\n\t\t/* parse/Parser/expressions/primary/bracketedExpression.js */\n\t\tvar bracketedExpression = function( types, errors ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, expr;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tif ( !parser.matchString( '(' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpr = parser.readExpression();\n\t\t\t\tif ( !expr ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.BRACKETED,\n\t\t\t\t\tx: expr\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, parse_Parser_expressions_shared_errors );\n\t\n\t\t/* parse/Parser/expressions/primary/_primary.js */\n\t\tvar primary = function( getLiteral, getReference, getBracketedExpression ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\treturn getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );\n\t\t\t};\n\t\t}( literal, reference, bracketedExpression );\n\t\n\t\t/* parse/Parser/expressions/shared/refinement.js */\n\t\tvar refinement = function( types, errors, patterns ) {\n\t\n\t\t\treturn function getRefinement( parser ) {\n\t\t\t\tvar start, name, expr;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// \".\" name\n\t\t\t\tif ( parser.matchString( '.' ) ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( name = parser.matchPattern( patterns.name ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\t\t\tn: name\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tparser.error( 'Expected a property name' );\n\t\t\t\t}\n\t\t\t\t// \"[\" expression \"]\"\n\t\t\t\tif ( parser.matchString( '[' ) ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\texpr = parser.readExpression();\n\t\t\t\t\tif ( !expr ) {\n\t\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t\t}\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\t\t\tparser.error( 'Expected \\']\\'' );\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\t\tx: expr\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}( types, parse_Parser_expressions_shared_errors, patterns );\n\t\n\t\t/* parse/Parser/expressions/memberOrInvocation.js */\n\t\tvar memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar current, expression, refinement, expressionList;\n\t\t\t\texpression = getPrimary( parser );\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\twhile ( expression ) {\n\t\t\t\t\tcurrent = parser.pos;\n\t\t\t\t\tif ( refinement = getRefinement( parser ) ) {\n\t\t\t\t\t\texpression = {\n\t\t\t\t\t\t\tt: types.MEMBER,\n\t\t\t\t\t\t\tx: expression,\n\t\t\t\t\t\t\tr: refinement\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ( parser.matchString( '(' ) ) {\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\texpressionList = getExpressionList( parser );\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpression = {\n\t\t\t\t\t\t\tt: types.INVOCATION,\n\t\t\t\t\t\t\tx: expression\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif ( expressionList ) {\n\t\t\t\t\t\t\texpression.o = expressionList;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn expression;\n\t\t\t};\n\t\t}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );\n\t\n\t\t/* parse/Parser/expressions/typeof.js */\n\t\tvar _typeof = function( types, errors, getMemberOrInvocation ) {\n\t\n\t\t\tvar getTypeof, makePrefixSequenceMatcher;\n\t\t\tmakePrefixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\t\treturn function( parser ) {\n\t\t\t\t\tvar expression;\n\t\t\t\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\t\t\t\treturn expression;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\texpression = parser.readExpression();\n\t\t\t\t\tif ( !expression ) {\n\t\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\ts: symbol,\n\t\t\t\t\t\to: expression,\n\t\t\t\t\t\tt: types.PREFIX_OPERATOR\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\t// create all prefix sequence matchers, return getTypeof\n\t\t\t( function() {\n\t\t\t\tvar i, len, matcher, prefixOperators, fallthrough;\n\t\t\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\t\t\t\tfallthrough = getMemberOrInvocation;\n\t\t\t\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\t\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );\n\t\t\t\t\tfallthrough = matcher;\n\t\t\t\t}\n\t\t\t\t// typeof operator is higher precedence than multiplication, so provides the\n\t\t\t\t// fallthrough for the multiplication sequence matcher we're about to create\n\t\t\t\t// (we're skipping void and delete)\n\t\t\t\tgetTypeof = fallthrough;\n\t\t\t}() );\n\t\t\treturn getTypeof;\n\t\t}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );\n\t\n\t\t/* parse/Parser/expressions/logicalOr.js */\n\t\tvar logicalOr = function( types, getTypeof ) {\n\t\n\t\t\tvar getLogicalOr, makeInfixSequenceMatcher;\n\t\t\tmakeInfixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\t\treturn function( parser ) {\n\t\t\t\t\tvar start, left, right;\n\t\t\t\t\tleft = fallthrough( parser );\n\t\t\t\t\tif ( !left ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t\t\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t\t\t\t// to parse `left` because that would be infinite regress.\n\t\t\t\t\twhile ( true ) {\n\t\t\t\t\t\tstart = parser.pos;\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\t\treturn left;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\t\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\t\treturn left;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\t\t\t\tright = fallthrough( parser );\n\t\t\t\t\t\tif ( !right ) {\n\t\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\t\treturn left;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleft = {\n\t\t\t\t\t\t\tt: types.INFIX_OPERATOR,\n\t\t\t\t\t\t\ts: symbol,\n\t\t\t\t\t\t\to: [\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t\t// create all infix sequence matchers, and return getLogicalOr\n\t\t\t( function() {\n\t\t\t\tvar i, len, matcher, infixOperators, fallthrough;\n\t\t\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t\t\t\t// Each sequence matcher will initially fall through to its higher precedence\n\t\t\t\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t\t\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t\t\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\t\t\t\t// A typeof operator is higher precedence than multiplication\n\t\t\t\tfallthrough = getTypeof;\n\t\t\t\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\t\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );\n\t\t\t\t\tfallthrough = matcher;\n\t\t\t\t}\n\t\t\t\t// Logical OR is the fallthrough for the conditional matcher\n\t\t\t\tgetLogicalOr = fallthrough;\n\t\t\t}() );\n\t\t\treturn getLogicalOr;\n\t\t}( types, _typeof );\n\t\n\t\t/* parse/Parser/expressions/conditional.js */\n\t\tvar conditional = function( types, getLogicalOr, errors ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, expression, ifTrue, ifFalse;\n\t\t\t\texpression = getLogicalOr( parser );\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tstart = parser.pos;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '?' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn expression;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tifTrue = parser.readExpression();\n\t\t\t\tif ( !ifTrue ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\t\tparser.error( 'Expected \":\"' );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tifFalse = parser.readExpression();\n\t\t\t\tif ( !ifFalse ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.CONDITIONAL,\n\t\t\t\t\to: [\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tifTrue,\n\t\t\t\t\t\tifFalse\n\t\t\t\t\t]\n\t\t\t\t};\n\t\t\t};\n\t\t}( types, logicalOr, parse_Parser_expressions_shared_errors );\n\t\n\t\t/* parse/Parser/utils/flattenExpression.js */\n\t\tvar flattenExpression = function( types, isObject ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function( expression ) {\n\t\t\t\tvar refs = [],\n\t\t\t\t\tflattened;\n\t\t\t\textractRefs( expression, refs );\n\t\t\t\tflattened = {\n\t\t\t\t\tr: refs,\n\t\t\t\t\ts: stringify( this, expression, refs )\n\t\t\t\t};\n\t\t\t\treturn flattened;\n\t\t\t};\n\t\n\t\t\tfunction quoteStringLiteral( str ) {\n\t\t\t\treturn JSON.stringify( String( str ) );\n\t\t\t}\n\t\t\t// TODO maybe refactor this?\n\t\t\tfunction extractRefs( node, refs ) {\n\t\t\t\tvar i, list;\n\t\t\t\tif ( node.t === types.REFERENCE ) {\n\t\t\t\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\t\t\t\trefs.unshift( node.n );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist = node.o || node.m;\n\t\t\t\tif ( list ) {\n\t\t\t\t\tif ( isObject( list ) ) {\n\t\t\t\t\t\textractRefs( list, refs );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = list.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\textractRefs( list[ i ], refs );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( node.x ) {\n\t\t\t\t\textractRefs( node.x, refs );\n\t\t\t\t}\n\t\t\t\tif ( node.r ) {\n\t\t\t\t\textractRefs( node.r, refs );\n\t\t\t\t}\n\t\t\t\tif ( node.v ) {\n\t\t\t\t\textractRefs( node.v, refs );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction stringify( parser, node, refs ) {\n\t\t\t\tvar stringifyAll = function( item ) {\n\t\t\t\t\treturn stringify( parser, item, refs );\n\t\t\t\t};\n\t\t\t\tswitch ( node.t ) {\n\t\t\t\t\tcase types.BOOLEAN_LITERAL:\n\t\t\t\t\tcase types.GLOBAL:\n\t\t\t\t\tcase types.NUMBER_LITERAL:\n\t\t\t\t\t\treturn node.v;\n\t\t\t\t\tcase types.STRING_LITERAL:\n\t\t\t\t\t\treturn quoteStringLiteral( node.v );\n\t\t\t\t\tcase types.ARRAY_LITERAL:\n\t\t\t\t\t\treturn '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';\n\t\t\t\t\tcase types.OBJECT_LITERAL:\n\t\t\t\t\t\treturn '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';\n\t\t\t\t\tcase types.KEY_VALUE_PAIR:\n\t\t\t\t\t\treturn node.k + ':' + stringify( parser, node.v, refs );\n\t\t\t\t\tcase types.PREFIX_OPERATOR:\n\t\t\t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );\n\t\t\t\t\tcase types.INFIX_OPERATOR:\n\t\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );\n\t\t\t\t\tcase types.INVOCATION:\n\t\t\t\t\t\treturn stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';\n\t\t\t\t\tcase types.BRACKETED:\n\t\t\t\t\t\treturn '(' + stringify( parser, node.x, refs ) + ')';\n\t\t\t\t\tcase types.MEMBER:\n\t\t\t\t\t\treturn stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );\n\t\t\t\t\tcase types.REFINEMENT:\n\t\t\t\t\t\treturn node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';\n\t\t\t\t\tcase types.CONDITIONAL:\n\t\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );\n\t\t\t\t\tcase types.REFERENCE:\n\t\t\t\t\t\treturn '_' + refs.indexOf( node.n );\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparser.error( 'Expected legal JavaScript' );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, isObject );\n\t\n\t\t/* parse/Parser/_Parser.js */\n\t\tvar Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {\n\t\n\t\t\tvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\t\t\tParseError = function( message ) {\n\t\t\t\tthis.name = 'ParseError';\n\t\t\t\tthis.message = message;\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error( message );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tthis.stack = e.stack;\n\t\t\t\t}\n\t\t\t};\n\t\t\tParseError.prototype = Error.prototype;\n\t\t\tParser = function( str, options ) {\n\t\t\t\tvar items, item, lineStart = 0;\n\t\t\t\tthis.str = str;\n\t\t\t\tthis.options = options || {};\n\t\t\t\tthis.pos = 0;\n\t\t\t\tthis.lines = this.str.split( '\\n' );\n\t\t\t\tthis.lineEnds = this.lines.map( function( line ) {\n\t\t\t\t\tvar lineEnd = lineStart + line.length + 1;\n\t\t\t\t\t// +1 for the newline\n\t\t\t\t\tlineStart = lineEnd;\n\t\t\t\t\treturn lineEnd;\n\t\t\t\t}, 0 );\n\t\t\t\t// Custom init logic\n\t\t\t\tif ( this.init )\n\t\t\t\t\tthis.init( str, options );\n\t\t\t\titems = [];\n\t\t\t\twhile ( this.pos < this.str.length && ( item = this.read() ) ) {\n\t\t\t\t\titems.push( item );\n\t\t\t\t}\n\t\t\t\tthis.leftover = this.remaining();\n\t\t\t\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t\t\t};\n\t\t\tParser.prototype = {\n\t\t\t\tread: function( converters ) {\n\t\t\t\t\tvar pos, i, len, item;\n\t\t\t\t\tif ( !converters )\n\t\t\t\t\t\tconverters = this.converters;\n\t\t\t\t\tpos = this.pos;\n\t\t\t\t\tlen = converters.length;\n\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\t// reset for each attempt\n\t\t\t\t\t\tif ( item = converters[ i ]( this ) ) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\treadExpression: function() {\n\t\t\t\t\t// The conditional operator is the lowest precedence operator (except yield,\n\t\t\t\t\t// assignment operators, and commas, none of which are supported), so we\n\t\t\t\t\t// start there. If it doesn't match, it 'falls through' to progressively\n\t\t\t\t\t// higher precedence operators, until it eventually matches (or fails to\n\t\t\t\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t\t\t\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t\t\t\t\treturn getConditional( this );\n\t\t\t\t},\n\t\t\t\tflattenExpression: flattenExpression,\n\t\t\t\tgetLinePos: function( char ) {\n\t\t\t\t\tvar lineNum = 0,\n\t\t\t\t\t\tlineStart = 0,\n\t\t\t\t\t\tcolumnNum;\n\t\t\t\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\t\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\t\t\t\tlineNum += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcolumnNum = char - lineStart;\n\t\t\t\t\treturn [\n\t\t\t\t\t\tlineNum + 1,\n\t\t\t\t\t\tcolumnNum + 1,\n\t\t\t\t\t\tchar\n\t\t\t\t\t];\n\t\t\t\t},\n\t\t\t\terror: function( message ) {\n\t\t\t\t\tvar pos, lineNum, columnNum, line, annotation, error;\n\t\t\t\t\tpos = this.getLinePos( this.pos );\n\t\t\t\t\tlineNum = pos[ 0 ];\n\t\t\t\t\tcolumnNum = pos[ 1 ];\n\t\t\t\t\tline = this.lines[ pos[ 0 ] - 1 ];\n\t\t\t\t\tannotation = line + '\\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';\n\t\t\t\t\terror = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\\n' + annotation );\n\t\t\t\t\terror.line = pos[ 0 ];\n\t\t\t\t\terror.character = pos[ 1 ];\n\t\t\t\t\terror.shortMessage = message;\n\t\t\t\t\tthrow error;\n\t\t\t\t},\n\t\t\t\tmatchString: function( string ) {\n\t\t\t\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\t\t\t\tthis.pos += string.length;\n\t\t\t\t\t\treturn string;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmatchPattern: function( pattern ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\t\t\t\tthis.pos += match[ 0 ].length;\n\t\t\t\t\t\treturn match[ 1 ] || match[ 0 ];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tallowWhitespace: function() {\n\t\t\t\t\tthis.matchPattern( leadingWhitespace );\n\t\t\t\t},\n\t\t\t\tremaining: function() {\n\t\t\t\t\treturn this.str.substring( this.pos );\n\t\t\t\t},\n\t\t\t\tnextChar: function() {\n\t\t\t\t\treturn this.str.charAt( this.pos );\n\t\t\t\t}\n\t\t\t};\n\t\t\tParser.extend = function( proto ) {\n\t\t\t\tvar Parent = this,\n\t\t\t\t\tChild, key;\n\t\t\t\tChild = function( str, options ) {\n\t\t\t\t\tParser.call( this, str, options );\n\t\t\t\t};\n\t\t\t\tChild.prototype = create( Parent.prototype );\n\t\t\t\tfor ( key in proto ) {\n\t\t\t\t\tif ( hasOwnProperty.call( proto, key ) ) {\n\t\t\t\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tChild.extend = Parser.extend;\n\t\t\t\treturn Child;\n\t\t\t};\n\t\t\tcircular.Parser = Parser;\n\t\t\treturn Parser;\n\t\t}( circular, create, hasOwn, conditional, flattenExpression );\n\t\n\t\t/* parse/converters/mustache/delimiterChange.js */\n\t\tvar delimiterChange = function() {\n\t\n\t\t\tvar delimiterChangePattern = /^[^\\s=]+/,\n\t\t\t\twhitespacePattern = /^\\s+/;\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, opening, closing;\n\t\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tstart = parser.pos;\n\t\t\t\t// allow whitespace before new opening delimiter\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\topening = parser.matchPattern( delimiterChangePattern );\n\t\t\t\tif ( !opening ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// allow whitespace (in fact, it's necessary...)\n\t\t\t\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tclosing = parser.matchPattern( delimiterChangePattern );\n\t\t\t\tif ( !closing ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// allow whitespace before closing '='\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\topening,\n\t\t\t\t\tclosing\n\t\t\t\t];\n\t\t\t};\n\t\t}();\n\t\n\t\t/* parse/converters/mustache/delimiterTypes.js */\n\t\tvar delimiterTypes = [ {\n\t\t\tdelimiters: 'delimiters',\n\t\t\tisTriple: false,\n\t\t\tisStatic: false\n\t\t}, {\n\t\t\tdelimiters: 'tripleDelimiters',\n\t\t\tisTriple: true,\n\t\t\tisStatic: false\n\t\t}, {\n\t\t\tdelimiters: 'staticDelimiters',\n\t\t\tisTriple: false,\n\t\t\tisStatic: true\n\t\t}, {\n\t\t\tdelimiters: 'staticTripleDelimiters',\n\t\t\tisTriple: true,\n\t\t\tisStatic: true\n\t\t} ];\n\t\n\t\t/* parse/converters/mustache/type.js */\n\t\tvar type = function( types ) {\n\t\n\t\t\tvar mustacheTypes = {\n\t\t\t\t'#': types.SECTION,\n\t\t\t\t'^': types.INVERTED,\n\t\t\t\t'/': types.CLOSING,\n\t\t\t\t'>': types.PARTIAL,\n\t\t\t\t'!': types.COMMENT,\n\t\t\t\t'&': types.TRIPLE\n\t\t\t};\n\t\t\treturn function( parser ) {\n\t\t\t\tvar type = mustacheTypes[ parser.str.charAt( parser.pos ) ];\n\t\t\t\tif ( !type ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.pos += 1;\n\t\t\t\treturn type;\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* parse/converters/mustache/handlebarsBlockCodes.js */\n\t\tvar handlebarsBlockCodes = function( types ) {\n\t\n\t\t\treturn {\n\t\t\t\t'each': types.SECTION_EACH,\n\t\t\t\t'if': types.SECTION_IF,\n\t\t\t\t'if-with': types.SECTION_IF_WITH,\n\t\t\t\t'with': types.SECTION_WITH,\n\t\t\t\t'unless': types.SECTION_UNLESS\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* empty/legacy.js */\n\t\tvar legacy = null;\n\t\n\t\t/* parse/converters/mustache/content.js */\n\t\tvar content = function( types, mustacheType, handlebarsBlockCodes ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\t\t\t\tarrayMemberPattern = /^[0-9][1-9]*$/,\n\t\t\t\thandlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' ),\n\t\t\t\tlegalReference;\n\t\t\tlegalReference = /^[a-zA-Z$_0-9]+(?:(\\.[a-zA-Z$_0-9]+)|(\\[[a-zA-Z$_0-9]+\\]))*$/;\n\t\t\t__export = function( parser, delimiterType ) {\n\t\t\t\tvar start, pos, mustache, type, block, expression, i, remaining, index, delimiters;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tmustache = {};\n\t\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\t\tif ( delimiterType.isStatic ) {\n\t\t\t\t\tmustache.s = true;\n\t\t\t\t}\n\t\t\t\t// Determine mustache type\n\t\t\t\tif ( delimiterType.isTriple ) {\n\t\t\t\t\tmustache.t = types.TRIPLE;\n\t\t\t\t} else {\n\t\t\t\t\t// We need to test for expressions before we test for mustache type, because\n\t\t\t\t\t// an expression that begins '!' looks a lot like a comment\n\t\t\t\t\tif ( parser.remaining()[ 0 ] === '!' ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\texpression = parser.readExpression();\n\t\t\t\t\t\t\t// Was it actually an expression, or a comment block in disguise?\n\t\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t\tif ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {\n\t\t\t\t\t\t\t\texpression = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmustache.t = types.INTERPOLATOR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\t\tif ( !expression ) {\n\t\t\t\t\t\t\tindex = parser.remaining().indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\t\tif ( ~index ) {\n\t\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.error( 'Expected closing delimiter (\\'' + delimiters[ 1 ] + '\\')' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tt: types.COMMENT\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( !expression ) {\n\t\t\t\t\t\ttype = mustacheType( parser );\n\t\t\t\t\t\tmustache.t = type || types.INTERPOLATOR;\n\t\t\t\t\t\t// default\n\t\t\t\t\t\t// See if there's an explicit section type e.g. {{#with}}...{{/with}}\n\t\t\t\t\t\tif ( type === types.SECTION ) {\n\t\t\t\t\t\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\t\t\t\t\t\tmustache.n = block;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t} else if ( type === types.COMMENT || type === types.CLOSING ) {\n\t\t\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];\n\t\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\t// allow whitespace\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t// get expression\n\t\t\t\t\texpression = parser.readExpression();\n\t\t\t\t\t// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These\n\t\t\t\t\t// cases involve a bit of a hack - we want to turn it into the equivalent of\n\t\t\t\t\t// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append\n\t\t\t\t\t// a 'contextPartialExpression' to the mustache, and process the context instead of\n\t\t\t\t\t// the reference\n\t\t\t\t\tvar temp;\n\t\t\t\t\tif ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {\n\t\t\t\t\t\tmustache = {\n\t\t\t\t\t\t\tcontextPartialExpression: expression\n\t\t\t\t\t\t};\n\t\t\t\t\t\texpression = temp;\n\t\t\t\t\t}\n\t\t\t\t\t// With certain valid references that aren't valid expressions,\n\t\t\t\t\t// e.g. {{1.foo}}, we have a problem: it looks like we've got an\n\t\t\t\t\t// expression, but the expression didn't consume the entire\n\t\t\t\t\t// reference. So we need to check that the mustache delimiters\n\t\t\t\t\t// appear next, unless there's an index reference (i.e. a colon)\n\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\tif ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {\n\t\t\t\t\t\tpos = parser.pos;\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).trim();\n\t\t\t\t\t\t\t// Check it's a legal reference\n\t\t\t\t\t\t\tif ( !legalReference.test( mustache.r ) ) {\n\t\t\t\t\t\t\t\tparser.error( 'Expected a legal Mustache reference' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trefineExpression( parser, expression, mustache );\n\t\t\t\t// if there was context, process the expression now and save it for later\n\t\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\t\tmustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {\n\t\t\t\t\t\tt: types.PARTIAL\n\t\t\t\t\t} ) ];\n\t\t\t\t}\n\t\t\t\t// optional index reference\n\t\t\t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\t\t\t\tmustache.i = i;\n\t\t\t\t}\n\t\t\t\treturn mustache;\n\t\t\t};\n\t\n\t\t\tfunction refineExpression( parser, expression, mustache ) {\n\t\t\t\tvar referenceExpression;\n\t\t\t\tif ( expression ) {\n\t\t\t\t\twhile ( expression.t === types.BRACKETED && expression.x ) {\n\t\t\t\t\t\texpression = expression.x;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - integers should be treated as array members references,\n\t\t\t\t\t// rather than as expressions in their own right\n\t\t\t\t\tif ( expression.t === types.REFERENCE ) {\n\t\t\t\t\t\tmustache.r = expression.n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {\n\t\t\t\t\t\t\tmustache.r = expression.v;\n\t\t\t\t\t\t} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {\n\t\t\t\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmustache.x = parser.flattenExpression( expression );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn mustache;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO refactor this! it's bewildering\n\t\t\tfunction getReferenceExpression( parser, expression ) {\n\t\t\t\tvar members = [],\n\t\t\t\t\trefinement;\n\t\t\t\twhile ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {\n\t\t\t\t\trefinement = expression.r;\n\t\t\t\t\tif ( refinement.x ) {\n\t\t\t\t\t\tif ( refinement.x.t === types.REFERENCE ) {\n\t\t\t\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmembers.unshift( parser.flattenExpression( refinement.x ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmembers.unshift( refinement.n );\n\t\t\t\t\t}\n\t\t\t\t\texpression = expression.x;\n\t\t\t\t}\n\t\t\t\tif ( expression.t !== types.REFERENCE ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tr: expression.n,\n\t\t\t\t\tm: members\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, type, handlebarsBlockCodes, legacy );\n\t\n\t\t/* parse/converters/mustache.js */\n\t\tvar mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar delimiterChangeToken = {\n\t\t\t\tt: types.DELIMCHANGE,\n\t\t\t\texclude: true\n\t\t\t};\n\t\t\t__export = getMustache;\n\t\n\t\t\tfunction getMustache( parser ) {\n\t\t\t\tvar types;\n\t\t\t\t// If we're inside a <script> or <style> tag, and we're not\n\t\t\t\t// interpolating, bug out\n\t\t\t\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ttypes = delimiterTypes.slice().sort( function compare( a, b ) {\n\t\t\t\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t\t\t\t// to protect against opening delimiters being substrings of each other\n\t\t\t\t\treturn parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;\n\t\t\t\t} );\n\t\t\t\treturn function r( type ) {\n\t\t\t\t\tif ( !type ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn getMustacheOfType( parser, type ) || r( types.shift() );\n\t\t\t\t\t}\n\t\t\t\t}( types.shift() );\n\t\t\t}\n\t\n\t\t\tfunction getMustacheOfType( parser, delimiterType ) {\n\t\t\t\tvar start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\t\tif ( !parser.matchString( delimiters[ 0 ] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// delimiter change?\n\t\t\t\tif ( mustache = delimiterChange( parser ) ) {\n\t\t\t\t\t// find closing delimiter or abort...\n\t\t\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// ...then make the switch\n\t\t\t\t\tparser[ delimiterType.delimiters ] = mustache;\n\t\t\t\t\treturn delimiterChangeToken;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tmustache = mustacheContent( parser, delimiterType );\n\t\t\t\tif ( mustache === null ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// allow whitespace before closing delimiter\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\t\tparser.error( 'Expected closing delimiter \\'' + delimiters[ 1 ] + '\\' after reference' );\n\t\t\t\t}\n\t\t\t\tif ( mustache.t === types.COMMENT ) {\n\t\t\t\t\tmustache.exclude = true;\n\t\t\t\t}\n\t\t\t\tif ( mustache.t === types.CLOSING ) {\n\t\t\t\t\tparser.sectionDepth -= 1;\n\t\t\t\t\tif ( parser.sectionDepth < 0 ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// partials with context\n\t\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\t\tmustache.f = mustache.contextPartialExpression;\n\t\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\t\tmustache.n = 'with';\n\t\t\t\t\tdelete mustache.contextPartialExpression;\n\t\t\t\t} else if ( isSection( mustache ) ) {\n\t\t\t\t\tparser.sectionDepth += 1;\n\t\t\t\t\tchildren = [];\n\t\t\t\t\tcurrentChildren = children;\n\t\t\t\t\texpectedClose = mustache.n;\n\t\t\t\t\twhile ( child = parser.read() ) {\n\t\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\t\t\t\t\tparser.error( 'Expected {{/' + expectedClose + '}}' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// {{else}} tags require special treatment\n\t\t\t\t\t\tif ( child.t === types.INTERPOLATOR && child.r === 'else' ) {\n\t\t\t\t\t\t\t// no {{else}} allowed in {{#unless}}\n\t\t\t\t\t\t\tif ( mustache.n === 'unless' ) {\n\t\t\t\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcurrentChildren = elseChildren = [];\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentChildren.push( child );\n\t\t\t\t\t}\n\t\t\t\t\tif ( children.length ) {\n\t\t\t\t\t\tmustache.f = children;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elseChildren && elseChildren.length ) {\n\t\t\t\t\t\tmustache.l = elseChildren;\n\t\t\t\t\t\tif ( mustache.n === 'with' ) {\n\t\t\t\t\t\t\tmustache.n = 'if-with';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t\t}\n\t\t\t\t// Replace block name with code\n\t\t\t\tif ( mustache.n ) {\n\t\t\t\t\tmustache.n = handlebarsBlockCodes[ mustache.n ];\n\t\t\t\t} else if ( mustache.t === types.INVERTED ) {\n\t\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\t\tmustache.n = types.SECTION_UNLESS;\n\t\t\t\t}\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\n\t\t\tfunction isSection( mustache ) {\n\t\t\t\treturn mustache.t === types.SECTION || mustache.t === types.INVERTED;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );\n\t\n\t\t/* parse/converters/comment.js */\n\t\tvar comment = function( types ) {\n\t\n\t\t\tvar OPEN_COMMENT = '<!--',\n\t\t\t\tCLOSE_COMMENT = '-->';\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, content, remaining, endIndex, comment;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tif ( !parser.matchString( OPEN_COMMENT ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tremaining = parser.remaining();\n\t\t\t\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\t\t\t\tif ( endIndex === -1 ) {\n\t\t\t\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t\t\t\t}\n\t\t\t\tcontent = remaining.substr( 0, endIndex );\n\t\t\t\tparser.pos += endIndex + 3;\n\t\t\t\tcomment = {\n\t\t\t\t\tt: types.COMMENT,\n\t\t\t\t\tc: content\n\t\t\t\t};\n\t\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\t\tcomment.p = parser.getLinePos( start );\n\t\t\t\t}\n\t\t\t\treturn comment;\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* config/voidElementNames.js */\n\t\tvar voidElementNames = function() {\n\t\n\t\t\tvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\t\t\treturn voidElementNames;\n\t\t}();\n\t\n\t\t/* parse/converters/utils/getLowestIndex.js */\n\t\tvar getLowestIndex = function( haystack, needles ) {\n\t\t\tvar i, index, lowest;\n\t\t\ti = needles.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tindex = haystack.indexOf( needles[ i ] );\n\t\t\t\t// short circuit\n\t\t\t\tif ( !index ) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( !lowest || index < lowest ) {\n\t\t\t\t\tlowest = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lowest || -1;\n\t\t};\n\t\n\t\t/* shared/decodeCharacterReferences.js */\n\t\tvar decodeCharacterReferences = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar htmlEntities, controlCharacters, entityPattern;\n\t\t\thtmlEntities = {\n\t\t\t\tquot: 34,\n\t\t\t\tamp: 38,\n\t\t\t\tapos: 39,\n\t\t\t\tlt: 60,\n\t\t\t\tgt: 62,\n\t\t\t\tnbsp: 160,\n\t\t\t\tiexcl: 161,\n\t\t\t\tcent: 162,\n\t\t\t\tpound: 163,\n\t\t\t\tcurren: 164,\n\t\t\t\tyen: 165,\n\t\t\t\tbrvbar: 166,\n\t\t\t\tsect: 167,\n\t\t\t\tuml: 168,\n\t\t\t\tcopy: 169,\n\t\t\t\tordf: 170,\n\t\t\t\tlaquo: 171,\n\t\t\t\tnot: 172,\n\t\t\t\tshy: 173,\n\t\t\t\treg: 174,\n\t\t\t\tmacr: 175,\n\t\t\t\tdeg: 176,\n\t\t\t\tplusmn: 177,\n\t\t\t\tsup2: 178,\n\t\t\t\tsup3: 179,\n\t\t\t\tacute: 180,\n\t\t\t\tmicro: 181,\n\t\t\t\tpara: 182,\n\t\t\t\tmiddot: 183,\n\t\t\t\tcedil: 184,\n\t\t\t\tsup1: 185,\n\t\t\t\tordm: 186,\n\t\t\t\traquo: 187,\n\t\t\t\tfrac14: 188,\n\t\t\t\tfrac12: 189,\n\t\t\t\tfrac34: 190,\n\t\t\t\tiquest: 191,\n\t\t\t\tAgrave: 192,\n\t\t\t\tAacute: 193,\n\t\t\t\tAcirc: 194,\n\t\t\t\tAtilde: 195,\n\t\t\t\tAuml: 196,\n\t\t\t\tAring: 197,\n\t\t\t\tAElig: 198,\n\t\t\t\tCcedil: 199,\n\t\t\t\tEgrave: 200,\n\t\t\t\tEacute: 201,\n\t\t\t\tEcirc: 202,\n\t\t\t\tEuml: 203,\n\t\t\t\tIgrave: 204,\n\t\t\t\tIacute: 205,\n\t\t\t\tIcirc: 206,\n\t\t\t\tIuml: 207,\n\t\t\t\tETH: 208,\n\t\t\t\tNtilde: 209,\n\t\t\t\tOgrave: 210,\n\t\t\t\tOacute: 211,\n\t\t\t\tOcirc: 212,\n\t\t\t\tOtilde: 213,\n\t\t\t\tOuml: 214,\n\t\t\t\ttimes: 215,\n\t\t\t\tOslash: 216,\n\t\t\t\tUgrave: 217,\n\t\t\t\tUacute: 218,\n\t\t\t\tUcirc: 219,\n\t\t\t\tUuml: 220,\n\t\t\t\tYacute: 221,\n\t\t\t\tTHORN: 222,\n\t\t\t\tszlig: 223,\n\t\t\t\tagrave: 224,\n\t\t\t\taacute: 225,\n\t\t\t\tacirc: 226,\n\t\t\t\tatilde: 227,\n\t\t\t\tauml: 228,\n\t\t\t\taring: 229,\n\t\t\t\taelig: 230,\n\t\t\t\tccedil: 231,\n\t\t\t\tegrave: 232,\n\t\t\t\teacute: 233,\n\t\t\t\tecirc: 234,\n\t\t\t\teuml: 235,\n\t\t\t\tigrave: 236,\n\t\t\t\tiacute: 237,\n\t\t\t\ticirc: 238,\n\t\t\t\tiuml: 239,\n\t\t\t\teth: 240,\n\t\t\t\tntilde: 241,\n\t\t\t\tograve: 242,\n\t\t\t\toacute: 243,\n\t\t\t\tocirc: 244,\n\t\t\t\totilde: 245,\n\t\t\t\touml: 246,\n\t\t\t\tdivide: 247,\n\t\t\t\toslash: 248,\n\t\t\t\tugrave: 249,\n\t\t\t\tuacute: 250,\n\t\t\t\tucirc: 251,\n\t\t\t\tuuml: 252,\n\t\t\t\tyacute: 253,\n\t\t\t\tthorn: 254,\n\t\t\t\tyuml: 255,\n\t\t\t\tOElig: 338,\n\t\t\t\toelig: 339,\n\t\t\t\tScaron: 352,\n\t\t\t\tscaron: 353,\n\t\t\t\tYuml: 376,\n\t\t\t\tfnof: 402,\n\t\t\t\tcirc: 710,\n\t\t\t\ttilde: 732,\n\t\t\t\tAlpha: 913,\n\t\t\t\tBeta: 914,\n\t\t\t\tGamma: 915,\n\t\t\t\tDelta: 916,\n\t\t\t\tEpsilon: 917,\n\t\t\t\tZeta: 918,\n\t\t\t\tEta: 919,\n\t\t\t\tTheta: 920,\n\t\t\t\tIota: 921,\n\t\t\t\tKappa: 922,\n\t\t\t\tLambda: 923,\n\t\t\t\tMu: 924,\n\t\t\t\tNu: 925,\n\t\t\t\tXi: 926,\n\t\t\t\tOmicron: 927,\n\t\t\t\tPi: 928,\n\t\t\t\tRho: 929,\n\t\t\t\tSigma: 931,\n\t\t\t\tTau: 932,\n\t\t\t\tUpsilon: 933,\n\t\t\t\tPhi: 934,\n\t\t\t\tChi: 935,\n\t\t\t\tPsi: 936,\n\t\t\t\tOmega: 937,\n\t\t\t\talpha: 945,\n\t\t\t\tbeta: 946,\n\t\t\t\tgamma: 947,\n\t\t\t\tdelta: 948,\n\t\t\t\tepsilon: 949,\n\t\t\t\tzeta: 950,\n\t\t\t\teta: 951,\n\t\t\t\ttheta: 952,\n\t\t\t\tiota: 953,\n\t\t\t\tkappa: 954,\n\t\t\t\tlambda: 955,\n\t\t\t\tmu: 956,\n\t\t\t\tnu: 957,\n\t\t\t\txi: 958,\n\t\t\t\tomicron: 959,\n\t\t\t\tpi: 960,\n\t\t\t\trho: 961,\n\t\t\t\tsigmaf: 962,\n\t\t\t\tsigma: 963,\n\t\t\t\ttau: 964,\n\t\t\t\tupsilon: 965,\n\t\t\t\tphi: 966,\n\t\t\t\tchi: 967,\n\t\t\t\tpsi: 968,\n\t\t\t\tomega: 969,\n\t\t\t\tthetasym: 977,\n\t\t\t\tupsih: 978,\n\t\t\t\tpiv: 982,\n\t\t\t\tensp: 8194,\n\t\t\t\temsp: 8195,\n\t\t\t\tthinsp: 8201,\n\t\t\t\tzwnj: 8204,\n\t\t\t\tzwj: 8205,\n\t\t\t\tlrm: 8206,\n\t\t\t\trlm: 8207,\n\t\t\t\tndash: 8211,\n\t\t\t\tmdash: 8212,\n\t\t\t\tlsquo: 8216,\n\t\t\t\trsquo: 8217,\n\t\t\t\tsbquo: 8218,\n\t\t\t\tldquo: 8220,\n\t\t\t\trdquo: 8221,\n\t\t\t\tbdquo: 8222,\n\t\t\t\tdagger: 8224,\n\t\t\t\tDagger: 8225,\n\t\t\t\tbull: 8226,\n\t\t\t\thellip: 8230,\n\t\t\t\tpermil: 8240,\n\t\t\t\tprime: 8242,\n\t\t\t\tPrime: 8243,\n\t\t\t\tlsaquo: 8249,\n\t\t\t\trsaquo: 8250,\n\t\t\t\toline: 8254,\n\t\t\t\tfrasl: 8260,\n\t\t\t\teuro: 8364,\n\t\t\t\timage: 8465,\n\t\t\t\tweierp: 8472,\n\t\t\t\treal: 8476,\n\t\t\t\ttrade: 8482,\n\t\t\t\talefsym: 8501,\n\t\t\t\tlarr: 8592,\n\t\t\t\tuarr: 8593,\n\t\t\t\trarr: 8594,\n\t\t\t\tdarr: 8595,\n\t\t\t\tharr: 8596,\n\t\t\t\tcrarr: 8629,\n\t\t\t\tlArr: 8656,\n\t\t\t\tuArr: 8657,\n\t\t\t\trArr: 8658,\n\t\t\t\tdArr: 8659,\n\t\t\t\thArr: 8660,\n\t\t\t\tforall: 8704,\n\t\t\t\tpart: 8706,\n\t\t\t\texist: 8707,\n\t\t\t\tempty: 8709,\n\t\t\t\tnabla: 8711,\n\t\t\t\tisin: 8712,\n\t\t\t\tnotin: 8713,\n\t\t\t\tni: 8715,\n\t\t\t\tprod: 8719,\n\t\t\t\tsum: 8721,\n\t\t\t\tminus: 8722,\n\t\t\t\tlowast: 8727,\n\t\t\t\tradic: 8730,\n\t\t\t\tprop: 8733,\n\t\t\t\tinfin: 8734,\n\t\t\t\tang: 8736,\n\t\t\t\tand: 8743,\n\t\t\t\tor: 8744,\n\t\t\t\tcap: 8745,\n\t\t\t\tcup: 8746,\n\t\t\t\t'int': 8747,\n\t\t\t\tthere4: 8756,\n\t\t\t\tsim: 8764,\n\t\t\t\tcong: 8773,\n\t\t\t\tasymp: 8776,\n\t\t\t\tne: 8800,\n\t\t\t\tequiv: 8801,\n\t\t\t\tle: 8804,\n\t\t\t\tge: 8805,\n\t\t\t\tsub: 8834,\n\t\t\t\tsup: 8835,\n\t\t\t\tnsub: 8836,\n\t\t\t\tsube: 8838,\n\t\t\t\tsupe: 8839,\n\t\t\t\toplus: 8853,\n\t\t\t\totimes: 8855,\n\t\t\t\tperp: 8869,\n\t\t\t\tsdot: 8901,\n\t\t\t\tlceil: 8968,\n\t\t\t\trceil: 8969,\n\t\t\t\tlfloor: 8970,\n\t\t\t\trfloor: 8971,\n\t\t\t\tlang: 9001,\n\t\t\t\trang: 9002,\n\t\t\t\tloz: 9674,\n\t\t\t\tspades: 9824,\n\t\t\t\tclubs: 9827,\n\t\t\t\thearts: 9829,\n\t\t\t\tdiams: 9830\n\t\t\t};\n\t\t\tcontrolCharacters = [\n\t\t\t\t8364,\n\t\t\t\t129,\n\t\t\t\t8218,\n\t\t\t\t402,\n\t\t\t\t8222,\n\t\t\t\t8230,\n\t\t\t\t8224,\n\t\t\t\t8225,\n\t\t\t\t710,\n\t\t\t\t8240,\n\t\t\t\t352,\n\t\t\t\t8249,\n\t\t\t\t338,\n\t\t\t\t141,\n\t\t\t\t381,\n\t\t\t\t143,\n\t\t\t\t144,\n\t\t\t\t8216,\n\t\t\t\t8217,\n\t\t\t\t8220,\n\t\t\t\t8221,\n\t\t\t\t8226,\n\t\t\t\t8211,\n\t\t\t\t8212,\n\t\t\t\t732,\n\t\t\t\t8482,\n\t\t\t\t353,\n\t\t\t\t8250,\n\t\t\t\t339,\n\t\t\t\t157,\n\t\t\t\t382,\n\t\t\t\t376\n\t\t\t];\n\t\t\tentityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\t\t\t__export = function decodeCharacterReferences( html ) {\n\t\t\t\treturn html.replace( entityPattern, function( match, entity ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\t// Handle named entities\n\t\t\t\t\tif ( entity[ 0 ] !== '#' ) {\n\t\t\t\t\t\tcode = htmlEntities[ entity ];\n\t\t\t\t\t} else if ( entity[ 1 ] === 'x' ) {\n\t\t\t\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !code ) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\treturn String.fromCharCode( validateCode( code ) );\n\t\t\t\t} );\n\t\t\t};\n\t\t\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t\t\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t\t\t// to replace them ourselves\n\t\t\t//\n\t\t\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\t\t\tfunction validateCode( code ) {\n\t\t\t\tif ( !code ) {\n\t\t\t\t\treturn 65533;\n\t\t\t\t}\n\t\t\t\t// line feed becomes generic whitespace\n\t\t\t\tif ( code === 10 ) {\n\t\t\t\t\treturn 32;\n\t\t\t\t}\n\t\t\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t\t\t\tif ( code < 128 ) {\n\t\t\t\t\treturn code;\n\t\t\t\t}\n\t\t\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t\t\t\t// to correct the mistake or we'll end up with missing € signs and so on\n\t\t\t\tif ( code <= 159 ) {\n\t\t\t\t\treturn controlCharacters[ code - 128 ];\n\t\t\t\t}\n\t\t\t\t// basic multilingual plane\n\t\t\t\tif ( code < 55296 ) {\n\t\t\t\t\treturn code;\n\t\t\t\t}\n\t\t\t\t// UTF-16 surrogate halves\n\t\t\t\tif ( code <= 57343 ) {\n\t\t\t\t\treturn 65533;\n\t\t\t\t}\n\t\t\t\t// rest of the basic multilingual plane\n\t\t\t\tif ( code <= 65535 ) {\n\t\t\t\t\treturn code;\n\t\t\t\t}\n\t\t\t\treturn 65533;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( legacy );\n\t\n\t\t/* parse/converters/text.js */\n\t\tvar text = function( getLowestIndex, decodeCharacterReferences ) {\n\t\n\t\t\treturn function( parser ) {\n\t\t\t\tvar index, remaining, disallowed, barrier;\n\t\t\t\tremaining = parser.remaining();\n\t\t\t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\t\t\t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\t\t\t\tindex = remaining.indexOf( barrier );\n\t\t\t\t} else {\n\t\t\t\t\tdisallowed = [\n\t\t\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t\t\t];\n\t\t\t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\t\t\t\tif ( parser.inAttribute === true ) {\n\t\t\t\t\t\t// we're inside an unquoted attribute value\n\t\t\t\t\t\tdisallowed.push( '\"', '\\'', '=', '<', '>', '`' );\n\t\t\t\t\t} else if ( parser.inAttribute ) {\n\t\t\t\t\t\t// quoted attribute value\n\t\t\t\t\t\tdisallowed.push( parser.inAttribute );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisallowed.push( barrier );\n\t\t\t\t\t}\n\t\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t\t}\n\t\t\t\tif ( !index ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tindex = remaining.length;\n\t\t\t\t}\n\t\t\t\tparser.pos += index;\n\t\t\t\treturn parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );\n\t\t\t};\n\t\t}( getLowestIndex, decodeCharacterReferences );\n\t\n\t\t/* parse/converters/element/closingTag.js */\n\t\tvar closingTag = function( types ) {\n\t\n\t\t\tvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\t\t\treturn function( parser ) {\n\t\t\t\tvar tag;\n\t\t\t\t// are we looking at a closing tag?\n\t\t\t\tif ( !parser.matchString( '</' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.CLOSING_TAG,\n\t\t\t\t\t\te: tag\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// We have an illegal closing tag, report it\n\t\t\t\tparser.pos -= 2;\n\t\t\t\tparser.error( 'Illegal closing tag' );\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* parse/converters/element/attribute.js */\n\t\tvar attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n\t\t\t\tunquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\t\t\t__export = getAttribute;\n\t\n\t\t\tfunction getAttribute( parser ) {\n\t\t\t\tvar attr, name, value;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tname = parser.matchPattern( attributeNamePattern );\n\t\t\t\tif ( !name ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tattr = {\n\t\t\t\t\tname: name\n\t\t\t\t};\n\t\t\t\tvalue = getAttributeValue( parser );\n\t\t\t\tif ( value ) {\n\t\t\t\t\tattr.value = value;\n\t\t\t\t}\n\t\t\t\treturn attr;\n\t\t\t}\n\t\n\t\t\tfunction getAttributeValue( parser ) {\n\t\t\t\tvar start, valueStart, startDepth, value;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tvalueStart = parser.pos;\n\t\t\t\tstartDepth = parser.sectionDepth;\n\t\t\t\tvalue = getQuotedAttributeValue( parser, '\\'' ) || getQuotedAttributeValue( parser, '\"' ) || getUnquotedAttributeValue( parser );\n\t\t\t\tif ( parser.sectionDepth !== startDepth ) {\n\t\t\t\t\tparser.pos = valueStart;\n\t\t\t\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t\t\t\t}\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ( !value.length ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ( value.length === 1 && typeof value[ 0 ] === 'string' ) {\n\t\t\t\t\treturn decodeCharacterReferences( value[ 0 ] );\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tfunction getUnquotedAttributeValueToken( parser ) {\n\t\t\t\tvar start, text, haystack, needles, index;\n\t\t\t\tstart = parser.pos;\n\t\t\t\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\t\t\t\tif ( !text ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\thaystack = text;\n\t\t\t\tneedles = [\n\t\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t\t];\n\t\t\t\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\t\t\t\ttext = text.substr( 0, index );\n\t\t\t\t\tparser.pos = start + text.length;\n\t\t\t\t}\n\t\t\t\treturn text;\n\t\t\t}\n\t\n\t\t\tfunction getUnquotedAttributeValue( parser ) {\n\t\t\t\tvar tokens, token;\n\t\t\t\tparser.inAttribute = true;\n\t\t\t\ttokens = [];\n\t\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\t\twhile ( token !== null ) {\n\t\t\t\t\ttokens.push( token );\n\t\t\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\t\t}\n\t\t\t\tif ( !tokens.length ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.inAttribute = false;\n\t\t\t\treturn tokens;\n\t\t\t}\n\t\n\t\t\tfunction getQuotedAttributeValue( parser, quoteMark ) {\n\t\t\t\tvar start, tokens, token;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.inAttribute = quoteMark;\n\t\t\t\ttokens = [];\n\t\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\t\twhile ( token !== null ) {\n\t\t\t\t\ttokens.push( token );\n\t\t\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\t\t}\n\t\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.inAttribute = false;\n\t\t\t\treturn tokens;\n\t\t\t}\n\t\n\t\t\tfunction getQuotedStringToken( parser, quoteMark ) {\n\t\t\t\tvar start, index, haystack, needles;\n\t\t\t\tstart = parser.pos;\n\t\t\t\thaystack = parser.remaining();\n\t\t\t\tneedles = [\n\t\t\t\t\tquoteMark,\n\t\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t\t];\n\t\t\t\tindex = getLowestIndex( haystack, needles );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t\t\t\t}\n\t\t\t\tif ( !index ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.pos += index;\n\t\t\t\treturn haystack.substr( 0, index );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( getLowestIndex, mustache, decodeCharacterReferences );\n\t\n\t\t/* utils/parseJSON.js */\n\t\tvar parseJSON = function( Parser, getStringLiteral, getKey ) {\n\t\n\t\t\tvar JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\t\t\tspecials = {\n\t\t\t\t'true': true,\n\t\t\t\t'false': false,\n\t\t\t\t'undefined': undefined,\n\t\t\t\t'null': null\n\t\t\t};\n\t\t\tspecialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );\n\t\t\tnumberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\t\tplaceholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\t\t\tplaceholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\t\t\tonlyWhitespace = /^\\s*$/;\n\t\t\tJsonParser = Parser.extend( {\n\t\t\t\tinit: function( str, options ) {\n\t\t\t\t\tthis.values = options.values;\n\t\t\t\t\tthis.allowWhitespace();\n\t\t\t\t},\n\t\t\t\tpostProcess: function( result ) {\n\t\t\t\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: result[ 0 ].v\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tconverters: [\n\t\n\t\t\t\t\tfunction getPlaceholder( parser ) {\n\t\t\t\t\t\tvar placeholder;\n\t\t\t\t\t\tif ( !parser.values ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplaceholder = parser.matchPattern( placeholderAtStartPattern );\n\t\t\t\t\t\tif ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: parser.values[ placeholder ]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfunction getSpecial( parser ) {\n\t\t\t\t\t\tvar special;\n\t\t\t\t\t\tif ( special = parser.matchPattern( specialsPattern ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: specials[ special ]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfunction getNumber( parser ) {\n\t\t\t\t\t\tvar number;\n\t\t\t\t\t\tif ( number = parser.matchPattern( numberPattern ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: +number\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfunction getString( parser ) {\n\t\t\t\t\t\tvar stringLiteral = getStringLiteral( parser ),\n\t\t\t\t\t\t\tvalues;\n\t\t\t\t\t\tif ( stringLiteral && ( values = parser.values ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {\n\t\t\t\t\t\t\t\t\treturn $1 in values ? values[ $1 ] : $1;\n\t\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn stringLiteral;\n\t\t\t\t\t},\n\t\t\t\t\tfunction getObject( parser ) {\n\t\t\t\t\t\tvar result, pair;\n\t\t\t\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\t\t\t\tresult[ pair.key ] = pair.value;\n\t\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t},\n\t\t\t\t\tfunction getArray( parser ) {\n\t\t\t\t\t\tvar result, valueToken;\n\t\t\t\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = [];\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\t\t\t\tresult.push( valueToken.v );\n\t\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t} );\n\t\n\t\t\tfunction getKeyValuePair( parser ) {\n\t\t\t\tvar key, valueToken, pair;\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tkey = getKey( parser );\n\t\t\t\tif ( !key ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpair = {\n\t\t\t\t\tkey: key\n\t\t\t\t};\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tvalueToken = parser.read();\n\t\t\t\tif ( !valueToken ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpair.value = valueToken.v;\n\t\t\t\treturn pair;\n\t\t\t}\n\t\t\treturn function( str, values ) {\n\t\t\t\tvar parser = new JsonParser( str, {\n\t\t\t\t\tvalues: values\n\t\t\t\t} );\n\t\t\t\treturn parser.result;\n\t\t\t};\n\t\t}( Parser, stringLiteral, key );\n\t\n\t\t/* parse/converters/element/processDirective.js */\n\t\tvar processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {\n\t\n\t\t\tvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n\t\t\t\tExpressionParser;\n\t\t\tExpressionParser = Parser.extend( {\n\t\t\t\tconverters: [ conditional ]\n\t\t\t} );\n\t\t\t// TODO clean this up, it's shocking\n\t\t\treturn function( tokens ) {\n\t\t\t\tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\t\t\t\tif ( typeof tokens === 'string' ) {\n\t\t\t\t\tif ( match = methodCallPattern.exec( tokens ) ) {\n\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\tm: match[ 1 ]\n\t\t\t\t\t\t};\n\t\t\t\t\t\targs = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';\n\t\t\t\t\t\tparser = new ExpressionParser( args );\n\t\t\t\t\t\tresult.a = flattenExpression( parser.result[ 0 ] );\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\t\t\t\treturn tokens.trim();\n\t\t\t\t\t}\n\t\t\t\t\ttokens = [ tokens ];\n\t\t\t\t}\n\t\t\t\tresult = {};\n\t\t\t\tdirectiveName = [];\n\t\t\t\tdirectiveArgs = [];\n\t\t\t\tif ( tokens ) {\n\t\t\t\t\twhile ( tokens.length ) {\n\t\t\t\t\t\ttoken = tokens.shift();\n\t\t\t\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\t\t\t\tcolonIndex = token.indexOf( ':' );\n\t\t\t\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t\t\t\t// no\n\t\t\t\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\t\t\t\tdirectiveArgs[ 0 ] = token.substring( colonIndex + 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t\t\t\t}\n\t\t\t\tif ( !directiveName.length ) {\n\t\t\t\t\tresult = '';\n\t\t\t\t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\t// TODO is this really necessary? just use the array\n\t\t\t\t\t\tn: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName\n\t\t\t\t\t};\n\t\t\t\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {\n\t\t\t\t\t\tparsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );\n\t\t\t\t\t\tresult.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.d = directiveArgs;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = directiveName;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}( Parser, conditional, flattenExpression, parseJSON );\n\t\n\t\t/* parse/converters/element.js */\n\t\tvar element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n\t\t\t\tvalidTagNameFollower = /^[\\s\\n\\/>]/,\n\t\t\t\tonPattern = /^on/,\n\t\t\t\tproxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n\t\t\t\treservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n\t\t\t\tdirectives = {\n\t\t\t\t\t'intro-outro': 't0',\n\t\t\t\t\tintro: 't1',\n\t\t\t\t\toutro: 't2',\n\t\t\t\t\tdecorator: 'o'\n\t\t\t\t},\n\t\t\t\texclude = {\n\t\t\t\t\texclude: true\n\t\t\t\t},\n\t\t\t\tconverters, disallowedContents;\n\t\t\t// Different set of converters, because this time we're looking for closing tags\n\t\t\tconverters = [\n\t\t\t\tgetMustache,\n\t\t\t\tgetComment,\n\t\t\t\tgetElement,\n\t\t\t\tgetText,\n\t\t\t\tgetClosingTag\n\t\t\t];\n\t\t\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\t\t\tdisallowedContents = {\n\t\t\t\tli: [ 'li' ],\n\t\t\t\tdt: [\n\t\t\t\t\t'dt',\n\t\t\t\t\t'dd'\n\t\t\t\t],\n\t\t\t\tdd: [\n\t\t\t\t\t'dt',\n\t\t\t\t\t'dd'\n\t\t\t\t],\n\t\t\t\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t\t\t\trt: [\n\t\t\t\t\t'rt',\n\t\t\t\t\t'rp'\n\t\t\t\t],\n\t\t\t\trp: [\n\t\t\t\t\t'rt',\n\t\t\t\t\t'rp'\n\t\t\t\t],\n\t\t\t\toptgroup: [ 'optgroup' ],\n\t\t\t\toption: [\n\t\t\t\t\t'option',\n\t\t\t\t\t'optgroup'\n\t\t\t\t],\n\t\t\t\tthead: [\n\t\t\t\t\t'tbody',\n\t\t\t\t\t'tfoot'\n\t\t\t\t],\n\t\t\t\ttbody: [\n\t\t\t\t\t'tbody',\n\t\t\t\t\t'tfoot'\n\t\t\t\t],\n\t\t\t\ttfoot: [ 'tbody' ],\n\t\t\t\ttr: [\n\t\t\t\t\t'tr',\n\t\t\t\t\t'tbody'\n\t\t\t\t],\n\t\t\t\ttd: [\n\t\t\t\t\t'td',\n\t\t\t\t\t'th',\n\t\t\t\t\t'tr'\n\t\t\t\t],\n\t\t\t\tth: [\n\t\t\t\t\t'td',\n\t\t\t\t\t'th',\n\t\t\t\t\t'tr'\n\t\t\t\t]\n\t\t\t};\n\t\t\t__export = getElement;\n\t\n\t\t\tfunction getElement( parser ) {\n\t\t\t\tvar start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tif ( parser.inside || parser.inAttribute ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ( !parser.matchString( '<' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// if this is a closing tag, abort straight away\n\t\t\t\tif ( parser.nextChar() === '/' ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telement = {\n\t\t\t\t\tt: types.ELEMENT\n\t\t\t\t};\n\t\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\t\telement.p = parser.getLinePos( start );\n\t\t\t\t}\n\t\t\t\tif ( parser.matchString( '!' ) ) {\n\t\t\t\t\telement.y = 1;\n\t\t\t\t}\n\t\t\t\t// element name\n\t\t\t\telement.e = parser.matchPattern( tagNamePattern );\n\t\t\t\tif ( !element.e ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// next character must be whitespace, closing solidus or '>'\n\t\t\t\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\t\t\t\tparser.error( 'Illegal tag name' );\n\t\t\t\t}\n\t\t\t\taddProxyEvent = function( name, directive ) {\n\t\t\t\t\tvar directiveName = directive.n || directive;\n\t\t\t\t\tif ( reservedEventNames.test( directiveName ) ) {\n\t\t\t\t\t\tparser.pos -= directiveName.length;\n\t\t\t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t\t\t\t}\n\t\t\t\t\telement.v[ name ] = directive;\n\t\t\t\t};\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// directives and attributes\n\t\t\t\twhile ( attribute = getMustache( parser ) || getAttribute( parser ) ) {\n\t\t\t\t\t// regular attributes\n\t\t\t\t\tif ( attribute.name ) {\n\t\t\t\t\t\t// intro, outro, decorator\n\t\t\t\t\t\tif ( directiveName = directives[ attribute.name ] ) {\n\t\t\t\t\t\t\telement[ directiveName ] = processDirective( attribute.value );\n\t\t\t\t\t\t} else if ( match = proxyEventPattern.exec( attribute.name ) ) {\n\t\t\t\t\t\t\tif ( !element.v )\n\t\t\t\t\t\t\t\telement.v = {};\n\t\t\t\t\t\t\tdirective = processDirective( attribute.value );\n\t\t\t\t\t\t\taddProxyEvent( match[ 1 ], directive );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {\n\t\t\t\t\t\t\t\tif ( !element.a )\n\t\t\t\t\t\t\t\t\telement.a = {};\n\t\t\t\t\t\t\t\telement.a[ attribute.name ] = attribute.value || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !element.m )\n\t\t\t\t\t\t\telement.m = [];\n\t\t\t\t\t\telement.m.push( attribute );\n\t\t\t\t\t}\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t}\n\t\t\t\t// allow whitespace before closing solidus\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// self-closing solidus?\n\t\t\t\tif ( parser.matchString( '/' ) ) {\n\t\t\t\t\tselfClosing = true;\n\t\t\t\t}\n\t\t\t\t// closing angle bracket\n\t\t\t\tif ( !parser.matchString( '>' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlowerCaseName = element.e.toLowerCase();\n\t\t\t\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t\t\t\t// Special case - if we open a script element, further tags should\n\t\t\t\t\t// be ignored unless they're a closing script element\n\t\t\t\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {\n\t\t\t\t\t\tparser.inside = lowerCaseName;\n\t\t\t\t\t}\n\t\t\t\t\tchildren = [];\n\t\t\t\t\twhile ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {\n\t\t\t\t\t\t// Special case - closing section tag\n\t\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( child.t === types.CLOSING_TAG ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t}\n\t\t\t\t\tif ( children.length ) {\n\t\t\t\t\t\telement.f = children;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser.inside = null;\n\t\t\t\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\t\t\t\treturn exclude;\n\t\t\t\t}\n\t\t\t\treturn element;\n\t\t\t}\n\t\n\t\t\tfunction canContain( name, remaining ) {\n\t\t\t\tvar match, disallowed;\n\t\t\t\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t\t\t\tdisallowed = disallowedContents[ name ];\n\t\t\t\tif ( !match || !disallowed ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn !~disallowed.indexOf( match[ 1 ].toLowerCase() );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );\n\t\n\t\t/* parse/utils/trimWhitespace.js */\n\t\tvar trimWhitespace = function() {\n\t\n\t\t\tvar leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n\t\t\t\ttrailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\t\t\treturn function( items, leading, trailing ) {\n\t\t\t\tvar item;\n\t\t\t\tif ( leading ) {\n\t\t\t\t\titem = items[ 0 ];\n\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\titem = item.replace( leadingWhitespace, '' );\n\t\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\t\titems.shift();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems[ 0 ] = item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( trailing ) {\n\t\t\t\t\titem = items[ items.length - 1 ];\n\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\titem = item.replace( trailingWhitespace, '' );\n\t\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\t\titems.pop();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}();\n\t\n\t\t/* parse/utils/stripStandalones.js */\n\t\tvar stripStandalones = function( types ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar leadingLinebreak = /^\\s*\\r?\\n/,\n\t\t\t\ttrailingLinebreak = /\\r?\\n\\s*$/;\n\t\t\t__export = function( items ) {\n\t\t\t\tvar i, current, backOne, backTwo, lastSectionItem;\n\t\t\t\tfor ( i = 1; i < items.length; i += 1 ) {\n\t\t\t\t\tcurrent = items[ i ];\n\t\t\t\t\tbackOne = items[ i - 1 ];\n\t\t\t\t\tbackTwo = items[ i - 2 ];\n\t\t\t\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\t\t\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\t\t\t\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\t\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\t\t\t\titems[ i - 2 ] = backTwo.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\t\t// and the leading line break of the second text token\n\t\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t\t\t\t// its first item is a linebreak...\n\t\t\t\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\t\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {\n\t\t\t\t\t\t\titems[ i - 1 ] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\t\tcurrent.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t\t\t\t// its last item is a linebreak...\n\t\t\t\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\t\t\t\tlastSectionItem = backOne.f[ backOne.f.length - 1 ];\n\t\t\t\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t};\n\t\n\t\t\tfunction isString( item ) {\n\t\t\t\treturn typeof item === 'string';\n\t\t\t}\n\t\n\t\t\tfunction isComment( item ) {\n\t\t\t\treturn item.t === types.COMMENT || item.t === types.DELIMCHANGE;\n\t\t\t}\n\t\n\t\t\tfunction isSection( item ) {\n\t\t\t\treturn ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types );\n\t\n\t\t/* utils/escapeRegExp.js */\n\t\tvar escapeRegExp = function() {\n\t\n\t\t\tvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\t\t\treturn function escapeRegExp( str ) {\n\t\t\t\treturn str.replace( pattern, '\\\\$&' );\n\t\t\t};\n\t\t}();\n\t\n\t\t/* parse/_parse.js */\n\t\tvar parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar StandardParser, parse, contiguousWhitespace = /[ \\t\\f\\r\\n]+/g,\n\t\t\t\tpreserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,\n\t\t\t\tleadingWhitespace = /^\\s+/,\n\t\t\t\ttrailingWhitespace = /\\s+$/;\n\t\t\tStandardParser = Parser.extend( {\n\t\t\t\tinit: function( str, options ) {\n\t\t\t\t\t// config\n\t\t\t\t\tsetDelimiters( options, this );\n\t\t\t\t\tthis.sectionDepth = 0;\n\t\t\t\t\tthis.interpolate = {\n\t\t\t\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\t\t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n\t\t\t\t\t};\n\t\t\t\t\tif ( options.sanitize === true ) {\n\t\t\t\t\t\toptions.sanitize = {\n\t\t\t\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\t\t\t\teventAttributes: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\t\t\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\t\t\t\tthis.includeLinePositions = options.includeLinePositions;\n\t\t\t\t},\n\t\t\t\tpostProcess: function( items, options ) {\n\t\t\t\t\tif ( this.sectionDepth > 0 ) {\n\t\t\t\t\t\tthis.error( 'A section was left open' );\n\t\t\t\t\t}\n\t\t\t\t\tcleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );\n\t\t\t\t\treturn items;\n\t\t\t\t},\n\t\t\t\tconverters: [\n\t\t\t\t\tmustache,\n\t\t\t\t\tcomment,\n\t\t\t\t\telement,\n\t\t\t\t\ttext\n\t\t\t\t]\n\t\t\t} );\n\t\t\tparse = function( template ) {\n\t\t\t\tvar options = arguments[ 1 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = {};\n\t\t\t\tvar result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;\n\t\t\t\tsetDelimiters( options );\n\t\t\t\tinlinePartialStart = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*>\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\t\tinlinePartialEnd = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*\\\\/\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\t\tresult = {\n\t\t\t\t\tv: 1\n\t\t\t\t};\n\t\t\t\tif ( inlinePartialStart.test( template ) ) {\n\t\t\t\t\tremaining = template;\n\t\t\t\t\ttemplate = '';\n\t\t\t\t\twhile ( startMatch = inlinePartialStart.exec( remaining ) ) {\n\t\t\t\t\t\tname = startMatch[ 1 ];\n\t\t\t\t\t\ttemplate += remaining.substr( 0, startMatch.index );\n\t\t\t\t\t\tremaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );\n\t\t\t\t\t\tendMatch = inlinePartialEnd.exec( remaining );\n\t\t\t\t\t\tif ( !endMatch || endMatch[ 1 ] !== name ) {\n\t\t\t\t\t\t\tthrow new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for \"' + name + '\", but ' + ( endMatch ? 'instead found \"' + endMatch[ 1 ] + '\"' : ' no closing found' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;\n\t\t\t\t\t\tremaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );\n\t\t\t\t\t}\n\t\t\t\t\ttemplate += remaining;\n\t\t\t\t\tresult.p = partials;\n\t\t\t\t}\n\t\t\t\tresult.t = new StandardParser( template, options ).result;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\t__export = parse;\n\t\n\t\t\tfunction cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {\n\t\t\t\tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;\n\t\t\t\t// First pass - remove standalones and comments etc\n\t\t\t\tstripStandalones( items );\n\t\t\t\ti = items.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\titem = items[ i ];\n\t\t\t\t\t// Remove delimiter changes, unsafe elements etc\n\t\t\t\t\tif ( item.exclude ) {\n\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t} else if ( stripComments && item.t === types.COMMENT ) {\n\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If necessary, remove leading and trailing whitespace\n\t\t\t\ttrimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );\n\t\t\t\ti = items.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\titem = items[ i ];\n\t\t\t\t\t// Recurse\n\t\t\t\t\tif ( item.f ) {\n\t\t\t\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\t\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\t\t\t\tnextItem = items[ i + 1 ];\n\t\t\t\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\t\t\t\tif ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {\n\t\t\t\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// and vice versa\n\t\t\t\t\t\t\tif ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {\n\t\t\t\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\t}\n\t\t\t\t\t// Split if-else blocks into two (an if, and an unless)\n\t\t\t\t\tif ( item.l ) {\n\t\t\t\t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\t\tif ( rewriteElse ) {\n\t\t\t\t\t\t\tunlessBlock = {\n\t\t\t\t\t\t\t\tt: 4,\n\t\t\t\t\t\t\t\tn: types.SECTION_UNLESS,\n\t\t\t\t\t\t\t\tf: item.l\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// copy the conditional based on its type\n\t\t\t\t\t\t\tif ( item.r ) {\n\t\t\t\t\t\t\t\tunlessBlock.r = item.r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( item.x ) {\n\t\t\t\t\t\t\t\tunlessBlock.x = item.x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( item.rx ) {\n\t\t\t\t\t\t\t\tunlessBlock.rx = item.rx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titems.splice( i + 1, 0, unlessBlock );\n\t\t\t\t\t\t\tdelete item.l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Clean up element attributes\n\t\t\t\t\tif ( item.a ) {\n\t\t\t\t\t\tfor ( key in item.a ) {\n\t\t\t\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// final pass - fuse text nodes together\n\t\t\t\ti = items.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( typeof items[ i ] === 'string' ) {\n\t\t\t\t\t\tif ( typeof items[ i + 1 ] === 'string' ) {\n\t\t\t\t\t\t\titems[ i ] = items[ i ] + items[ i + 1 ];\n\t\t\t\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\t\t\t\titems[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( items[ i ] === '' ) {\n\t\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction setDelimiters( source ) {\n\t\t\t\tvar target = arguments[ 1 ];\n\t\t\t\tif ( target === void 0 )\n\t\t\t\t\ttarget = source;\n\t\t\t\ttarget.delimiters = source.delimiters || [\n\t\t\t\t\t'{{',\n\t\t\t\t\t'}}'\n\t\t\t\t];\n\t\t\t\ttarget.tripleDelimiters = source.tripleDelimiters || [\n\t\t\t\t\t'{{{',\n\t\t\t\t\t'}}}'\n\t\t\t\t];\n\t\t\t\ttarget.staticDelimiters = source.staticDelimiters || [\n\t\t\t\t\t'[[',\n\t\t\t\t\t']]'\n\t\t\t\t];\n\t\t\t\ttarget.staticTripleDelimiters = source.staticTripleDelimiters || [\n\t\t\t\t\t'[[[',\n\t\t\t\t\t']]]'\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );\n\t\n\t\t/* config/options/groups/optionGroup.js */\n\t\tvar optionGroup = function() {\n\t\n\t\t\treturn function createOptionGroup( keys, config ) {\n\t\t\t\tvar group = keys.map( config );\n\t\t\t\tkeys.forEach( function( key, i ) {\n\t\t\t\t\tgroup[ key ] = group[ i ];\n\t\t\t\t} );\n\t\t\t\treturn group;\n\t\t\t};\n\t\t}( legacy );\n\t\n\t\t/* config/options/groups/parseOptions.js */\n\t\tvar parseOptions = function( optionGroup ) {\n\t\n\t\t\tvar keys, parseOptions;\n\t\t\tkeys = [\n\t\t\t\t'preserveWhitespace',\n\t\t\t\t'sanitize',\n\t\t\t\t'stripComments',\n\t\t\t\t'delimiters',\n\t\t\t\t'tripleDelimiters',\n\t\t\t\t'interpolate'\n\t\t\t];\n\t\t\tparseOptions = optionGroup( keys, function( key ) {\n\t\t\t\treturn key;\n\t\t\t} );\n\t\t\treturn parseOptions;\n\t\t}( optionGroup );\n\t\n\t\t/* config/options/template/parser.js */\n\t\tvar parser = function( errors, isClient, parse, create, parseOptions ) {\n\t\n\t\t\tvar parser = {\n\t\t\t\tparse: doParse,\n\t\t\t\tfromId: fromId,\n\t\t\t\tisHashedId: isHashedId,\n\t\t\t\tisParsed: isParsed,\n\t\t\t\tgetParseOptions: getParseOptions,\n\t\t\t\tcreateHelper: createHelper\n\t\t\t};\n\t\n\t\t\tfunction createHelper( parseOptions ) {\n\t\t\t\tvar helper = create( parser );\n\t\t\t\thelper.parse = function( template, options ) {\n\t\t\t\t\treturn doParse( template, options || parseOptions );\n\t\t\t\t};\n\t\t\t\treturn helper;\n\t\t\t}\n\t\n\t\t\tfunction doParse( template, parseOptions ) {\n\t\t\t\tif ( !parse ) {\n\t\t\t\t\tthrow new Error( errors.missingParser );\n\t\t\t\t}\n\t\t\t\treturn parse( template, parseOptions || this.options );\n\t\t\t}\n\t\n\t\t\tfunction fromId( id, options ) {\n\t\t\t\tvar template;\n\t\t\t\tif ( !isClient ) {\n\t\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );\n\t\t\t\t}\n\t\t\t\tif ( isHashedId( id ) ) {\n\t\t\t\t\tid = id.substring( 1 );\n\t\t\t\t}\n\t\t\t\tif ( !( template = document.getElementById( id ) ) ) {\n\t\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error( 'Could not find template element with id #' + id );\n\t\t\t\t}\n\t\t\t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error( 'Template element with id #' + id + ', must be a <script> element' );\n\t\t\t\t}\n\t\t\t\treturn template.innerHTML;\n\t\t\t}\n\t\n\t\t\tfunction isHashedId( id ) {\n\t\t\t\treturn id && id.charAt( 0 ) === '#';\n\t\t\t}\n\t\n\t\t\tfunction isParsed( template ) {\n\t\t\t\treturn !( typeof template === 'string' );\n\t\t\t}\n\t\n\t\t\tfunction getParseOptions( ractive ) {\n\t\t\t\t// Could be Ractive or a Component\n\t\t\t\tif ( ractive.defaults ) {\n\t\t\t\t\tractive = ractive.defaults;\n\t\t\t\t}\n\t\t\t\treturn parseOptions.reduce( function( val, key ) {\n\t\t\t\t\tval[ key ] = ractive[ key ];\n\t\t\t\t\treturn val;\n\t\t\t\t}, {} );\n\t\t\t}\n\t\t\treturn parser;\n\t\t}( errors, isClient, parse, create, parseOptions );\n\t\n\t\t/* config/options/template/template.js */\n\t\tvar template = function( parser, parse ) {\n\t\n\t\t\tvar templateConfig = {\n\t\t\t\tname: 'template',\n\t\t\t\textend: function extend( Parent, proto, options ) {\n\t\t\t\t\tvar template;\n\t\t\t\t\t// only assign if exists\n\t\t\t\t\tif ( 'template' in options ) {\n\t\t\t\t\t\ttemplate = options.template;\n\t\t\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\t\t\tproto.template = template;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tproto.template = parseIfString( template, proto );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tinit: function init( Parent, ractive, options ) {\n\t\t\t\t\tvar template, fn;\n\t\t\t\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t\t\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t\t\t\t// At present that breaks the test mocks' expectations\n\t\t\t\t\ttemplate = 'template' in options ? options.template : Parent.prototype.template;\n\t\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\t\tfn = template;\n\t\t\t\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\t\t\t\t\t\tractive._config.template = {\n\t\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\t\tresult: template\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\ttemplate = parseIfString( template, ractive );\n\t\t\t\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t\t\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t\t\t\t// it's unnecessary, because the developer never needs to access\n\t\t\t\t\t// ractive.template\n\t\t\t\t\tractive.template = template.t;\n\t\t\t\t\tif ( template.p ) {\n\t\t\t\t\t\textendPartials( ractive.partials, template.p );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function( ractive ) {\n\t\t\t\t\tvar result = resetValue( ractive ),\n\t\t\t\t\t\tparsed;\n\t\t\t\t\tif ( result ) {\n\t\t\t\t\t\tparsed = parseIfString( result, ractive );\n\t\t\t\t\t\tractive.template = parsed.t;\n\t\t\t\t\t\textendPartials( ractive.partials, parsed.p, true );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction resetValue( ractive ) {\n\t\t\t\tvar initial = ractive._config.template,\n\t\t\t\t\tresult;\n\t\t\t\t// If this isn't a dynamic template, there's nothing to do\n\t\t\t\tif ( !initial || !initial.fn ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresult = getDynamicTemplate( ractive, initial.fn );\n\t\t\t\t// TODO deep equality check to prevent unnecessary re-rendering\n\t\t\t\t// in the case of already-parsed templates\n\t\t\t\tif ( result !== initial.result ) {\n\t\t\t\t\tinitial.result = result;\n\t\t\t\t\tresult = parseIfString( result, ractive );\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction getDynamicTemplate( ractive, fn ) {\n\t\t\t\tvar helper = parser.createHelper( parser.getParseOptions( ractive ) );\n\t\t\t\treturn fn.call( ractive, ractive.data, helper );\n\t\t\t}\n\t\n\t\t\tfunction parseIfString( template, ractive ) {\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\t// ID of an element containing the template?\n\t\t\t\t\tif ( template[ 0 ] === '#' ) {\n\t\t\t\t\t\ttemplate = parser.fromId( template );\n\t\t\t\t\t}\n\t\t\t\t\ttemplate = parse( template, parser.getParseOptions( ractive ) );\n\t\t\t\t} else if ( template.v !== 1 ) {\n\t\t\t\t\tthrow new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );\n\t\t\t\t}\n\t\t\t\treturn template;\n\t\t\t}\n\t\n\t\t\tfunction extendPartials( existingPartials, newPartials, overwrite ) {\n\t\t\t\tif ( !newPartials )\n\t\t\t\t\treturn;\n\t\t\t\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t\t\t\t// case, but not initially...\n\t\t\t\tfor ( var key in newPartials ) {\n\t\t\t\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\t\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn templateConfig;\n\t\t}( parser, parse );\n\t\n\t\t/* config/options/Registry.js */\n\t\tvar Registry = function( create ) {\n\t\n\t\t\tfunction Registry( name, useDefaults ) {\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.useDefaults = useDefaults;\n\t\t\t}\n\t\t\tRegistry.prototype = {\n\t\t\t\tconstructor: Registry,\n\t\t\t\textend: function( Parent, proto, options ) {\n\t\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );\n\t\t\t\t},\n\t\t\t\tinit: function( Parent, ractive, options ) {\n\t\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );\n\t\t\t\t},\n\t\t\t\tconfigure: function( Parent, target, options ) {\n\t\t\t\t\tvar name = this.name,\n\t\t\t\t\t\toption = options[ name ],\n\t\t\t\t\t\tregistry;\n\t\t\t\t\tregistry = create( Parent[ name ] );\n\t\t\t\t\tfor ( var key in option ) {\n\t\t\t\t\t\tregistry[ key ] = option[ key ];\n\t\t\t\t\t}\n\t\t\t\t\ttarget[ name ] = registry;\n\t\t\t\t},\n\t\t\t\treset: function( ractive ) {\n\t\t\t\t\tvar registry = ractive[ this.name ];\n\t\t\t\t\tvar changed = false;\n\t\t\t\t\tObject.keys( registry ).forEach( function( key ) {\n\t\t\t\t\t\tvar item = registry[ key ];\n\t\t\t\t\t\tif ( item._fn ) {\n\t\t\t\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\t\t\t\tregistry[ key ] = item._fn;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdelete registry[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn changed;\n\t\t\t\t},\n\t\t\t\tfindOwner: function( ractive, key ) {\n\t\t\t\t\treturn ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );\n\t\t\t\t},\n\t\t\t\tfindConstructor: function( constructor, key ) {\n\t\t\t\t\tif ( !constructor ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );\n\t\t\t\t},\n\t\t\t\tfind: function( ractive, key ) {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\t\treturn r[ this$0.name ][ key ];\n\t\t\t\t\t} );\n\t\t\t\t},\n\t\t\t\tfindInstance: function( ractive, key ) {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\t\treturn r[ this$0.name ][ key ] ? r : void 0;\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction recurseFind( ractive, fn ) {\n\t\t\t\tvar find, parent;\n\t\t\t\tif ( find = fn( ractive ) ) {\n\t\t\t\t\treturn find;\n\t\t\t\t}\n\t\t\t\tif ( !ractive.isolated && ( parent = ractive._parent ) ) {\n\t\t\t\t\treturn recurseFind( parent, fn );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Registry;\n\t\t}( create, legacy );\n\t\n\t\t/* config/options/groups/registries.js */\n\t\tvar registries = function( optionGroup, Registry ) {\n\t\n\t\t\tvar keys = [\n\t\t\t\t\t'adaptors',\n\t\t\t\t\t'components',\n\t\t\t\t\t'computed',\n\t\t\t\t\t'decorators',\n\t\t\t\t\t'easing',\n\t\t\t\t\t'events',\n\t\t\t\t\t'interpolators',\n\t\t\t\t\t'partials',\n\t\t\t\t\t'transitions'\n\t\t\t\t],\n\t\t\t\tregistries = optionGroup( keys, function( key ) {\n\t\t\t\t\treturn new Registry( key, key === 'computed' );\n\t\t\t\t} );\n\t\t\treturn registries;\n\t\t}( optionGroup, Registry );\n\t\n\t\t/* utils/noop.js */\n\t\tvar noop = function() {};\n\t\n\t\t/* utils/wrapPrototypeMethod.js */\n\t\tvar wrapPrototypeMethod = function( noop ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function wrap( parent, name, method ) {\n\t\t\t\tif ( !/_super/.test( method ) ) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t\tvar wrapper = function wrapSuper() {\n\t\t\t\t\tvar superMethod = getSuperMethod( wrapper._parent, name ),\n\t\t\t\t\t\thasSuper = '_super' in this,\n\t\t\t\t\t\toldSuper = this._super,\n\t\t\t\t\t\tresult;\n\t\t\t\t\tthis._super = superMethod;\n\t\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\t\tthis._super = oldSuper;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this._super;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t\twrapper._parent = parent;\n\t\t\t\twrapper._method = method;\n\t\t\t\treturn wrapper;\n\t\t\t};\n\t\n\t\t\tfunction getSuperMethod( parent, name ) {\n\t\t\t\tvar method;\n\t\t\t\tif ( name in parent ) {\n\t\t\t\t\tvar value = parent[ name ];\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\tmethod = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmethod = function returnValue() {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmethod = noop;\n\t\t\t\t}\n\t\t\t\treturn method;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( noop );\n\t\n\t\t/* config/deprecate.js */\n\t\tvar deprecate = function( warn, isArray ) {\n\t\n\t\t\tfunction deprecate( options, deprecated, correct ) {\n\t\t\t\tif ( deprecated in options ) {\n\t\t\t\t\tif ( !( correct in options ) ) {\n\t\t\t\t\t\twarn( getMessage( deprecated, correct ) );\n\t\t\t\t\t\toptions[ correct ] = options[ deprecated ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error( getMessage( deprecated, correct, true ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction getMessage( deprecated, correct, isError ) {\n\t\t\t\treturn 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );\n\t\t\t}\n\t\n\t\t\tfunction deprecateEventDefinitions( options ) {\n\t\t\t\tdeprecate( options, 'eventDefinitions', 'events' );\n\t\t\t}\n\t\n\t\t\tfunction deprecateAdaptors( options ) {\n\t\t\t\t// Using extend with Component instead of options,\n\t\t\t\t// like Human.extend( Spider ) means adaptors as a registry\n\t\t\t\t// gets copied to options. So we have to check if actually an array\n\t\t\t\tif ( isArray( options.adaptors ) ) {\n\t\t\t\t\tdeprecate( options, 'adaptors', 'adapt' );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function deprecateOptions( options ) {\n\t\t\t\tdeprecate( options, 'beforeInit', 'onconstruct' );\n\t\t\t\tdeprecate( options, 'init', 'onrender' );\n\t\t\t\tdeprecate( options, 'complete', 'oncomplete' );\n\t\t\t\tdeprecateEventDefinitions( options );\n\t\t\t\tdeprecateAdaptors( options );\n\t\t\t};\n\t\t}( warn, isArray );\n\t\n\t\t/* config/config.js */\n\t\tvar config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {\n\t\n\t\t\tvar custom, options, config, blacklisted;\n\t\t\t// would be nice to not have these here,\n\t\t\t// they get added during initialise, so for now we have\n\t\t\t// to make sure not to try and extend them.\n\t\t\t// Possibly, we could re-order and not add till later\n\t\t\t// in process.\n\t\t\tblacklisted = {\n\t\t\t\t'_parent': true,\n\t\t\t\t'_component': true\n\t\t\t};\n\t\t\tcustom = {\n\t\t\t\tdata: data,\n\t\t\t\ttemplate: template,\n\t\t\t\tcss: css\n\t\t\t};\n\t\t\toptions = Object.keys( defaults ).filter( function( key ) {\n\t\t\t\treturn !registries[ key ] && !custom[ key ] && !parseOptions[ key ];\n\t\t\t} );\n\t\t\t// this defines the order:\n\t\t\tconfig = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );\n\t\t\tfor ( var key in custom ) {\n\t\t\t\tconfig[ key ] = custom[ key ];\n\t\t\t}\n\t\t\t// for iteration\n\t\t\tconfig.keys = Object.keys( defaults ).concat( registries.map( function( r ) {\n\t\t\t\treturn r.name;\n\t\t\t} ) ).concat( [ 'css' ] );\n\t\t\t// add these to blacklisted key's that we don't double extend\n\t\t\tconfig.keys.forEach( function( key ) {\n\t\t\t\treturn blacklisted[ key ] = true;\n\t\t\t} );\n\t\t\tconfig.parseOptions = parseOptions;\n\t\t\tconfig.registries = registries;\n\t\n\t\t\tfunction customConfig( method, key, Parent, instance, options ) {\n\t\t\t\tcustom[ key ][ method ]( Parent, instance, options );\n\t\t\t}\n\t\t\tconfig.extend = function( Parent, proto, options ) {\n\t\t\t\tconfigure( 'extend', Parent, proto, options );\n\t\t\t};\n\t\t\tconfig.init = function( Parent, ractive, options ) {\n\t\t\t\tconfigure( 'init', Parent, ractive, options );\n\t\t\t};\n\t\n\t\t\tfunction isStandardDefaultKey( key ) {\n\t\t\t\treturn key in defaults && !( key in config.parseOptions ) && !( key in custom );\n\t\t\t}\n\t\n\t\t\tfunction configure( method, Parent, instance, options ) {\n\t\t\t\tdeprecate( options );\n\t\t\t\tcustomConfig( method, 'data', Parent, instance, options );\n\t\t\t\tconfig.parseOptions.forEach( function( key ) {\n\t\t\t\t\tif ( key in options ) {\n\t\t\t\t\t\tinstance[ key ] = options[ key ];\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tfor ( var key in options ) {\n\t\t\t\t\tif ( isStandardDefaultKey( key ) ) {\n\t\t\t\t\t\tvar value = options[ key ];\n\t\t\t\t\t\tinstance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconfig.registries.forEach( function( registry ) {\n\t\t\t\t\tregistry[ method ]( Parent, instance, options );\n\t\t\t\t} );\n\t\t\t\tcustomConfig( method, 'template', Parent, instance, options );\n\t\t\t\tcustomConfig( method, 'css', Parent, instance, options );\n\t\t\t\textendOtherMethods( Parent.prototype, instance, options );\n\t\t\t}\n\t\n\t\t\tfunction extendOtherMethods( parent, instance, options ) {\n\t\t\t\tfor ( var key in options ) {\n\t\t\t\t\tif ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tvar member = options[ key ];\n\t\t\t\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\t\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\t\t\t\tmember = wrapPrototype( parent, key, member );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinstance[ key ] = member;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfig.reset = function( ractive ) {\n\t\t\t\treturn config.filter( function( c ) {\n\t\t\t\t\treturn c.reset && c.reset( ractive );\n\t\t\t\t} ).map( function( c ) {\n\t\t\t\t\treturn c.name;\n\t\t\t\t} );\n\t\t\t};\n\t\t\tconfig.getConstructTarget = function( ractive, options ) {\n\t\t\t\tif ( options.onconstruct ) {\n\t\t\t\t\t// pretend this object literal is the ractive instance\n\t\t\t\t\treturn {\n\t\t\t\t\t\tonconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),\n\t\t\t\t\t\tfire: ractive.fire.bind( ractive )\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn ractive;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn config;\n\t\t}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );\n\t\n\t\t/* shared/interpolate.js */\n\t\tvar interpolate = function( circular, warn, interpolators, config ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar interpolate = function( from, to, ractive, type ) {\n\t\t\t\tif ( from === to ) {\n\t\t\t\t\treturn snap( to );\n\t\t\t\t}\n\t\t\t\tif ( type ) {\n\t\t\t\t\tvar interpol = config.registries.interpolators.find( ractive, type );\n\t\t\t\t\tif ( interpol ) {\n\t\t\t\t\t\treturn interpol( from, to ) || snap( to );\n\t\t\t\t\t}\n\t\t\t\t\twarn( 'Missing \"' + type + '\" interpolator. You may need to download a plugin from [TODO]' );\n\t\t\t\t}\n\t\t\t\treturn interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );\n\t\t\t};\n\t\t\tcircular.interpolate = interpolate;\n\t\t\t__export = interpolate;\n\t\n\t\t\tfunction snap( to ) {\n\t\t\t\treturn function() {\n\t\t\t\t\treturn to;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( circular, warn, interpolators, config );\n\t\n\t\t/* Ractive/prototype/animate/Animation.js */\n\t\tvar Ractive$animate_Animation = function( warn, runloop, interpolate ) {\n\t\n\t\t\tvar Animation = function( options ) {\n\t\t\t\tvar key;\n\t\t\t\tthis.startTime = Date.now();\n\t\t\t\t// from and to\n\t\t\t\tfor ( key in options ) {\n\t\t\t\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tthis[ key ] = options[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\t\t\t\tthis.running = true;\n\t\t\t\tthis.tick();\n\t\t\t};\n\t\t\tAnimation.prototype = {\n\t\t\t\ttick: function() {\n\t\t\t\t\tvar elapsed, t, value, timeNow, index, keypath;\n\t\t\t\t\tkeypath = this.keypath;\n\t\t\t\t\tif ( this.running ) {\n\t\t\t\t\t\ttimeNow = Date.now();\n\t\t\t\t\t\telapsed = timeNow - this.startTime;\n\t\t\t\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.complete( this.to );\n\t\t\t\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t\t\t\t// TODO investigate why this happens\n\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t\t\t\t\tthis.running = false;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;\n\t\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\t\tthis.step( t, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tstop: function() {\n\t\t\t\t\tvar index;\n\t\t\t\t\tthis.running = false;\n\t\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t\t// TODO investigate why this happens\n\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t\t}\n\t\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Animation;\n\t\t}( warn, runloop, interpolate );\n\t\n\t\t/* Ractive/prototype/animate.js */\n\t\tvar Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar noop = function() {},\n\t\t\t\tnoAnimation = {\n\t\t\t\t\tstop: noop\n\t\t\t\t};\n\t\t\t__export = function Ractive$animate( keypath, to, options ) {\n\t\t\t\tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\t\t\t\tpromise = new Promise( function( fulfil ) {\n\t\t\t\t\tfulfilPromise = fulfil;\n\t\t\t\t} );\n\t\t\t\t// animate multiple keypaths\n\t\t\t\tif ( typeof keypath === 'object' ) {\n\t\t\t\t\toptions = to || {};\n\t\t\t\t\teasing = options.easing;\n\t\t\t\t\tduration = options.duration;\n\t\t\t\t\tanimations = [];\n\t\t\t\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t\t\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t\t\t\t// our own...\n\t\t\t\t\tstep = options.step;\n\t\t\t\t\tcomplete = options.complete;\n\t\t\t\t\tif ( step || complete ) {\n\t\t\t\t\t\tcurrentValues = {};\n\t\t\t\t\t\toptions.step = null;\n\t\t\t\t\t\toptions.complete = null;\n\t\t\t\t\t\tmakeValueCollector = function( keypath ) {\n\t\t\t\t\t\t\treturn function( t, value ) {\n\t\t\t\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k in keypath ) {\n\t\t\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\t\t\tif ( step || complete ) {\n\t\t\t\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\t\t\t\toptions = {\n\t\t\t\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\t\t\t\tduration: duration\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\t\t\t\tanimations.push( animate( this, k, keypath[ k ], options ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Create a dummy animation, to facilitate step/complete\n\t\t\t\t\t// callbacks, and Promise fulfilment\n\t\t\t\t\tdummyOptions = {\n\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\tduration: duration\n\t\t\t\t\t};\n\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\tdummyOptions.step = function( t ) {\n\t\t\t\t\t\t\tstep( t, currentValues );\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif ( complete ) {\n\t\t\t\t\t\tpromise.then( function( t ) {\n\t\t\t\t\t\t\tcomplete( t, currentValues );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tdummyOptions.complete = fulfilPromise;\n\t\t\t\t\tdummy = animate( this, null, null, dummyOptions );\n\t\t\t\t\tanimations.push( dummy );\n\t\t\t\t\tpromise.stop = function() {\n\t\t\t\t\t\tvar animation;\n\t\t\t\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( dummy ) {\n\t\t\t\t\t\t\tdummy.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\t\t\t\t// animate a single keypath\n\t\t\t\toptions = options || {};\n\t\t\t\tif ( options.complete ) {\n\t\t\t\t\tpromise.then( options.complete );\n\t\t\t\t}\n\t\t\t\toptions.complete = fulfilPromise;\n\t\t\t\tanimation = animate( this, keypath, to, options );\n\t\t\t\tpromise.stop = function() {\n\t\t\t\t\tanimation.stop();\n\t\t\t\t};\n\t\t\t\treturn promise;\n\t\t\t};\n\t\n\t\t\tfunction animate( root, keypath, to, options ) {\n\t\t\t\tvar easing, duration, animation, from;\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\t}\n\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\tfrom = root.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t\t// cancel any existing animation\n\t\t\t\t// TODO what about upstream/downstream keypaths?\n\t\t\t\tanimations.abort( keypath, root );\n\t\t\t\t// don't bother animating values that stay the same\n\t\t\t\tif ( isEqual( from, to ) ) {\n\t\t\t\t\tif ( options.complete ) {\n\t\t\t\t\t\toptions.complete( options.to );\n\t\t\t\t\t}\n\t\t\t\t\treturn noAnimation;\n\t\t\t\t}\n\t\t\t\t// easing function\n\t\t\t\tif ( options.easing ) {\n\t\t\t\t\tif ( typeof options.easing === 'function' ) {\n\t\t\t\t\t\teasing = options.easing;\n\t\t\t\t\t} else {\n\t\t\t\t\t\teasing = root.easing[ options.easing ];\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof easing !== 'function' ) {\n\t\t\t\t\t\teasing = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// duration\n\t\t\t\tduration = options.duration === undefined ? 400 : options.duration;\n\t\t\t\t// TODO store keys, use an internal set method\n\t\t\t\tanimation = new Animation( {\n\t\t\t\t\tkeypath: keypath,\n\t\t\t\t\tfrom: from,\n\t\t\t\t\tto: to,\n\t\t\t\t\troot: root,\n\t\t\t\t\tduration: duration,\n\t\t\t\t\teasing: easing,\n\t\t\t\t\tinterpolator: options.interpolator,\n\t\t\t\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\t\t\t\tstep: options.step,\n\t\t\t\t\tcomplete: options.complete\n\t\t\t\t} );\n\t\t\t\tanimations.add( animation );\n\t\t\t\troot._animations.push( animation );\n\t\t\t\treturn animation;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );\n\t\n\t\t/* Ractive/prototype/detach.js */\n\t\tvar Ractive$detach = function( Hook, removeFromArray ) {\n\t\n\t\t\tvar detachHook = new Hook( 'detach' );\n\t\t\treturn function Ractive$detach() {\n\t\t\t\tif ( this.detached ) {\n\t\t\t\t\treturn this.detached;\n\t\t\t\t}\n\t\t\t\tif ( this.el ) {\n\t\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t\t}\n\t\t\t\tthis.detached = this.fragment.detach();\n\t\t\t\tdetachHook.fire( this );\n\t\t\t\treturn this.detached;\n\t\t\t};\n\t\t}( Ractive$shared_hooks_Hook, removeFromArray );\n\t\n\t\t/* Ractive/prototype/find.js */\n\t\tvar Ractive$find = function Ractive$find( selector ) {\n\t\t\tif ( !this.el ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn this.fragment.find( selector );\n\t\t};\n\t\n\t\t/* utils/matches.js */\n\t\tvar matches = function( isClient, vendors, createElement ) {\n\t\n\t\t\tvar matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;\n\t\t\tif ( !isClient ) {\n\t\t\t\tmatches = null;\n\t\t\t} else {\n\t\t\t\tdiv = createElement( 'div' );\n\t\t\t\tmethodNames = [\n\t\t\t\t\t'matches',\n\t\t\t\t\t'matchesSelector'\n\t\t\t\t];\n\t\t\t\tmakeFunction = function( methodName ) {\n\t\t\t\t\treturn function( node, selector ) {\n\t\t\t\t\t\treturn node[ methodName ]( selector );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\ti = methodNames.length;\n\t\t\t\twhile ( i-- && !matches ) {\n\t\t\t\t\tunprefixed = methodNames[ i ];\n\t\t\t\t\tif ( div[ unprefixed ] ) {\n\t\t\t\t\t\tmatches = makeFunction( unprefixed );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj = vendors.length;\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\tprefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\t\t\t\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// IE8...\n\t\t\t\tif ( !matches ) {\n\t\t\t\t\tmatches = function( node, selector ) {\n\t\t\t\t\t\tvar nodes, parentNode, i;\n\t\t\t\t\t\tparentNode = node.parentNode;\n\t\t\t\t\t\tif ( !parentNode ) {\n\t\t\t\t\t\t\t// empty dummy <div>\n\t\t\t\t\t\t\tdiv.innerHTML = '';\n\t\t\t\t\t\t\tparentNode = div;\n\t\t\t\t\t\t\tnode = node.cloneNode();\n\t\t\t\t\t\t\tdiv.appendChild( node );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnodes = parentNode.querySelectorAll( selector );\n\t\t\t\t\t\ti = nodes.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( nodes[ i ] === node ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches;\n\t\t}( isClient, vendors, createElement );\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/test.js */\n\t\tvar Ractive$shared_makeQuery_test = function( matches ) {\n\t\n\t\t\treturn function( item, noDirty ) {\n\t\t\t\tvar itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );\n\t\t\t\tif ( itemMatches ) {\n\t\t\t\t\tthis.push( item.node || item.instance );\n\t\t\t\t\tif ( !noDirty ) {\n\t\t\t\t\t\tthis._makeDirty();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\t\t}( matches );\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/cancel.js */\n\t\tvar Ractive$shared_makeQuery_cancel = function() {\n\t\t\tvar liveQueries, selector, index;\n\t\t\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t\t\tselector = this.selector;\n\t\t\tindex = liveQueries.indexOf( selector );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tliveQueries.splice( index, 1 );\n\t\t\t\tliveQueries[ selector ] = null;\n\t\t\t}\n\t\t};\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */\n\t\tvar Ractive$shared_makeQuery_sortByItemPosition = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function( a, b ) {\n\t\t\t\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\t\t\t\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\t\t\t\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\t\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t\t// remove items from the end of both ancestries as long as they are identical\n\t\t\t\t// - the final one removed is the closest mutual ancestor\n\t\t\t\twhile ( oldestA && oldestA === oldestB ) {\n\t\t\t\t\tancestryA.pop();\n\t\t\t\t\tancestryB.pop();\n\t\t\t\t\tmutualAncestor = oldestA;\n\t\t\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t\t}\n\t\t\t\t// now that we have the mutual ancestor, we can find which is earliest\n\t\t\t\toldestA = oldestA.component || oldestA;\n\t\t\t\toldestB = oldestB.component || oldestB;\n\t\t\t\tfragmentA = oldestA.parentFragment;\n\t\t\t\tfragmentB = oldestB.parentFragment;\n\t\t\t\t// if both items share a parent fragment, our job is easy\n\t\t\t\tif ( fragmentA === fragmentB ) {\n\t\t\t\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\t\t\t\tindexB = fragmentB.items.indexOf( oldestB );\n\t\t\t\t\t// if it's the same index, it means one contains the other,\n\t\t\t\t\t// so we see which has the longest ancestry\n\t\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t\t}\n\t\t\t\t// if mutual ancestor is a section, we first test to see which section\n\t\t\t\t// fragment comes first\n\t\t\t\tif ( fragments = mutualAncestor.fragments ) {\n\t\t\t\t\tindexA = fragments.indexOf( fragmentA );\n\t\t\t\t\tindexB = fragments.indexOf( fragmentB );\n\t\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n\t\t\t};\n\t\n\t\t\tfunction getParent( item ) {\n\t\t\t\tvar parentFragment;\n\t\t\t\tif ( parentFragment = item.parentFragment ) {\n\t\t\t\t\treturn parentFragment.owner;\n\t\t\t\t}\n\t\t\t\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\t\t\t\treturn parentFragment.owner;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction getAncestry( item ) {\n\t\t\t\tvar ancestry, ancestor;\n\t\t\t\tancestry = [ item ];\n\t\t\t\tancestor = getParent( item );\n\t\t\t\twhile ( ancestor ) {\n\t\t\t\t\tancestry.push( ancestor );\n\t\t\t\t\tancestor = getParent( ancestor );\n\t\t\t\t}\n\t\t\t\treturn ancestry;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */\n\t\tvar Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {\n\t\n\t\t\treturn function( node, otherNode ) {\n\t\t\t\tvar bitmask;\n\t\t\t\tif ( node.compareDocumentPosition ) {\n\t\t\t\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\t\t\t\treturn bitmask & 2 ? 1 : -1;\n\t\t\t\t}\n\t\t\t\t// In old IE, we can piggy back on the mechanism for\n\t\t\t\t// comparing component positions\n\t\t\t\treturn sortByItemPosition( node, otherNode );\n\t\t\t};\n\t\t}( Ractive$shared_makeQuery_sortByItemPosition );\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/sort.js */\n\t\tvar Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {\n\t\n\t\t\treturn function() {\n\t\t\t\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t\t\t\tthis._dirty = false;\n\t\t\t};\n\t\t}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/dirty.js */\n\t\tvar Ractive$shared_makeQuery_dirty = function( runloop ) {\n\t\n\t\t\treturn function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tif ( !this._dirty ) {\n\t\t\t\t\tthis._dirty = true;\n\t\t\t\t\t// Once the DOM has been updated, ensure the query\n\t\t\t\t\t// is correctly ordered\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\tthis$0._sort();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t}( runloop );\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/remove.js */\n\t\tvar Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {\n\t\t\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tthis.splice( index, 1 );\n\t\t\t}\n\t\t};\n\t\n\t\t/* Ractive/prototype/shared/makeQuery/_makeQuery.js */\n\t\tvar Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {\n\t\n\t\t\treturn function makeQuery( ractive, selector, live, isComponentQuery ) {\n\t\t\t\tvar query = [];\n\t\t\t\tdefineProperties( query, {\n\t\t\t\t\tselector: {\n\t\t\t\t\t\tvalue: selector\n\t\t\t\t\t},\n\t\t\t\t\tlive: {\n\t\t\t\t\t\tvalue: live\n\t\t\t\t\t},\n\t\t\t\t\t_isComponentQuery: {\n\t\t\t\t\t\tvalue: isComponentQuery\n\t\t\t\t\t},\n\t\t\t\t\t_test: {\n\t\t\t\t\t\tvalue: test\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( !live ) {\n\t\t\t\t\treturn query;\n\t\t\t\t}\n\t\t\t\tdefineProperties( query, {\n\t\t\t\t\tcancel: {\n\t\t\t\t\t\tvalue: cancel\n\t\t\t\t\t},\n\t\t\t\t\t_root: {\n\t\t\t\t\t\tvalue: ractive\n\t\t\t\t\t},\n\t\t\t\t\t_sort: {\n\t\t\t\t\t\tvalue: sort\n\t\t\t\t\t},\n\t\t\t\t\t_makeDirty: {\n\t\t\t\t\t\tvalue: dirty\n\t\t\t\t\t},\n\t\t\t\t\t_remove: {\n\t\t\t\t\t\tvalue: remove\n\t\t\t\t\t},\n\t\t\t\t\t_dirty: {\n\t\t\t\t\t\tvalue: false,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn query;\n\t\t\t};\n\t\t}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );\n\t\n\t\t/* Ractive/prototype/findAll.js */\n\t\tvar Ractive$findAll = function( makeQuery ) {\n\t\n\t\t\treturn function Ractive$findAll( selector, options ) {\n\t\t\t\tvar liveQueries, query;\n\t\t\t\tif ( !this.el ) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\toptions = options || {};\n\t\t\t\tliveQueries = this._liveQueries;\n\t\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t\t}\n\t\t\t\tquery = makeQuery( this, selector, !!options.live, false );\n\t\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t\t// if applicable\n\t\t\t\tif ( query.live ) {\n\t\t\t\t\tliveQueries.push( selector );\n\t\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t\t}\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t\treturn query;\n\t\t\t};\n\t\t}( Ractive$shared_makeQuery__makeQuery );\n\t\n\t\t/* Ractive/prototype/findAllComponents.js */\n\t\tvar Ractive$findAllComponents = function( makeQuery ) {\n\t\n\t\t\treturn function Ractive$findAllComponents( selector, options ) {\n\t\t\t\tvar liveQueries, query;\n\t\t\t\toptions = options || {};\n\t\t\t\tliveQueries = this._liveComponentQueries;\n\t\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t\t}\n\t\t\t\tquery = makeQuery( this, selector, !!options.live, true );\n\t\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t\t// if applicable\n\t\t\t\tif ( query.live ) {\n\t\t\t\t\tliveQueries.push( selector );\n\t\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t\t}\n\t\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t\t\treturn query;\n\t\t\t};\n\t\t}( Ractive$shared_makeQuery__makeQuery );\n\t\n\t\t/* Ractive/prototype/findComponent.js */\n\t\tvar Ractive$findComponent = function Ractive$findComponent( selector ) {\n\t\t\treturn this.fragment.findComponent( selector );\n\t\t};\n\t\n\t\t/* utils/getPotentialWildcardMatches.js */\n\t\tvar getPotentialWildcardMatches = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar starMaps = {};\n\t\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t\t// all the variants of that keypath that include a wildcard in place\n\t\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t\t// to see if any pattern observers are downstream of one or more of\n\t\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\t\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tif ( !( starMap = starMaps[ keys.length ] ) ) {\n\t\t\t\t\tstarMap = getStarMap( keys.length );\n\t\t\t\t}\n\t\t\t\tresult = [];\n\t\t\t\tmapper = function( star, i ) {\n\t\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t\t};\n\t\t\t\ti = starMap.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\twildcardKeypath = starMap[ i ].map( mapper ).join( '.' );\n\t\t\t\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\t\t\t\tresult.push( wildcardKeypath );\n\t\t\t\t\t\tresult[ wildcardKeypath ] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\t// This function returns all the possible true/false combinations for\n\t\t\t// a given number - e.g. for two, the possible combinations are\n\t\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\t\tfunction getStarMap( num ) {\n\t\t\t\tvar ones = '',\n\t\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\t\tif ( !starMaps[ num ] ) {\n\t\t\t\t\tstarMap = [];\n\t\t\t\t\twhile ( ones.length < num ) {\n\t\t\t\t\t\tones += 1;\n\t\t\t\t\t}\n\t\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\t\treturn digit === '1';\n\t\t\t\t\t};\n\t\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\t\twhile ( binary.length < num ) {\n\t\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t\t}\n\t\t\t\t\tstarMaps[ num ] = starMap;\n\t\t\t\t}\n\t\t\t\treturn starMaps[ num ];\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* Ractive/prototype/shared/fireEvent.js */\n\t\tvar Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function fireEvent( ractive, eventName ) {\n\t\t\t\tvar options = arguments[ 2 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = {};\n\t\t\t\tif ( !eventName ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !options.event ) {\n\t\t\t\t\toptions.event = {\n\t\t\t\t\t\tname: eventName,\n\t\t\t\t\t\tcontext: ractive.data,\n\t\t\t\t\t\tkeypath: '',\n\t\t\t\t\t\t// until event not included as argument default\n\t\t\t\t\t\t_noArg: true\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\toptions.event.name = eventName;\n\t\t\t\t}\n\t\t\t\tvar eventNames = getPotentialWildcardMatches( eventName );\n\t\t\t\tfireEventAs( ractive, eventNames, options.event, options.args, true );\n\t\t\t};\n\t\n\t\t\tfunction fireEventAs( ractive, eventNames, event, args ) {\n\t\t\t\tvar initialFire = arguments[ 4 ];\n\t\t\t\tif ( initialFire === void 0 )\n\t\t\t\t\tinitialFire = false;\n\t\t\t\tvar subscribers, i, bubble = true;\n\t\t\t\tif ( event ) {\n\t\t\t\t\tractive.event = event;\n\t\t\t\t}\n\t\t\t\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\t\t\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\t\t\t\t\tif ( subscribers ) {\n\t\t\t\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( event ) {\n\t\t\t\t\tdelete ractive.event;\n\t\t\t\t}\n\t\t\t\tif ( ractive._parent && bubble ) {\n\t\t\t\t\tif ( initialFire && ractive.component ) {\n\t\t\t\t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];\n\t\t\t\t\t\teventNames = getPotentialWildcardMatches( fullName );\n\t\t\t\t\t\tif ( event ) {\n\t\t\t\t\t\t\tevent.component = ractive;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfireEventAs( ractive._parent, eventNames, event, args );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction notifySubscribers( ractive, subscribers, event, args ) {\n\t\t\t\tvar originalEvent = null,\n\t\t\t\t\tstopEvent = false;\n\t\t\t\tif ( event && !event._noArg ) {\n\t\t\t\t\targs = [ event ].concat( args );\n\t\t\t\t}\n\t\t\t\tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\t\t\t\tif ( subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\t\t\t\tstopEvent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\t\t\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\t\t\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t\t\t\t}\n\t\t\t\treturn !stopEvent;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( getPotentialWildcardMatches );\n\t\n\t\t/* Ractive/prototype/fire.js */\n\t\tvar Ractive$fire = function( fireEvent ) {\n\t\n\t\t\treturn function Ractive$fire( eventName ) {\n\t\t\t\tvar options = {\n\t\t\t\t\targs: Array.prototype.slice.call( arguments, 1 )\n\t\t\t\t};\n\t\t\t\tfireEvent( this, eventName, options );\n\t\t\t};\n\t\t}( Ractive$shared_fireEvent );\n\t\n\t\t/* Ractive/prototype/get.js */\n\t\tvar Ractive$get = function( normaliseKeypath, resolveRef ) {\n\t\n\t\t\tvar options = {\n\t\t\t\tcapture: true\n\t\t\t};\n\t\t\t// top-level calls should be intercepted\n\t\t\treturn function Ractive$get( keypath ) {\n\t\t\t\tvar value;\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\tvalue = this.viewmodel.get( keypath, options );\n\t\t\t\t// Create inter-component binding, if necessary\n\t\t\t\tif ( value === undefined && this._parent && !this.isolated ) {\n\t\t\t\t\tif ( resolveRef( this, keypath, this.fragment ) ) {\n\t\t\t\t\t\t// creates binding as side-effect, if appropriate\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}( normaliseKeypath, resolveRef );\n\t\n\t\t/* utils/getElement.js */\n\t\tvar getElement = function getElement( input ) {\n\t\t\tvar output;\n\t\t\tif ( !input || typeof input === 'boolean' ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( typeof window === 'undefined' || !document || !input ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t\t\tif ( input.nodeType ) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\t// Get node from string\n\t\t\tif ( typeof input === 'string' ) {\n\t\t\t\t// try ID first\n\t\t\t\toutput = document.getElementById( input );\n\t\t\t\t// then as selector, if possible\n\t\t\t\tif ( !output && document.querySelector ) {\n\t\t\t\t\toutput = document.querySelector( input );\n\t\t\t\t}\n\t\t\t\t// did it work?\n\t\t\t\tif ( output && output.nodeType ) {\n\t\t\t\t\treturn output;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t\t\tif ( input[ 0 ] && input[ 0 ].nodeType ) {\n\t\t\t\treturn input[ 0 ];\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* Ractive/prototype/insert.js */\n\t\tvar Ractive$insert = function( Hook, getElement ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar insertHook = new Hook( 'insert' );\n\t\t\t__export = function Ractive$insert( target, anchor ) {\n\t\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\t\t// TODO create, and link to, documentation explaining this\n\t\t\t\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t\t\t\t}\n\t\t\t\ttarget = getElement( target );\n\t\t\t\tanchor = getElement( anchor ) || null;\n\t\t\t\tif ( !target ) {\n\t\t\t\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t\t\t\t}\n\t\t\t\ttarget.insertBefore( this.detach(), anchor );\n\t\t\t\tthis.el = target;\n\t\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t\t\t\tthis.detached = null;\n\t\t\t\tfireInsertHook( this );\n\t\t\t};\n\t\n\t\t\tfunction fireInsertHook( ractive ) {\n\t\t\t\tinsertHook.fire( ractive );\n\t\t\t\tractive.findAllComponents( '*' ).forEach( function( child ) {\n\t\t\t\t\tfireInsertHook( child.instance );\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( Ractive$shared_hooks_Hook, getElement );\n\t\n\t\t/* Ractive/prototype/merge.js */\n\t\tvar Ractive$merge = function( runloop, isArray, normaliseKeypath ) {\n\t\n\t\t\treturn function Ractive$merge( keypath, array, options ) {\n\t\t\t\tvar currentArray, promise;\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\tcurrentArray = this.viewmodel.get( keypath );\n\t\t\t\t// If either the existing value or the new value isn't an\n\t\t\t\t// array, just do a regular set\n\t\t\t\tif ( !isArray( currentArray ) || !isArray( array ) ) {\n\t\t\t\t\treturn this.set( keypath, array, options && options.complete );\n\t\t\t\t}\n\t\t\t\t// Manage transitions\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\tthis.viewmodel.merge( keypath, currentArray, array, options );\n\t\t\t\trunloop.end();\n\t\t\t\t// attach callback as fulfilment handler, if specified\n\t\t\t\tif ( options && options.complete ) {\n\t\t\t\t\tpromise.then( options.complete );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( runloop, isArray, normaliseKeypath );\n\t\n\t\t/* Ractive/prototype/observe/Observer.js */\n\t\tvar Ractive$observe_Observer = function( runloop, isEqual ) {\n\t\n\t\t\tvar Observer = function( ractive, keypath, callback, options ) {\n\t\t\t\tthis.root = ractive;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.callback = callback;\n\t\t\t\tthis.defer = options.defer;\n\t\t\t\t// default to root as context, but allow it to be overridden\n\t\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t\t};\n\t\t\tObserver.prototype = {\n\t\t\t\tinit: function( immediate ) {\n\t\t\t\t\tthis.value = this.root.get( this.keypath );\n\t\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.oldValue = this.value;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\t\treturn this$0.update();\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.update();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdate: function() {\n\t\t\t\t\t// Prevent infinite loops\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath );\n\t\t\t\t\tthis.oldValue = this.value;\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Observer;\n\t\t}( runloop, isEqual );\n\t\n\t\t/* shared/getMatchingKeypaths.js */\n\t\tvar getMatchingKeypaths = function( isArray ) {\n\t\n\t\t\treturn function getMatchingKeypaths( ractive, pattern ) {\n\t\t\t\tvar keys, key, matchingKeypaths;\n\t\t\t\tkeys = pattern.split( '.' );\n\t\t\t\tmatchingKeypaths = [ '' ];\n\t\t\t\twhile ( key = keys.shift() ) {\n\t\t\t\t\tif ( key === '*' ) {\n\t\t\t\t\t\t// expand to find all valid child keypaths\n\t\t\t\t\t\tmatchingKeypaths = matchingKeypaths.reduce( expand, [] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( matchingKeypaths[ 0 ] === '' ) {\n\t\t\t\t\t\t\t// first key\n\t\t\t\t\t\t\tmatchingKeypaths[ 0 ] = key;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatchingKeypaths = matchingKeypaths.map( concatenate( key ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn matchingKeypaths;\n\t\n\t\t\t\tfunction expand( matchingKeypaths, keypath ) {\n\t\t\t\t\tvar value, key, childKeypath;\n\t\t\t\t\tvalue = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );\n\t\t\t\t\tfor ( key in value ) {\n\t\t\t\t\t\tif ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {\n\t\t\t\t\t\t\t// for benefit of IE8\n\t\t\t\t\t\t\tchildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t\t\tmatchingKeypaths.push( childKeypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn matchingKeypaths;\n\t\t\t\t}\n\t\n\t\t\t\tfunction concatenate( key ) {\n\t\t\t\t\treturn function( keypath ) {\n\t\t\t\t\t\treturn keypath ? keypath + '.' + key : key;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t}( isArray );\n\t\n\t\t/* Ractive/prototype/observe/getPattern.js */\n\t\tvar Ractive$observe_getPattern = function( getMatchingKeypaths ) {\n\t\n\t\t\treturn function getPattern( ractive, pattern ) {\n\t\t\t\tvar matchingKeypaths, values;\n\t\t\t\tmatchingKeypaths = getMatchingKeypaths( ractive, pattern );\n\t\t\t\tvalues = {};\n\t\t\t\tmatchingKeypaths.forEach( function( keypath ) {\n\t\t\t\t\tvalues[ keypath ] = ractive.get( keypath );\n\t\t\t\t} );\n\t\t\t\treturn values;\n\t\t\t};\n\t\t}( getMatchingKeypaths );\n\t\n\t\t/* Ractive/prototype/observe/PatternObserver.js */\n\t\tvar Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {\n\t\n\t\t\tvar PatternObserver, wildcard = /\\*/,\n\t\t\t\tslice = Array.prototype.slice;\n\t\t\tPatternObserver = function( ractive, keypath, callback, options ) {\n\t\t\t\tthis.root = ractive;\n\t\t\t\tthis.callback = callback;\n\t\t\t\tthis.defer = options.defer;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.regex = new RegExp( '^' + keypath.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\t\t\t\tthis.values = {};\n\t\t\t\tif ( this.defer ) {\n\t\t\t\t\tthis.proxies = [];\n\t\t\t\t}\n\t\t\t\t// default to root as context, but allow it to be overridden\n\t\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t\t};\n\t\t\tPatternObserver.prototype = {\n\t\t\t\tinit: function( immediate ) {\n\t\t\t\t\tvar values, keypath;\n\t\t\t\t\tvalues = getPattern( this.root, this.keypath );\n\t\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.values = values;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdate: function( keypath ) {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar values;\n\t\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\t\tvalues = getPattern( this.root, keypath );\n\t\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - array mutation should not trigger `array.*`\n\t\t\t\t\t// pattern observer with `array.length`\n\t\t\t\t\tif ( this.root.viewmodel.implicitChanges[ keypath ] ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn this$0.getProxy( keypath ).update();\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.reallyUpdate( keypath );\n\t\t\t\t},\n\t\t\t\treallyUpdate: function( keypath ) {\n\t\t\t\t\tvar value, keys, args;\n\t\t\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\t\t\t// Prevent infinite loops\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\tif ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {\n\t\t\t\t\t\tkeys = slice.call( this.regex.exec( keypath ), 1 );\n\t\t\t\t\t\targs = [\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tthis.values[ keypath ],\n\t\t\t\t\t\t\tkeypath\n\t\t\t\t\t\t].concat( keys );\n\t\t\t\t\t\tthis.callback.apply( this.context, args );\n\t\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t\t}\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t},\n\t\t\t\tgetProxy: function( keypath ) {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tif ( !this.proxies[ keypath ] ) {\n\t\t\t\t\t\tthis.proxies[ keypath ] = {\n\t\t\t\t\t\t\tupdate: function() {\n\t\t\t\t\t\t\t\tself.reallyUpdate( keypath );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn this.proxies[ keypath ];\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn PatternObserver;\n\t\t}( runloop, isEqual, Ractive$observe_getPattern );\n\t\n\t\t/* Ractive/prototype/observe/getObserverFacade.js */\n\t\tvar Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {\n\t\n\t\t\tvar wildcard = /\\*/,\n\t\t\t\temptyObject = {};\n\t\t\treturn function getObserverFacade( ractive, keypath, callback, options ) {\n\t\t\t\tvar observer, isPatternObserver, cancelled;\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\toptions = options || emptyObject;\n\t\t\t\t// pattern observers are treated differently\n\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\t\t\t\tractive.viewmodel.patternObservers.push( observer );\n\t\t\t\t\tisPatternObserver = true;\n\t\t\t\t} else {\n\t\t\t\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t\t\t\t}\n\t\t\t\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\t\t\t\tobserver.init( options.init );\n\t\t\t\t// This flag allows observers to initialise even with undefined values\n\t\t\t\tobserver.ready = true;\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\tif ( cancelled ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( isPatternObserver ) {\n\t\t\t\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\t\t\t\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcancelled = true;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );\n\t\n\t\t/* Ractive/prototype/observe.js */\n\t\tvar Ractive$observe = function( isObject, getObserverFacade ) {\n\t\n\t\t\treturn function Ractive$observe( keypath, callback, options ) {\n\t\t\t\tvar observers, map, keypaths, i;\n\t\t\t\t// Allow a map of keypaths to handlers\n\t\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\t\toptions = callback;\n\t\t\t\t\tmap = keypath;\n\t\t\t\t\tobservers = [];\n\t\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tcallback = map[ keypath ];\n\t\t\t\t\t\t\tobservers.push( this.observe( keypath, callback, options ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Allow `ractive.observe( callback )` - i.e. observe entire model\n\t\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\t\toptions = callback;\n\t\t\t\t\tcallback = keypath;\n\t\t\t\t\tkeypath = '';\n\t\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t\t}\n\t\t\t\tkeypaths = keypath.split( ' ' );\n\t\t\t\t// Single keypath\n\t\t\t\tif ( keypaths.length === 1 ) {\n\t\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t\t}\n\t\t\t\t// Multiple space-separated keypaths\n\t\t\t\tobservers = [];\n\t\t\t\ti = keypaths.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tkeypath = keypaths[ i ];\n\t\t\t\t\tif ( keypath ) {\n\t\t\t\t\t\tobservers.push( getObserverFacade( this, keypath, callback, options ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}( isObject, Ractive$observe_getObserverFacade );\n\t\n\t\t/* Ractive/prototype/shared/trim.js */\n\t\tvar Ractive$shared_trim = function( str ) {\n\t\t\treturn str.trim();\n\t\t};\n\t\n\t\t/* Ractive/prototype/shared/notEmptyString.js */\n\t\tvar Ractive$shared_notEmptyString = function( str ) {\n\t\t\treturn str !== '';\n\t\t};\n\t\n\t\t/* Ractive/prototype/off.js */\n\t\tvar Ractive$off = function( trim, notEmptyString ) {\n\t\n\t\t\treturn function Ractive$off( eventName, callback ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar eventNames;\n\t\t\t\t// if no arguments specified, remove all callbacks\n\t\t\t\tif ( !eventName ) {\n\t\t\t\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t\t\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t\t\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t\t\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\t\t\t\tfor ( eventName in this._subs ) {\n\t\t\t\t\t\tdelete this._subs[ eventName ];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle multiple space-separated event names\n\t\t\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t\t\tvar subscribers, index;\n\t\t\t\t\t\t// If we have subscribers for this event...\n\t\t\t\t\t\tif ( subscribers = this$0._subs[ eventName ] ) {\n\t\t\t\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tindex = subscribers.indexOf( callback );\n\t\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis$0._subs[ eventName ] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\t\n\t\t/* Ractive/prototype/on.js */\n\t\tvar Ractive$on = function( trim, notEmptyString ) {\n\t\n\t\t\treturn function Ractive$on( eventName, callback ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar self = this,\n\t\t\t\t\tlisteners, n, eventNames;\n\t\t\t\t// allow mutliple listeners to be bound in one go\n\t\t\t\tif ( typeof eventName === 'object' ) {\n\t\t\t\t\tlisteners = [];\n\t\t\t\t\tfor ( n in eventName ) {\n\t\t\t\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\t\tvar listener;\n\t\t\t\t\t\t\twhile ( listener = listeners.pop() ) {\n\t\t\t\t\t\t\t\tlistener.cancel();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Handle multiple space-separated event names\n\t\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t\t( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );\n\t\t\t\t} );\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\t\n\t\t/* shared/getNewIndices.js */\n\t\tvar getNewIndices = function() {\n\t\n\t\t\tvar __export;\n\t\t\t// This function takes an array, the name of a mutator method, and the\n\t\t\t// arguments to call that mutator method with, and returns an array that\n\t\t\t// maps the old indices to their new indices.\n\t\t\t// So if you had something like this...\n\t\t\t//\n\t\t\t//     array = [ 'a', 'b', 'c', 'd' ];\n\t\t\t//     array.push( 'e' );\n\t\t\t//\n\t\t\t// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t\t\t// have changed. If you then did this...\n\t\t\t//\n\t\t\t//     array.unshift( 'z' );\n\t\t\t//\n\t\t\t// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t\t\t// one higher to make room for the 'z'. If you removed an item, the new index\n\t\t\t// would be -1...\n\t\t\t//\n\t\t\t//     array.splice( 2, 2 );\n\t\t\t//\n\t\t\t// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t\t\t//\n\t\t\t// This information is used to enable fast, non-destructive shuffling of list\n\t\t\t// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\t\t\t__export = function getNewIndices( array, methodName, args ) {\n\t\t\t\tvar spliceArguments, len, newIndices = [],\n\t\t\t\t\tremoveStart, removeEnd, balance, i;\n\t\t\t\tspliceArguments = getSpliceEquivalent( array, methodName, args );\n\t\t\t\tif ( !spliceArguments ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlen = array.length;\n\t\t\t\tbalance = spliceArguments.length - 2 - spliceArguments[ 1 ];\n\t\t\t\tremoveStart = Math.min( len, spliceArguments[ 0 ] );\n\t\t\t\tremoveEnd = removeStart + spliceArguments[ 1 ];\n\t\t\t\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\t\t\t\tnewIndices.push( i );\n\t\t\t\t}\n\t\t\t\tfor ( ; i < removeEnd; i += 1 ) {\n\t\t\t\t\tnewIndices.push( -1 );\n\t\t\t\t}\n\t\t\t\tfor ( ; i < len; i += 1 ) {\n\t\t\t\t\tnewIndices.push( i + balance );\n\t\t\t\t}\n\t\t\t\treturn newIndices;\n\t\t\t};\n\t\t\t// The pop, push, shift an unshift methods can all be represented\n\t\t\t// as an equivalent splice\n\t\t\tfunction getSpliceEquivalent( array, methodName, args ) {\n\t\t\t\tswitch ( methodName ) {\n\t\t\t\t\tcase 'splice':\n\t\t\t\t\t\tif ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {\n\t\t\t\t\t\t\targs[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( args.length < 2 ) {\n\t\t\t\t\t\t\targs.push( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ensure we only remove elements that exist\n\t\t\t\t\t\targs[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );\n\t\t\t\t\t\treturn args;\n\t\t\t\t\tcase 'sort':\n\t\t\t\t\tcase 'reverse':\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase 'pop':\n\t\t\t\t\t\tif ( array.length ) {\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tarray.length - 1,\n\t\t\t\t\t\t\t\t1\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase 'push':\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tarray.length,\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t].concat( args );\n\t\t\t\t\tcase 'shift':\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t];\n\t\t\t\t\tcase 'unshift':\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t].concat( args );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* Ractive/prototype/shared/makeArrayMethod.js */\n\t\tvar Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {\n\t\n\t\t\tvar arrayProto = Array.prototype;\n\t\t\treturn function( methodName ) {\n\t\t\t\treturn function( keypath ) {\n\t\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\t\tvar args = SLICE$0.call( arguments, 1 );\n\t\t\t\t\tvar array, newIndices = [],\n\t\t\t\t\t\tlen, promise, result;\n\t\t\t\t\tarray = this.get( keypath );\n\t\t\t\t\tlen = array.length;\n\t\t\t\t\tif ( !isArray( array ) ) {\n\t\t\t\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath + '\\'), but \\'' + keypath + '\\' does not refer to an array' );\n\t\t\t\t\t}\n\t\t\t\t\tnewIndices = getNewIndices( array, methodName, args );\n\t\t\t\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\t\t\t\tpromise = runloop.start( this, true ).then( function() {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( !!newIndices ) {\n\t\t\t\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.viewmodel.mark( keypath );\n\t\t\t\t\t}\n\t\t\t\t\trunloop.end();\n\t\t\t\t\treturn promise;\n\t\t\t\t};\n\t\t\t};\n\t\t}( isArray, runloop, getNewIndices );\n\t\n\t\t/* Ractive/prototype/pop.js */\n\t\tvar Ractive$pop = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'pop' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/push.js */\n\t\tvar Ractive$push = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'push' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* global/css.js */\n\t\tvar global_css = function( circular, isClient, removeFromArray ) {\n\t\n\t\t\tvar css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\\n',\n\t\t\t\tcomponentsInPage = {},\n\t\t\t\tstyles = [];\n\t\t\tif ( !isClient ) {\n\t\t\t\tcss = null;\n\t\t\t} else {\n\t\t\t\tcircular.push( function() {\n\t\t\t\t\trunloop = circular.runloop;\n\t\t\t\t} );\n\t\t\t\tstyleElement = document.createElement( 'style' );\n\t\t\t\tstyleElement.type = 'text/css';\n\t\t\t\thead = document.getElementsByTagName( 'head' )[ 0 ];\n\t\t\t\tinDom = false;\n\t\t\t\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t\t\t\t// use styleSheet.cssText instead\n\t\t\t\tstyleSheet = styleElement.styleSheet;\n\t\t\t\tupdate = function() {\n\t\t\t\t\tvar css;\n\t\t\t\t\tif ( styles.length ) {\n\t\t\t\t\t\tcss = prefix + styles.join( ' ' );\n\t\t\t\t\t\tif ( styleSheet ) {\n\t\t\t\t\t\t\tstyleSheet.cssText = css;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyleElement.innerHTML = css;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !inDom ) {\n\t\t\t\t\t\t\thead.appendChild( styleElement );\n\t\t\t\t\t\t\tinDom = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( inDom ) {\n\t\t\t\t\t\thead.removeChild( styleElement );\n\t\t\t\t\t\tinDom = false;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcss = {\n\t\t\t\t\tadd: function( Component ) {\n\t\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\t\t// we create this counter so that we can in/decrement it as\n\t\t\t\t\t\t\t// instances are added and removed. When all components are\n\t\t\t\t\t\t\t// removed, the style is too\n\t\t\t\t\t\t\tcomponentsInPage[ Component._guid ] = 0;\n\t\t\t\t\t\t\tstyles.push( Component.css );\n\t\t\t\t\t\t\tupdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomponentsInPage[ Component._guid ] += 1;\n\t\t\t\t\t},\n\t\t\t\t\tremove: function( Component ) {\n\t\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomponentsInPage[ Component._guid ] -= 1;\n\t\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\t\tremoveFromArray( styles, Component.css );\n\t\t\t\t\t\t\trunloop.scheduleTask( update );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn css;\n\t\t}( circular, isClient, removeFromArray );\n\t\n\t\t/* Ractive/prototype/render.js */\n\t\tvar Ractive$render = function( css, Hook, getElement, runloop ) {\n\t\n\t\t\tvar renderHook = new Hook( 'render' ),\n\t\t\t\tcompleteHook = new Hook( 'complete' );\n\t\t\treturn function Ractive$render( target, anchor ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar promise, instances, transitionsEnabled;\n\t\t\t\t// if `noIntro` is `true`, temporarily disable transitions\n\t\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\t\tif ( this.noIntro ) {\n\t\t\t\t\tthis.transitionsEnabled = false;\n\t\t\t\t}\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn renderHook.fire( this$0 );\n\t\t\t\t}, true );\n\t\t\t\tif ( this.fragment.rendered ) {\n\t\t\t\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t\t\t\t}\n\t\t\t\ttarget = getElement( target ) || this.el;\n\t\t\t\tanchor = getElement( anchor ) || this.anchor;\n\t\t\t\tthis.el = target;\n\t\t\t\tthis.anchor = anchor;\n\t\t\t\t// Add CSS, if applicable\n\t\t\t\tif ( this.constructor.css ) {\n\t\t\t\t\tcss.add( this.constructor );\n\t\t\t\t}\n\t\t\t\tif ( target ) {\n\t\t\t\t\tif ( !( instances = target.__ractive_instances__ ) ) {\n\t\t\t\t\t\ttarget.__ractive_instances__ = [ this ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstances.push( this );\n\t\t\t\t\t}\n\t\t\t\t\tif ( anchor ) {\n\t\t\t\t\t\ttarget.insertBefore( this.fragment.render(), anchor );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.appendChild( this.fragment.render() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t\t\t// It is now more problematic to know if the complete hook\n\t\t\t\t// would fire. Method checking is straight-forward, but would\n\t\t\t\t// also require preflighting event subscriptions. Which seems\n\t\t\t\t// like more work then just letting the promise happen.\n\t\t\t\t// But perhaps I'm wrong about that...\n\t\t\t\tpromise.then( function() {\n\t\t\t\t\treturn completeHook.fire( this$0 );\n\t\t\t\t} );\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );\n\t\n\t\t/* virtualdom/Fragment/prototype/bubble.js */\n\t\tvar virtualdom_Fragment$bubble = function Fragment$bubble() {\n\t\t\tthis.dirtyValue = this.dirtyArgs = true;\n\t\t\tif ( this.bound && typeof this.owner.bubble === 'function' ) {\n\t\t\t\tthis.owner.bubble();\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/detach.js */\n\t\tvar virtualdom_Fragment$detach = function Fragment$detach() {\n\t\t\tvar docFrag;\n\t\t\tif ( this.items.length === 1 ) {\n\t\t\t\treturn this.items[ 0 ].detach();\n\t\t\t}\n\t\t\tdocFrag = document.createDocumentFragment();\n\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\tvar node = item.detach();\n\t\t\t\t// TODO The if {...} wasn't previously required - it is now, because we're\n\t\t\t\t// forcibly detaching everything to reorder sections after an update. That's\n\t\t\t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n\t\t\t\t// - as soon as it's replaced with something more elegant, this should\n\t\t\t\t// revert to `docFrag.appendChild( item.detach() )`\n\t\t\t\tif ( node ) {\n\t\t\t\t\tdocFrag.appendChild( node );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn docFrag;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/find.js */\n\t\tvar virtualdom_Fragment$find = function Fragment$find( selector ) {\n\t\t\tvar i, len, item, queryResult;\n\t\t\tif ( this.items ) {\n\t\t\t\tlen = this.items.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.find && ( queryResult = item.find( selector ) ) ) {\n\t\t\t\t\t\treturn queryResult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/findAll.js */\n\t\tvar virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {\n\t\t\tvar i, len, item;\n\t\t\tif ( this.items ) {\n\t\t\t\tlen = this.items.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.findAll ) {\n\t\t\t\t\t\titem.findAll( selector, query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn query;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/findAllComponents.js */\n\t\tvar virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {\n\t\t\tvar i, len, item;\n\t\t\tif ( this.items ) {\n\t\t\t\tlen = this.items.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.findAllComponents ) {\n\t\t\t\t\t\titem.findAllComponents( selector, query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn query;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/findComponent.js */\n\t\tvar virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {\n\t\t\tvar len, i, item, queryResult;\n\t\t\tif ( this.items ) {\n\t\t\t\tlen = this.items.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {\n\t\t\t\t\t\treturn queryResult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/findNextNode.js */\n\t\tvar virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {\n\t\t\tvar index = item.index,\n\t\t\t\tnode;\n\t\t\tif ( this.items[ index + 1 ] ) {\n\t\t\t\tnode = this.items[ index + 1 ].firstNode();\n\t\t\t} else if ( this.owner === this.root ) {\n\t\t\t\tif ( !this.owner.component ) {\n\t\t\t\t\t// TODO but something else could have been appended to\n\t\t\t\t\t// this.root.el, no?\n\t\t\t\t\tnode = null;\n\t\t\t\t} else {\n\t\t\t\t\tnode = this.owner.component.findNextNode();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = this.owner.findNextNode( this );\n\t\t\t}\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/firstNode.js */\n\t\tvar virtualdom_Fragment$firstNode = function Fragment$firstNode() {\n\t\t\tif ( this.items && this.items[ 0 ] ) {\n\t\t\t\treturn this.items[ 0 ].firstNode();\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/getNode.js */\n\t\tvar virtualdom_Fragment$getNode = function Fragment$getNode() {\n\t\t\tvar fragment = this;\n\t\t\tdo {\n\t\t\t\tif ( fragment.pElement ) {\n\t\t\t\t\treturn fragment.pElement.node;\n\t\t\t\t}\n\t\t\t} while ( fragment = fragment.parent );\n\t\t\treturn this.root.detached || this.root.el;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/getValue.js */\n\t\tvar virtualdom_Fragment$getValue = function( parseJSON ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar empty = {};\n\t\t\t__export = function Fragment$getValue() {\n\t\t\t\tvar options = arguments[ 0 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = empty;\n\t\t\t\tvar asArgs, values, source, parsed, cachedResult, dirtyFlag, result;\n\t\t\t\tasArgs = options.args;\n\t\t\t\tcachedResult = asArgs ? 'argsList' : 'value';\n\t\t\t\tdirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';\n\t\t\t\tif ( this[ dirtyFlag ] ) {\n\t\t\t\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\t\t\t\tparsed = parseJSON( asArgs ? '[' + source + ']' : source, values );\n\t\t\t\t\tif ( !parsed ) {\n\t\t\t\t\t\tresult = asArgs ? [ this.toString() ] : this.toString();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = parsed.value;\n\t\t\t\t\t}\n\t\t\t\t\tthis[ cachedResult ] = result;\n\t\t\t\t\tthis[ dirtyFlag ] = false;\n\t\t\t\t}\n\t\t\t\treturn this[ cachedResult ];\n\t\t\t};\n\t\n\t\t\tfunction processItems( items, values, guid, counter ) {\n\t\t\t\tcounter = counter || 0;\n\t\t\t\treturn items.map( function( item ) {\n\t\t\t\t\tvar placeholderId, wrapped, value;\n\t\t\t\t\tif ( item.text ) {\n\t\t\t\t\t\treturn item.text;\n\t\t\t\t\t}\n\t\t\t\t\tif ( item.fragments ) {\n\t\t\t\t\t\treturn item.fragments.map( function( fragment ) {\n\t\t\t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t\t\t\t} ).join( '' );\n\t\t\t\t\t}\n\t\t\t\t\tplaceholderId = guid + '-' + counter++;\n\t\t\t\t\tif ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {\n\t\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = item.getValue();\n\t\t\t\t\t}\n\t\t\t\t\tvalues[ placeholderId ] = value;\n\t\t\t\t\treturn '${' + placeholderId + '}';\n\t\t\t\t} ).join( '' );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( parseJSON );\n\t\n\t\t/* utils/escapeHtml.js */\n\t\tvar escapeHtml = function() {\n\t\n\t\t\tvar lessThan = /</g;\n\t\t\tvar greaterThan = />/g;\n\t\t\tvar amp = /&/g;\n\t\t\treturn function escapeHtml( str ) {\n\t\t\t\treturn str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );\n\t\t\t};\n\t\t}();\n\t\n\t\t/* utils/detachNode.js */\n\t\tvar detachNode = function detachNode( node ) {\n\t\t\tif ( node && node.parentNode ) {\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/* virtualdom/items/shared/detach.js */\n\t\tvar detach = function( detachNode ) {\n\t\n\t\t\treturn function() {\n\t\t\t\treturn detachNode( this.node );\n\t\t\t};\n\t\t}( detachNode );\n\t\n\t\t/* virtualdom/items/Text.js */\n\t\tvar Text = function( types, escapeHtml, detach ) {\n\t\n\t\t\tvar Text = function( options ) {\n\t\t\t\tthis.type = types.TEXT;\n\t\t\t\tthis.text = options.template;\n\t\t\t};\n\t\t\tText.prototype = {\n\t\t\t\tdetach: detach,\n\t\t\t\tfirstNode: function() {\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tif ( !this.node ) {\n\t\t\t\t\t\tthis.node = document.createTextNode( this.text );\n\t\t\t\t\t}\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\ttoString: function( escape ) {\n\t\t\t\t\treturn escape ? escapeHtml( this.text ) : this.text;\n\t\t\t\t},\n\t\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\t\treturn this.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Text;\n\t\t}( types, escapeHtml, detach );\n\t\n\t\t/* virtualdom/items/shared/unbind.js */\n\t\tvar unbind = function unbind() {\n\t\t\tif ( this.registered ) {\n\t\t\t\t// this was registered as a dependant\n\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t}\n\t\t\tif ( this.resolver ) {\n\t\t\t\tthis.resolver.unbind();\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/shared/Mustache/getValue.js */\n\t\tvar getValue = function Mustache$getValue() {\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\t/* virtualdom/items/shared/utils/startsWithKeypath.js */\n\t\tvar startsWithKeypath = function startsWithKeypath( target, keypath ) {\n\t\t\treturn target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';\n\t\t};\n\t\n\t\t/* virtualdom/items/shared/utils/getNewKeypath.js */\n\t\tvar getNewKeypath = function( startsWithKeypath ) {\n\t\n\t\t\treturn function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {\n\t\t\t\t// exact match\n\t\t\t\tif ( targetKeypath === oldKeypath ) {\n\t\t\t\t\treturn newKeypath !== undefined ? newKeypath : null;\n\t\t\t\t}\n\t\t\t\t// partial match based on leading keypath segments\n\t\t\t\tif ( startsWithKeypath( targetKeypath, oldKeypath ) ) {\n\t\t\t\t\treturn newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );\n\t\t\t\t}\n\t\t\t};\n\t\t}( startsWithKeypath );\n\t\n\t\t/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */\n\t\tvar ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {\n\t\n\t\t\tvar ReferenceResolver = function( owner, ref, callback ) {\n\t\t\t\tvar keypath;\n\t\t\t\tthis.ref = ref;\n\t\t\t\tthis.resolved = false;\n\t\t\t\tthis.root = owner.root;\n\t\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\t\tthis.callback = callback;\n\t\t\t\tkeypath = resolveRef( owner.root, ref, owner.parentFragment );\n\t\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t\tthis.resolve( keypath );\n\t\t\t\t} else {\n\t\t\t\t\trunloop.addUnresolved( this );\n\t\t\t\t}\n\t\t\t};\n\t\t\tReferenceResolver.prototype = {\n\t\t\t\tresolve: function( keypath ) {\n\t\t\t\t\tthis.resolved = true;\n\t\t\t\t\tthis.keypath = keypath;\n\t\t\t\t\tthis.callback( keypath );\n\t\t\t\t},\n\t\t\t\tforceResolution: function() {\n\t\t\t\t\tthis.resolve( this.ref );\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tvar keypath;\n\t\t\t\t\tif ( this.keypath !== undefined ) {\n\t\t\t\t\t\tkeypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );\n\t\t\t\t\t\t// was a new keypath created?\n\t\t\t\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t\t\t\t// resolve it\n\t\t\t\t\t\t\tthis.resolve( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tif ( !this.resolved ) {\n\t\t\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn ReferenceResolver;\n\t\t}( runloop, resolveRef, getNewKeypath );\n\t\n\t\t/* virtualdom/items/shared/Resolvers/SpecialResolver.js */\n\t\tvar SpecialResolver = function() {\n\t\n\t\t\tvar SpecialResolver = function( owner, ref, callback ) {\n\t\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\t\tthis.ref = ref;\n\t\t\t\tthis.callback = callback;\n\t\t\t\tthis.rebind();\n\t\t\t};\n\t\t\tSpecialResolver.prototype = {\n\t\t\t\trebind: function() {\n\t\t\t\t\tvar ref = this.ref,\n\t\t\t\t\t\tfragment = this.parentFragment;\n\t\t\t\t\tif ( ref === '@keypath' ) {\n\t\t\t\t\t\twhile ( fragment ) {\n\t\t\t\t\t\t\tif ( !!fragment.context ) {\n\t\t\t\t\t\t\t\treturn this.callback( '@' + fragment.context );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( ref === '@index' || ref === '@key' ) {\n\t\t\t\t\t\twhile ( fragment ) {\n\t\t\t\t\t\t\tif ( fragment.index !== undefined ) {\n\t\t\t\t\t\t\t\treturn this.callback( '@' + fragment.index );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error( 'Unknown special reference \"' + ref + '\" - valid references are @index, @key and @keypath' );\n\t\t\t\t},\n\t\t\t\tunbind: function() {}\n\t\t\t};\n\t\t\treturn SpecialResolver;\n\t\t}();\n\t\n\t\t/* virtualdom/items/shared/Resolvers/IndexResolver.js */\n\t\tvar IndexResolver = function() {\n\t\n\t\t\tvar IndexResolver = function( owner, ref, callback ) {\n\t\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\t\tthis.ref = ref;\n\t\t\t\tthis.callback = callback;\n\t\t\t\tthis.rebind();\n\t\t\t};\n\t\t\tIndexResolver.prototype = {\n\t\t\t\trebind: function() {\n\t\t\t\t\tvar ref = this.ref,\n\t\t\t\t\t\tindexRefs = this.parentFragment.indexRefs,\n\t\t\t\t\t\tindex = indexRefs[ ref ];\n\t\t\t\t\tif ( index !== undefined ) {\n\t\t\t\t\t\tthis.callback( '@' + index );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunbind: function() {}\n\t\t\t};\n\t\t\treturn IndexResolver;\n\t\t}();\n\t\n\t\t/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */\n\t\tvar createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {\n\t\n\t\t\treturn function createReferenceResolver( owner, ref, callback ) {\n\t\t\t\tvar indexRefs, index;\n\t\t\t\tif ( ref.charAt( 0 ) === '@' ) {\n\t\t\t\t\treturn new SpecialResolver( owner, ref, callback );\n\t\t\t\t}\n\t\t\t\tindexRefs = owner.parentFragment.indexRefs;\n\t\t\t\tif ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\treturn new IndexResolver( owner, ref, callback );\n\t\t\t\t}\n\t\t\t\treturn new ReferenceResolver( owner, ref, callback );\n\t\t\t};\n\t\t}( ReferenceResolver, SpecialResolver, IndexResolver );\n\t\n\t\t/* shared/getFunctionFromString.js */\n\t\tvar getFunctionFromString = function() {\n\t\n\t\t\tvar cache = {};\n\t\t\treturn function getFunctionFromString( str, i ) {\n\t\t\t\tvar fn, args;\n\t\t\t\tif ( cache[ str ] ) {\n\t\t\t\t\treturn cache[ str ];\n\t\t\t\t}\n\t\t\t\targs = [];\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\targs[ i ] = '_' + i;\n\t\t\t\t}\n\t\t\t\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\t\t\t\tcache[ str ] = fn;\n\t\t\t\treturn fn;\n\t\t\t};\n\t\t}();\n\t\n\t\t/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */\n\t\tvar ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar ExpressionResolver, bind = Function.prototype.bind;\n\t\t\tExpressionResolver = function( owner, parentFragment, expression, callback ) {\n\t\t\t\tvar resolver = this,\n\t\t\t\t\tractive, indexRefs;\n\t\t\t\tractive = owner.root;\n\t\t\t\tresolver.root = ractive;\n\t\t\t\tresolver.parentFragment = parentFragment;\n\t\t\t\tresolver.callback = callback;\n\t\t\t\tresolver.owner = owner;\n\t\t\t\tresolver.str = expression.s;\n\t\t\t\tresolver.keypaths = [];\n\t\t\t\tindexRefs = parentFragment.indexRefs;\n\t\t\t\t// Create resolvers for each reference\n\t\t\t\tresolver.pending = expression.r.length;\n\t\t\t\tresolver.refResolvers = expression.r.map( function( ref, i ) {\n\t\t\t\t\treturn createReferenceResolver( resolver, ref, function( keypath ) {\n\t\t\t\t\t\tresolver.resolve( i, keypath );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tresolver.ready = true;\n\t\t\t\tresolver.bubble();\n\t\t\t};\n\t\t\tExpressionResolver.prototype = {\n\t\t\t\tbubble: function() {\n\t\t\t\t\tif ( !this.ready ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.uniqueString = getUniqueString( this.str, this.keypaths );\n\t\t\t\t\tthis.keypath = getKeypath( this.uniqueString );\n\t\t\t\t\tthis.createEvaluator();\n\t\t\t\t\tthis.callback( this.keypath );\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tvar resolver;\n\t\t\t\t\twhile ( resolver = this.refResolvers.pop() ) {\n\t\t\t\t\t\tresolver.unbind();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tresolve: function( index, keypath ) {\n\t\t\t\t\tthis.keypaths[ index ] = keypath;\n\t\t\t\t\tthis.bubble();\n\t\t\t\t},\n\t\t\t\tcreateEvaluator: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar self = this,\n\t\t\t\t\t\tcomputation, valueGetters, signature, keypath, fn;\n\t\t\t\t\tcomputation = this.root.viewmodel.computations[ this.keypath ];\n\t\t\t\t\t// only if it doesn't exist yet!\n\t\t\t\t\tif ( !computation ) {\n\t\t\t\t\t\tfn = getFunctionFromString( this.str, this.refResolvers.length );\n\t\t\t\t\t\tvalueGetters = this.keypaths.map( function( keypath ) {\n\t\t\t\t\t\t\tvar value;\n\t\t\t\t\t\t\tif ( keypath === 'undefined' ) {\n\t\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 'special' keypaths encode a value\n\t\t\t\t\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\t\t\t\treturn isNumeric( value ) ? function() {\n\t\t\t\t\t\t\t\t\treturn +value;\n\t\t\t\t\t\t\t\t} : function() {\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\tvar value = this$0.root.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\t\t\t\tvalue = wrapFunction( value, self.root );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tsignature = {\n\t\t\t\t\t\t\tdeps: this.keypaths.filter( isValidDependency ),\n\t\t\t\t\t\t\tget: function() {\n\t\t\t\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcomputation = this.root.viewmodel.compute( this.keypath, signature );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.root.viewmodel.mark( this.keypath );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\t// TODO only bubble once, no matter how many references are affected by the rebind\n\t\t\t\t\tthis.refResolvers.forEach( function( r ) {\n\t\t\t\t\t\treturn r.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t\t__export = ExpressionResolver;\n\t\n\t\t\tfunction call( value ) {\n\t\t\t\treturn value.call();\n\t\t\t}\n\t\n\t\t\tfunction getUniqueString( str, keypaths ) {\n\t\t\t\t// get string that is unique to this expression\n\t\t\t\treturn str.replace( /_([0-9]+)/g, function( match, $1 ) {\n\t\t\t\t\tvar keypath, value;\n\t\t\t\t\tkeypath = keypaths[ $1 ];\n\t\t\t\t\tif ( keypath === undefined ) {\n\t\t\t\t\t\treturn 'undefined';\n\t\t\t\t\t}\n\t\t\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\t\treturn isNumeric( value ) ? value : '\"' + value + '\"';\n\t\t\t\t\t}\n\t\t\t\t\treturn keypath;\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tfunction getKeypath( uniqueString ) {\n\t\t\t\t// Sanitize by removing any periods or square brackets. Otherwise\n\t\t\t\t// we can't split the keypath into keys!\n\t\t\t\treturn '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ) + '}';\n\t\t\t}\n\t\n\t\t\tfunction isValidDependency( keypath ) {\n\t\t\t\treturn keypath !== undefined && keypath[ 0 ] !== '@';\n\t\t\t}\n\t\n\t\t\tfunction wrapFunction( fn, ractive ) {\n\t\t\t\tvar wrapped, prop, key;\n\t\t\t\tif ( fn._noWrap ) {\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\t\t\t\tprop = '__ractive_' + ractive._guid;\n\t\t\t\twrapped = fn[ prop ];\n\t\t\t\tif ( wrapped ) {\n\t\t\t\t\treturn wrapped;\n\t\t\t\t} else if ( /this/.test( fn.toString() ) ) {\n\t\t\t\t\tdefineProperty( fn, prop, {\n\t\t\t\t\t\tvalue: bind.call( fn, ractive )\n\t\t\t\t\t} );\n\t\t\t\t\t// Add properties/methods to wrapped function\n\t\t\t\t\tfor ( key in fn ) {\n\t\t\t\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn fn[ prop ];\n\t\t\t\t}\n\t\t\t\tdefineProperty( fn, '__ractive_nowrap', {\n\t\t\t\t\tvalue: fn\n\t\t\t\t} );\n\t\t\t\treturn fn.__ractive_nowrap;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );\n\t\n\t\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */\n\t\tvar MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {\n\t\n\t\t\tvar MemberResolver = function( template, resolver, parentFragment ) {\n\t\t\t\tvar member = this,\n\t\t\t\t\tkeypath;\n\t\t\t\tmember.resolver = resolver;\n\t\t\t\tmember.root = resolver.root;\n\t\t\t\tmember.parentFragment = parentFragment;\n\t\t\t\tmember.viewmodel = resolver.root.viewmodel;\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\tmember.value = template;\n\t\t\t\t} else if ( template.t === types.REFERENCE ) {\n\t\t\t\t\tmember.refResolver = createReferenceResolver( this, template.n, function( keypath ) {\n\t\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tnew ExpressionResolver( resolver, parentFragment, template, function( keypath ) {\n\t\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t\tMemberResolver.prototype = {\n\t\t\t\tresolve: function( keypath ) {\n\t\t\t\t\tif ( this.keypath ) {\n\t\t\t\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t\t\t\t}\n\t\t\t\t\tthis.keypath = keypath;\n\t\t\t\t\tthis.value = this.viewmodel.get( keypath );\n\t\t\t\t\tthis.bind();\n\t\t\t\t\tthis.resolver.bubble();\n\t\t\t\t},\n\t\t\t\tbind: function() {\n\t\t\t\t\tthis.viewmodel.register( this.keypath, this );\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tif ( this.refResolver ) {\n\t\t\t\t\t\tthis.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.resolver.bubble();\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tif ( this.keypath ) {\n\t\t\t\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.unresolved ) {\n\t\t\t\t\t\tthis.unresolved.unbind();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforceResolution: function() {\n\t\t\t\t\tif ( this.refResolver ) {\n\t\t\t\t\t\tthis.refResolver.forceResolution();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn MemberResolver;\n\t\t}( types, createReferenceResolver, ExpressionResolver );\n\t\n\t\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */\n\t\tvar ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {\n\t\n\t\t\tvar ReferenceExpressionResolver = function( mustache, template, callback ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar resolver = this,\n\t\t\t\t\tractive, ref, keypath, parentFragment;\n\t\t\t\tresolver.parentFragment = parentFragment = mustache.parentFragment;\n\t\t\t\tresolver.root = ractive = mustache.root;\n\t\t\t\tresolver.mustache = mustache;\n\t\t\t\tresolver.ref = ref = template.r;\n\t\t\t\tresolver.callback = callback;\n\t\t\t\tresolver.unresolved = [];\n\t\t\t\t// Find base keypath\n\t\t\t\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\t\t\t\tresolver.base = keypath;\n\t\t\t\t} else {\n\t\t\t\t\tresolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {\n\t\t\t\t\t\tresolver.base = keypath;\n\t\t\t\t\t\tresolver.baseResolver = null;\n\t\t\t\t\t\tresolver.bubble();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// Find values for members, or mark them as unresolved\n\t\t\t\tresolver.members = template.m.map( function( template ) {\n\t\t\t\t\treturn new MemberResolver( template, this$0, parentFragment );\n\t\t\t\t} );\n\t\t\t\tresolver.ready = true;\n\t\t\t\tresolver.bubble();\n\t\t\t};\n\t\t\tReferenceExpressionResolver.prototype = {\n\t\t\t\tgetKeypath: function() {\n\t\t\t\t\tvar values = this.members.map( getValue );\n\t\t\t\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.base + '.' + values.join( '.' );\n\t\t\t\t},\n\t\t\t\tbubble: function() {\n\t\t\t\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.callback( this.getKeypath() );\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.members.forEach( unbind );\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tvar changed;\n\t\t\t\t\tthis.members.forEach( function( members ) {\n\t\t\t\t\t\tif ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tif ( changed ) {\n\t\t\t\t\t\tthis.bubble();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforceResolution: function() {\n\t\t\t\t\tif ( this.baseResolver ) {\n\t\t\t\t\t\tthis.base = this.ref;\n\t\t\t\t\t\tthis.baseResolver.unbind();\n\t\t\t\t\t\tthis.baseResolver = null;\n\t\t\t\t\t}\n\t\t\t\t\tthis.members.forEach( function( m ) {\n\t\t\t\t\t\treturn m.forceResolution();\n\t\t\t\t\t} );\n\t\t\t\t\tthis.bubble();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction getValue( member ) {\n\t\t\t\treturn member.value;\n\t\t\t}\n\t\n\t\t\tfunction isDefined( value ) {\n\t\t\t\treturn value != undefined;\n\t\t\t}\n\t\n\t\t\tfunction unbind( member ) {\n\t\t\t\tmember.unbind();\n\t\t\t}\n\t\t\treturn ReferenceExpressionResolver;\n\t\t}( resolveRef, ReferenceResolver, MemberResolver );\n\t\n\t\t/* virtualdom/items/shared/Mustache/initialise.js */\n\t\tvar initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {\n\t\n\t\t\treturn function Mustache$init( mustache, options ) {\n\t\t\t\tvar ref, parentFragment, template;\n\t\t\t\tparentFragment = options.parentFragment;\n\t\t\t\ttemplate = options.template;\n\t\t\t\tmustache.root = parentFragment.root;\n\t\t\t\tmustache.parentFragment = parentFragment;\n\t\t\t\tmustache.pElement = parentFragment.pElement;\n\t\t\t\tmustache.template = options.template;\n\t\t\t\tmustache.index = options.index || 0;\n\t\t\t\tmustache.isStatic = options.template.s;\n\t\t\t\tmustache.type = options.template.t;\n\t\t\t\tmustache.registered = false;\n\t\t\t\t// if this is a simple mustache, with a reference, we just need to resolve\n\t\t\t\t// the reference to a keypath\n\t\t\t\tif ( ref = template.r ) {\n\t\t\t\t\tmustache.resolver = new createReferenceResolver( mustache, ref, resolve );\n\t\t\t\t}\n\t\t\t\t// if it's an expression, we have a bit more work to do\n\t\t\t\tif ( options.template.x ) {\n\t\t\t\t\tmustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );\n\t\t\t\t}\n\t\t\t\tif ( options.template.rx ) {\n\t\t\t\t\tmustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );\n\t\t\t\t}\n\t\t\t\t// Special case - inverted sections\n\t\t\t\tif ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {\n\t\t\t\t\tmustache.setValue( undefined );\n\t\t\t\t}\n\t\n\t\t\t\tfunction resolve( keypath ) {\n\t\t\t\t\tmustache.resolve( keypath );\n\t\t\t\t}\n\t\n\t\t\t\tfunction resolveAndRebindChildren( newKeypath ) {\n\t\t\t\t\tvar oldKeypath = mustache.keypath;\n\t\t\t\t\tif ( newKeypath !== oldKeypath ) {\n\t\t\t\t\t\tmustache.resolve( newKeypath );\n\t\t\t\t\t\tif ( oldKeypath !== undefined ) {\n\t\t\t\t\t\t\tmustache.fragments && mustache.fragments.forEach( function( f ) {\n\t\t\t\t\t\t\t\tf.rebind( null, null, oldKeypath, newKeypath );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );\n\t\n\t\t/* virtualdom/items/shared/Mustache/resolve.js */\n\t\tvar resolve = function( isNumeric ) {\n\t\n\t\t\treturn function Mustache$resolve( keypath ) {\n\t\t\t\tvar wasResolved, value, twowayBinding;\n\t\t\t\t// 'Special' keypaths, e.g. @foo or @7, encode a value\n\t\t\t\tif ( keypath && keypath[ 0 ] === '@' ) {\n\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\tif ( isNumeric( value ) ) {\n\t\t\t\t\t\tvalue = +value;\n\t\t\t\t\t}\n\t\t\t\t\tthis.keypath = keypath;\n\t\t\t\t\tthis.setValue( value );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// If we resolved previously, we need to unregister\n\t\t\t\tif ( this.registered ) {\n\t\t\t\t\t// undefined or null\n\t\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t\t\tthis.registered = false;\n\t\t\t\t\twasResolved = true;\n\t\t\t\t}\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\t// If the new keypath exists, we need to register\n\t\t\t\t// with the viewmodel\n\t\t\t\tif ( keypath != undefined ) {\n\t\t\t\t\t// undefined or null\n\t\t\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\t\t\tthis.root.viewmodel.register( keypath, this );\n\t\t\t\t\tthis.registered = true;\n\t\t\t\t}\n\t\t\t\t// Either way we need to queue up a render (`value`\n\t\t\t\t// will be `undefined` if there's no keypath)\n\t\t\t\tthis.setValue( value );\n\t\t\t\t// Two-way bindings need to point to their new target keypath\n\t\t\t\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\t\t\t\ttwowayBinding.rebound();\n\t\t\t\t}\n\t\t\t};\n\t\t}( isNumeric );\n\t\n\t\t/* virtualdom/items/shared/Mustache/rebind.js */\n\t\tvar rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t// Children first\n\t\t\tif ( this.fragments ) {\n\t\t\t\tthis.fragments.forEach( function( f ) {\n\t\t\t\t\treturn f.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Expression mustache?\n\t\t\tif ( this.resolver ) {\n\t\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/shared/Mustache/_Mustache.js */\n\t\tvar Mustache = function( getValue, init, resolve, rebind ) {\n\t\n\t\t\treturn {\n\t\t\t\tgetValue: getValue,\n\t\t\t\tinit: init,\n\t\t\t\tresolve: resolve,\n\t\t\t\trebind: rebind\n\t\t\t};\n\t\t}( getValue, initialise, resolve, rebind );\n\t\n\t\t/* virtualdom/items/Interpolator.js */\n\t\tvar Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {\n\t\n\t\t\tvar Interpolator = function( options ) {\n\t\t\t\tthis.type = types.INTERPOLATOR;\n\t\t\t\tMustache.init( this, options );\n\t\t\t};\n\t\t\tInterpolator.prototype = {\n\t\t\t\tupdate: function() {\n\t\t\t\t\tthis.node.data = this.value == undefined ? '' : this.value;\n\t\t\t\t},\n\t\t\t\tresolve: Mustache.resolve,\n\t\t\t\trebind: Mustache.rebind,\n\t\t\t\tdetach: detach,\n\t\t\t\tunbind: unbind,\n\t\t\t\trender: function() {\n\t\t\t\t\tif ( !this.node ) {\n\t\t\t\t\t\tthis.node = document.createTextNode( this.value != undefined ? this.value : '' );\n\t\t\t\t\t}\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\t\tdetachNode( this.node );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetValue: Mustache.getValue,\n\t\t\t\t// TEMP\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\tvar wrapper;\n\t\t\t\t\t// TODO is there a better way to approach this?\n\t\t\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t\t\tif ( this.node ) {\n\t\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfirstNode: function() {\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\ttoString: function( escape ) {\n\t\t\t\t\tvar string = this.value != undefined ? '' + this.value : '';\n\t\t\t\t\treturn escape ? escapeHtml( string ) : string;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Interpolator;\n\t\t}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );\n\t\n\t\t/* virtualdom/items/Section/prototype/bubble.js */\n\t\tvar virtualdom_items_Section$bubble = function Section$bubble() {\n\t\t\tthis.parentFragment.bubble();\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/detach.js */\n\t\tvar virtualdom_items_Section$detach = function Section$detach() {\n\t\t\tvar docFrag;\n\t\t\tif ( this.fragments.length === 1 ) {\n\t\t\t\treturn this.fragments[ 0 ].detach();\n\t\t\t}\n\t\t\tdocFrag = document.createDocumentFragment();\n\t\t\tthis.fragments.forEach( function( item ) {\n\t\t\t\tdocFrag.appendChild( item.detach() );\n\t\t\t} );\n\t\t\treturn docFrag;\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/find.js */\n\t\tvar virtualdom_items_Section$find = function Section$find( selector ) {\n\t\t\tvar i, len, queryResult;\n\t\t\tlen = this.fragments.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( queryResult = this.fragments[ i ].find( selector ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/findAll.js */\n\t\tvar virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {\n\t\t\tvar i, len;\n\t\t\tlen = this.fragments.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis.fragments[ i ].findAll( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/findAllComponents.js */\n\t\tvar virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {\n\t\t\tvar i, len;\n\t\t\tlen = this.fragments.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis.fragments[ i ].findAllComponents( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/findComponent.js */\n\t\tvar virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {\n\t\t\tvar i, len, queryResult;\n\t\t\tlen = this.fragments.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( queryResult = this.fragments[ i ].findComponent( selector ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/findNextNode.js */\n\t\tvar virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {\n\t\t\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\t\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t\t\t}\n\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/firstNode.js */\n\t\tvar virtualdom_items_Section$firstNode = function Section$firstNode() {\n\t\t\tvar len, i, node;\n\t\t\tif ( len = this.fragments.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tif ( node = this.fragments[ i ].firstNode() ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/shuffle.js */\n\t\tvar virtualdom_items_Section$shuffle = function( types, runloop, circular ) {\n\t\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\treturn function Section$shuffle( newIndices ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar section = this,\n\t\t\t\t\tparentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\t\t\t\t// short circuit any double-updates, and ensure that this isn't applied to\n\t\t\t\t// non-list sections\n\t\t\t\tif ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.shuffling = true;\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.shuffling = false;\n\t\t\t\t} );\n\t\t\t\tparentFragment = this.parentFragment;\n\t\t\t\treboundFragments = [];\n\t\t\t\t// first, rebind existing fragments\n\t\t\t\tnewIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {\n\t\t\t\t\tvar fragment, by, oldKeypath, newKeypath;\n\t\t\t\t\tif ( newIndex === oldIndex ) {\n\t\t\t\t\t\treboundFragments[ newIndex ] = section.fragments[ oldIndex ];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfragment = section.fragments[ oldIndex ];\n\t\t\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t\t\tfirstChange = oldIndex;\n\t\t\t\t\t}\n\t\t\t\t\t// does this fragment need to be torn down?\n\t\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\t\tfragment.unbind();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, it needs to be rebound to a new index\n\t\t\t\t\tby = newIndex - oldIndex;\n\t\t\t\t\toldKeypath = section.keypath + '.' + oldIndex;\n\t\t\t\t\tnewKeypath = section.keypath + '.' + newIndex;\n\t\t\t\t\tfragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\tfragment.index = newIndex;\n\t\t\t\t\treboundFragments[ newIndex ] = fragment;\n\t\t\t\t} );\n\t\t\t\tnewLength = this.root.get( this.keypath ).length;\n\t\t\t\t// If nothing changed with the existing fragments, then we start adding\n\t\t\t\t// new fragments at the end...\n\t\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t\t// ...unless there are no new fragments to add\n\t\t\t\t\tif ( this.length === newLength ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfirstChange = this.length;\n\t\t\t\t}\n\t\t\t\tthis.length = this.fragments.length = newLength;\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t\t// Prepare new fragment options\n\t\t\t\tfragmentOptions = {\n\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\towner: this\n\t\t\t\t};\n\t\t\t\tif ( this.template.i ) {\n\t\t\t\t\tfragmentOptions.indexRef = this.template.i;\n\t\t\t\t}\n\t\t\t\t// Add as many new fragments as we need to, or add back existing\n\t\t\t\t// (detached) fragments\n\t\t\t\tfor ( i = firstChange; i < newLength; i += 1 ) {\n\t\t\t\t\tfragment = reboundFragments[ i ];\n\t\t\t\t\tif ( !fragment ) {\n\t\t\t\t\t\tthis.fragmentsToCreate.push( i );\n\t\t\t\t\t}\n\t\t\t\t\tthis.fragments[ i ] = fragment;\n\t\t\t\t}\n\t\t\t};\n\t\t}( types, runloop, circular );\n\t\n\t\t/* virtualdom/items/Section/prototype/render.js */\n\t\tvar virtualdom_items_Section$render = function Section$render() {\n\t\t\tvar docFrag;\n\t\t\tdocFrag = this.docFrag = document.createDocumentFragment();\n\t\t\tthis.update();\n\t\t\tthis.rendered = true;\n\t\t\treturn docFrag;\n\t\t};\n\t\n\t\t/* utils/isArrayLike.js */\n\t\tvar isArrayLike = function() {\n\t\n\t\t\tvar pattern = /^\\[object (?:Array|FileList)\\]$/,\n\t\t\t\ttoString = Object.prototype.toString;\n\t\t\treturn function isArrayLike( obj ) {\n\t\t\t\treturn pattern.test( toString.call( obj ) );\n\t\t\t};\n\t\t}();\n\t\n\t\t/* virtualdom/items/Section/prototype/setValue.js */\n\t\tvar virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\t__export = function Section$setValue( value ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar wrapper, fragmentOptions;\n\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t\t\t\t// expression refers to a function that mutates the array that this\n\t\t\t\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t\t\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.updating = true;\n\t\t\t\t// with sections, we need to get the fake value if we have a wrapped object\n\t\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t\t// If any fragments are awaiting creation after a splice,\n\t\t\t\t// this is the place to do it\n\t\t\t\tif ( this.fragmentsToCreate.length ) {\n\t\t\t\t\tfragmentOptions = {\n\t\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\tpElement: this.pElement,\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\tindexRef: this.template.i\n\t\t\t\t\t};\n\t\t\t\t\tthis.fragmentsToCreate.forEach( function( index ) {\n\t\t\t\t\t\tvar fragment;\n\t\t\t\t\t\tfragmentOptions.context = this$0.keypath + '.' + index;\n\t\t\t\t\t\tfragmentOptions.index = index;\n\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\tthis$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );\n\t\t\t\t\t} );\n\t\t\t\t\tthis.fragmentsToCreate.length = 0;\n\t\t\t\t} else if ( reevaluateSection( this, value ) ) {\n\t\t\t\t\tthis.bubble();\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.updating = false;\n\t\t\t};\n\t\n\t\t\tfunction reevaluateSection( section, value ) {\n\t\t\t\tvar fragmentOptions = {\n\t\t\t\t\ttemplate: section.template.f,\n\t\t\t\t\troot: section.root,\n\t\t\t\t\tpElement: section.parentFragment.pElement,\n\t\t\t\t\towner: section\n\t\t\t\t};\n\t\t\t\t// If we already know the section type, great\n\t\t\t\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t\t\t\t// and avoid doing this each time?\n\t\t\t\tif ( section.subtype ) {\n\t\t\t\t\tswitch ( section.subtype ) {\n\t\t\t\t\t\tcase types.SECTION_IF:\n\t\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t\t\t\t\tcase types.SECTION_UNLESS:\n\t\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\t\t\t\t\t\tcase types.SECTION_WITH:\n\t\t\t\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t\t\t\tcase types.SECTION_IF_WITH:\n\t\t\t\t\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\t\t\t\t\t\tcase types.SECTION_EACH:\n\t\t\t\t\t\t\tif ( isObject( value ) ) {\n\t\t\t\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise we need to work out what sort of section we're dealing with\n\t\t\t\tsection.ordered = !!isArrayLike( value );\n\t\t\t\t// Ordered list section\n\t\t\t\tif ( section.ordered ) {\n\t\t\t\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t\t\t\t}\n\t\t\t\t// Unordered list, or context\n\t\t\t\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t\t\t\t// Index reference indicates section should be treated as a list\n\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, object provides context for contents\n\t\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t\t}\n\t\t\t\t// Conditional section\n\t\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t\t}\n\t\n\t\t\tfunction reevaluateListSection( section, value, fragmentOptions ) {\n\t\t\t\tvar i, length, fragment;\n\t\t\t\tlength = value.length;\n\t\t\t\tif ( length === section.length ) {\n\t\t\t\t\t// Nothing to do\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// if the array is shorter than it was previously, remove items\n\t\t\t\tif ( length < section.length ) {\n\t\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\t} else {\n\t\t\t\t\tif ( length > section.length ) {\n\t\t\t\t\t\t// add any new ones\n\t\t\t\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t\t\t\t// append list item to context stack\n\t\t\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + i;\n\t\t\t\t\t\t\tfragmentOptions.index = i;\n\t\t\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ i ] = fragment );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsection.length = length;\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\tfunction reevaluateListObjectSection( section, value, fragmentOptions ) {\n\t\t\t\tvar id, i, hasKey, fragment, changed;\n\t\t\t\thasKey = section.hasKey || ( section.hasKey = {} );\n\t\t\t\t// remove any fragments that should no longer exist\n\t\t\t\ti = section.fragments.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tfragment = section.fragments[ i ];\n\t\t\t\t\tif ( !( fragment.index in value ) ) {\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tfragment.unbind();\n\t\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\t\tsection.fragments.splice( i, 1 );\n\t\t\t\t\t\thasKey[ fragment.index ] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add any that haven't been created yet\n\t\t\t\tfor ( id in value ) {\n\t\t\t\t\tif ( !hasKey[ id ] ) {\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + id;\n\t\t\t\t\t\tfragmentOptions.index = id;\n\t\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\t\t\t\tsection.fragments.push( fragment );\n\t\t\t\t\t\thasKey[ id ] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsection.length = section.fragments.length;\n\t\t\t\treturn changed;\n\t\t\t}\n\t\n\t\t\tfunction reevaluateConditionalContextSection( section, value, fragmentOptions ) {\n\t\t\t\tif ( value ) {\n\t\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t\t} else {\n\t\t\t\t\treturn removeSectionFragments( section );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction reevaluateContextSection( section, fragmentOptions ) {\n\t\t\t\tvar fragment;\n\t\t\t\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t\t\t\t// (if it is already rendered, then any children dependent on the context stack\n\t\t\t\t// will update themselves without any prompting)\n\t\t\t\tif ( !section.length ) {\n\t\t\t\t\t// append this section to the context stack\n\t\t\t\t\tfragmentOptions.context = section.keypath;\n\t\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\t\tsection.length = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {\n\t\t\t\tvar doRender, emptyArray, emptyObject, fragment, name;\n\t\t\t\temptyArray = isArrayLike( value ) && value.length === 0;\n\t\t\t\temptyObject = false;\n\t\t\t\tif ( !isArrayLike( value ) && isObject( value ) ) {\n\t\t\t\t\temptyObject = true;\n\t\t\t\t\tfor ( name in value ) {\n\t\t\t\t\t\temptyObject = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( inverted ) {\n\t\t\t\t\tdoRender = emptyArray || emptyObject || !value;\n\t\t\t\t} else {\n\t\t\t\t\tdoRender = value && !emptyArray && !emptyObject;\n\t\t\t\t}\n\t\t\t\tif ( doRender ) {\n\t\t\t\t\tif ( !section.length ) {\n\t\t\t\t\t\t// no change to context stack\n\t\t\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\t\t\tsection.length = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( section.length > 1 ) {\n\t\t\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn removeSectionFragments( section );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction removeSectionFragments( section ) {\n\t\t\t\tif ( section.length ) {\n\t\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction unbind( fragment ) {\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\n\t\t\tfunction isRendered( fragment ) {\n\t\t\t\treturn fragment.rendered;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, isArrayLike, isObject, runloop, circular );\n\t\n\t\t/* virtualdom/items/Section/prototype/toString.js */\n\t\tvar virtualdom_items_Section$toString = function Section$toString( escape ) {\n\t\t\tvar str, i, len;\n\t\t\tstr = '';\n\t\t\ti = 0;\n\t\t\tlen = this.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tstr += this.fragments[ i ].toString( escape );\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/prototype/unbind.js */\n\t\tvar virtualdom_items_Section$unbind = function( unbind ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Section$unbind() {\n\t\t\t\tthis.fragments.forEach( unbindFragment );\n\t\t\t\tunbind.call( this );\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis.unbound = true;\n\t\t\t};\n\t\n\t\t\tfunction unbindFragment( fragment ) {\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( unbind );\n\t\n\t\t/* virtualdom/items/Section/prototype/unrender.js */\n\t\tvar virtualdom_items_Section$unrender = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Section$unrender( shouldDestroy ) {\n\t\t\t\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t\t\t};\n\t\n\t\t\tfunction unrenderAndDestroy( fragment ) {\n\t\t\t\tfragment.unrender( true );\n\t\t\t}\n\t\n\t\t\tfunction unrender( fragment ) {\n\t\t\t\tfragment.unrender( false );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* virtualdom/items/Section/prototype/update.js */\n\t\tvar virtualdom_items_Section$update = function Section$update() {\n\t\t\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\t\t\t// `this.renderedFragments` is in the order of the previous render.\n\t\t\t// If fragments have shuffled about, this allows us to quickly\n\t\t\t// reinsert them in the correct place\n\t\t\trenderedFragments = this.renderedFragments;\n\t\t\t// Remove fragments that have been marked for destruction\n\t\t\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\t\t\tfragment.unrender( true );\n\t\t\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t\t\t}\n\t\t\t// Render new fragments (but don't insert them yet)\n\t\t\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\t\t\tfragment.render();\n\t\t\t}\n\t\t\tif ( this.rendered ) {\n\t\t\t\ttarget = this.parentFragment.getNode();\n\t\t\t}\n\t\t\tlen = this.fragments.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tfragment = this.fragments[ i ];\n\t\t\t\trenderIndex = renderedFragments.indexOf( fragment, i );\n\t\t\t\t// search from current index - it's guaranteed to be the same or higher\n\t\t\t\tif ( renderIndex === i ) {\n\t\t\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.docFrag.appendChild( fragment.detach() );\n\t\t\t\t// update renderedFragments\n\t\t\t\tif ( renderIndex !== -1 ) {\n\t\t\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t\t\t}\n\t\t\t\trenderedFragments.splice( i, 0, fragment );\n\t\t\t}\n\t\t\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t}\n\t\t\t// Save the rendering order for next time\n\t\t\tthis.renderedFragments = this.fragments.slice();\n\t\t};\n\t\n\t\t/* virtualdom/items/Section/_Section.js */\n\t\tvar Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {\n\t\n\t\t\tvar Section = function( options ) {\n\t\t\t\tthis.type = types.SECTION;\n\t\t\t\tthis.subtype = options.template.n;\n\t\t\t\tthis.inverted = this.subtype === types.SECTION_UNLESS;\n\t\t\t\tthis.pElement = options.pElement;\n\t\t\t\tthis.fragments = [];\n\t\t\t\tthis.fragmentsToCreate = [];\n\t\t\t\tthis.fragmentsToRender = [];\n\t\t\t\tthis.fragmentsToUnrender = [];\n\t\t\t\tthis.renderedFragments = [];\n\t\t\t\tthis.length = 0;\n\t\t\t\t// number of times this section is rendered\n\t\t\t\tMustache.init( this, options );\n\t\t\t};\n\t\t\tSection.prototype = {\n\t\t\t\tbubble: bubble,\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfindAllComponents: findAllComponents,\n\t\t\t\tfindComponent: findComponent,\n\t\t\t\tfindNextNode: findNextNode,\n\t\t\t\tfirstNode: firstNode,\n\t\t\t\tgetValue: Mustache.getValue,\n\t\t\t\tshuffle: shuffle,\n\t\t\t\trebind: Mustache.rebind,\n\t\t\t\trender: render,\n\t\t\t\tresolve: Mustache.resolve,\n\t\t\t\tsetValue: setValue,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender,\n\t\t\t\tupdate: update\n\t\t\t};\n\t\t\treturn Section;\n\t\t}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );\n\t\n\t\t/* virtualdom/items/Triple/prototype/detach.js */\n\t\tvar virtualdom_items_Triple$detach = function Triple$detach() {\n\t\t\tvar len, i;\n\t\t\tif ( this.docFrag ) {\n\t\t\t\tlen = this.nodes.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tthis.docFrag.appendChild( this.nodes[ i ] );\n\t\t\t\t}\n\t\t\t\treturn this.docFrag;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Triple/prototype/find.js */\n\t\tvar virtualdom_items_Triple$find = function( matches ) {\n\t\n\t\t\treturn function Triple$find( selector ) {\n\t\t\t\tvar i, len, node, queryResult;\n\t\t\t\tlen = this.nodes.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\t\t\t\treturn queryResult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}( matches );\n\t\n\t\t/* virtualdom/items/Triple/prototype/findAll.js */\n\t\tvar virtualdom_items_Triple$findAll = function( matches ) {\n\t\n\t\t\treturn function Triple$findAll( selector, queryResult ) {\n\t\t\t\tvar i, len, node, queryAllResult, numNodes, j;\n\t\t\t\tlen = this.nodes.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\t\tqueryResult.push( node );\n\t\t\t\t\t}\n\t\t\t\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\t\t\t\tnumNodes = queryAllResult.length;\n\t\t\t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\t\t\t\tqueryResult.push( queryAllResult[ j ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( matches );\n\t\n\t\t/* virtualdom/items/Triple/prototype/firstNode.js */\n\t\tvar virtualdom_items_Triple$firstNode = function Triple$firstNode() {\n\t\t\tif ( this.rendered && this.nodes[ 0 ] ) {\n\t\t\t\treturn this.nodes[ 0 ];\n\t\t\t}\n\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t};\n\t\n\t\t/* virtualdom/items/Triple/helpers/insertHtml.js */\n\t\tvar insertHtml = function( namespaces, createElement ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar elementCache = {},\n\t\t\t\tieBug, ieBlacklist;\n\t\t\ttry {\n\t\t\t\tcreateElement( 'table' ).innerHTML = 'foo';\n\t\t\t} catch ( err ) {\n\t\t\t\tieBug = true;\n\t\t\t\tieBlacklist = {\n\t\t\t\t\tTABLE: [\n\t\t\t\t\t\t'<table class=\"x\">',\n\t\t\t\t\t\t'</table>'\n\t\t\t\t\t],\n\t\t\t\t\tTHEAD: [\n\t\t\t\t\t\t'<table><thead class=\"x\">',\n\t\t\t\t\t\t'</thead></table>'\n\t\t\t\t\t],\n\t\t\t\t\tTBODY: [\n\t\t\t\t\t\t'<table><tbody class=\"x\">',\n\t\t\t\t\t\t'</tbody></table>'\n\t\t\t\t\t],\n\t\t\t\t\tTR: [\n\t\t\t\t\t\t'<table><tr class=\"x\">',\n\t\t\t\t\t\t'</tr></table>'\n\t\t\t\t\t],\n\t\t\t\t\tSELECT: [\n\t\t\t\t\t\t'<select class=\"x\">',\n\t\t\t\t\t\t'</select>'\n\t\t\t\t\t]\n\t\t\t\t};\n\t\t\t}\n\t\t\t__export = function( html, node, docFrag ) {\n\t\t\t\tvar container, nodes = [],\n\t\t\t\t\twrapper, selectedOption, child, i;\n\t\t\t\t// render 0 and false\n\t\t\t\tif ( html != null && html !== '' ) {\n\t\t\t\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\t\tcontainer.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];\n\t\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( node.namespaceURI === namespaces.svg ) {\n\t\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = element( node.tagName );\n\t\t\t\t\t\tcontainer.innerHTML = html;\n\t\t\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile ( child = container.firstChild ) {\n\t\t\t\t\t\tnodes.push( child );\n\t\t\t\t\t\tdocFrag.appendChild( child );\n\t\t\t\t\t}\n\t\t\t\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t\t\t\t// temporary container <select> causes the remaining ones to\n\t\t\t\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t\t\t\t// amaze me. You really do\n\t\t\t\t\t// ...and now Chrome too\n\t\t\t\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\t\t\t\ti = nodes.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( nodes[ i ] !== selectedOption ) {\n\t\t\t\t\t\t\t\tnodes[ i ].selected = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nodes;\n\t\t\t};\n\t\n\t\t\tfunction element( tagName ) {\n\t\t\t\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( namespaces, createElement );\n\t\n\t\t/* utils/toArray.js */\n\t\tvar toArray = function toArray( arrayLike ) {\n\t\t\tvar array = [],\n\t\t\t\ti = arrayLike.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tarray[ i ] = arrayLike[ i ];\n\t\t\t}\n\t\t\treturn array;\n\t\t};\n\t\n\t\t/* virtualdom/items/Triple/helpers/updateSelect.js */\n\t\tvar updateSelect = function( toArray ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function updateSelect( parentElement ) {\n\t\t\t\tvar selectedOptions, option, value;\n\t\t\t\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\t\t\t\t// If one of them had a `selected` attribute, we need to sync\n\t\t\t\t// the model to the view\n\t\t\t\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\t\t\t\tvalue = selectedOptions.map( function( o ) {\n\t\t\t\t\t\treturn o.value;\n\t\t\t\t\t} );\n\t\t\t\t} else if ( option = selectedOptions[ 0 ] ) {\n\t\t\t\t\tvalue = option.value;\n\t\t\t\t}\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tparentElement.binding.setValue( value );\n\t\t\t\t}\n\t\t\t\tparentElement.bubble();\n\t\t\t};\n\t\n\t\t\tfunction isSelected( option ) {\n\t\t\t\treturn option.selected;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( toArray );\n\t\n\t\t/* virtualdom/items/Triple/prototype/render.js */\n\t\tvar virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {\n\t\n\t\t\treturn function Triple$render() {\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t\t\t\t}\n\t\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\t\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\t\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\t\tupdateSelect( this.pElement );\n\t\t\t\tthis.rendered = true;\n\t\t\t\treturn this.docFrag;\n\t\t\t};\n\t\t}( insertHtml, updateSelect );\n\t\n\t\t/* virtualdom/items/Triple/prototype/setValue.js */\n\t\tvar virtualdom_items_Triple$setValue = function( runloop ) {\n\t\n\t\t\treturn function Triple$setValue( value ) {\n\t\t\t\tvar wrapper;\n\t\t\t\t// TODO is there a better way to approach this?\n\t\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t\tif ( value !== this.value ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( runloop );\n\t\n\t\t/* virtualdom/items/Triple/prototype/toString.js */\n\t\tvar virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {\n\t\n\t\t\treturn function Triple$toString() {\n\t\t\t\treturn this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';\n\t\t\t};\n\t\t}( decodeCharacterReferences );\n\t\n\t\t/* virtualdom/items/Triple/prototype/unrender.js */\n\t\tvar virtualdom_items_Triple$unrender = function( detachNode ) {\n\t\n\t\t\treturn function Triple$unrender( shouldDestroy ) {\n\t\t\t\tif ( this.rendered && shouldDestroy ) {\n\t\t\t\t\tthis.nodes.forEach( detachNode );\n\t\t\t\t\tthis.rendered = false;\n\t\t\t\t}\n\t\t\t};\n\t\t}( detachNode );\n\t\n\t\t/* virtualdom/items/Triple/prototype/update.js */\n\t\tvar virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {\n\t\n\t\t\treturn function Triple$update() {\n\t\t\t\tvar node, parentNode;\n\t\t\t\tif ( !this.rendered ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Remove existing nodes\n\t\t\t\twhile ( this.nodes && this.nodes.length ) {\n\t\t\t\t\tnode = this.nodes.pop();\n\t\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t\t}\n\t\t\t\t// Insert new nodes\n\t\t\t\tparentNode = this.parentFragment.getNode();\n\t\t\t\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\t\t\t\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\t\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\t\tupdateSelect( this.pElement );\n\t\t\t};\n\t\t}( insertHtml, updateSelect );\n\t\n\t\t/* virtualdom/items/Triple/_Triple.js */\n\t\tvar Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {\n\t\n\t\t\tvar Triple = function( options ) {\n\t\t\t\tthis.type = types.TRIPLE;\n\t\t\t\tMustache.init( this, options );\n\t\t\t};\n\t\t\tTriple.prototype = {\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfirstNode: firstNode,\n\t\t\t\tgetValue: Mustache.getValue,\n\t\t\t\trebind: Mustache.rebind,\n\t\t\t\trender: render,\n\t\t\t\tresolve: Mustache.resolve,\n\t\t\t\tsetValue: setValue,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender,\n\t\t\t\tupdate: update\n\t\t\t};\n\t\t\treturn Triple;\n\t\t}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );\n\t\n\t\t/* virtualdom/items/Element/prototype/bubble.js */\n\t\tvar virtualdom_items_Element$bubble = function() {\n\t\t\tthis.parentFragment.bubble();\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/detach.js */\n\t\tvar virtualdom_items_Element$detach = function Element$detach() {\n\t\t\tvar node = this.node,\n\t\t\t\tparentNode;\n\t\t\tif ( node ) {\n\t\t\t\t// need to check for parent node - DOM may have been altered\n\t\t\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\t\t\tif ( parentNode = node.parentNode ) {\n\t\t\t\t\tparentNode.removeChild( node );\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/find.js */\n\t\tvar virtualdom_items_Element$find = function( matches ) {\n\t\n\t\t\treturn function( selector ) {\n\t\t\t\tif ( matches( this.node, selector ) ) {\n\t\t\t\t\treturn this.node;\n\t\t\t\t}\n\t\t\t\tif ( this.fragment && this.fragment.find ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t}\n\t\t\t};\n\t\t}( matches );\n\t\n\t\t/* virtualdom/items/Element/prototype/findAll.js */\n\t\tvar virtualdom_items_Element$findAll = function( selector, query ) {\n\t\t\t// Add this node to the query, if applicable, and register the\n\t\t\t// query on this element\n\t\t\tif ( query._test( this, true ) && query.live ) {\n\t\t\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/findAllComponents.js */\n\t\tvar virtualdom_items_Element$findAllComponents = function( selector, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/findComponent.js */\n\t\tvar virtualdom_items_Element$findComponent = function( selector ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/findNextNode.js */\n\t\tvar virtualdom_items_Element$findNextNode = function Element$findNextNode() {\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/firstNode.js */\n\t\tvar virtualdom_items_Element$firstNode = function Element$firstNode() {\n\t\t\treturn this.node;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/prototype/getAttribute.js */\n\t\tvar virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {\n\t\t\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn this.attributes[ name ].value;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/shared/enforceCase.js */\n\t\tvar enforceCase = function() {\n\t\n\t\t\tvar svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n\t\t\tsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\n\t\t\tsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\t\t\tcreateMap = function( items ) {\n\t\t\t\tvar map = {},\n\t\t\t\t\ti = items.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tmap[ items[ i ].toLowerCase() ] = items[ i ];\n\t\t\t\t}\n\t\t\t\treturn map;\n\t\t\t};\n\t\t\tmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\t\t\treturn function( elementName ) {\n\t\t\t\tvar lowerCaseElementName = elementName.toLowerCase();\n\t\t\t\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n\t\t\t};\n\t\t}();\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/bubble.js */\n\t\tvar virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {\n\t\n\t\t\treturn function Attribute$bubble() {\n\t\t\t\tvar value = this.fragment.getValue();\n\t\t\t\t// TODO this can register the attribute multiple times (see render test\n\t\t\t\t// 'Attribute with nested mustaches')\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\t// Need to clear old id from ractive.nodes\n\t\t\t\t\tif ( this.name === 'id' && this.value ) {\n\t\t\t\t\t\tdelete this.root.nodes[ this.value ];\n\t\t\t\t\t}\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\t\t\t\tthis.node._ractive.value = value;\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( runloop, isEqual );\n\t\n\t\t/* config/booleanAttributes.js */\n\t\tvar booleanAttributes = function() {\n\t\n\t\t\t// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\t\t\tvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\t\t\treturn booleanAttributes;\n\t\t}();\n\t\n\t\t/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */\n\t\tvar determineNameAndNamespace = function( namespaces, enforceCase ) {\n\t\n\t\t\treturn function( attribute, name ) {\n\t\t\t\tvar colonIndex, namespacePrefix;\n\t\t\t\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\t\t\t\tcolonIndex = name.indexOf( ':' );\n\t\t\t\tif ( colonIndex !== -1 ) {\n\t\t\t\t\t// looks like we are, yes...\n\t\t\t\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\t\t\t\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t\t\t\t// that only valid namespaces will be used)\n\t\t\t\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\t\t\t\tname = name.substring( colonIndex + 1 );\n\t\t\t\t\t\tattribute.name = enforceCase( name );\n\t\t\t\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\t\t\t\tattribute.namespacePrefix = namespacePrefix;\n\t\t\t\t\t\tif ( !attribute.namespace ) {\n\t\t\t\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// SVG attribute names are case sensitive\n\t\t\t\tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;\n\t\t\t};\n\t\t}( namespaces, enforceCase );\n\t\n\t\t/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */\n\t\tvar getInterpolator = function( types ) {\n\t\n\t\t\treturn function getInterpolator( attribute ) {\n\t\t\t\tvar items = attribute.fragment.items;\n\t\t\t\tif ( items.length !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( items[ 0 ].type === types.INTERPOLATOR ) {\n\t\t\t\t\treturn items[ 0 ];\n\t\t\t\t}\n\t\t\t};\n\t\t}( types );\n\t\n\t\t/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */\n\t\tvar determinePropertyName = function( namespaces, booleanAttributes ) {\n\t\n\t\t\tvar propertyNames = {\n\t\t\t\t'accept-charset': 'acceptCharset',\n\t\t\t\taccesskey: 'accessKey',\n\t\t\t\tbgcolor: 'bgColor',\n\t\t\t\t'class': 'className',\n\t\t\t\tcodebase: 'codeBase',\n\t\t\t\tcolspan: 'colSpan',\n\t\t\t\tcontenteditable: 'contentEditable',\n\t\t\t\tdatetime: 'dateTime',\n\t\t\t\tdirname: 'dirName',\n\t\t\t\t'for': 'htmlFor',\n\t\t\t\t'http-equiv': 'httpEquiv',\n\t\t\t\tismap: 'isMap',\n\t\t\t\tmaxlength: 'maxLength',\n\t\t\t\tnovalidate: 'noValidate',\n\t\t\t\tpubdate: 'pubDate',\n\t\t\t\treadonly: 'readOnly',\n\t\t\t\trowspan: 'rowSpan',\n\t\t\t\ttabindex: 'tabIndex',\n\t\t\t\tusemap: 'useMap'\n\t\t\t};\n\t\t\treturn function( attribute, options ) {\n\t\t\t\tvar propertyName;\n\t\t\t\tif ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {\n\t\t\t\t\tpropertyName = propertyNames[ attribute.name ] || attribute.name;\n\t\t\t\t\tif ( options.pNode[ propertyName ] !== undefined ) {\n\t\t\t\t\t\tattribute.propertyName = propertyName;\n\t\t\t\t\t}\n\t\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\t\tattribute.useProperty = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( namespaces, booleanAttributes );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/init.js */\n\t\tvar virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {\n\t\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\treturn function Attribute$init( options ) {\n\t\t\t\tthis.type = types.ATTRIBUTE;\n\t\t\t\tthis.element = options.element;\n\t\t\t\tthis.root = options.root;\n\t\t\t\tdetermineNameAndNamespace( this, options.name );\n\t\t\t\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t\t\t\t// mustache shenanigans, set the attribute accordingly and go home\n\t\t\t\tif ( !options.value || typeof options.value === 'string' ) {\n\t\t\t\t\tthis.value = booleanAttributes.test( this.name ) ? true : options.value || '';\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// otherwise we need to do some work\n\t\t\t\t// share parentFragment with parent element\n\t\t\t\tthis.parentFragment = this.element.parentFragment;\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: options.value,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\towner: this\n\t\t\t\t} );\n\t\t\t\tthis.value = this.fragment.getValue();\n\t\t\t\t// Store a reference to this attribute's interpolator, if its fragment\n\t\t\t\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t\t\t\t// for correctly rendering HTML later\n\t\t\t\tthis.interpolator = getInterpolator( this );\n\t\t\t\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\t\t\t\t// can we establish this attribute's property name equivalent?\n\t\t\t\tdeterminePropertyName( this, options );\n\t\t\t\t// mark as ready\n\t\t\t\tthis.ready = true;\n\t\t\t};\n\t\t}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/rebind.js */\n\t\tvar virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/render.js */\n\t\tvar virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {\n\t\n\t\t\tvar propertyNames = {\n\t\t\t\t'accept-charset': 'acceptCharset',\n\t\t\t\t'accesskey': 'accessKey',\n\t\t\t\t'bgcolor': 'bgColor',\n\t\t\t\t'class': 'className',\n\t\t\t\t'codebase': 'codeBase',\n\t\t\t\t'colspan': 'colSpan',\n\t\t\t\t'contenteditable': 'contentEditable',\n\t\t\t\t'datetime': 'dateTime',\n\t\t\t\t'dirname': 'dirName',\n\t\t\t\t'for': 'htmlFor',\n\t\t\t\t'http-equiv': 'httpEquiv',\n\t\t\t\t'ismap': 'isMap',\n\t\t\t\t'maxlength': 'maxLength',\n\t\t\t\t'novalidate': 'noValidate',\n\t\t\t\t'pubdate': 'pubDate',\n\t\t\t\t'readonly': 'readOnly',\n\t\t\t\t'rowspan': 'rowSpan',\n\t\t\t\t'tabindex': 'tabIndex',\n\t\t\t\t'usemap': 'useMap'\n\t\t\t};\n\t\t\treturn function Attribute$render( node ) {\n\t\t\t\tvar propertyName;\n\t\t\t\tthis.node = node;\n\t\t\t\t// should we use direct property access, or setAttribute?\n\t\t\t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\t\t\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\t\t\t\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\t\t\t\tthis.propertyName = propertyName;\n\t\t\t\t\t}\n\t\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( propertyName === 'value' ) {\n\t\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t\t\tnode._ractive.value = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.rendered = true;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}( namespaces, booleanAttributes );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/toString.js */\n\t\tvar virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Attribute$toString() {\n\t\t\t\tvar name = ( fragment = this ).name,\n\t\t\t\t\tnamespacePrefix = fragment.namespacePrefix,\n\t\t\t\t\tvalue = fragment.value,\n\t\t\t\t\tinterpolator = fragment.interpolator,\n\t\t\t\t\tfragment = fragment.fragment;\n\t\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\t\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Special case - content editable\n\t\t\t\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Special case - radio names\n\t\t\t\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\t\t\t\treturn 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';\n\t\t\t\t}\n\t\t\t\t// Boolean attributes\n\t\t\t\tif ( booleanAttributes.test( name ) ) {\n\t\t\t\t\treturn value ? name : '';\n\t\t\t\t}\n\t\t\t\tif ( fragment ) {\n\t\t\t\t\tvalue = fragment.toString();\n\t\t\t\t}\n\t\t\t\tif ( namespacePrefix ) {\n\t\t\t\t\tname = namespacePrefix + ':' + name;\n\t\t\t\t}\n\t\t\t\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n\t\t\t};\n\t\n\t\t\tfunction escape( value ) {\n\t\t\t\treturn value.replace( /&/g, '&amp;' ).replace( /\"/g, '&quot;' ).replace( /'/g, '&#39;' );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( booleanAttributes );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/unbind.js */\n\t\tvar virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {\n\t\t\t// ignore non-dynamic attributes\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t}\n\t\t\tif ( this.name === 'id' ) {\n\t\t\t\tdelete this.root.nodes[ this.value ];\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {\n\t\t\tvar value = this.value,\n\t\t\t\toptions, option, optionValue, i;\n\t\t\tif ( !this.locked ) {\n\t\t\t\tthis.node._ractive.value = value;\n\t\t\t\toptions = this.node.options;\n\t\t\t\ti = options.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\t\tif ( optionValue == value ) {\n\t\t\t\t\t\t// double equals as we may be comparing numbers with strings\n\t\t\t\t\t\toption.selected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/* utils/arrayContains.js */\n\t\tvar arrayContains = function arrayContains( array, value ) {\n\t\t\tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t\t\t\tif ( array[ i ] == value ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {\n\t\n\t\t\treturn function Attribute$updateMultipleSelect() {\n\t\t\t\tvar value = this.value,\n\t\t\t\t\toptions, i, option, optionValue;\n\t\t\t\tif ( !isArray( value ) ) {\n\t\t\t\t\tvalue = [ value ];\n\t\t\t\t}\n\t\t\t\toptions = this.node.options;\n\t\t\t\ti = options.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\t\toption.selected = arrayContains( value, optionValue );\n\t\t\t\t}\n\t\t\t};\n\t\t}( arrayContains, isArray );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {\n\t\t\tvar node = ( value = this ).node,\n\t\t\t\tvalue = value.value;\n\t\t\tnode.checked = value == node._ractive.value;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {\n\t\n\t\t\treturn function Attribute$updateRadioValue() {\n\t\t\t\tvar wasChecked, node = this.node,\n\t\t\t\t\tbinding, bindings, i;\n\t\t\t\twasChecked = node.checked;\n\t\t\t\tnode.value = this.element.getAttribute( 'value' );\n\t\t\t\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\t\t\t\t// This is a special case - if the input was checked, and the value\n\t\t\t\t// changed so that it's no longer checked, the twoway binding is\n\t\t\t\t// most likely out of date. To fix it we have to jump through some\n\t\t\t\t// hoops... this is a little kludgy but it works\n\t\t\t\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\t\t\t\tbindings = this.element.binding.siblings;\n\t\t\t\t\tif ( i = bindings.length ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t\t\t\t// we'll come back later...\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( runloop );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {\n\t\n\t\t\treturn function Attribute$updateCheckboxName() {\n\t\t\t\tvar element = ( value = this ).element,\n\t\t\t\t\tnode = value.node,\n\t\t\t\t\tvalue = value.value,\n\t\t\t\t\tvalueAttribute, i;\n\t\t\t\tvalueAttribute = element.getAttribute( 'value' );\n\t\t\t\tif ( !isArray( value ) ) {\n\t\t\t\t\tnode.checked = value == valueAttribute;\n\t\t\t\t} else {\n\t\t\t\t\ti = value.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( valueAttribute == value[ i ] ) {\n\t\t\t\t\t\t\tnode.checked = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode.checked = false;\n\t\t\t\t}\n\t\t\t};\n\t\t}( isArray );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {\n\t\t\tvar node, value;\n\t\t\tnode = this.node;\n\t\t\tvalue = this.value;\n\t\t\tif ( value === undefined ) {\n\t\t\t\tvalue = '';\n\t\t\t}\n\t\t\tnode.className = value;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {\n\t\t\tvar node = ( value = this ).node,\n\t\t\t\tvalue = value.value;\n\t\t\tthis.root.nodes[ value ] = node;\n\t\t\tnode.id = value;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {\n\t\t\tvar node, value;\n\t\t\tnode = this.node;\n\t\t\tvalue = this.value;\n\t\t\tif ( value === undefined ) {\n\t\t\t\tvalue = '';\n\t\t\t}\n\t\t\tnode.style.setAttribute( 'cssText', value );\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {\n\t\t\tvar value = this.value;\n\t\t\tif ( value === undefined ) {\n\t\t\t\tvalue = '';\n\t\t\t}\n\t\t\tif ( !this.locked ) {\n\t\t\t\tthis.node.innerHTML = value;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {\n\t\t\tvar node = ( value = this ).node,\n\t\t\t\tvalue = value.value;\n\t\t\t// store actual value, so it doesn't get coerced to a string\n\t\t\tnode._ractive.value = value;\n\t\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t\t// otherwise the cursor will often be sent to the wrong place\n\t\t\tif ( !this.locked ) {\n\t\t\t\tnode.value = value == undefined ? '' : value;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {\n\t\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t\t// otherwise the cursor will often be sent to the wrong place\n\t\t\tif ( !this.locked ) {\n\t\t\t\tthis.node[ this.propertyName ] = this.value;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */\n\t\tvar virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {\n\t\n\t\t\treturn function Attribute$updateEverythingElse() {\n\t\t\t\tvar node = ( fragment = this ).node,\n\t\t\t\t\tnamespace = fragment.namespace,\n\t\t\t\t\tname = fragment.name,\n\t\t\t\t\tvalue = fragment.value,\n\t\t\t\t\tfragment = fragment.fragment;\n\t\t\t\tif ( namespace ) {\n\t\t\t\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t\t\t\t} else if ( !booleanAttributes.test( name ) ) {\n\t\t\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t\t\t} else {\n\t\t\t\t\tif ( value ) {\n\t\t\t\t\t\tnode.setAttribute( name, '' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}( booleanAttributes );\n\t\n\t\t/* virtualdom/items/Element/Attribute/prototype/update.js */\n\t\tvar virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {\n\t\n\t\t\treturn function Attribute$update() {\n\t\t\t\tvar name = ( node = this ).name,\n\t\t\t\t\telement = node.element,\n\t\t\t\t\tnode = node.node,\n\t\t\t\t\ttype, updateMethod;\n\t\t\t\tif ( name === 'id' ) {\n\t\t\t\t\tupdateMethod = updateIdAttribute;\n\t\t\t\t} else if ( name === 'value' ) {\n\t\t\t\t\t// special case - selects\n\t\t\t\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\t\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t\t\t\t} else if ( element.name === 'textarea' ) {\n\t\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t\t} else if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\t\t\t\tupdateMethod = updateContentEditableValue;\n\t\t\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\t\t\t// type='file' value='{{fileList}}'>\n\t\t\t\t\t\tif ( type === 'file' ) {\n\t\t\t\t\t\t\tupdateMethod = noop;\n\t\t\t\t\t\t} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.twoway && name === 'name' ) {\n\t\t\t\t\tif ( node.type === 'radio' ) {\n\t\t\t\t\t\tupdateMethod = updateRadioName;\n\t\t\t\t\t} else if ( node.type === 'checkbox' ) {\n\t\t\t\t\t\tupdateMethod = updateCheckboxName;\n\t\t\t\t\t}\n\t\t\t\t} else if ( name === 'style' && node.style.setAttribute ) {\n\t\t\t\t\tupdateMethod = updateIEStyleAttribute;\n\t\t\t\t} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\t\t\t\tupdateMethod = updateClassName;\n\t\t\t\t} else if ( this.useProperty ) {\n\t\t\t\t\tupdateMethod = updateBoolean;\n\t\t\t\t}\n\t\t\t\tif ( !updateMethod ) {\n\t\t\t\t\tupdateMethod = updateEverythingElse;\n\t\t\t\t}\n\t\t\t\tthis.update = updateMethod;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );\n\t\n\t\t/* virtualdom/items/Element/Attribute/_Attribute.js */\n\t\tvar Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {\n\t\n\t\t\tvar Attribute = function( options ) {\n\t\t\t\tthis.init( options );\n\t\t\t};\n\t\t\tAttribute.prototype = {\n\t\t\t\tbubble: bubble,\n\t\t\t\tinit: init,\n\t\t\t\trebind: rebind,\n\t\t\t\trender: render,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tupdate: update\n\t\t\t};\n\t\t\treturn Attribute;\n\t\t}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );\n\t\n\t\t/* virtualdom/items/Element/prototype/init/createAttributes.js */\n\t\tvar virtualdom_items_Element$init_createAttributes = function( Attribute ) {\n\t\n\t\t\treturn function( element, attributes ) {\n\t\t\t\tvar name, attribute, result = [];\n\t\t\t\tfor ( name in attributes ) {\n\t\t\t\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\t\t\t\tattribute = new Attribute( {\n\t\t\t\t\t\t\telement: element,\n\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\tvalue: attributes[ name ],\n\t\t\t\t\t\t\troot: element.root\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tresult.push( result[ name ] = attribute );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}( Attribute );\n\t\n\t\t/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */\n\t\tvar ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Fragment, div;\n\t\t\tif ( typeof document !== 'undefined' ) {\n\t\t\t\tdiv = createElement( 'div' );\n\t\t\t}\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tvar ConditionalAttribute = function( element, template ) {\n\t\t\t\tthis.element = element;\n\t\t\t\tthis.root = element.root;\n\t\t\t\tthis.parentFragment = element.parentFragment;\n\t\t\t\tthis.attributes = [];\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\troot: element.root,\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: [ template ]\n\t\t\t\t} );\n\t\t\t};\n\t\t\tConditionalAttribute.prototype = {\n\t\t\t\tbubble: function() {\n\t\t\t\t\tif ( this.node ) {\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t}\n\t\t\t\t\tthis.element.bubble();\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t},\n\t\t\t\trender: function( node ) {\n\t\t\t\t\tthis.node = node;\n\t\t\t\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\t\t\t\t\tthis.update();\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t},\n\t\t\t\tupdate: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar str, attrs;\n\t\t\t\t\tstr = this.fragment.toString();\n\t\t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\t\t\t\t\t// any attributes that previously existed but no longer do\n\t\t\t\t\t// must be removed\n\t\t\t\t\tthis.attributes.filter( function( a ) {\n\t\t\t\t\t\treturn notIn( attrs, a );\n\t\t\t\t\t} ).forEach( function( a ) {\n\t\t\t\t\t\tthis$0.node.removeAttribute( a.name );\n\t\t\t\t\t} );\n\t\t\t\t\tattrs.forEach( function( a ) {\n\t\t\t\t\t\tthis$0.node.setAttribute( a.name, a.value );\n\t\t\t\t\t} );\n\t\t\t\t\tthis.attributes = attrs;\n\t\t\t\t},\n\t\t\t\ttoString: function() {\n\t\t\t\t\treturn this.fragment.toString();\n\t\t\t\t}\n\t\t\t};\n\t\t\t__export = ConditionalAttribute;\n\t\n\t\t\tfunction parseAttributes( str, isSvg ) {\n\t\t\t\tvar tag = isSvg ? 'svg' : 'div';\n\t\t\t\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\t\t\t\treturn toArray( div.childNodes[ 0 ].attributes );\n\t\t\t}\n\t\n\t\t\tfunction notIn( haystack, needle ) {\n\t\t\t\tvar i = haystack.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( haystack[ i ].name === needle.name ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( circular, namespaces, createElement, toArray );\n\t\n\t\t/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */\n\t\tvar virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {\n\t\n\t\t\treturn function( element, attributes ) {\n\t\t\t\tif ( !attributes ) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\treturn attributes.map( function( a ) {\n\t\t\t\t\treturn new ConditionalAttribute( element, a );\n\t\t\t\t} );\n\t\t\t};\n\t\t}( ConditionalAttribute );\n\t\n\t\t/* utils/extend.js */\n\t\tvar extend = function( target ) {\n\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\t\tvar prop, source;\n\t\t\twhile ( source = sources.shift() ) {\n\t\t\t\tfor ( prop in source ) {\n\t\t\t\t\tif ( source.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Binding/Binding.js */\n\t\tvar Binding = function( runloop, warn, create, extend, removeFromArray ) {\n\t\n\t\t\tvar Binding = function( element ) {\n\t\t\t\tvar interpolator, keypath, value;\n\t\t\t\tthis.element = element;\n\t\t\t\tthis.root = element.root;\n\t\t\t\tthis.attribute = element.attributes[ this.name || 'value' ];\n\t\t\t\tinterpolator = this.attribute.interpolator;\n\t\t\t\tinterpolator.twowayBinding = this;\n\t\t\t\tif ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {\n\t\t\t\t\twarn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t\t\t//\n\t\t\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t\t\t// assumption. That assumption is that the input in question should\n\t\t\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t\t\t// and not `foo.bar`.\n\t\t\t\t//\n\t\t\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\t\t\tif ( !interpolator.keypath ) {\n\t\t\t\t\tinterpolator.resolver.forceResolution();\n\t\t\t\t}\n\t\t\t\tthis.keypath = keypath = interpolator.keypath;\n\t\t\t\t// initialise value, if it's undefined\n\t\t\t\tif ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {\n\t\t\t\t\tvalue = this.getInitialValue();\n\t\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tBinding.prototype = {\n\t\t\t\thandleChange: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t} );\n\t\t\t\t\trunloop.end();\n\t\t\t\t},\n\t\t\t\trebound: function() {\n\t\t\t\t\tvar bindings, oldKeypath, newKeypath;\n\t\t\t\t\toldKeypath = this.keypath;\n\t\t\t\t\tnewKeypath = this.attribute.interpolator.keypath;\n\t\t\t\t\t// The attribute this binding is linked to has already done the work\n\t\t\t\t\tif ( oldKeypath === newKeypath ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath ], this );\n\t\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\t\tbindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );\n\t\t\t\t\tbindings.push( this );\n\t\t\t\t},\n\t\t\t\tunbind: function() {}\n\t\t\t};\n\t\t\tBinding.extend = function( properties ) {\n\t\t\t\tvar Parent = this,\n\t\t\t\t\tSpecialisedBinding;\n\t\t\t\tSpecialisedBinding = function( element ) {\n\t\t\t\t\tBinding.call( this, element );\n\t\t\t\t\tif ( this.init ) {\n\t\t\t\t\t\tthis.init();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tSpecialisedBinding.prototype = create( Parent.prototype );\n\t\t\t\textend( SpecialisedBinding.prototype, properties );\n\t\t\t\tSpecialisedBinding.extend = Binding.extend;\n\t\t\t\treturn SpecialisedBinding;\n\t\t\t};\n\t\t\treturn Binding;\n\t\t}( runloop, warn, create, extend, removeFromArray );\n\t\n\t\t/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */\n\t\tvar handleDomEvent = function handleChange() {\n\t\t\tthis._ractive.binding.handleChange();\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Binding/ContentEditableBinding.js */\n\t\tvar ContentEditableBinding = function( Binding, handleDomEvent ) {\n\t\n\t\t\tvar ContentEditableBinding = Binding.extend( {\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.element.node.innerHTML;\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn ContentEditableBinding;\n\t\t}( Binding, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/shared/getSiblings.js */\n\t\tvar getSiblings = function() {\n\t\n\t\t\tvar sets = {};\n\t\t\treturn function getSiblings( id, group, keypath ) {\n\t\t\t\tvar hash = id + group + keypath;\n\t\t\t\treturn sets[ hash ] || ( sets[ hash ] = [] );\n\t\t\t};\n\t\t}();\n\t\n\t\t/* virtualdom/items/Element/Binding/RadioBinding.js */\n\t\tvar RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\t\n\t\t\tvar RadioBinding = Binding.extend( {\n\t\t\t\tname: 'checked',\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\t\t\t\tthis.siblings.push( this );\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\thandleChange: function() {\n\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\tthis.siblings.forEach( function( binding ) {\n\t\t\t\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t\t\t\t} );\n\t\t\t\t\trunloop.end();\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.element.node.checked;\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn RadioBinding;\n\t\t}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/RadioNameBinding.js */\n\t\tvar RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {\n\t\n\t\t\tvar RadioNameBinding = Binding.extend( {\n\t\t\t\tname: 'name',\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );\n\t\t\t\t\tthis.siblings.push( this );\n\t\t\t\t\tthis.radioName = true;\n\t\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\t\tthis.attribute.twoway = true;\n\t\t\t\t},\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\treturn node._ractive ? node._ractive.value : node.value;\n\t\t\t\t},\n\t\t\t\thandleChange: function() {\n\t\t\t\t\t// If this <input> is the one that's checked, then the value of its\n\t\t\t\t\t// `name` keypath gets set to its value\n\t\t\t\t\tif ( this.element.node.checked ) {\n\t\t\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tvar node;\n\t\t\t\t\tBinding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\tif ( node = this.element.node ) {\n\t\t\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn RadioNameBinding;\n\t\t}( removeFromArray, Binding, handleDomEvent, getSiblings );\n\t\n\t\t/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */\n\t\tvar CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\t\n\t\t\tvar CheckboxNameBinding = Binding.extend( {\n\t\t\t\tname: 'name',\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\t// This only gets called once per group (of inputs that\n\t\t\t\t\t// share a name), because it only gets called if there\n\t\t\t\t\t// isn't an initial value. By the same token, we can make\n\t\t\t\t\t// a note of that fact that there was no initial value,\n\t\t\t\t\t// and populate it using any `checked` attributes that\n\t\t\t\t\t// exist (which users should avoid, but which we should\n\t\t\t\t\t// support anyway to avoid breaking expectations)\n\t\t\t\t\tthis.noInitialValue = true;\n\t\t\t\t\treturn [];\n\t\t\t\t},\n\t\t\t\tinit: function() {\n\t\t\t\t\tvar existingValue, bindingValue;\n\t\t\t\t\tthis.checkboxName = true;\n\t\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\t\tthis.attribute.twoway = true;\n\t\t\t\t\t// we set this property so that the attribute gets the correct update method\n\t\t\t\t\t// Each input has a reference to an array containing it and its\n\t\t\t\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t\t\t\t// the status of all inputs within the group\n\t\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );\n\t\t\t\t\tthis.siblings.push( this );\n\t\t\t\t\tif ( this.noInitialValue ) {\n\t\t\t\t\t\tthis.siblings.noInitialValue = true;\n\t\t\t\t\t}\n\t\t\t\t\t// If no initial value was set, and this input is checked, we\n\t\t\t\t\t// update the model\n\t\t\t\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\t\t\texistingValue.push( bindingValue );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node,\n\t\t\t\t\t\texistingValue, bindingValue;\n\t\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\t\tif ( isArray( existingValue ) ) {\n\t\t\t\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t\t\t\t}\n\t\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\t\tnode.checked = this.isChecked;\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\t// in case of IE emergency, bind to click event as well\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tchanged: function() {\n\t\t\t\t\tvar wasChecked = !!this.isChecked;\n\t\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\t\treturn this.isChecked === wasChecked;\n\t\t\t\t},\n\t\t\t\thandleChange: function() {\n\t\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tfunction isChecked( binding ) {\n\t\t\t\treturn binding.isChecked;\n\t\t\t}\n\t\n\t\t\tfunction getValue( binding ) {\n\t\t\t\treturn binding.element.getAttribute( 'value' );\n\t\t\t}\n\t\t\treturn CheckboxNameBinding;\n\t\t}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/CheckboxBinding.js */\n\t\tvar CheckboxBinding = function( Binding, handleDomEvent ) {\n\t\n\t\t\tvar CheckboxBinding = Binding.extend( {\n\t\t\t\tname: 'checked',\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.element.node.checked;\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn CheckboxBinding;\n\t\t}( Binding, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/SelectBinding.js */\n\t\tvar SelectBinding = function( runloop, Binding, handleDomEvent ) {\n\t\n\t\t\tvar SelectBinding = Binding.extend( {\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\tvar options = this.element.options,\n\t\t\t\t\t\tlen, i, value, optionWasSelected;\n\t\t\t\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ti = len = options.length;\n\t\t\t\t\tif ( !len ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// take the final selected option...\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( options[ i ].getAttribute( 'selected' ) ) {\n\t\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// or the first non-disabled option, if none are selected\n\t\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\t\twhile ( ++i < len ) {\n\t\t\t\t\t\t\tif ( !options[ i ].getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t\t\t\t// other more expensive work\n\t\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\t\tthis.element.attributes.value.value = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\t// TODO this method is an anomaly... is it necessary?\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\tvar options, i, len, option, optionValue;\n\t\t\t\t\toptions = this.element.node.options;\n\t\t\t\t\tlen = options.length;\n\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\t\t\t\t\tif ( options[ i ].selected ) {\n\t\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\t\treturn optionValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforceUpdate: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar value = this.getValue();\n\t\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn SelectBinding;\n\t\t}( runloop, Binding, handleDomEvent );\n\t\n\t\t/* utils/arrayContentsMatch.js */\n\t\tvar arrayContentsMatch = function( isArray ) {\n\t\n\t\t\treturn function( a, b ) {\n\t\t\t\tvar i;\n\t\t\t\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( a.length !== b.length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti = a.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\t}( isArray );\n\t\n\t\t/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */\n\t\tvar MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {\n\t\n\t\t\tvar MultipleSelectBinding = SelectBinding.extend( {\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\treturn this.element.options.filter( function( option ) {\n\t\t\t\t\t\treturn option.getAttribute( 'selected' );\n\t\t\t\t\t} ).map( function( option ) {\n\t\t\t\t\t\treturn option.getAttribute( 'value' );\n\t\t\t\t\t} );\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar valueFromModel;\n\t\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\t\t\t\t\tif ( valueFromModel === undefined ) {\n\t\t\t\t\t\t// get value from DOM, if possible\n\t\t\t\t\t\tthis.handleChange();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tsetValue: function() {\n\t\t\t\t\tthrow new Error( 'TODO not implemented yet' );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\tvar selectedValues, options, i, len, option, optionValue;\n\t\t\t\t\tselectedValues = [];\n\t\t\t\t\toptions = this.element.node.options;\n\t\t\t\t\tlen = options.length;\n\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\t\tselectedValues.push( optionValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn selectedValues;\n\t\t\t\t},\n\t\t\t\thandleChange: function() {\n\t\t\t\t\tvar attribute, previousValue, value;\n\t\t\t\t\tattribute = this.attribute;\n\t\t\t\t\tpreviousValue = attribute.value;\n\t\t\t\t\tvalue = this.getValue();\n\t\t\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\t\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tforceUpdate: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar value = this.getValue();\n\t\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdateModel: function() {\n\t\t\t\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\t\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn MultipleSelectBinding;\n\t\t}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/FileListBinding.js */\n\t\tvar FileListBinding = function( Binding, handleDomEvent ) {\n\t\n\t\t\tvar FileListBinding = Binding.extend( {\n\t\t\t\trender: function() {\n\t\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.element.node.files;\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn FileListBinding;\n\t\t}( Binding, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/GenericBinding.js */\n\t\tvar GenericBinding = function( Binding, handleDomEvent ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar GenericBinding, getOptions;\n\t\t\tgetOptions = {\n\t\t\t\tevaluateWrapped: true\n\t\t\t};\n\t\t\tGenericBinding = Binding.extend( {\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.element.node.value;\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t\t\t\t},\n\t\t\t\tunrender: function() {\n\t\t\t\t\tvar node = this.element.node;\n\t\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t\t\t\t}\n\t\t\t} );\n\t\t\t__export = GenericBinding;\n\t\n\t\t\tfunction handleBlur() {\n\t\t\t\tvar value;\n\t\t\t\thandleDomEvent.call( this );\n\t\t\t\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );\n\t\t\t\tthis.value = value == undefined ? '' : value;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( Binding, handleDomEvent );\n\t\n\t\t/* virtualdom/items/Element/Binding/NumericBinding.js */\n\t\tvar NumericBinding = function( GenericBinding ) {\n\t\n\t\t\treturn GenericBinding.extend( {\n\t\t\t\tgetInitialValue: function() {\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\tvar value = parseFloat( this.element.node.value );\n\t\t\t\t\treturn isNaN( value ) ? undefined : value;\n\t\t\t\t}\n\t\t\t} );\n\t\t}( GenericBinding );\n\t\n\t\t/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */\n\t\tvar virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function createTwowayBinding( element ) {\n\t\t\t\tvar attributes = element.attributes,\n\t\t\t\t\ttype, Binding, bindName, bindChecked;\n\t\t\t\t// if this is a late binding, and there's already one, it\n\t\t\t\t// needs to be torn down\n\t\t\t\tif ( element.binding ) {\n\t\t\t\t\telement.binding.teardown();\n\t\t\t\t\telement.binding = null;\n\t\t\t\t}\n\t\t\t\t// contenteditable\n\t\t\t\tif ( // if the contenteditable attribute is true or is bindable and may thus become true\n\t\t\t\t\t( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = ContentEditableBinding;\n\t\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\t\t\t\tbindName = isBindable( attributes.name );\n\t\t\t\t\t\tbindChecked = isBindable( attributes.checked );\n\t\t\t\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\t\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\t\tmessage: 'badRadioInputBinding'\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( bindName ) {\n\t\t\t\t\t\t\tBinding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t\t\t\t\t\t} else if ( bindChecked ) {\n\t\t\t\t\t\t\tBinding = type === 'radio' ? RadioBinding : CheckboxBinding;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\t\t\t\tBinding = FileListBinding;\n\t\t\t\t\t} else if ( isBindable( attributes.value ) ) {\n\t\t\t\t\t\tBinding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;\n\t\t\t\t\t}\n\t\t\t\t} else if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;\n\t\t\t\t} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = GenericBinding;\n\t\t\t\t}\n\t\t\t\tif ( Binding ) {\n\t\t\t\t\treturn new Binding( element );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction isBindable( attribute ) {\n\t\t\t\treturn attribute && attribute.isBindable;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/bubble.js */\n\t\tvar virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {\n\t\t\tvar hasAction = this.getAction();\n\t\t\tif ( hasAction && !this.hasListener ) {\n\t\t\t\tthis.listen();\n\t\t\t} else if ( !hasAction && this.hasListener ) {\n\t\t\t\tthis.unrender();\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/fire.js */\n\t\tvar virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {\n\t\n\t\t\treturn function EventHandler$fire( event ) {\n\t\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\t\tevent: event\n\t\t\t\t} );\n\t\t\t};\n\t\t}( Ractive$shared_fireEvent );\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/getAction.js */\n\t\tvar virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {\n\t\t\treturn this.action.toString().trim();\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/init.js */\n\t\tvar virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Fragment, getValueOptions = {\n\t\t\t\t\targs: true\n\t\t\t\t},\n\t\t\t\teventPattern = /^event(?:\\.(.+))?/;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\t__export = function EventHandler$init( element, name, template ) {\n\t\t\t\tvar handler = this,\n\t\t\t\t\taction, refs, ractive;\n\t\t\t\thandler.element = element;\n\t\t\t\thandler.root = element.root;\n\t\t\t\thandler.name = name;\n\t\t\t\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\tmessage: 'noElementProxyEventWildcards',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\telement: element.tagName,\n\t\t\t\t\t\t\tevent: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tthis.invalid = true;\n\t\t\t\t}\n\t\t\t\tif ( template.m ) {\n\t\t\t\t\trefs = template.a.r;\n\t\t\t\t\t// This is a method call\n\t\t\t\t\thandler.method = template.m;\n\t\t\t\t\thandler.keypaths = [];\n\t\t\t\t\thandler.fn = getFunctionFromString( template.a.s, refs.length );\n\t\t\t\t\thandler.parentFragment = element.parentFragment;\n\t\t\t\t\tractive = handler.root;\n\t\t\t\t\t// Create resolvers for each reference\n\t\t\t\t\thandler.refResolvers = refs.map( function( ref, i ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\t// special case - the `event` object\n\t\t\t\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\t\t\t\thandler.keypaths[ i ] = {\n\t\t\t\t\t\t\t\teventObject: true,\n\t\t\t\t\t\t\t\trefinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn createReferenceResolver( handler, ref, function( keypath ) {\n\t\t\t\t\t\t\thandler.resolve( i, keypath );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t\tthis.fire = fireMethodCall;\n\t\t\t\t} else {\n\t\t\t\t\t// Get action ('foo' in 'on-click='foo')\n\t\t\t\t\taction = template.n || template;\n\t\t\t\t\tif ( typeof action !== 'string' ) {\n\t\t\t\t\t\taction = new Fragment( {\n\t\t\t\t\t\t\ttemplate: action,\n\t\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\t\towner: this\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tthis.action = action;\n\t\t\t\t\t// Get parameters\n\t\t\t\t\tif ( template.d ) {\n\t\t\t\t\t\tthis.dynamicParams = new Fragment( {\n\t\t\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\t\towner: this.element\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t\t\t\t} else if ( template.a ) {\n\t\t\t\t\t\tthis.params = template.a;\n\t\t\t\t\t\tthis.fire = fireEventWithParams;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction fireMethodCall( event ) {\n\t\t\t\tvar ractive, values, args;\n\t\t\t\tractive = this.root;\n\t\t\t\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\t\t\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t\t\t\t}\n\t\t\t\tvalues = this.keypaths.map( function( keypath ) {\n\t\t\t\t\tvar value, len, i;\n\t\t\t\t\tif ( keypath === undefined ) {\n\t\t\t\t\t\t// not yet resolved\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO the refinements stuff would be better handled at parse time\n\t\t\t\t\tif ( keypath.eventObject ) {\n\t\t\t\t\t\tvalue = event;\n\t\t\t\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\t\t\tvalue = value[ keypath.refinements[ i ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t} );\n\t\t\t\tractive.event = event;\n\t\t\t\targs = this.fn.apply( null, values );\n\t\t\t\tractive[ this.method ].apply( ractive, args );\n\t\t\t\tdelete ractive.event;\n\t\t\t}\n\t\n\t\t\tfunction fireEventWithParams( event ) {\n\t\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\t\tevent: event,\n\t\t\t\t\targs: this.params\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tfunction fireEventWithDynamicParams( event ) {\n\t\t\t\tvar args = this.dynamicParams.getValue( getValueOptions );\n\t\t\t\t// need to strip [] from ends if a string!\n\t\t\t\tif ( typeof args === 'string' ) {\n\t\t\t\t\targs = args.substr( 1, args.length - 2 );\n\t\t\t\t}\n\t\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\t\tevent: event,\n\t\t\t\t\targs: args\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );\n\t\n\t\t/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */\n\t\tvar genericHandler = function genericHandler( event ) {\n\t\t\tvar storage, handler;\n\t\t\tstorage = this._ractive;\n\t\t\thandler = storage.events[ event.type ];\n\t\t\thandler.fire( {\n\t\t\t\tnode: this,\n\t\t\t\toriginal: event,\n\t\t\t\tindex: storage.index,\n\t\t\t\tkeypath: storage.keypath,\n\t\t\t\tcontext: storage.root.get( storage.keypath )\n\t\t\t} );\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/listen.js */\n\t\tvar virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar customHandlers = {},\n\t\t\t\ttouchEvents = {\n\t\t\t\t\ttouchstart: true,\n\t\t\t\t\ttouchmove: true,\n\t\t\t\t\ttouchend: true,\n\t\t\t\t\ttouchcancel: true,\n\t\t\t\t\t//not w3c, but supported in some browsers\n\t\t\t\t\ttouchleave: true\n\t\t\t\t};\n\t\t\t__export = function EventHandler$listen() {\n\t\t\t\tvar definition, name = this.name;\n\t\t\t\tif ( this.invalid ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( definition = config.registries.events.find( this.root, name ) ) {\n\t\t\t\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t\t\t\t} else {\n\t\t\t\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\t\t\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {\n\t\t\t\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\t\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\tplugin: 'event',\n\t\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.node.addEventListener( name, genericHandler, false );\n\t\t\t\t}\n\t\t\t\tthis.hasListener = true;\n\t\t\t};\n\t\n\t\t\tfunction getCustomHandler( name ) {\n\t\t\t\tif ( !customHandlers[ name ] ) {\n\t\t\t\t\tcustomHandlers[ name ] = function( event ) {\n\t\t\t\t\t\tvar storage = event.node._ractive;\n\t\t\t\t\t\tevent.index = storage.index;\n\t\t\t\t\t\tevent.keypath = storage.keypath;\n\t\t\t\t\t\tevent.context = storage.root.get( storage.keypath );\n\t\t\t\t\t\tstorage.events[ name ].fire( event );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn customHandlers[ name ];\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( config, genericHandler, log );\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/rebind.js */\n\t\tvar virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar fragment;\n\t\t\tif ( this.method ) {\n\t\t\t\tfragment = this.element.parentFragment;\n\t\t\t\tthis.refResolvers.forEach( rebind );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( typeof this.action !== 'string' ) {\n\t\t\t\trebind( this.action );\n\t\t\t}\n\t\t\tif ( this.dynamicParams ) {\n\t\t\t\trebind( this.dynamicParams );\n\t\t\t}\n\t\n\t\t\tfunction rebind( thing ) {\n\t\t\t\tthing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/render.js */\n\t\tvar virtualdom_items_Element_EventHandler$render = function EventHandler$render() {\n\t\t\tthis.node = this.element.node;\n\t\t\t// store this on the node itself, so it can be retrieved by a\n\t\t\t// universal handler\n\t\t\tthis.node._ractive.events[ this.name ] = this;\n\t\t\tif ( this.method || this.getAction() ) {\n\t\t\t\tthis.listen();\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/resolve.js */\n\t\tvar virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {\n\t\t\tthis.keypaths[ index ] = keypath;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/unbind.js */\n\t\tvar virtualdom_items_Element_EventHandler$unbind = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function EventHandler$unbind() {\n\t\t\t\tif ( this.method ) {\n\t\t\t\t\tthis.refResolvers.forEach( unbind );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Tear down dynamic name\n\t\t\t\tif ( typeof this.action !== 'string' ) {\n\t\t\t\t\tthis.action.unbind();\n\t\t\t\t}\n\t\t\t\t// Tear down dynamic parameters\n\t\t\t\tif ( this.dynamicParams ) {\n\t\t\t\t\tthis.dynamicParams.unbind();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction unbind( x ) {\n\t\t\t\tx.unbind();\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* virtualdom/items/Element/EventHandler/prototype/unrender.js */\n\t\tvar virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {\n\t\n\t\t\treturn function EventHandler$unrender() {\n\t\t\t\tif ( this.custom ) {\n\t\t\t\t\tthis.custom.teardown();\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t\t\t\t}\n\t\t\t\tthis.hasListener = false;\n\t\t\t};\n\t\t}( genericHandler );\n\t\n\t\t/* virtualdom/items/Element/EventHandler/_EventHandler.js */\n\t\tvar EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {\n\t\n\t\t\tvar EventHandler = function( element, name, template ) {\n\t\t\t\tthis.init( element, name, template );\n\t\t\t};\n\t\t\tEventHandler.prototype = {\n\t\t\t\tbubble: bubble,\n\t\t\t\tfire: fire,\n\t\t\t\tgetAction: getAction,\n\t\t\t\tinit: init,\n\t\t\t\tlisten: listen,\n\t\t\t\trebind: rebind,\n\t\t\t\trender: render,\n\t\t\t\tresolve: resolve,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender\n\t\t\t};\n\t\t\treturn EventHandler;\n\t\t}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );\n\t\n\t\t/* virtualdom/items/Element/prototype/init/createEventHandlers.js */\n\t\tvar virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {\n\t\n\t\t\treturn function( element, template ) {\n\t\t\t\tvar i, name, names, handler, result = [];\n\t\t\t\tfor ( name in template ) {\n\t\t\t\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\t\t\t\tnames = name.split( '-' );\n\t\t\t\t\t\ti = names.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\thandler = new EventHandler( element, names[ i ], template[ name ] );\n\t\t\t\t\t\t\tresult.push( handler );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}( EventHandler );\n\t\n\t\t/* virtualdom/items/Element/Decorator/_Decorator.js */\n\t\tvar Decorator = function( log, circular, config ) {\n\t\n\t\t\tvar Fragment, getValueOptions, Decorator;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tgetValueOptions = {\n\t\t\t\targs: true\n\t\t\t};\n\t\t\tDecorator = function( element, template ) {\n\t\t\t\tvar decorator = this,\n\t\t\t\t\tractive, name, fragment;\n\t\t\t\tdecorator.element = element;\n\t\t\t\tdecorator.root = ractive = element.root;\n\t\t\t\tname = template.n || template;\n\t\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\t\ttemplate: name,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: element\n\t\t\t\t\t} );\n\t\t\t\t\tname = fragment.toString();\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t}\n\t\t\t\tif ( template.a ) {\n\t\t\t\t\tdecorator.params = template.a;\n\t\t\t\t} else if ( template.d ) {\n\t\t\t\t\tdecorator.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: element\n\t\t\t\t\t} );\n\t\t\t\t\tdecorator.params = decorator.fragment.getValue( getValueOptions );\n\t\t\t\t\tdecorator.fragment.bubble = function() {\n\t\t\t\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\t\t\t\tdecorator.params = this.getValue( getValueOptions );\n\t\t\t\t\t\tif ( decorator.ready ) {\n\t\t\t\t\t\t\tdecorator.update();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tdecorator.fn = config.registries.decorators.find( ractive, name );\n\t\t\t\tif ( !decorator.fn ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tplugin: 'decorator',\n\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t\tDecorator.prototype = {\n\t\t\t\tinit: function() {\n\t\t\t\t\tvar decorator = this,\n\t\t\t\t\t\tnode, result, args;\n\t\t\t\t\tnode = decorator.element.node;\n\t\t\t\t\tif ( decorator.params ) {\n\t\t\t\t\t\targs = [ node ].concat( decorator.params );\n\t\t\t\t\t\tresult = decorator.fn.apply( decorator.root, args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = decorator.fn.call( decorator.root, node );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !result || !result.teardown ) {\n\t\t\t\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t\t\t\t}\n\t\t\t\t\t// TODO does this make sense?\n\t\t\t\t\tdecorator.actual = result;\n\t\t\t\t\tdecorator.ready = true;\n\t\t\t\t},\n\t\t\t\tupdate: function() {\n\t\t\t\t\tif ( this.actual.update ) {\n\t\t\t\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.actual.teardown( true );\n\t\t\t\t\t\tthis.init();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tteardown: function( updating ) {\n\t\t\t\t\tthis.actual.teardown();\n\t\t\t\t\tif ( !updating && this.fragment ) {\n\t\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Decorator;\n\t\t}( log, circular, config );\n\t\n\t\t/* virtualdom/items/Element/special/select/sync.js */\n\t\tvar sync = function( toArray ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function syncSelect( selectElement ) {\n\t\t\t\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\t\t\t\tselectNode = selectElement.node;\n\t\t\t\tif ( !selectNode ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\toptions = toArray( selectNode.options );\n\t\t\t\tselectValue = selectElement.getAttribute( 'value' );\n\t\t\t\tisMultiple = selectElement.getAttribute( 'multiple' );\n\t\t\t\t// If the <select> has a specified value, that should override\n\t\t\t\t// these options\n\t\t\t\tif ( selectValue !== undefined ) {\n\t\t\t\t\toptions.forEach( function( o ) {\n\t\t\t\t\t\tvar optionValue, shouldSelect;\n\t\t\t\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\t\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\t\t\t\t\t\tif ( shouldSelect ) {\n\t\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\to.selected = shouldSelect;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\t\tif ( options[ 0 ] ) {\n\t\t\t\t\t\t\toptions[ 0 ].selected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( selectElement.binding ) {\n\t\t\t\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ( selectElement.binding ) {\n\t\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction valueContains( selectValue, optionValue ) {\n\t\t\t\tvar i = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( toArray );\n\t\n\t\t/* virtualdom/items/Element/special/select/bubble.js */\n\t\tvar bubble = function( runloop, syncSelect ) {\n\t\n\t\t\treturn function bubbleSelect() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\tsyncSelect( this$0 );\n\t\t\t\t\t\tthis$0.dirty = false;\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t};\n\t\t}( runloop, sync );\n\t\n\t\t/* virtualdom/items/Element/special/option/findParentSelect.js */\n\t\tvar findParentSelect = function findParentSelect( element ) {\n\t\t\tdo {\n\t\t\t\tif ( element.name === 'select' ) {\n\t\t\t\t\treturn element;\n\t\t\t\t}\n\t\t\t} while ( element = element.parent );\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/special/option/init.js */\n\t\tvar init = function( findParentSelect ) {\n\t\n\t\t\treturn function initOption( option, template ) {\n\t\t\t\toption.select = findParentSelect( option.parent );\n\t\t\t\t// we might be inside a <datalist> element\n\t\t\t\tif ( !option.select ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\toption.select.options.push( option );\n\t\t\t\t// If the value attribute is missing, use the element's content\n\t\t\t\tif ( !template.a ) {\n\t\t\t\t\ttemplate.a = {};\n\t\t\t\t}\n\t\t\t\t// ...as long as it isn't disabled\n\t\t\t\tif ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\t\t\t\ttemplate.a.value = template.f;\n\t\t\t\t}\n\t\t\t\t// If there is a `selected` attribute, but the <select>\n\t\t\t\t// already has a value, delete it\n\t\t\t\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\tdelete template.a.selected;\n\t\t\t\t}\n\t\t\t};\n\t\t}( findParentSelect );\n\t\n\t\t/* virtualdom/items/Element/prototype/init.js */\n\t\tvar virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {\n\t\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\treturn function Element$init( options ) {\n\t\t\t\tvar parentFragment, template, ractive, binding, bindings;\n\t\t\t\tthis.type = types.ELEMENT;\n\t\t\t\t// stuff we'll need later\n\t\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\t\ttemplate = this.template = options.template;\n\t\t\t\tthis.parent = options.pElement || parentFragment.pElement;\n\t\t\t\tthis.root = ractive = parentFragment.root;\n\t\t\t\tthis.index = options.index;\n\t\t\t\tthis.name = enforceCase( template.e );\n\t\t\t\t// Special case - <option> elements\n\t\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t\tinitOption( this, template );\n\t\t\t\t}\n\t\t\t\t// Special case - <select> elements\n\t\t\t\tif ( this.name === 'select' ) {\n\t\t\t\t\tthis.options = [];\n\t\t\t\t\tthis.bubble = bubbleSelect;\n\t\t\t\t}\n\t\t\t\t// create attributes\n\t\t\t\tthis.attributes = createAttributes( this, template.a );\n\t\t\t\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\t\t\t\t// append children, if there are any\n\t\t\t\tif ( template.f ) {\n\t\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: template.f,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\tpElement: this\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// create twoway binding\n\t\t\t\tif ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\t\t\t\tthis.binding = binding;\n\t\t\t\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );\n\t\t\t\t\tbindings.push( binding );\n\t\t\t\t}\n\t\t\t\t// create event proxies\n\t\t\t\tif ( template.v ) {\n\t\t\t\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t\t\t\t}\n\t\t\t\t// create decorator\n\t\t\t\tif ( template.o ) {\n\t\t\t\t\tthis.decorator = new Decorator( this, template.o );\n\t\t\t\t}\n\t\t\t\t// create transitions\n\t\t\t\tthis.intro = template.t0 || template.t1;\n\t\t\t\tthis.outro = template.t0 || template.t2;\n\t\t\t};\n\t\t}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );\n\t\n\t\t/* virtualdom/items/shared/utils/startsWith.js */\n\t\tvar startsWith = function( startsWithKeypath ) {\n\t\n\t\t\treturn function startsWith( target, keypath ) {\n\t\t\t\treturn target === keypath || startsWithKeypath( target, keypath );\n\t\t\t};\n\t\t}( startsWithKeypath );\n\t\n\t\t/* virtualdom/items/shared/utils/assignNewKeypath.js */\n\t\tvar assignNewKeypath = function( startsWith, getNewKeypath ) {\n\t\n\t\t\treturn function assignNewKeypath( target, property, oldKeypath, newKeypath ) {\n\t\t\t\tvar existingKeypath = target[ property ];\n\t\t\t\tif ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttarget[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );\n\t\t\t};\n\t\t}( startsWith, getNewKeypath );\n\t\n\t\t/* virtualdom/items/Element/prototype/rebind.js */\n\t\tvar virtualdom_items_Element$rebind = function( assignNewKeypath ) {\n\t\n\t\t\treturn function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar i, storage, liveQueries, ractive;\n\t\t\t\tif ( this.attributes ) {\n\t\t\t\t\tthis.attributes.forEach( rebind );\n\t\t\t\t}\n\t\t\t\tif ( this.conditionalAttributes ) {\n\t\t\t\t\tthis.conditionalAttributes.forEach( rebind );\n\t\t\t\t}\n\t\t\t\tif ( this.eventHandlers ) {\n\t\t\t\t\tthis.eventHandlers.forEach( rebind );\n\t\t\t\t}\n\t\t\t\tif ( this.decorator ) {\n\t\t\t\t\trebind( this.decorator );\n\t\t\t\t}\n\t\t\t\t// rebind children\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\trebind( this.fragment );\n\t\t\t\t}\n\t\t\t\t// Update live queries, if necessary\n\t\t\t\tif ( liveQueries = this.liveQueries ) {\n\t\t\t\t\tractive = this.root;\n\t\t\t\t\ti = liveQueries.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tliveQueries[ i ]._makeDirty();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( this.node && ( storage = this.node._ractive ) ) {\n\t\t\t\t\t// adjust keypath if needed\n\t\t\t\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t\t\t\t\tif ( indexRef != undefined ) {\n\t\t\t\t\t\tstorage.index[ indexRef ] = newIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfunction rebind( thing ) {\n\t\t\t\t\tthing.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t};\n\t\t}( assignNewKeypath );\n\t\n\t\t/* virtualdom/items/Element/special/img/render.js */\n\t\tvar render = function renderImage( img ) {\n\t\t\tvar loadHandler;\n\t\t\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t\t\t// from overriding width and height when it loads the src\n\t\t\tif ( img.attributes.width || img.attributes.height ) {\n\t\t\t\timg.node.addEventListener( 'load', loadHandler = function() {\n\t\t\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\t\t\theight = img.getAttribute( 'height' );\n\t\t\t\t\tif ( width !== undefined ) {\n\t\t\t\t\t\timg.node.setAttribute( 'width', width );\n\t\t\t\t\t}\n\t\t\t\t\tif ( height !== undefined ) {\n\t\t\t\t\t\timg.node.setAttribute( 'height', height );\n\t\t\t\t\t}\n\t\t\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t\t\t}, false );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/init.js */\n\t\tvar virtualdom_items_Element_Transition$init = function( log, config, circular ) {\n\t\n\t\t\tvar Fragment, getValueOptions = {};\n\t\t\t// TODO what are the options?\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\treturn function Transition$init( element, template, isIntro ) {\n\t\t\t\tvar t = this,\n\t\t\t\t\tractive, name, fragment;\n\t\t\t\tt.element = element;\n\t\t\t\tt.root = ractive = element.root;\n\t\t\t\tt.isIntro = isIntro;\n\t\t\t\tname = template.n || template;\n\t\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\t\ttemplate: name,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: element\n\t\t\t\t\t} );\n\t\t\t\t\tname = fragment.toString();\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t}\n\t\t\t\tt.name = name;\n\t\t\t\tif ( template.a ) {\n\t\t\t\t\tt.params = template.a;\n\t\t\t\t} else if ( template.d ) {\n\t\t\t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t\t\t\t// 'dependency thrashing'?\n\t\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: element\n\t\t\t\t\t} );\n\t\t\t\t\tt.params = fragment.getValue( getValueOptions );\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t}\n\t\t\t\tt._fn = config.registries.transitions.find( ractive, name );\n\t\t\t\tif ( !t._fn ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tplugin: 'transition',\n\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t}( log, config, circular );\n\t\n\t\t/* utils/camelCase.js */\n\t\tvar camelCase = function( hyphenatedStr ) {\n\t\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {\n\t\t\t\treturn $1.toUpperCase();\n\t\t\t} );\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Transition/helpers/prefix.js */\n\t\tvar prefix = function( isClient, vendors, createElement, camelCase ) {\n\t\n\t\t\tvar prefix, prefixCache, testStyle;\n\t\t\tif ( !isClient ) {\n\t\t\t\tprefix = null;\n\t\t\t} else {\n\t\t\t\tprefixCache = {};\n\t\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\t\tprefix = function( prop ) {\n\t\t\t\t\tvar i, vendor, capped;\n\t\t\t\t\tprop = camelCase( prop );\n\t\t\t\t\tif ( !prefixCache[ prop ] ) {\n\t\t\t\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// test vendors...\n\t\t\t\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\t\t\t\t\t\t\ti = vendors.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn prefixCache[ prop ];\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn prefix;\n\t\t}( isClient, vendors, createElement, camelCase );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/getStyle.js */\n\t\tvar virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {\n\t\n\t\t\tvar getStyle, getComputedStyle;\n\t\t\tif ( !isClient ) {\n\t\t\t\tgetStyle = null;\n\t\t\t} else {\n\t\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\t\tgetStyle = function( props ) {\n\t\t\t\t\tvar computedStyle, styles, i, prop, value;\n\t\t\t\t\tcomputedStyle = getComputedStyle( this.node );\n\t\t\t\t\tif ( typeof props === 'string' ) {\n\t\t\t\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isArray( props ) ) {\n\t\t\t\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t\t\t\t}\n\t\t\t\t\tstyles = {};\n\t\t\t\t\ti = props.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = props[ i ];\n\t\t\t\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyles[ prop ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn styles;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn getStyle;\n\t\t}( legacy, isClient, isArray, prefix );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/setStyle.js */\n\t\tvar virtualdom_items_Element_Transition$setStyle = function( prefix ) {\n\t\n\t\t\treturn function( style, value ) {\n\t\t\t\tvar prop;\n\t\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\t\tthis.node.style[ prefix( style ) ] = value;\n\t\t\t\t} else {\n\t\t\t\t\tfor ( prop in style ) {\n\t\t\t\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}( prefix );\n\t\n\t\t/* shared/Ticker.js */\n\t\tvar Ticker = function( warn, getTime, animations ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Ticker = function( options ) {\n\t\t\t\tvar easing;\n\t\t\t\tthis.duration = options.duration;\n\t\t\t\tthis.step = options.step;\n\t\t\t\tthis.complete = options.complete;\n\t\t\t\t// easing\n\t\t\t\tif ( typeof options.easing === 'string' ) {\n\t\t\t\t\teasing = options.root.easing[ options.easing ];\n\t\t\t\t\tif ( !easing ) {\n\t\t\t\t\t\twarn( 'Missing easing function (\"' + options.easing + '\"). You may need to download a plugin from [TODO]' );\n\t\t\t\t\t\teasing = linear;\n\t\t\t\t\t}\n\t\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t\t\t\t\teasing = options.easing;\n\t\t\t\t} else {\n\t\t\t\t\teasing = linear;\n\t\t\t\t}\n\t\t\t\tthis.easing = easing;\n\t\t\t\tthis.start = getTime();\n\t\t\t\tthis.end = this.start + this.duration;\n\t\t\t\tthis.running = true;\n\t\t\t\tanimations.add( this );\n\t\t\t};\n\t\t\tTicker.prototype = {\n\t\t\t\ttick: function( now ) {\n\t\t\t\t\tvar elapsed, eased;\n\t\t\t\t\tif ( !this.running ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( now > this.end ) {\n\t\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\t\tthis.step( 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this.complete ) {\n\t\t\t\t\t\t\tthis.complete( 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telapsed = now - this.start;\n\t\t\t\t\teased = this.easing( elapsed / this.duration );\n\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\tthis.step( eased );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tstop: function() {\n\t\t\t\t\tif ( this.abort ) {\n\t\t\t\t\t\tthis.abort();\n\t\t\t\t\t}\n\t\t\t\t\tthis.running = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\t__export = Ticker;\n\t\n\t\t\tfunction linear( t ) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( warn, getTime, animations );\n\t\n\t\t/* virtualdom/items/Element/Transition/helpers/unprefix.js */\n\t\tvar unprefix = function( vendors ) {\n\t\n\t\t\tvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\t\t\treturn function( prop ) {\n\t\t\t\treturn prop.replace( unprefixPattern, '' );\n\t\t\t};\n\t\t}( vendors );\n\t\n\t\t/* virtualdom/items/Element/Transition/helpers/hyphenate.js */\n\t\tvar hyphenate = function( vendors ) {\n\t\n\t\t\tvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\t\t\treturn function( str ) {\n\t\t\t\tvar hyphenated;\n\t\t\t\tif ( !str ) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\tif ( vendorPattern.test( str ) ) {\n\t\t\t\t\tstr = '-' + str;\n\t\t\t\t}\n\t\t\t\thyphenated = str.replace( /[A-Z]/g, function( match ) {\n\t\t\t\t\treturn '-' + match.toLowerCase();\n\t\t\t\t} );\n\t\t\t\treturn hyphenated;\n\t\t\t};\n\t\t}( vendors );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */\n\t\tvar virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {\n\t\n\t\t\tvar createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},\n\t\t\t\tcannotUseCssTransitions = {};\n\t\t\tif ( !isClient ) {\n\t\t\t\tcreateTransitions = null;\n\t\t\t} else {\n\t\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\t\t// determine some facts about our environment\n\t\t\t\t( function() {\n\t\t\t\t\tif ( testStyle.transition !== undefined ) {\n\t\t\t\t\t\tTRANSITION = 'transition';\n\t\t\t\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\t\t\t\tTRANSITION = 'webkitTransition';\n\t\t\t\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t\t\t\t}\n\t\t\t\t}() );\n\t\t\t\tif ( TRANSITION ) {\n\t\t\t\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\t\t\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\t\t\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t\t\t\t}\n\t\t\t\tcreateTransitions = function( t, to, options, changedProperties, resolve ) {\n\t\t\t\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t\t\t\t// TODO use a fastdom-style mechanism?\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\t\t\t\t\t\tcheckComplete = function() {\n\t\t\t\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t\t\t\t// which properties\n\t\t\t\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\t\t\t\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\t\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\t\t\t\tt.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';\n\t\t\t\t\t\ttransitionEndHandler = function( event ) {\n\t\t\t\t\t\t\tvar index;\n\t\t\t\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t\t\t\t// still transitioning...\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\t\tvar i = changedProperties.length,\n\t\t\t\t\t\t\t\thash, originalValue, index, propertiesToTransitionInJs = [],\n\t\t\t\t\t\t\t\tprop, suffix;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = changedProperties[ i ];\n\t\t\t\t\t\t\t\thash = hashPrefix + prop;\n\t\t\t\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\t\t\t\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];\n\t\t\t\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\t\t\t\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\t\t\twarn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\t\t\t\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[ 0 ];\n\t\t\t\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\t\t\t\tpropertiesToTransitionInJs.push( {\n\t\t\t\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// javascript transitions\n\t\t\t\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\t\t\t\tnew Ticker( {\n\t\t\t\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\t\t\t\tstep: function( pos ) {\n\t\t\t\t\t\t\t\t\t\tvar prop, i;\n\t\t\t\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[ i ];\n\t\t\t\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 0 );\n\t\t\t\t\t}, options.delay || 0 );\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn createTransitions;\n\t\t}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */\n\t\tvar virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {\n\t\n\t\t\tvar hidden, vendor, prefix, i, visibility;\n\t\t\tif ( typeof document !== 'undefined' ) {\n\t\t\t\thidden = 'hidden';\n\t\t\t\tvisibility = {};\n\t\t\t\tif ( hidden in document ) {\n\t\t\t\t\tprefix = '';\n\t\t\t\t} else {\n\t\t\t\t\ti = vendors.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\t\thidden = vendor + 'Hidden';\n\t\t\t\t\t\tif ( hidden in document ) {\n\t\t\t\t\t\t\tprefix = vendor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( prefix !== undefined ) {\n\t\t\t\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\t\t\t\t\t// initialise\n\t\t\t\t\tonChange();\n\t\t\t\t} else {\n\t\t\t\t\t// gah, we're in an old browser\n\t\t\t\t\tif ( 'onfocusout' in document ) {\n\t\t\t\t\t\tdocument.addEventListener( 'focusout', onHide );\n\t\t\t\t\t\tdocument.addEventListener( 'focusin', onShow );\n\t\t\t\t\t} else {\n\t\t\t\t\t\twindow.addEventListener( 'pagehide', onHide );\n\t\t\t\t\t\twindow.addEventListener( 'blur', onHide );\n\t\t\t\t\t\twindow.addEventListener( 'pageshow', onShow );\n\t\t\t\t\t\twindow.addEventListener( 'focus', onShow );\n\t\t\t\t\t}\n\t\t\t\t\tvisibility.hidden = false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction onChange() {\n\t\t\t\tvisibility.hidden = document[ hidden ];\n\t\t\t}\n\t\n\t\t\tfunction onHide() {\n\t\t\t\tvisibility.hidden = true;\n\t\t\t}\n\t\n\t\t\tfunction onShow() {\n\t\t\t\tvisibility.hidden = false;\n\t\t\t}\n\t\t\treturn visibility;\n\t\t}( vendors );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */\n\t\tvar virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {\n\t\n\t\t\tvar animateStyle, getComputedStyle, resolved;\n\t\t\tif ( !isClient ) {\n\t\t\t\tanimateStyle = null;\n\t\t\t} else {\n\t\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\t\tanimateStyle = function( style, value, options, complete ) {\n\t\t\t\t\tvar t = this,\n\t\t\t\t\t\tto;\n\t\t\t\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t\t\t\t// that way you'll never get CSS transitionend events\n\t\t\t\t\tif ( visibility.hidden ) {\n\t\t\t\t\t\tthis.setStyle( style, value );\n\t\t\t\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\t\t\tto = {};\n\t\t\t\t\t\tto[ style ] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = style;\n\t\t\t\t\t\t// shuffle arguments\n\t\t\t\t\t\tcomplete = options;\n\t\t\t\t\t\toptions = value;\n\t\t\t\t\t}\n\t\t\t\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t\t\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t\t\t\t// callback function that gets called after the animation completes\n\t\t\t\t\t// TODO remove this check in a future version\n\t\t\t\t\tif ( !options ) {\n\t\t\t\t\t\twarn( 'The \"' + t.name + '\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );\n\t\t\t\t\t\toptions = t;\n\t\t\t\t\t\tcomplete = t.complete;\n\t\t\t\t\t}\n\t\t\t\t\tvar promise = new Promise( function( resolve ) {\n\t\t\t\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\t\t\t\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\t\t\t\tif ( !options.duration ) {\n\t\t\t\t\t\t\tt.setStyle( to );\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Get a list of the properties we're animating\n\t\t\t\t\t\tpropertyNames = Object.keys( to );\n\t\t\t\t\t\tchangedProperties = [];\n\t\t\t\t\t\t// Store the current styles\n\t\t\t\t\t\tcomputedStyle = getComputedStyle( t.node );\n\t\t\t\t\t\tfrom = {};\n\t\t\t\t\t\ti = propertyNames.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprop = propertyNames[ i ];\n\t\t\t\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\t\t\t\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\t\t\t\tif ( current != to[ prop ] ) {\n\t\t\t\t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\t\t\t\tchangedProperties.push( prop );\n\t\t\t\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = current;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t\t\t\t// will never fire! So we complete early\n\t\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreateTransitions( t, to, options, changedProperties, resolve );\n\t\t\t\t\t} );\n\t\t\t\t\t// If a callback was supplied, do the honours\n\t\t\t\t\t// TODO remove this check in future\n\t\t\t\t\tif ( complete ) {\n\t\t\t\t\t\twarn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );\n\t\t\t\t\t\tpromise.then( complete );\n\t\t\t\t\t}\n\t\t\t\t\treturn promise;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn animateStyle;\n\t\t}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );\n\t\n\t\t/* utils/fillGaps.js */\n\t\tvar fillGaps = function( target ) {\n\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\t\tsources.forEach( function( s ) {\n\t\t\t\tfor ( var key in s ) {\n\t\t\t\t\tif ( s.hasOwnProperty( key ) && !( key in target ) ) {\n\t\t\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn target;\n\t\t};\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/processParams.js */\n\t\tvar virtualdom_items_Element_Transition$processParams = function( fillGaps ) {\n\t\n\t\t\treturn function( params, defaults ) {\n\t\t\t\tif ( typeof params === 'number' ) {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: params\n\t\t\t\t\t};\n\t\t\t\t} else if ( typeof params === 'string' ) {\n\t\t\t\t\tif ( params === 'slow' ) {\n\t\t\t\t\t\tparams = {\n\t\t\t\t\t\t\tduration: 600\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ( params === 'fast' ) {\n\t\t\t\t\t\tparams = {\n\t\t\t\t\t\t\tduration: 200\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparams = {\n\t\t\t\t\t\t\tduration: 400\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else if ( !params ) {\n\t\t\t\t\tparams = {};\n\t\t\t\t}\n\t\t\t\treturn fillGaps( {}, params, defaults );\n\t\t\t};\n\t\t}( fillGaps );\n\t\n\t\t/* virtualdom/items/Element/Transition/prototype/start.js */\n\t\tvar virtualdom_items_Element_Transition$start = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Transition$start() {\n\t\t\t\tvar t = this,\n\t\t\t\t\tnode, originalStyle, completed;\n\t\t\t\tnode = t.node = t.element.node;\n\t\t\t\toriginalStyle = node.getAttribute( 'style' );\n\t\t\t\t// create t.complete() - we don't want this on the prototype,\n\t\t\t\t// because we don't want `this` silliness when passing it as\n\t\t\t\t// an argument\n\t\t\t\tt.complete = function( noReset ) {\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !noReset && t.isIntro ) {\n\t\t\t\t\t\tresetStyle( node, originalStyle );\n\t\t\t\t\t}\n\t\t\t\t\tnode._ractive.transition = null;\n\t\t\t\t\tt._manager.remove( t );\n\t\t\t\t\tcompleted = true;\n\t\t\t\t};\n\t\t\t\t// If the transition function doesn't exist, abort\n\t\t\t\tif ( !t._fn ) {\n\t\t\t\t\tt.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tt._fn.apply( t.root, [ t ].concat( t.params ) );\n\t\t\t};\n\t\n\t\t\tfunction resetStyle( node, style ) {\n\t\t\t\tif ( style ) {\n\t\t\t\t\tnode.setAttribute( 'style', style );\n\t\t\t\t} else {\n\t\t\t\t\t// Next line is necessary, to remove empty style attribute!\n\t\t\t\t\t// See http://stackoverflow.com/a/7167553\n\t\t\t\t\tnode.getAttribute( 'style' );\n\t\t\t\t\tnode.removeAttribute( 'style' );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* virtualdom/items/Element/Transition/_Transition.js */\n\t\tvar Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {\n\t\n\t\t\tvar Fragment, Transition;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tTransition = function( owner, template, isIntro ) {\n\t\t\t\tthis.init( owner, template, isIntro );\n\t\t\t};\n\t\t\tTransition.prototype = {\n\t\t\t\tinit: init,\n\t\t\t\tstart: start,\n\t\t\t\tgetStyle: getStyle,\n\t\t\t\tsetStyle: setStyle,\n\t\t\t\tanimateStyle: animateStyle,\n\t\t\t\tprocessParams: processParams\n\t\t\t};\n\t\t\treturn Transition;\n\t\t}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );\n\t\n\t\t/* virtualdom/items/Element/prototype/render.js */\n\t\tvar virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar updateCss, updateScript;\n\t\t\tupdateCss = function() {\n\t\t\t\tvar node = this.node,\n\t\t\t\t\tcontent = this.fragment.toString( false );\n\t\t\t\t// IE8 has no styleSheet unless there's a type text/css\n\t\t\t\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\t\t\t\tnode.type = 'text/css';\n\t\t\t\t}\n\t\t\t\tif ( node.styleSheet ) {\n\t\t\t\t\tnode.styleSheet.cssText = content;\n\t\t\t\t} else {\n\t\t\t\t\twhile ( node.hasChildNodes() ) {\n\t\t\t\t\t\tnode.removeChild( node.firstChild );\n\t\t\t\t\t}\n\t\t\t\t\tnode.appendChild( document.createTextNode( content ) );\n\t\t\t\t}\n\t\t\t};\n\t\t\tupdateScript = function() {\n\t\t\t\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\t\t\t\twarn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );\n\t\t\t\t}\n\t\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t\t};\n\t\t\t__export = function Element$render() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar root = this.root,\n\t\t\t\t\tnamespace, node;\n\t\t\t\tnamespace = getNamespace( this );\n\t\t\t\tnode = this.node = createElement( this.name, namespace );\n\t\t\t\t// Is this a top-level node of a component? If so, we may need to add\n\t\t\t\t// a data-rvcguid attribute, for CSS encapsulation\n\t\t\t\t// NOTE: css no longer copied to instance, so we check constructor.css -\n\t\t\t\t// we can enhance to handle instance, but this is more \"correct\" with current\n\t\t\t\t// functionality\n\t\t\t\tif ( root.constructor.css && this.parentFragment.getNode() === root.el ) {\n\t\t\t\t\tthis.node.setAttribute( 'data-rvcguid', root.constructor._guid );\n\t\t\t\t}\n\t\t\t\t// Add _ractive property to the node - we use this object to store stuff\n\t\t\t\t// related to proxy events, two-way bindings etc\n\t\t\t\tdefineProperty( this.node, '_ractive', {\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tproxy: this,\n\t\t\t\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\t\t\t\tindex: this.parentFragment.indexRefs,\n\t\t\t\t\t\tevents: create( null ),\n\t\t\t\t\t\troot: root\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\t// Render attributes\n\t\t\t\tthis.attributes.forEach( function( a ) {\n\t\t\t\t\treturn a.render( node );\n\t\t\t\t} );\n\t\t\t\tthis.conditionalAttributes.forEach( function( a ) {\n\t\t\t\t\treturn a.render( node );\n\t\t\t\t} );\n\t\t\t\t// Render children\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t// Special case - <script> element\n\t\t\t\t\tif ( this.name === 'script' ) {\n\t\t\t\t\t\tthis.bubble = updateScript;\n\t\t\t\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t\t\t\t\t// bypass warning initially\n\t\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t\t} else if ( this.name === 'style' ) {\n\t\t\t\t\t\tthis.bubble = updateCss;\n\t\t\t\t\t\tthis.bubble();\n\t\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t\t} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Add proxy event handlers\n\t\t\t\tif ( this.eventHandlers ) {\n\t\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\t\treturn h.render();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// deal with two-way bindings\n\t\t\t\tif ( this.binding ) {\n\t\t\t\t\tthis.binding.render();\n\t\t\t\t\tthis.node._ractive.binding = this.binding;\n\t\t\t\t}\n\t\t\t\t// Special case: if this is an <img>, and we're in a crap browser, we may\n\t\t\t\t// need to prevent it from overriding width and height when it loads the src\n\t\t\t\tif ( this.name === 'img' ) {\n\t\t\t\t\trenderImage( this );\n\t\t\t\t}\n\t\t\t\t// apply decorator(s)\n\t\t\t\tif ( this.decorator && this.decorator.fn ) {\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.decorator.init();\n\t\t\t\t\t}, true );\n\t\t\t\t}\n\t\t\t\t// trigger intro transition\n\t\t\t\tif ( root.transitionsEnabled && this.intro ) {\n\t\t\t\t\tvar transition = new Transition( this, this.intro, true );\n\t\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn transition.start();\n\t\t\t\t\t}, true );\n\t\t\t\t\tthis.transition = transition;\n\t\t\t\t}\n\t\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t\tprocessOption( this );\n\t\t\t\t}\n\t\t\t\tif ( this.node.autofocus ) {\n\t\t\t\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t\t\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t\t\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.node.focus();\n\t\t\t\t\t}, true );\n\t\t\t\t}\n\t\t\t\tupdateLiveQueries( this );\n\t\t\t\treturn this.node;\n\t\t\t};\n\t\n\t\t\tfunction getNamespace( element ) {\n\t\t\t\tvar namespace, xmlns, parent;\n\t\t\t\t// Use specified namespace...\n\t\t\t\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\t\t\t\tnamespace = xmlns;\n\t\t\t\t} else if ( element.name === 'svg' ) {\n\t\t\t\t\tnamespace = namespaces.svg;\n\t\t\t\t} else if ( parent = element.parent ) {\n\t\t\t\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\t\t\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\t\t\t\tnamespace = namespaces.html;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnamespace = parent.node.namespaceURI;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnamespace = element.root.el.namespaceURI;\n\t\t\t\t}\n\t\t\t\treturn namespace;\n\t\t\t}\n\t\n\t\t\tfunction processOption( option ) {\n\t\t\t\tvar optionValue, selectValue, i;\n\t\t\t\tif ( !option.select ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tselectValue = option.select.getAttribute( 'value' );\n\t\t\t\tif ( selectValue === undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\toptionValue = option.getAttribute( 'value' );\n\t\t\t\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\t\t\t\ti = selectValue.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( optionValue == selectValue[ i ] ) {\n\t\t\t\t\t\t\toption.node.selected = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toption.node.selected = optionValue == selectValue;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction updateLiveQueries( element ) {\n\t\t\t\tvar instance, liveQueries, i, selector, query;\n\t\t\t\t// Does this need to be added to any live queries?\n\t\t\t\tinstance = element.root;\n\t\t\t\tdo {\n\t\t\t\t\tliveQueries = instance._liveQueries;\n\t\t\t\t\ti = liveQueries.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tselector = liveQueries[ i ];\n\t\t\t\t\t\tquery = liveQueries[ '_' + selector ];\n\t\t\t\t\t\tif ( query._test( element ) ) {\n\t\t\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while ( instance = instance._parent );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );\n\t\n\t\t/* virtualdom/items/Element/prototype/toString.js */\n\t\tvar virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function() {\n\t\t\t\tvar str, escape;\n\t\t\t\tstr = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );\n\t\t\t\tstr += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\t\t\t\t// Special case - selected options\n\t\t\t\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\t\t\t\tstr += ' selected';\n\t\t\t\t}\n\t\t\t\t// Special case - two-way radio name bindings\n\t\t\t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\t\t\t\tstr += ' checked';\n\t\t\t\t}\n\t\t\t\tstr += '>';\n\t\t\t\t// Special case - textarea\n\t\t\t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t\t\t\t} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\t\tstr += this.getAttribute( 'value' );\n\t\t\t\t}\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tescape = this.name !== 'script' && this.name !== 'style';\n\t\t\t\t\tstr += this.fragment.toString( escape );\n\t\t\t\t}\n\t\t\t\t// add a closing tag if this isn't a void element\n\t\t\t\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\t\t\t\tstr += '</' + this.template.e + '>';\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t};\n\t\n\t\t\tfunction optionIsSelected( element ) {\n\t\t\t\tvar optionValue, selectValue, i;\n\t\t\t\toptionValue = element.getAttribute( 'value' );\n\t\t\t\tif ( optionValue === undefined || !element.select ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tselectValue = element.select.getAttribute( 'value' );\n\t\t\t\tif ( selectValue == optionValue ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\t\t\t\ti = selectValue.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction inputIsCheckedRadio( element ) {\n\t\t\t\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\t\t\t\tattributes = element.attributes;\n\t\t\t\ttypeAttribute = attributes.type;\n\t\t\t\tvalueAttribute = attributes.value;\n\t\t\t\tnameAttribute = attributes.name;\n\t\t\t\tif ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction stringifyAttribute( attribute ) {\n\t\t\t\tvar str = attribute.toString();\n\t\t\t\treturn str ? ' ' + str : '';\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( voidElementNames, isArray, escapeHtml );\n\t\n\t\t/* virtualdom/items/Element/special/option/unbind.js */\n\t\tvar virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {\n\t\n\t\t\treturn function unbindOption( option ) {\n\t\t\t\tif ( option.select ) {\n\t\t\t\t\tremoveFromArray( option.select.options, option );\n\t\t\t\t}\n\t\t\t};\n\t\t}( removeFromArray );\n\t\n\t\t/* virtualdom/items/Element/prototype/unbind.js */\n\t\tvar virtualdom_items_Element$unbind = function( unbindOption ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Element$unbind() {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t\tif ( this.binding ) {\n\t\t\t\t\tthis.binding.unbind();\n\t\t\t\t}\n\t\t\t\tif ( this.eventHandlers ) {\n\t\t\t\t\tthis.eventHandlers.forEach( unbind );\n\t\t\t\t}\n\t\t\t\t// Special case - <option>\n\t\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t\tunbindOption( this );\n\t\t\t\t}\n\t\t\t\tthis.attributes.forEach( unbind );\n\t\t\t\tthis.conditionalAttributes.forEach( unbind );\n\t\t\t};\n\t\n\t\t\tfunction unbind( x ) {\n\t\t\t\tx.unbind();\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( virtualdom_items_Element_special_option_unbind );\n\t\n\t\t/* virtualdom/items/Element/prototype/unrender.js */\n\t\tvar virtualdom_items_Element$unrender = function( runloop, Transition ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Element$unrender( shouldDestroy ) {\n\t\t\t\tvar binding, bindings;\n\t\t\t\tif ( this.transition ) {\n\t\t\t\t\tthis.transition.complete();\n\t\t\t\t}\n\t\t\t\t// Detach as soon as we can\n\t\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t\t// <option> elements detach immediately, so that\n\t\t\t\t\t// their parent <select> element syncs correctly, and\n\t\t\t\t\t// since option elements can't have transitions anyway\n\t\t\t\t\tthis.detach();\n\t\t\t\t} else if ( shouldDestroy ) {\n\t\t\t\t\trunloop.detachWhenReady( this );\n\t\t\t\t}\n\t\t\t\t// Children first. that way, any transitions on child elements will be\n\t\t\t\t// handled by the current transitionManager\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unrender( false );\n\t\t\t\t}\n\t\t\t\tif ( binding = this.binding ) {\n\t\t\t\t\tthis.binding.unrender();\n\t\t\t\t\tthis.node._ractive.binding = null;\n\t\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ];\n\t\t\t\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t\t\t\t}\n\t\t\t\t// Remove event handlers\n\t\t\t\tif ( this.eventHandlers ) {\n\t\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\t\treturn h.unrender();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tif ( this.decorator ) {\n\t\t\t\t\tthis.decorator.teardown();\n\t\t\t\t}\n\t\t\t\t// trigger outro transition if necessary\n\t\t\t\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\t\t\t\tvar transition = new Transition( this, this.outro, false );\n\t\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn transition.start();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// Remove this node from any live queries\n\t\t\t\tif ( this.liveQueries ) {\n\t\t\t\t\tremoveFromLiveQueries( this );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction removeFromLiveQueries( element ) {\n\t\t\t\tvar query, selector, i;\n\t\t\t\ti = element.liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tquery = element.liveQueries[ i ];\n\t\t\t\t\tselector = query.selector;\n\t\t\t\t\tquery._remove( element.node );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( runloop, Transition );\n\t\n\t\t/* virtualdom/items/Element/_Element.js */\n\t\tvar Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {\n\t\n\t\t\tvar Element = function( options ) {\n\t\t\t\tthis.init( options );\n\t\t\t};\n\t\t\tElement.prototype = {\n\t\t\t\tbubble: bubble,\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfindAllComponents: findAllComponents,\n\t\t\t\tfindComponent: findComponent,\n\t\t\t\tfindNextNode: findNextNode,\n\t\t\t\tfirstNode: firstNode,\n\t\t\t\tgetAttribute: getAttribute,\n\t\t\t\tinit: init,\n\t\t\t\trebind: rebind,\n\t\t\t\trender: render,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender\n\t\t\t};\n\t\t\treturn Element;\n\t\t}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );\n\t\n\t\t/* virtualdom/items/Partial/deIndent.js */\n\t\tvar deIndent = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar empty = /^\\s*$/,\n\t\t\t\tleadingWhitespace = /^\\s*/;\n\t\t\t__export = function( str ) {\n\t\t\t\tvar lines, firstLine, lastLine, minIndent;\n\t\t\t\tlines = str.split( '\\n' );\n\t\t\t\t// remove first and last line, if they only contain whitespace\n\t\t\t\tfirstLine = lines[ 0 ];\n\t\t\t\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\t\t\t\tlines.shift();\n\t\t\t\t}\n\t\t\t\tlastLine = lines[ lines.length - 1 ];\n\t\t\t\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\t\t\t\tlines.pop();\n\t\t\t\t}\n\t\t\t\tminIndent = lines.reduce( reducer, null );\n\t\t\t\tif ( minIndent ) {\n\t\t\t\t\tstr = lines.map( function( line ) {\n\t\t\t\t\t\treturn line.replace( minIndent, '' );\n\t\t\t\t\t} ).join( '\\n' );\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t};\n\t\n\t\t\tfunction reducer( previous, line ) {\n\t\t\t\tvar lineIndent = leadingWhitespace.exec( line )[ 0 ];\n\t\t\t\tif ( previous === null || lineIndent.length < previous.length ) {\n\t\t\t\t\treturn lineIndent;\n\t\t\t\t}\n\t\t\t\treturn previous;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* virtualdom/items/Partial/getPartialTemplate.js */\n\t\tvar getPartialTemplate = function( log, config, parser, deIndent ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function getPartialTemplate( ractive, name ) {\n\t\t\t\tvar partial;\n\t\t\t\t// If the partial in instance or view heirarchy instances, great\n\t\t\t\tif ( partial = getPartialFromRegistry( ractive, name ) ) {\n\t\t\t\t\treturn partial;\n\t\t\t\t}\n\t\t\t\t// Does it exist on the page as a script tag?\n\t\t\t\tpartial = parser.fromId( name, {\n\t\t\t\t\tnoThrow: true\n\t\t\t\t} );\n\t\t\t\tif ( partial ) {\n\t\t\t\t\t// is this necessary?\n\t\t\t\t\tpartial = deIndent( partial );\n\t\t\t\t\t// parse and register to this ractive instance\n\t\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t\t\t\t\t// register (and return main partial if there are others in the template)\n\t\t\t\t\treturn ractive.partials[ name ] = parsed.t;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction getPartialFromRegistry( ractive, name ) {\n\t\t\t\tvar partials = config.registries.partials;\n\t\t\t\t// find first instance in the ractive or view hierarchy that has this partial\n\t\t\t\tvar instance = partials.findInstance( ractive, name );\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar partial = instance.partials[ name ],\n\t\t\t\t\tfn;\n\t\t\t\t// partial is a function?\n\t\t\t\tif ( typeof partial === 'function' ) {\n\t\t\t\t\tfn = partial.bind( instance );\n\t\t\t\t\tfn.isOwner = instance.partials.hasOwnProperty( name );\n\t\t\t\t\tpartial = fn( instance.data, parser );\n\t\t\t\t}\n\t\t\t\tif ( !partial ) {\n\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tregistry: 'partial',\n\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// If this was added manually to the registry,\n\t\t\t\t// but hasn't been parsed, parse it now\n\t\t\t\tif ( !parser.isParsed( partial ) ) {\n\t\t\t\t\t// use the parseOptions of the ractive instance on which it was found\n\t\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\t\t\t\t\t// Partials cannot contain nested partials!\n\t\t\t\t\t// TODO add a test for this\n\t\t\t\t\tif ( parsed.p ) {\n\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\tmessage: 'noNestedPartials',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\trname: name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t\t\t\t// in the correct point in prototype chain on instance or constructor\n\t\t\t\t\tvar target = fn ? instance : partials.findOwner( instance, name );\n\t\t\t\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\t\t\t\ttarget.partials[ name ] = partial = parsed.t;\n\t\t\t\t}\n\t\t\t\t// store for reset\n\t\t\t\tif ( fn ) {\n\t\t\t\t\tpartial._fn = fn;\n\t\t\t\t}\n\t\t\t\treturn partial.v ? partial.t : partial;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( log, config, parser, deIndent );\n\t\n\t\t/* virtualdom/items/Partial/applyIndent.js */\n\t\tvar applyIndent = function( string, indent ) {\n\t\t\tvar indented;\n\t\t\tif ( !indent ) {\n\t\t\t\treturn string;\n\t\t\t}\n\t\t\tindented = string.split( '\\n' ).map( function( line, notFirstLine ) {\n\t\t\t\treturn notFirstLine ? indent + line : line;\n\t\t\t} ).join( '\\n' );\n\t\t\treturn indented;\n\t\t};\n\t\n\t\t/* virtualdom/items/Partial/_Partial.js */\n\t\tvar Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {\n\t\n\t\t\tvar Partial, Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tPartial = function( options ) {\n\t\t\t\tvar parentFragment, template;\n\t\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\t\tthis.root = parentFragment.root;\n\t\t\t\tthis.type = types.PARTIAL;\n\t\t\t\tthis.index = options.index;\n\t\t\t\tthis.name = options.template.r;\n\t\t\t\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\t\t\t\tMustache.init( this, options );\n\t\t\t\t// If this didn't resolve, it most likely means we have a named partial\n\t\t\t\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t\t\t\t// whose name is the value of `foo`')\n\t\t\t\tif ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\t\tunbind.call( this );\n\t\t\t\t\t// prevent any further changes\n\t\t\t\t\tthis.isNamed = true;\n\t\t\t\t\tthis.setTemplate( template );\n\t\t\t\t}\n\t\t\t};\n\t\t\tPartial.prototype = {\n\t\t\t\tbubble: function() {\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t},\n\t\t\t\tdetach: function() {\n\t\t\t\t\treturn this.fragment.detach();\n\t\t\t\t},\n\t\t\t\tfind: function( selector ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t},\n\t\t\t\tfindAll: function( selector, query ) {\n\t\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t\t},\n\t\t\t\tfindComponent: function( selector ) {\n\t\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t\t},\n\t\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t\t},\n\t\t\t\tfirstNode: function() {\n\t\t\t\t\treturn this.fragment.firstNode();\n\t\t\t\t},\n\t\t\t\tfindNextNode: function() {\n\t\t\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t\t\t},\n\t\t\t\tgetValue: function() {\n\t\t\t\t\treturn this.fragment.getValue();\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\trebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.rendered = true;\n\t\t\t\t\treturn this.docFrag;\n\t\t\t\t},\n\t\t\t\tresolve: Mustache.resolve,\n\t\t\t\tsetValue: function( value ) {\n\t\t\t\t\tvar template;\n\t\t\t\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t\t\t\t// nothing has changed, so no work to be done\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttemplate = getPartialTemplate( this.root, '' + value );\n\t\t\t\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t\t\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t\t\t\t// and a partial. In those cases, this becomes a named partial\n\t\t\t\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\t\t\tunbind.call( this );\n\t\t\t\t\t\tthis.isNamed = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !template ) {\n\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\t\tmessage: 'noTemplateForPartial',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tname: this.name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tthis.setTemplate( template || [] );\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.bubble();\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetTemplate: function( template ) {\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t\t\t}\n\t\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: template,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\tpElement: this.parentFragment.pElement\n\t\t\t\t\t} );\n\t\t\t\t\tthis.fragmentToRender = this.fragment;\n\t\t\t\t},\n\t\t\t\ttoString: function( toString ) {\n\t\t\t\t\tvar string, previousItem, lastLine, match;\n\t\t\t\t\tstring = this.fragment.toString( toString );\n\t\t\t\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\t\t\t\t\tif ( !previousItem || previousItem.type !== types.TEXT ) {\n\t\t\t\t\t\treturn string;\n\t\t\t\t\t}\n\t\t\t\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\t\t\t\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\t\t\t\treturn applyIndent( string, match[ 0 ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn string;\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tif ( !this.isNamed ) {\n\t\t\t\t\t\t// dynamic partial - need to unbind self\n\t\t\t\t\t\tunbind.call( this );\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.rendered = false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdate: function() {\n\t\t\t\t\tvar target, anchor;\n\t\t\t\t\tif ( this.fragmentToUnrender ) {\n\t\t\t\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\t\t\t\tthis.fragmentToUnrender = null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.fragmentToRender ) {\n\t\t\t\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\t\t\t\tthis.fragmentToRender = null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\ttarget = this.parentFragment.getNode();\n\t\t\t\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Partial;\n\t\t}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );\n\t\n\t\t/* virtualdom/items/Component/getComponent.js */\n\t\tvar getComponent = function( config, log, circular ) {\n\t\n\t\t\tvar Ractive;\n\t\t\tcircular.push( function() {\n\t\t\t\tRactive = circular.Ractive;\n\t\t\t} );\n\t\t\t// finds the component constructor in the registry or view hierarchy registries\n\t\t\treturn function getComponent( ractive, name ) {\n\t\t\t\tvar component, instance = config.registries.components.findInstance( ractive, name );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tcomponent = instance.components[ name ];\n\t\t\t\t\t// best test we have for not Ractive.extend\n\t\t\t\t\tif ( !component._parent ) {\n\t\t\t\t\t\t// function option, execute and store for reset\n\t\t\t\t\t\tvar fn = component.bind( instance );\n\t\t\t\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\t\t\t\tcomponent = fn( instance.data );\n\t\t\t\t\t\tif ( !component ) {\n\t\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\tregistry: 'component',\n\t\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( typeof component === 'string' ) {\n\t\t\t\t\t\t\t//allow string lookup\n\t\t\t\t\t\t\tcomponent = getComponent( ractive, component );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomponent._fn = fn;\n\t\t\t\t\t\tinstance.components[ name ] = component;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn component;\n\t\t\t};\n\t\t}( config, log, circular );\n\t\n\t\t/* virtualdom/items/Component/prototype/detach.js */\n\t\tvar virtualdom_items_Component$detach = function( Hook ) {\n\t\n\t\t\tvar detachHook = new Hook( 'detach' );\n\t\t\treturn function Component$detach() {\n\t\t\t\tvar detached = this.instance.fragment.detach();\n\t\t\t\tdetachHook.fire( this.instance );\n\t\t\t\treturn detached;\n\t\t\t};\n\t\t}( Ractive$shared_hooks_Hook );\n\t\n\t\t/* virtualdom/items/Component/prototype/find.js */\n\t\tvar virtualdom_items_Component$find = function Component$find( selector ) {\n\t\t\treturn this.instance.fragment.find( selector );\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/findAll.js */\n\t\tvar virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {\n\t\t\treturn this.instance.fragment.findAll( selector, query );\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/findAllComponents.js */\n\t\tvar virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {\n\t\t\tquery._test( this, true );\n\t\t\tif ( this.instance.fragment ) {\n\t\t\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/findComponent.js */\n\t\tvar virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {\n\t\t\tif ( !selector || selector === this.name ) {\n\t\t\t\treturn this.instance;\n\t\t\t}\n\t\t\tif ( this.instance.fragment ) {\n\t\t\t\treturn this.instance.fragment.findComponent( selector );\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/findNextNode.js */\n\t\tvar virtualdom_items_Component$findNextNode = function Component$findNextNode() {\n\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/firstNode.js */\n\t\tvar virtualdom_items_Component$firstNode = function Component$firstNode() {\n\t\t\tif ( this.rendered ) {\n\t\t\t\treturn this.instance.fragment.firstNode();\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */\n\t\tvar ComponentParameter = function( runloop, circular ) {\n\t\n\t\t\tvar Fragment, ComponentParameter;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tComponentParameter = function( component, key, value ) {\n\t\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\t\tthis.component = component;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: value,\n\t\t\t\t\troot: component.root,\n\t\t\t\t\towner: this\n\t\t\t\t} );\n\t\t\t\tthis.value = this.fragment.getValue();\n\t\t\t};\n\t\t\tComponentParameter.prototype = {\n\t\t\t\tbubble: function() {\n\t\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdate: function() {\n\t\t\t\t\tvar value = this.fragment.getValue();\n\t\t\t\t\tthis.component.instance.viewmodel.set( this.key, value );\n\t\t\t\t\trunloop.addViewmodel( this.component.instance.viewmodel );\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn ComponentParameter;\n\t\t}( runloop, circular );\n\t\n\t\t/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */\n\t\tvar ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {\n\t\n\t\t\tvar ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tthis.root = component.root;\n\t\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\t\tthis.ready = false;\n\t\t\t\tthis.hash = null;\n\t\t\t\tthis.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {\n\t\t\t\t\t// Are we updating an existing binding?\n\t\t\t\t\tif ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {\n\t\t\t\t\t\tcomponent.bindings[ this$0.hash ] = null;\n\t\t\t\t\t\tthis$0.binding.rebind( keypath );\n\t\t\t\t\t\tthis$0.hash = keypath + '=' + childKeypath;\n\t\t\t\t\t\tcomponent.bindings[ this$0.hash ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !this$0.ready ) {\n\t\t\t\t\t\t\t// The child instance isn't created yet, we need to create the binding later\n\t\t\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\t\t\tchildKeypath: childKeypath,\n\t\t\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcreateComponentBinding( component, component.root, keypath, childKeypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis$0.value = component.root.viewmodel.get( keypath );\n\t\t\t\t} );\n\t\t\t};\n\t\t\tReferenceExpressionParameter.prototype = {\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.resolver.unbind();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn ReferenceExpressionParameter;\n\t\t}( ReferenceExpressionResolver, createComponentBinding );\n\t\n\t\t/* virtualdom/items/Component/initialise/createModel/_createModel.js */\n\t\tvar createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function( component, defaultData, attributes, toBind ) {\n\t\t\t\tvar data = {},\n\t\t\t\t\tkey, value;\n\t\t\t\t// some parameters, e.g. foo=\"The value is {{bar}}\", are 'complex' - in\n\t\t\t\t// other words, we need to construct a string fragment to watch\n\t\t\t\t// when they change. We store these so they can be torn down later\n\t\t\t\tcomponent.complexParameters = [];\n\t\t\t\tfor ( key in attributes ) {\n\t\t\t\t\tif ( attributes.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tvalue = getValue( component, key, attributes[ key ], toBind );\n\t\t\t\t\t\tif ( value !== undefined || defaultData[ key ] === undefined ) {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t};\n\t\n\t\t\tfunction getValue( component, key, template, toBind ) {\n\t\t\t\tvar parameter, parsed, parentInstance, parentFragment, keypath, indexRef;\n\t\t\t\tparentInstance = component.root;\n\t\t\t\tparentFragment = component.parentFragment;\n\t\t\t\t// If this is a static value, great\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\tparsed = parseJSON( template );\n\t\t\t\t\tif ( !parsed ) {\n\t\t\t\t\t\treturn template;\n\t\t\t\t\t}\n\t\t\t\t\treturn parsed.value;\n\t\t\t\t}\n\t\t\t\t// If null, we treat it as a boolean attribute (i.e. true)\n\t\t\t\tif ( template === null ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// Single interpolator?\n\t\t\t\tif ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {\n\t\t\t\t\t// If it's a regular interpolator, we bind to it\n\t\t\t\t\tif ( template[ 0 ].r ) {\n\t\t\t\t\t\t// Is it an index reference?\n\t\t\t\t\t\tif ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {\n\t\t\t\t\t\t\tcomponent.indexRefBindings[ indexRef ] = key;\n\t\t\t\t\t\t\treturn parentFragment.indexRefs[ indexRef ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO what about references that resolve late? Should these be considered?\n\t\t\t\t\t\tkeypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;\n\t\t\t\t\t\t// We need to set up bindings between parent and child, but\n\t\t\t\t\t\t// we can't do it yet because the child instance doesn't exist\n\t\t\t\t\t\t// yet - so we make a note instead\n\t\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\t\tchildKeypath: key,\n\t\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn parentInstance.viewmodel.get( keypath );\n\t\t\t\t\t}\n\t\t\t\t\t// If it's a reference expression (e.g. `{{foo[bar]}}`), we need\n\t\t\t\t\t// to watch the keypath and create/destroy bindings\n\t\t\t\t\tif ( template[ 0 ].rx ) {\n\t\t\t\t\t\tparameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );\n\t\t\t\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\t\t\t\tparameter.ready = true;\n\t\t\t\t\t\treturn parameter.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// We have a 'complex parameter' - we need to create a full-blown string\n\t\t\t\t// fragment in order to evaluate and observe its value\n\t\t\t\tparameter = new ComponentParameter( component, key, template );\n\t\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\t\treturn parameter.value;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );\n\t\n\t\t/* virtualdom/items/Component/initialise/createInstance.js */\n\t\tvar createInstance = function( log ) {\n\t\n\t\t\treturn function( component, Component, data, contentDescriptor ) {\n\t\t\t\tvar instance, parentFragment, partials, ractive;\n\t\t\t\tparentFragment = component.parentFragment;\n\t\t\t\tractive = component.root;\n\t\t\t\t// Make contents available as a {{>content}} partial\n\t\t\t\tpartials = {\n\t\t\t\t\tcontent: contentDescriptor || []\n\t\t\t\t};\n\t\t\t\tif ( Component.defaults.el ) {\n\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'defaultElSpecified',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tname: component.name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tinstance = new Component( {\n\t\t\t\t\tel: null,\n\t\t\t\t\tappend: true,\n\t\t\t\t\tdata: data,\n\t\t\t\t\tpartials: partials,\n\t\t\t\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\t\t\t\tmodifyArrays: ractive.modifyArrays,\n\t\t\t\t\t_parent: ractive,\n\t\t\t\t\t_component: component,\n\t\t\t\t\t// need to inherit runtime parent adaptors\n\t\t\t\t\tadapt: ractive.adapt,\n\t\t\t\t\tyield: {\n\t\t\t\t\t\ttemplate: contentDescriptor,\n\t\t\t\t\t\tinstance: ractive\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn instance;\n\t\t\t};\n\t\t}( log );\n\t\n\t\t/* virtualdom/items/Component/initialise/createBindings.js */\n\t\tvar createBindings = function( createComponentBinding ) {\n\t\n\t\t\treturn function createInitialComponentBindings( component, toBind ) {\n\t\t\t\ttoBind.forEach( function createInitialComponentBinding( pair ) {\n\t\t\t\t\tvar childValue, parentValue;\n\t\t\t\t\tcreateComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );\n\t\t\t\t\tchildValue = component.instance.viewmodel.get( pair.childKeypath );\n\t\t\t\t\tparentValue = component.root.viewmodel.get( pair.parentKeypath );\n\t\t\t\t\tif ( childValue !== undefined && parentValue === undefined ) {\n\t\t\t\t\t\tcomponent.root.viewmodel.set( pair.parentKeypath, childValue );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t}( createComponentBinding );\n\t\n\t\t/* virtualdom/items/Component/initialise/propagateEvents.js */\n\t\tvar propagateEvents = function( circular, fireEvent, log ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\t__export = function propagateEvents( component, eventsDescriptor ) {\n\t\t\t\tvar eventName;\n\t\t\t\tfor ( eventName in eventsDescriptor ) {\n\t\t\t\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\t\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {\n\t\t\t\tif ( typeof proxyEventName !== 'string' ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: parentInstance.debug,\n\t\t\t\t\t\tmessage: 'noComponentEventArguments'\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tchildInstance.on( eventName, function() {\n\t\t\t\t\tvar event, args;\n\t\t\t\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\t\t\t\tif ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {\n\t\t\t\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t\t\t\t}\n\t\t\t\t\targs = Array.prototype.slice.call( arguments );\n\t\t\t\t\tfireEvent( parentInstance, proxyEventName, {\n\t\t\t\t\t\tevent: event,\n\t\t\t\t\t\targs: args\n\t\t\t\t\t} );\n\t\t\t\t\t// cancel bubbling\n\t\t\t\t\treturn false;\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( circular, Ractive$shared_fireEvent, log );\n\t\n\t\t/* virtualdom/items/Component/initialise/updateLiveQueries.js */\n\t\tvar updateLiveQueries = function( component ) {\n\t\t\tvar ancestor, query;\n\t\t\t// If there's a live query for this component type, add it\n\t\t\tancestor = component.root;\n\t\t\twhile ( ancestor ) {\n\t\t\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\t\tquery.push( component.instance );\n\t\t\t\t}\n\t\t\t\tancestor = ancestor._parent;\n\t\t\t}\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/init.js */\n\t\tvar virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {\n\t\n\t\t\treturn function Component$init( options, Component ) {\n\t\t\t\tvar parentFragment, root, data, toBind;\n\t\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\t\troot = parentFragment.root;\n\t\t\t\tthis.root = root;\n\t\t\t\tthis.type = types.COMPONENT;\n\t\t\t\tthis.name = options.template.e;\n\t\t\t\tthis.index = options.index;\n\t\t\t\tthis.indexRefBindings = {};\n\t\t\t\tthis.bindings = [];\n\t\t\t\t// even though only one yielder is allowed, we need to have an array of them\n\t\t\t\t// as it's possible to cause a yielder to be created before the last one\n\t\t\t\t// was destroyed in the same turn of the runloop\n\t\t\t\tthis.yielders = [];\n\t\t\t\tif ( !Component ) {\n\t\t\t\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t\t\t\t}\n\t\t\t\t// First, we need to create a model for the component - e.g. if we\n\t\t\t\t// encounter <widget foo='bar'/> then we need to create a widget\n\t\t\t\t// with `data: { foo: 'bar' }`.\n\t\t\t\t//\n\t\t\t\t// This may involve setting up some bindings, but we can't do it\n\t\t\t\t// yet so we take some notes instead\n\t\t\t\ttoBind = [];\n\t\t\t\tdata = createModel( this, Component.defaults.data || {}, options.template.a, toBind );\n\t\t\t\tcreateInstance( this, Component, data, options.template.f );\n\t\t\t\tcreateBindings( this, toBind );\n\t\t\t\tpropagateEvents( this, options.template.v );\n\t\t\t\t// intro, outro and decorator directives have no effect\n\t\t\t\tif ( options.template.t1 || options.template.t2 || options.template.o ) {\n\t\t\t\t\twarn( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components' );\n\t\t\t\t}\n\t\t\t\tupdateLiveQueries( this );\n\t\t\t};\n\t\t}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );\n\t\n\t\t/* virtualdom/items/Component/prototype/rebind.js */\n\t\tvar virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {\n\t\n\t\t\treturn function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar childInstance = this.instance,\n\t\t\t\t\tparentInstance = childInstance._parent,\n\t\t\t\t\tindexRefAlias, query;\n\t\t\t\tthis.bindings.forEach( function( binding ) {\n\t\t\t\t\tvar updated;\n\t\t\t\t\tif ( binding.root !== parentInstance ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {\n\t\t\t\t\t\tbinding.rebind( updated );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthis.complexParameters.forEach( rebind );\n\t\t\t\tif ( this.yielders[ 0 ] ) {\n\t\t\t\t\trebind( this.yielders[ 0 ] );\n\t\t\t\t}\n\t\t\t\tif ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {\n\t\t\t\t\trunloop.addViewmodel( childInstance.viewmodel );\n\t\t\t\t\tchildInstance.viewmodel.set( indexRefAlias, newIndex );\n\t\t\t\t}\n\t\t\t\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\t\t\t\tquery._makeDirty();\n\t\t\t\t}\n\t\n\t\t\t\tfunction rebind( x ) {\n\t\t\t\t\tx.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t};\n\t\t}( runloop, getNewKeypath );\n\t\n\t\t/* virtualdom/items/Component/prototype/render.js */\n\t\tvar virtualdom_items_Component$render = function Component$render() {\n\t\t\tvar instance = this.instance;\n\t\t\tinstance.render( this.parentFragment.getNode() );\n\t\t\tthis.rendered = true;\n\t\t\treturn instance.fragment.detach();\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/toString.js */\n\t\tvar virtualdom_items_Component$toString = function Component$toString() {\n\t\t\treturn this.instance.fragment.toString();\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/prototype/unbind.js */\n\t\tvar virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar teardownHook = new Hook( 'teardown' );\n\t\t\t__export = function Component$unbind() {\n\t\t\t\tvar instance = this.instance;\n\t\t\t\tthis.complexParameters.forEach( unbind );\n\t\t\t\tthis.bindings.forEach( unbind );\n\t\t\t\tremoveFromLiveComponentQueries( this );\n\t\t\t\t// teardown the instance\n\t\t\t\tinstance.fragment.unbind();\n\t\t\t\tinstance.viewmodel.teardown();\n\t\t\t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\t\t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t\t\t\t}\n\t\t\t\tteardownHook.fire( instance );\n\t\t\t};\n\t\n\t\t\tfunction unbind( thing ) {\n\t\t\t\tthing.unbind();\n\t\t\t}\n\t\n\t\t\tfunction removeFromLiveComponentQueries( component ) {\n\t\t\t\tvar instance, query;\n\t\t\t\tinstance = component.root;\n\t\t\t\tdo {\n\t\t\t\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\t\t\tquery._remove( component );\n\t\t\t\t\t}\n\t\t\t\t} while ( instance = instance._parent );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( Ractive$shared_hooks_Hook, removeFromArray );\n\t\n\t\t/* virtualdom/items/Component/prototype/unrender.js */\n\t\tvar virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {\n\t\t\tthis.shouldDestroy = shouldDestroy;\n\t\t\tthis.instance.unrender();\n\t\t};\n\t\n\t\t/* virtualdom/items/Component/_Component.js */\n\t\tvar Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {\n\t\n\t\t\tvar Component = function( options, Constructor ) {\n\t\t\t\tthis.init( options, Constructor );\n\t\t\t};\n\t\t\tComponent.prototype = {\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfindAllComponents: findAllComponents,\n\t\t\t\tfindComponent: findComponent,\n\t\t\t\tfindNextNode: findNextNode,\n\t\t\t\tfirstNode: firstNode,\n\t\t\t\tinit: init,\n\t\t\t\trebind: rebind,\n\t\t\t\trender: render,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender\n\t\t\t};\n\t\t\treturn Component;\n\t\t}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );\n\t\n\t\t/* virtualdom/items/Comment.js */\n\t\tvar Comment = function( types, detach ) {\n\t\n\t\t\tvar Comment = function( options ) {\n\t\t\t\tthis.type = types.COMMENT;\n\t\t\t\tthis.value = options.template.c;\n\t\t\t};\n\t\t\tComment.prototype = {\n\t\t\t\tdetach: detach,\n\t\t\t\tfirstNode: function() {\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\tif ( !this.node ) {\n\t\t\t\t\t\tthis.node = document.createComment( this.value );\n\t\t\t\t\t}\n\t\t\t\t\treturn this.node;\n\t\t\t\t},\n\t\t\t\ttoString: function() {\n\t\t\t\t\treturn '<!--' + this.value + '-->';\n\t\t\t\t},\n\t\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Comment;\n\t\t}( types, detach );\n\t\n\t\t/* virtualdom/items/Yielder.js */\n\t\tvar Yielder = function( runloop, removeFromArray, circular ) {\n\t\n\t\t\tvar Fragment;\n\t\t\tcircular.push( function() {\n\t\t\t\tFragment = circular.Fragment;\n\t\t\t} );\n\t\t\tvar Yielder = function( options ) {\n\t\t\t\tvar componentInstance, component;\n\t\t\t\tcomponentInstance = options.parentFragment.root;\n\t\t\t\tthis.component = component = componentInstance.component;\n\t\t\t\tthis.surrogateParent = options.parentFragment;\n\t\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\towner: this,\n\t\t\t\t\troot: componentInstance.yield.instance,\n\t\t\t\t\ttemplate: componentInstance.yield.template,\n\t\t\t\t\tpElement: this.surrogateParent.pElement\n\t\t\t\t} );\n\t\t\t\tcomponent.yielders.push( this );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tif ( component.yielders.length > 1 ) {\n\t\t\t\t\t\tthrow new Error( 'A component template can only have one {{yield}} declaration at a time' );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t\tYielder.prototype = {\n\t\t\t\tdetach: function() {\n\t\t\t\t\treturn this.fragment.detach();\n\t\t\t\t},\n\t\t\t\tfind: function( selector ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t},\n\t\t\t\tfindAll: function( selector, query ) {\n\t\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t\t},\n\t\t\t\tfindComponent: function( selector ) {\n\t\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t\t},\n\t\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t\t},\n\t\t\t\tfindNextNode: function() {\n\t\t\t\t\treturn this.surrogateParent.findNextNode( this );\n\t\t\t\t},\n\t\t\t\tfirstNode: function() {\n\t\t\t\t\treturn this.fragment.firstNode();\n\t\t\t\t},\n\t\t\t\tgetValue: function( options ) {\n\t\t\t\t\treturn this.fragment.getValue( options );\n\t\t\t\t},\n\t\t\t\trender: function() {\n\t\t\t\t\treturn this.fragment.render();\n\t\t\t\t},\n\t\t\t\tunbind: function() {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t},\n\t\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\t\tremoveFromArray( this.component.yielders, this );\n\t\t\t\t},\n\t\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t},\n\t\t\t\ttoString: function() {\n\t\t\t\t\treturn this.fragment.toString();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Yielder;\n\t\t}( runloop, removeFromArray, circular );\n\t\n\t\t/* virtualdom/Fragment/prototype/init/createItem.js */\n\t\tvar virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {\n\t\n\t\t\treturn function createItem( options ) {\n\t\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\t\treturn new Text( options );\n\t\t\t\t}\n\t\t\t\tswitch ( options.template.t ) {\n\t\t\t\t\tcase types.INTERPOLATOR:\n\t\t\t\t\t\tif ( options.template.r === 'yield' ) {\n\t\t\t\t\t\t\treturn new Yielder( options );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Interpolator( options );\n\t\t\t\t\tcase types.SECTION:\n\t\t\t\t\t\treturn new Section( options );\n\t\t\t\t\tcase types.TRIPLE:\n\t\t\t\t\t\treturn new Triple( options );\n\t\t\t\t\tcase types.ELEMENT:\n\t\t\t\t\t\tvar constructor;\n\t\t\t\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\t\t\t\treturn new Component( options, constructor );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Element( options );\n\t\t\t\t\tcase types.PARTIAL:\n\t\t\t\t\t\treturn new Partial( options );\n\t\t\t\t\tcase types.COMMENT:\n\t\t\t\t\t\treturn new Comment( options );\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t\t\t\t}\n\t\t\t};\n\t\t}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );\n\t\n\t\t/* virtualdom/Fragment/prototype/init.js */\n\t\tvar virtualdom_Fragment$init = function( types, create, createItem ) {\n\t\n\t\t\treturn function Fragment$init( options ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar parentFragment, parentRefs, ref;\n\t\t\t\t// The item that owns this fragment - an element, section, partial, or attribute\n\t\t\t\tthis.owner = options.owner;\n\t\t\t\tparentFragment = this.parent = this.owner.parentFragment;\n\t\t\t\t// inherited properties\n\t\t\t\tthis.root = options.root;\n\t\t\t\tthis.pElement = options.pElement;\n\t\t\t\tthis.context = options.context;\n\t\t\t\t// If parent item is a section, this may not be the only fragment\n\t\t\t\t// that belongs to it - we need to make a note of the index\n\t\t\t\tif ( this.owner.type === types.SECTION ) {\n\t\t\t\t\tthis.index = options.index;\n\t\t\t\t}\n\t\t\t\t// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade\n\t\t\t\t// down the tree\n\t\t\t\tif ( parentFragment ) {\n\t\t\t\t\tparentRefs = parentFragment.indexRefs;\n\t\t\t\t\tif ( parentRefs ) {\n\t\t\t\t\t\tthis.indexRefs = create( null );\n\t\t\t\t\t\t// avoids need for hasOwnProperty\n\t\t\t\t\t\tfor ( ref in parentRefs ) {\n\t\t\t\t\t\t\tthis.indexRefs[ ref ] = parentRefs[ ref ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( options.indexRef ) {\n\t\t\t\t\tif ( !this.indexRefs ) {\n\t\t\t\t\t\tthis.indexRefs = {};\n\t\t\t\t\t}\n\t\t\t\t\tthis.indexRefs[ options.indexRef ] = options.index;\n\t\t\t\t}\n\t\t\t\t// Time to create this fragment's child items\n\t\t\t\t// TEMP should this be happening?\n\t\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\t\toptions.template = [ options.template ];\n\t\t\t\t} else if ( !options.template ) {\n\t\t\t\t\toptions.template = [];\n\t\t\t\t}\n\t\t\t\tthis.items = options.template.map( function( template, i ) {\n\t\t\t\t\treturn createItem( {\n\t\t\t\t\t\tparentFragment: this$0,\n\t\t\t\t\t\tpElement: options.pElement,\n\t\t\t\t\t\ttemplate: template,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tthis.value = this.argsList = null;\n\t\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\t\tthis.bound = true;\n\t\t\t};\n\t\t}( types, create, virtualdom_Fragment$init_createItem );\n\t\n\t\t/* virtualdom/Fragment/prototype/rebind.js */\n\t\tvar virtualdom_Fragment$rebind = function( assignNewKeypath ) {\n\t\n\t\t\treturn function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.index = newIndex;\n\t\t\t\t// assign new context keypath if needed\n\t\t\t\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\t\t\t\tif ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {\n\t\t\t\t\tthis.indexRefs[ indexRef ] = newIndex;\n\t\t\t\t}\n\t\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\t\tif ( item.rebind ) {\n\t\t\t\t\t\titem.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t}( assignNewKeypath );\n\t\n\t\t/* virtualdom/Fragment/prototype/render.js */\n\t\tvar virtualdom_Fragment$render = function Fragment$render() {\n\t\t\tvar result;\n\t\t\tif ( this.items.length === 1 ) {\n\t\t\t\tresult = this.items[ 0 ].render();\n\t\t\t} else {\n\t\t\t\tresult = document.createDocumentFragment();\n\t\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\t\tresult.appendChild( item.render() );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tthis.rendered = true;\n\t\t\treturn result;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/toString.js */\n\t\tvar virtualdom_Fragment$toString = function Fragment$toString( escape ) {\n\t\t\tif ( !this.items ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn this.items.map( function( item ) {\n\t\t\t\treturn item.toString( escape );\n\t\t\t} ).join( '' );\n\t\t};\n\t\n\t\t/* virtualdom/Fragment/prototype/unbind.js */\n\t\tvar virtualdom_Fragment$unbind = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Fragment$unbind() {\n\t\t\t\tif ( !this.bound ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.items.forEach( unbindItem );\n\t\t\t\tthis.bound = false;\n\t\t\t};\n\t\n\t\t\tfunction unbindItem( item ) {\n\t\t\t\tif ( item.unbind ) {\n\t\t\t\t\titem.unbind();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* virtualdom/Fragment/prototype/unrender.js */\n\t\tvar virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {\n\t\t\tif ( !this.rendered ) {\n\t\t\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t\t\t}\n\t\t\tthis.items.forEach( function( i ) {\n\t\t\t\treturn i.unrender( shouldDestroy );\n\t\t\t} );\n\t\t\tthis.rendered = false;\n\t\t};\n\t\n\t\t/* virtualdom/Fragment.js */\n\t\tvar Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {\n\t\n\t\t\tvar Fragment = function( options ) {\n\t\t\t\tthis.init( options );\n\t\t\t};\n\t\t\tFragment.prototype = {\n\t\t\t\tbubble: bubble,\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfindAllComponents: findAllComponents,\n\t\t\t\tfindComponent: findComponent,\n\t\t\t\tfindNextNode: findNextNode,\n\t\t\t\tfirstNode: firstNode,\n\t\t\t\tgetNode: getNode,\n\t\t\t\tgetValue: getValue,\n\t\t\t\tinit: init,\n\t\t\t\trebind: rebind,\n\t\t\t\trender: render,\n\t\t\t\ttoString: toString,\n\t\t\t\tunbind: unbind,\n\t\t\t\tunrender: unrender\n\t\t\t};\n\t\t\tcircular.Fragment = Fragment;\n\t\t\treturn Fragment;\n\t\t}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );\n\t\n\t\t/* Ractive/prototype/reset.js */\n\t\tvar Ractive$reset = function( Hook, runloop, Fragment, config ) {\n\t\n\t\t\tvar shouldRerender = [\n\t\t\t\t\t'template',\n\t\t\t\t\t'partials',\n\t\t\t\t\t'components',\n\t\t\t\t\t'decorators',\n\t\t\t\t\t'events'\n\t\t\t\t],\n\t\t\t\tresetHook = new Hook( 'reset' );\n\t\t\treturn function Ractive$reset( data, callback ) {\n\t\t\t\tvar promise, wrapper, changes, i, rerender;\n\t\t\t\tif ( typeof data === 'function' && !callback ) {\n\t\t\t\t\tcallback = data;\n\t\t\t\t\tdata = {};\n\t\t\t\t} else {\n\t\t\t\t\tdata = data || {};\n\t\t\t\t}\n\t\t\t\tif ( typeof data !== 'object' ) {\n\t\t\t\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t\t\t\t}\n\t\t\t\t// If the root object is wrapped, try and use the wrapper's reset value\n\t\t\t\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\t\t\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t\t\t\t// reset was rejected, we need to replace the object\n\t\t\t\t\t\tthis.data = data;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.data = data;\n\t\t\t\t}\n\t\t\t\t// reset config items and track if need to rerender\n\t\t\t\tchanges = config.reset( this );\n\t\t\t\ti = changes.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {\n\t\t\t\t\t\trerender = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( rerender ) {\n\t\t\t\t\tvar component;\n\t\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t\t\t// detaching its own nodes\n\t\t\t\t\tif ( component = this.component ) {\n\t\t\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t\t\t}\n\t\t\t\t\tthis.unrender();\n\t\t\t\t\tif ( component ) {\n\t\t\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t\t\t}\n\t\t\t\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t\t\t\t// TODO if we're here, presumably it did?\n\t\t\t\t\tif ( this.fragment.template !== this.template ) {\n\t\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\t\t\ttemplate: this.template,\n\t\t\t\t\t\t\troot: this,\n\t\t\t\t\t\t\towner: this\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tpromise = this.render( this.el, this.anchor );\n\t\t\t\t} else {\n\t\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\t\trunloop.end();\n\t\t\t\t}\n\t\t\t\tresetHook.fire( this, data );\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tpromise.then( callback );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( Ractive$shared_hooks_Hook, runloop, Fragment, config );\n\t\n\t\t/* Ractive/prototype/resetTemplate.js */\n\t\tvar Ractive$resetTemplate = function( config, Fragment ) {\n\t\n\t\t\treturn function Ractive$resetTemplate( template ) {\n\t\t\t\tvar transitionsEnabled, component;\n\t\t\t\tconfig.template.init( null, this, {\n\t\t\t\t\ttemplate: template\n\t\t\t\t} );\n\t\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\t\tthis.transitionsEnabled = false;\n\t\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t\t// detaching its own nodes\n\t\t\t\tif ( component = this.component ) {\n\t\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t\t}\n\t\t\t\tthis.unrender();\n\t\t\t\tif ( component ) {\n\t\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t\t}\n\t\t\t\t// remove existing fragment and create new one\n\t\t\t\tthis.fragment.unbind();\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: this.template,\n\t\t\t\t\troot: this,\n\t\t\t\t\towner: this\n\t\t\t\t} );\n\t\t\t\tthis.render( this.el, this.anchor );\n\t\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t\t};\n\t\t}( config, Fragment );\n\t\n\t\t/* Ractive/prototype/reverse.js */\n\t\tvar Ractive$reverse = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'reverse' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/set.js */\n\t\tvar Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {\n\t\n\t\t\tvar wildcard = /\\*/;\n\t\t\treturn function Ractive$set( keypath, value, callback ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar map, promise;\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\t// Set multiple keypaths in one go\n\t\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\t\tmap = keypath;\n\t\t\t\t\tcallback = value;\n\t\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tvalue = map[ keypath ];\n\t\t\t\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\t\tgetMatchingKeypaths( this, keypath ).forEach( function( keypath ) {\n\t\t\t\t\t\t\tthis$0.viewmodel.set( keypath, value );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );\n\t\n\t\t/* Ractive/prototype/shift.js */\n\t\tvar Ractive$shift = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'shift' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/sort.js */\n\t\tvar Ractive$sort = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'sort' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/splice.js */\n\t\tvar Ractive$splice = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'splice' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/subtract.js */\n\t\tvar Ractive$subtract = function( add ) {\n\t\n\t\t\treturn function Ractive$subtract( keypath, d ) {\n\t\t\t\treturn add( this, keypath, d === undefined ? -1 : -d );\n\t\t\t};\n\t\t}( Ractive$shared_add );\n\t\n\t\t/* Ractive/prototype/teardown.js */\n\t\tvar Ractive$teardown = function( Hook, Promise, removeFromArray ) {\n\t\n\t\t\tvar teardownHook = new Hook( 'teardown' );\n\t\t\t// Teardown. This goes through the root fragment and all its children, removing observers\n\t\t\t// and generally cleaning up after itself\n\t\t\treturn function Ractive$teardown( callback ) {\n\t\t\t\tvar promise;\n\t\t\t\tthis.fragment.unbind();\n\t\t\t\tthis.viewmodel.teardown();\n\t\t\t\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t\t}\n\t\t\t\tthis.shouldDestroy = true;\n\t\t\t\tpromise = this.fragment.rendered ? this.unrender() : Promise.resolve();\n\t\t\t\tteardownHook.fire( this );\n\t\t\t\tif ( callback ) {\n\t\t\t\t\t// TODO deprecate this?\n\t\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( Ractive$shared_hooks_Hook, Promise, removeFromArray );\n\t\n\t\t/* Ractive/prototype/toggle.js */\n\t\tvar Ractive$toggle = function( log ) {\n\t\n\t\t\treturn function Ractive$toggle( keypath, callback ) {\n\t\t\t\tvar value;\n\t\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\t\tlog.errorOnly( {\n\t\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\t\tmesssage: 'badArguments',\n\t\t\t\t\t\targ: {\n\t\t\t\t\t\t\targuments: keypath\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tvalue = this.get( keypath );\n\t\t\t\treturn this.set( keypath, !value, callback );\n\t\t\t};\n\t\t}( log );\n\t\n\t\t/* Ractive/prototype/toHTML.js */\n\t\tvar Ractive$toHTML = function Ractive$toHTML() {\n\t\t\treturn this.fragment.toString( true );\n\t\t};\n\t\n\t\t/* Ractive/prototype/unrender.js */\n\t\tvar Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {\n\t\n\t\t\tvar unrenderHook = new Hook( 'unrender' );\n\t\t\treturn function Ractive$unrender() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar promise, shouldDestroy;\n\t\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\t\tmessage: 'ractive.unrender() was called on a Ractive instance that was not rendered'\n\t\t\t\t\t} );\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\t// If this is a component, and the component isn't marked for destruction,\n\t\t\t\t// don't detach nodes from the DOM unnecessarily\n\t\t\t\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t\t\t\tif ( this.constructor.css ) {\n\t\t\t\t\tpromise.then( function() {\n\t\t\t\t\t\tcss.remove( this$0.constructor );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// Cancel any animations in progress\n\t\t\t\twhile ( this._animations[ 0 ] ) {\n\t\t\t\t\tthis._animations[ 0 ].stop();\n\t\t\t\t}\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t\tunrenderHook.fire( this );\n\t\t\t\trunloop.end();\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );\n\t\n\t\t/* Ractive/prototype/unshift.js */\n\t\tvar Ractive$unshift = function( makeArrayMethod ) {\n\t\n\t\t\treturn makeArrayMethod( 'unshift' );\n\t\t}( Ractive$shared_makeArrayMethod );\n\t\n\t\t/* Ractive/prototype/update.js */\n\t\tvar Ractive$update = function( Hook, runloop ) {\n\t\n\t\t\tvar updateHook = new Hook( 'update' );\n\t\t\treturn function Ractive$update( keypath, callback ) {\n\t\t\t\tvar promise;\n\t\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\t\tcallback = keypath;\n\t\t\t\t\tkeypath = '';\n\t\t\t\t} else {\n\t\t\t\t\tkeypath = keypath || '';\n\t\t\t\t}\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\tthis.viewmodel.mark( keypath );\n\t\t\t\trunloop.end();\n\t\t\t\tupdateHook.fire( this, keypath );\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}( Ractive$shared_hooks_Hook, runloop );\n\t\n\t\t/* Ractive/prototype/updateModel.js */\n\t\tvar Ractive$updateModel = function( arrayContentsMatch, isEqual ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Ractive$updateModel( keypath, cascade ) {\n\t\t\t\tvar values;\n\t\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\t\tkeypath = '';\n\t\t\t\t\tcascade = true;\n\t\t\t\t}\n\t\t\t\tconsolidateChangedValues( this, keypath, values = {}, cascade );\n\t\t\t\treturn this.set( values );\n\t\t\t};\n\t\n\t\t\tfunction consolidateChangedValues( ractive, keypath, values, cascade ) {\n\t\t\t\tvar bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];\n\t\t\t\tbindings = ractive._twowayBindings[ keypath ];\n\t\t\t\tif ( bindings && ( i = bindings.length ) ) {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t\t// special case - radio name bindings\n\t\t\t\t\t\tif ( binding.radioName && !binding.element.node.checked ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// special case - checkbox name bindings come in groups, so\n\t\t\t\t\t\t// we want to get the value once at most\n\t\t\t\t\t\tif ( binding.checkboxName ) {\n\t\t\t\t\t\t\tif ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {\n\t\t\t\t\t\t\t\tcheckboxGroups.push( binding.keypath );\n\t\t\t\t\t\t\t\tcheckboxGroups[ binding.keypath ] = binding;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\t\t\t\tif ( checkboxGroups.length ) {\n\t\t\t\t\tcheckboxGroups.forEach( function( keypath ) {\n\t\t\t\t\t\tvar binding, oldValue, newValue;\n\t\t\t\t\t\tbinding = checkboxGroups[ keypath ];\n\t\t\t\t\t\t// one to represent the entire group\n\t\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tif ( !cascade ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// cascade\n\t\t\t\tchildDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];\n\t\t\t\tif ( childDeps ) {\n\t\t\t\t\ti = childDeps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tconsolidateChangedValues( ractive, childDeps[ i ], values, cascade );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( arrayContentsMatch, isEqual );\n\t\n\t\t/* Ractive/prototype.js */\n\t\tvar prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {\n\t\n\t\t\treturn {\n\t\t\t\tadd: add,\n\t\t\t\tanimate: animate,\n\t\t\t\tdetach: detach,\n\t\t\t\tfind: find,\n\t\t\t\tfindAll: findAll,\n\t\t\t\tfindAllComponents: findAllComponents,\n\t\t\t\tfindComponent: findComponent,\n\t\t\t\tfire: fire,\n\t\t\t\tget: get,\n\t\t\t\tinsert: insert,\n\t\t\t\tmerge: merge,\n\t\t\t\tobserve: observe,\n\t\t\t\toff: off,\n\t\t\t\ton: on,\n\t\t\t\tpop: pop,\n\t\t\t\tpush: push,\n\t\t\t\trender: render,\n\t\t\t\treset: reset,\n\t\t\t\tresetTemplate: resetTemplate,\n\t\t\t\treverse: reverse,\n\t\t\t\tset: set,\n\t\t\t\tshift: shift,\n\t\t\t\tsort: sort,\n\t\t\t\tsplice: splice,\n\t\t\t\tsubtract: subtract,\n\t\t\t\tteardown: teardown,\n\t\t\t\ttoggle: toggle,\n\t\t\t\ttoHTML: toHTML,\n\t\t\t\tunrender: unrender,\n\t\t\t\tunshift: unshift,\n\t\t\t\tupdate: update,\n\t\t\t\tupdateModel: updateModel\n\t\t\t};\n\t\t}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );\n\t\n\t\t/* utils/getGuid.js */\n\t\tvar getGuid = function() {\n\t\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {\n\t\t\t\tvar r, v;\n\t\t\t\tr = Math.random() * 16 | 0;\n\t\t\t\tv = c == 'x' ? r : r & 3 | 8;\n\t\t\t\treturn v.toString( 16 );\n\t\t\t} );\n\t\t};\n\t\n\t\t/* utils/getNextNumber.js */\n\t\tvar getNextNumber = function() {\n\t\n\t\t\tvar i = 0;\n\t\t\treturn function() {\n\t\t\t\treturn 'r-' + i++;\n\t\t\t};\n\t\t}();\n\t\n\t\t/* Ractive/prototype/shared/hooks/HookQueue.js */\n\t\tvar Ractive$shared_hooks_HookQueue = function( Hook ) {\n\t\n\t\t\tfunction HookQueue( event ) {\n\t\t\t\tthis.hook = new Hook( event );\n\t\t\t\tthis.inProcess = {};\n\t\t\t\tthis.queue = {};\n\t\t\t}\n\t\t\tHookQueue.prototype = {\n\t\t\t\tconstructor: HookQueue,\n\t\t\t\tbegin: function( ractive ) {\n\t\t\t\t\tthis.inProcess[ ractive._guid ] = true;\n\t\t\t\t},\n\t\t\t\tend: function( ractive ) {\n\t\t\t\t\tvar parent = ractive._parent;\n\t\t\t\t\t// If this is *isn't* a child of a component that's in process,\n\t\t\t\t\t// it should call methods or fire at this point\n\t\t\t\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\t\t\t\tfire( this, ractive );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t\t\t\t}\n\t\t\t\t\tdelete this.inProcess[ ractive._guid ];\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction getChildQueue( queue, ractive ) {\n\t\t\t\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t\t\t}\n\t\n\t\t\tfunction fire( hookQueue, ractive ) {\n\t\t\t\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\t\t\t\thookQueue.hook.fire( ractive );\n\t\t\t\t// queue is \"live\" because components can end up being\n\t\t\t\t// added while hooks fire on parents that modify data values.\n\t\t\t\twhile ( childQueue.length ) {\n\t\t\t\t\tfire( hookQueue, childQueue.shift() );\n\t\t\t\t}\n\t\t\t\tdelete hookQueue.queue[ ractive._guid ];\n\t\t\t}\n\t\t\treturn HookQueue;\n\t\t}( Ractive$shared_hooks_Hook );\n\t\n\t\t/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */\n\t\tvar viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {\n\t\t\tvar root = wrapper.root,\n\t\t\t\tkeypath = wrapper.keypath;\n\t\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t\t// TODO use merge logic?\n\t\t\tif ( methodName === 'sort' || methodName === 'reverse' ) {\n\t\t\t\troot.viewmodel.set( keypath, array );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t};\n\t\n\t\t/* viewmodel/prototype/get/arrayAdaptor/patch.js */\n\t\tvar viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {\n\t\n\t\t\tvar patchedArrayProto = [],\n\t\t\t\tmutatorMethods = [\n\t\t\t\t\t'pop',\n\t\t\t\t\t'push',\n\t\t\t\t\t'reverse',\n\t\t\t\t\t'shift',\n\t\t\t\t\t'sort',\n\t\t\t\t\t'splice',\n\t\t\t\t\t'unshift'\n\t\t\t\t],\n\t\t\t\ttestObj, patchArrayMethods, unpatchArrayMethods;\n\t\t\tmutatorMethods.forEach( function( methodName ) {\n\t\t\t\tvar method = function() {\n\t\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\t\tvar args = SLICE$0.call( arguments, 0 );\n\t\t\t\t\tvar newIndices, result, wrapper, i;\n\t\t\t\t\tnewIndices = getNewIndices( this, methodName, args );\n\t\t\t\t\t// apply the underlying method\n\t\t\t\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\t\t\t\t\t// trigger changes\n\t\t\t\t\trunloop.start();\n\t\t\t\t\tthis._ractive.setting = true;\n\t\t\t\t\ti = this._ractive.wrappers.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\twrapper = this._ractive.wrappers[ i ];\n\t\t\t\t\t\trunloop.addViewmodel( wrapper.root.viewmodel );\n\t\t\t\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t\t\t\t}\n\t\t\t\t\trunloop.end();\n\t\t\t\t\tthis._ractive.setting = false;\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t\tdefineProperty( patchedArrayProto, methodName, {\n\t\t\t\t\tvalue: method\n\t\t\t\t} );\n\t\t\t} );\n\t\t\t// can we use prototype chain injection?\n\t\t\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\t\t\ttestObj = {};\n\t\t\tif ( testObj.__proto__ ) {\n\t\t\t\t// yes, we can\n\t\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\t\tarray.__proto__ = patchedArrayProto;\n\t\t\t\t};\n\t\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\t\tarray.__proto__ = Array.prototype;\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// no, we can't\n\t\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\t\tvar i, methodName;\n\t\t\t\t\ti = mutatorMethods.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tmethodName = mutatorMethods[ i ];\n\t\t\t\t\t\tdefineProperty( array, methodName, {\n\t\t\t\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\t\tvar i;\n\t\t\t\t\ti = mutatorMethods.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tdelete array[ mutatorMethods[ i ] ];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tpatchArrayMethods.unpatch = unpatchArrayMethods;\n\t\t\treturn patchArrayMethods;\n\t\t}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );\n\t\n\t\t/* viewmodel/prototype/get/arrayAdaptor.js */\n\t\tvar viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {\n\t\n\t\t\tvar arrayAdaptor,\n\t\t\t\t// helpers\n\t\t\t\tArrayWrapper, errorMessage;\n\t\t\tarrayAdaptor = {\n\t\t\t\tfilter: function( object ) {\n\t\t\t\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t\t\t\t// or the array didn't trigger the get() itself\n\t\t\t\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t\t\t\t},\n\t\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t\tArrayWrapper = function( ractive, array, keypath ) {\n\t\t\t\tthis.root = ractive;\n\t\t\t\tthis.value = array;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\t// if this array hasn't already been ractified, ractify it\n\t\t\t\tif ( !array._ractive ) {\n\t\t\t\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\t\t\t\tdefineProperty( array, '_ractive', {\n\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\twrappers: [],\n\t\t\t\t\t\t\tinstances: [],\n\t\t\t\t\t\t\tsetting: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t\tpatch( array );\n\t\t\t\t}\n\t\t\t\t// store the ractive instance, so we can handle transitions later\n\t\t\t\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\t\t\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\t\t\t\tarray._ractive.instances.push( ractive );\n\t\t\t\t}\n\t\t\t\tarray._ractive.instances[ ractive._guid ] += 1;\n\t\t\t\tarray._ractive.wrappers.push( this );\n\t\t\t};\n\t\t\tArrayWrapper.prototype = {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar array, storage, wrappers, instances, index;\n\t\t\t\t\tarray = this.value;\n\t\t\t\t\tstorage = array._ractive;\n\t\t\t\t\twrappers = storage.wrappers;\n\t\t\t\t\tinstances = storage.instances;\n\t\t\t\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t\t\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t\t\t\t// and immediate setup\n\t\t\t\t\tif ( storage.setting ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t\t}\n\t\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t\t// if nothing else depends on this array, we can revert it to its\n\t\t\t\t\t// natural state\n\t\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\t\tdelete array._ractive;\n\t\t\t\t\t\tpatch.unpatch( this.value );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// remove ractive instance if possible\n\t\t\t\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\t\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\t\t\t\tindex = instances.indexOf( this.root );\n\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinstances.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\terrorMessage = 'Something went wrong in a rather interesting way';\n\t\t\treturn arrayAdaptor;\n\t\t}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );\n\t\n\t\t/* viewmodel/prototype/get/magicArrayAdaptor.js */\n\t\tvar viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {\n\t\n\t\t\tvar magicArrayAdaptor, MagicArrayWrapper;\n\t\t\tif ( magicAdaptor ) {\n\t\t\t\tmagicArrayAdaptor = {\n\t\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t\t\t\t},\n\t\t\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tMagicArrayWrapper = function( ractive, array, keypath ) {\n\t\t\t\t\tthis.value = array;\n\t\t\t\t\tthis.magic = true;\n\t\t\t\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\t\t\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t\t\t\t};\n\t\t\t\tMagicArrayWrapper.prototype = {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn this.value;\n\t\t\t\t\t},\n\t\t\t\t\tteardown: function() {\n\t\t\t\t\t\tthis.arrayWrapper.teardown();\n\t\t\t\t\t\tthis.magicWrapper.teardown();\n\t\t\t\t\t},\n\t\t\t\t\treset: function( value ) {\n\t\t\t\t\t\treturn this.magicWrapper.reset( value );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn magicArrayAdaptor;\n\t\t}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );\n\t\n\t\t/* viewmodel/prototype/adapt.js */\n\t\tvar viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar prefixers = {};\n\t\t\t__export = function Viewmodel$adapt( keypath, value ) {\n\t\t\t\tvar ractive = this.ractive,\n\t\t\t\t\tlen, i, adaptor, wrapped;\n\t\t\t\t// Do we have an adaptor for this value?\n\t\t\t\tlen = ractive.adapt.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tadaptor = ractive.adapt[ i ];\n\t\t\t\t\t// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -\n\t\t\t\t\t// we need to get the actual adaptor if that's the case\n\t\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\t\tvar found = config.registries.adaptors.find( ractive, adaptor );\n\t\t\t\t\t\tif ( !found ) {\n\t\t\t\t\t\t\t// will throw. \"return\" for safety, if we downgrade :)\n\t\t\t\t\t\t\treturn log.critical( {\n\t\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\tplugin: 'adaptor',\n\t\t\t\t\t\t\t\t\tname: adaptor\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tadaptor = ractive.adapt[ i ] = found;\n\t\t\t\t\t}\n\t\t\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\t\t\t\twrapped.value = value;\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( ractive.magic ) {\n\t\t\t\t\tif ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\t\tthis.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t\t} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\t\tthis.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t\t}\n\t\t\t\t} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\n\t\t\tfunction prefixKeypath( obj, prefix ) {\n\t\t\t\tvar prefixed = {},\n\t\t\t\t\tkey;\n\t\t\t\tif ( !prefix ) {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t\tprefix += '.';\n\t\t\t\tfor ( key in obj ) {\n\t\t\t\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn prefixed;\n\t\t\t}\n\t\n\t\t\tfunction getPrefixer( rootKeypath ) {\n\t\t\t\tvar rootDot;\n\t\t\t\tif ( !prefixers[ rootKeypath ] ) {\n\t\t\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\t\t\t\t\tprefixers[ rootKeypath ] = function( relativeKeypath, value ) {\n\t\t\t\t\t\tvar obj;\n\t\t\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\t\t\t\treturn obj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn prefixers[ rootKeypath ];\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );\n\t\n\t\t/* viewmodel/helpers/getUpstreamChanges.js */\n\t\tvar getUpstreamChanges = function getUpstreamChanges( changes ) {\n\t\t\tvar upstreamChanges = [ '' ],\n\t\t\t\ti, keypath, keys, upstreamKeypath;\n\t\t\ti = changes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tkeypath = changes[ i ];\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\twhile ( keys.length > 1 ) {\n\t\t\t\t\tkeys.pop();\n\t\t\t\t\tupstreamKeypath = keys.join( '.' );\n\t\t\t\t\tif ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {\n\t\t\t\t\t\tupstreamChanges.push( upstreamKeypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn upstreamChanges;\n\t\t};\n\t\n\t\t/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */\n\t\tvar viewmodel$applyChanges_getPotentialWildcardMatches = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar starMaps = {};\n\t\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t\t// all the variants of that keypath that include a wildcard in place\n\t\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t\t// to see if any pattern observers are downstream of one or more of\n\t\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\t\tvar keys, starMap, mapper, result;\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tstarMap = getStarMap( keys.length );\n\t\t\t\tmapper = function( star, i ) {\n\t\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t\t};\n\t\t\t\tresult = starMap.map( function( mask ) {\n\t\t\t\t\treturn mask.map( mapper ).join( '.' );\n\t\t\t\t} );\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\t// This function returns all the possible true/false combinations for\n\t\t\t// a given number - e.g. for two, the possible combinations are\n\t\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\t\tfunction getStarMap( length ) {\n\t\t\t\tvar ones = '',\n\t\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\t\tif ( !starMaps[ length ] ) {\n\t\t\t\t\tstarMap = [];\n\t\t\t\t\twhile ( ones.length < length ) {\n\t\t\t\t\t\tones += 1;\n\t\t\t\t\t}\n\t\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\t\treturn digit === '1';\n\t\t\t\t\t};\n\t\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\t\twhile ( binary.length < length ) {\n\t\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t\t}\n\t\t\t\t\tstarMaps[ length ] = starMap;\n\t\t\t\t}\n\t\t\t\treturn starMaps[ length ];\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */\n\t\tvar viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar lastKey = /[^\\.]+$/;\n\t\t\t__export = notifyPatternObservers;\n\t\n\t\t\tfunction notifyPatternObservers( viewmodel, keypath, onlyDirect ) {\n\t\t\t\tvar potentialWildcardMatches;\n\t\t\t\tupdateMatchingPatternObservers( viewmodel, keypath );\n\t\t\t\tif ( onlyDirect ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpotentialWildcardMatches = getPotentialWildcardMatches( keypath );\n\t\t\t\tpotentialWildcardMatches.forEach( function( upstreamPattern ) {\n\t\t\t\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tfunction cascade( viewmodel, upstreamPattern, keypath ) {\n\t\t\t\tvar group, map, actualChildKeypath;\n\t\t\t\tgroup = viewmodel.depsMap.patternObservers;\n\t\t\t\tmap = group[ upstreamPattern ];\n\t\t\t\tif ( map ) {\n\t\t\t\t\tmap.forEach( function( childKeypath ) {\n\t\t\t\t\t\tvar key = lastKey.exec( childKeypath )[ 0 ];\n\t\t\t\t\t\t// 'baz'\n\t\t\t\t\t\tactualChildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t\t// 'foo.bar.baz'\n\t\t\t\t\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\t\t\t\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction updateMatchingPatternObservers( viewmodel, keypath ) {\n\t\t\t\tviewmodel.patternObservers.forEach( function( observer ) {\n\t\t\t\t\tif ( observer.regex.test( keypath ) ) {\n\t\t\t\t\t\tobserver.update( keypath );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( viewmodel$applyChanges_getPotentialWildcardMatches );\n\t\n\t\t/* viewmodel/prototype/applyChanges.js */\n\t\tvar viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Viewmodel$applyChanges() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar self = this,\n\t\t\t\t\tchanges, upstreamChanges, hash = {};\n\t\t\t\tchanges = this.changes;\n\t\t\t\tif ( !changes.length ) {\n\t\t\t\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tfunction cascade( keypath ) {\n\t\t\t\t\tvar map, dependants, keys;\n\t\t\t\t\tif ( self.noCascade.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t\t\tkeys.forEach( cascade );\n\t\t\t\t\t}\n\t\t\t\t\tif ( map = self.depsMap.computed[ keypath ] ) {\n\t\t\t\t\t\tmap.forEach( cascade );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfunction mark( keypath ) {\n\t\t\t\t\tself.mark( keypath );\n\t\t\t\t}\n\t\t\t\tchanges.forEach( cascade );\n\t\t\t\tupstreamChanges = getUpstreamChanges( changes );\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\tvar dependants, keys;\n\t\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t\t\tkeys.forEach( cascade );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthis.changes = [];\n\t\t\t\t// Pattern observers are a weird special case\n\t\t\t\tif ( this.patternObservers.length ) {\n\t\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\t\treturn notifyPatternObservers( this$0, keypath, true );\n\t\t\t\t\t} );\n\t\t\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\t\t\treturn notifyPatternObservers( this$0, keypath );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tif ( this.deps.observers ) {\n\t\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\t\treturn notifyUpstreamDependants( this$0, null, keypath, 'observers' );\n\t\t\t\t\t} );\n\t\t\t\t\tnotifyAllDependants( this, changes, 'observers' );\n\t\t\t\t}\n\t\t\t\tif ( this.deps[ 'default' ] ) {\n\t\t\t\t\tvar bindings = [];\n\t\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\t\treturn notifyUpstreamDependants( this$0, bindings, keypath, 'default' );\n\t\t\t\t\t} );\n\t\t\t\t\tif ( bindings.length ) {\n\t\t\t\t\t\tnotifyBindings( this, bindings, changes );\n\t\t\t\t\t}\n\t\t\t\t\tnotifyAllDependants( this, changes, 'default' );\n\t\t\t\t}\n\t\t\t\t// Return a hash of keypaths to updated values\n\t\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\t\thash[ keypath ] = this$0.get( keypath );\n\t\t\t\t} );\n\t\t\t\tthis.implicitChanges = {};\n\t\t\t\tthis.noCascade = {};\n\t\t\t\treturn hash;\n\t\t\t};\n\t\n\t\t\tfunction invalidate( computation ) {\n\t\t\t\tcomputation.invalidate();\n\t\t\t}\n\t\n\t\t\tfunction getKey( computation ) {\n\t\t\t\treturn computation.key;\n\t\t\t}\n\t\n\t\t\tfunction notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {\n\t\t\t\tvar dependants, value;\n\t\t\t\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\t\t\t\tvalue = viewmodel.get( keypath );\n\t\t\t\t\tdependants.forEach( function( d ) {\n\t\t\t\t\t\t// don't \"set\" the parent value, refine it\n\t\t\t\t\t\t// i.e. not data = value, but data[foo] = fooValue\n\t\t\t\t\t\tif ( bindings && d.refineValue ) {\n\t\t\t\t\t\t\tbindings.push( d );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\td.setValue( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction notifyBindings( viewmodel, bindings, changes ) {\n\t\t\t\tbindings.forEach( function( binding ) {\n\t\t\t\t\tvar useSet = false,\n\t\t\t\t\t\ti = 0,\n\t\t\t\t\t\tlength = changes.length,\n\t\t\t\t\t\trefinements = [];\n\t\t\t\t\twhile ( i < length ) {\n\t\t\t\t\t\tvar keypath = changes[ i ];\n\t\t\t\t\t\tif ( keypath === binding.keypath ) {\n\t\t\t\t\t\t\tuseSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {\n\t\t\t\t\t\t\trefinements.push( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tif ( useSet ) {\n\t\t\t\t\t\tbinding.setValue( viewmodel.get( binding.keypath ) );\n\t\t\t\t\t}\n\t\t\t\t\tif ( refinements.length ) {\n\t\t\t\t\t\tbinding.refineValue( refinements );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tfunction notifyAllDependants( viewmodel, keypaths, groupName ) {\n\t\t\t\tvar queue = [];\n\t\t\t\taddKeypaths( keypaths );\n\t\t\t\tqueue.forEach( dispatch );\n\t\n\t\t\t\tfunction addKeypaths( keypaths ) {\n\t\t\t\t\tkeypaths.forEach( addKeypath );\n\t\t\t\t\tkeypaths.forEach( cascade );\n\t\t\t\t}\n\t\n\t\t\t\tfunction addKeypath( keypath ) {\n\t\t\t\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\t\t\t\t\tif ( deps ) {\n\t\t\t\t\t\tqueue.push( {\n\t\t\t\t\t\t\tkeypath: keypath,\n\t\t\t\t\t\t\tdeps: deps\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfunction cascade( keypath ) {\n\t\t\t\t\tvar childDeps;\n\t\t\t\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {\n\t\t\t\t\t\taddKeypaths( childDeps );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfunction dispatch( set ) {\n\t\t\t\t\tvar value = viewmodel.get( set.keypath );\n\t\t\t\t\tset.deps.forEach( function( d ) {\n\t\t\t\t\t\treturn d.setValue( value );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction findDependants( viewmodel, keypath, groupName ) {\n\t\t\t\tvar group = viewmodel.deps[ groupName ];\n\t\t\t\treturn group ? group[ keypath ] : null;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );\n\t\n\t\t/* viewmodel/prototype/capture.js */\n\t\tvar viewmodel$capture = function Viewmodel$capture() {\n\t\t\tthis.captureGroups.push( [] );\n\t\t};\n\t\n\t\t/* viewmodel/prototype/clearCache.js */\n\t\tvar viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {\n\t\t\tvar cacheMap, wrapper;\n\t\t\tif ( !dontTeardownWrapper ) {\n\t\t\t\t// Is there a wrapped property at this keypath?\n\t\t\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t\t\t// Did we unwrap it?\n\t\t\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t\t\t// Is this right?\n\t\t\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cache[ keypath ] = undefined;\n\t\t\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\t\t\twhile ( cacheMap.length ) {\n\t\t\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/* viewmodel/Computation/getComputationSignature.js */\n\t\tvar getComputationSignature = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\t\t\t__export = function( signature ) {\n\t\t\t\tif ( typeof signature === 'function' ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tget: signature\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( typeof signature === 'string' ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tget: createFunctionFromString( signature )\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( typeof signature === 'object' && typeof signature.get === 'string' ) {\n\t\t\t\t\tsignature = {\n\t\t\t\t\t\tget: createFunctionFromString( signature.get ),\n\t\t\t\t\t\tset: signature.set\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn signature;\n\t\t\t};\n\t\n\t\t\tfunction createFunctionFromString( signature ) {\n\t\t\t\tvar functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {\n\t\t\t\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t\t\t\t} ) + ')';\n\t\t\t\treturn new Function( functionBody );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/Computation/Computation.js */\n\t\tvar Computation = function( log, isEqual ) {\n\t\n\t\t\tvar Computation = function( ractive, key, signature ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tthis.ractive = ractive;\n\t\t\t\tthis.viewmodel = ractive.viewmodel;\n\t\t\t\tthis.key = key;\n\t\t\t\tthis.getter = signature.get;\n\t\t\t\tthis.setter = signature.set;\n\t\t\t\tthis.hardDeps = signature.deps || [];\n\t\t\t\tthis.softDeps = [];\n\t\t\t\tthis.depValues = {};\n\t\t\t\tif ( this.hardDeps ) {\n\t\t\t\t\tthis.hardDeps.forEach( function( d ) {\n\t\t\t\t\t\treturn ractive.viewmodel.register( d, this$0, 'computed' );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis._dirty = this._firstRun = true;\n\t\t\t};\n\t\t\tComputation.prototype = {\n\t\t\t\tconstructor: Computation,\n\t\t\t\tinit: function() {\n\t\t\t\t\tvar initial;\n\t\t\t\t\tthis.bypass = true;\n\t\t\t\t\tinitial = this.ractive.viewmodel.get( this.key );\n\t\t\t\t\tthis.ractive.viewmodel.clearCache( this.key );\n\t\t\t\t\tthis.bypass = false;\n\t\t\t\t\tif ( this.setter && initial !== undefined ) {\n\t\t\t\t\t\tthis.set( initial );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tinvalidate: function() {\n\t\t\t\t\tthis._dirty = true;\n\t\t\t\t},\n\t\t\t\tget: function() {\n\t\t\t\t\tvar this$0 = this;\n\t\t\t\t\tvar ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\t\t\t\t\tif ( this.getting ) {\n\t\t\t\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.getting = true;\n\t\t\t\t\tif ( this._dirty ) {\n\t\t\t\t\t\tractive = this.ractive;\n\t\t\t\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t\t\t\t// other computed values\n\t\t\t\t\t\tif ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\t\tvar keypath, value, i;\n\t\t\t\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ti = deps.length;\n\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\tkeypath = deps[ i ];\n\t\t\t\t\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\t\tif ( !isEqual( value, this$0.depValues[ keypath ] ) ) {\n\t\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = value;\n\t\t\t\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\t\tractive.viewmodel.capture();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tthis.value = this.getter.call( ractive );\n\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\t\t\tmessage: 'failedComputation',\n\t\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\t\tkey: this.key,\n\t\t\t\t\t\t\t\t\t\terr: err.message || err\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\tthis.value = void 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewDeps = ractive.viewmodel.release();\n\t\t\t\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\t\t\t\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\t\t\tdeps.forEach( function( keypath ) {\n\t\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._dirty = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.getting = this._firstRun = false;\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\tset: function( value ) {\n\t\t\t\t\tif ( this.setting ) {\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !this.setter ) {\n\t\t\t\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t\t\t\t}\n\t\t\t\t\tthis.setter.call( this.ractive, value );\n\t\t\t\t},\n\t\t\t\tupdateDependencies: function( newDeps ) {\n\t\t\t\t\tvar i, oldDeps, keypath, dependenciesChanged;\n\t\t\t\t\toldDeps = this.softDeps;\n\t\t\t\t\t// remove dependencies that are no longer used\n\t\t\t\t\ti = oldDeps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = oldDeps[ i ];\n\t\t\t\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// create references for any new dependencies\n\t\t\t\t\ti = newDeps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = newDeps[ i ];\n\t\t\t\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t\tthis.softDeps = newDeps.slice();\n\t\t\t\t\t}\n\t\t\t\t\treturn dependenciesChanged;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Computation;\n\t\t}( log, isEqual );\n\t\n\t\t/* viewmodel/prototype/compute.js */\n\t\tvar viewmodel$compute = function( getComputationSignature, Computation ) {\n\t\n\t\t\treturn function Viewmodel$compute( key, signature ) {\n\t\t\t\tsignature = getComputationSignature( signature );\n\t\t\t\treturn this.computations[ key ] = new Computation( this.ractive, key, signature );\n\t\t\t};\n\t\t}( getComputationSignature, Computation );\n\t\n\t\t/* viewmodel/prototype/get/FAILED_LOOKUP.js */\n\t\tvar viewmodel$get_FAILED_LOOKUP = {\n\t\t\tFAILED_LOOKUP: true\n\t\t};\n\t\n\t\t/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */\n\t\tvar viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {\n\t\n\t\t\tvar empty = {};\n\t\t\tvar UnresolvedImplicitDependency = function( viewmodel, keypath ) {\n\t\t\t\tthis.viewmodel = viewmodel;\n\t\t\t\tthis.root = viewmodel.ractive;\n\t\t\t\t// TODO eliminate this\n\t\t\t\tthis.ref = keypath;\n\t\t\t\tthis.parentFragment = empty;\n\t\t\t\tviewmodel.unresolvedImplicitDependencies[ keypath ] = true;\n\t\t\t\tviewmodel.unresolvedImplicitDependencies.push( this );\n\t\t\t\trunloop.addUnresolved( this );\n\t\t\t};\n\t\t\tUnresolvedImplicitDependency.prototype = {\n\t\t\t\tresolve: function() {\n\t\t\t\t\tthis.viewmodel.mark( this.ref );\n\t\t\t\t\tthis.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;\n\t\t\t\t\tremoveFromArray( this.viewmodel.unresolvedImplicitDependencies, this );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn UnresolvedImplicitDependency;\n\t\t}( removeFromArray, runloop );\n\t\n\t\t/* viewmodel/prototype/get.js */\n\t\tvar viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar empty = {};\n\t\t\t__export = function Viewmodel$get( keypath ) {\n\t\t\t\tvar options = arguments[ 1 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = empty;\n\t\t\t\tvar ractive = this.ractive,\n\t\t\t\t\tcache = this.cache,\n\t\t\t\t\tvalue, computation, wrapped, captureGroup;\n\t\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\treturn isNumeric( value ) ? +value : value;\n\t\t\t\t}\n\t\t\t\tif ( cache[ keypath ] === undefined ) {\n\t\t\t\t\t// Is this a computed property?\n\t\t\t\t\tif ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {\n\t\t\t\t\t\tvalue = computation.get();\n\t\t\t\t\t\tthis.adapt( keypath, value );\n\t\t\t\t\t} else if ( wrapped = this.wrapped[ keypath ] ) {\n\t\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t\t} else if ( !keypath ) {\n\t\t\t\t\t\tthis.adapt( '', ractive.data );\n\t\t\t\t\t\tvalue = ractive.data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = retrieve( this, keypath );\n\t\t\t\t\t}\n\t\t\t\t\tcache[ keypath ] = value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = cache[ keypath ];\n\t\t\t\t}\n\t\t\t\tif ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {\n\t\t\t\t\tvalue = wrapped.get();\n\t\t\t\t}\n\t\t\t\t// capture the keypath, if we're inside a computation\n\t\t\t\tif ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {\n\t\t\t\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\t\t\t\tcaptureGroup.push( keypath );\n\t\t\t\t\t\t// if we couldn't resolve the keypath, we need to make it as a failed\n\t\t\t\t\t\t// lookup, so that the computation updates correctly once we CAN\n\t\t\t\t\t\t// resolve the keypath\n\t\t\t\t\t\tif ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {\n\t\t\t\t\t\t\tnew UnresolvedImplicitDependency( this, keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value === FAILED_LOOKUP ? void 0 : value;\n\t\t\t};\n\t\n\t\t\tfunction retrieve( viewmodel, keypath ) {\n\t\t\t\tvar keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tkey = keys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\t\tif ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\t\tparentValue = wrapped.get();\n\t\t\t\t}\n\t\t\t\tif ( parentValue === null || parentValue === undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// update cache map\n\t\t\t\tif ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {\n\t\t\t\t\tviewmodel.cacheMap[ parentKeypath ] = [ keypath ];\n\t\t\t\t} else {\n\t\t\t\t\tif ( cacheMap.indexOf( keypath ) === -1 ) {\n\t\t\t\t\t\tcacheMap.push( keypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If this property doesn't exist, we return a sentinel value\n\t\t\t\t// so that we know to query parent scope (if such there be)\n\t\t\t\tif ( typeof parentValue === 'object' && !( key in parentValue ) ) {\n\t\t\t\t\treturn viewmodel.cache[ keypath ] = FAILED_LOOKUP;\n\t\t\t\t}\n\t\t\t\tvalue = parentValue[ key ];\n\t\t\t\t// Do we have an adaptor for this value?\n\t\t\t\tviewmodel.adapt( keypath, value, false );\n\t\t\t\t// Update cache\n\t\t\t\tviewmodel.cache[ keypath ] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );\n\t\n\t\t/* viewmodel/prototype/init.js */\n\t\tvar viewmodel$init = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Viewmodel$init() {\n\t\t\t\tvar key, computation, computations = [];\n\t\t\t\tfor ( key in this.ractive.computed ) {\n\t\t\t\t\tcomputation = this.compute( key, this.ractive.computed[ key ] );\n\t\t\t\t\tcomputations.push( computation );\n\t\t\t\t}\n\t\t\t\tcomputations.forEach( init );\n\t\t\t};\n\t\n\t\t\tfunction init( computation ) {\n\t\t\t\tcomputation.init();\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/prototype/mark.js */\n\t\tvar viewmodel$mark = function Viewmodel$mark( keypath, options ) {\n\t\t\tvar computation;\n\t\t\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t\t\t// should not be picked up by pattern observers\n\t\t\tif ( options ) {\n\t\t\t\tif ( options.implicit ) {\n\t\t\t\t\tthis.implicitChanges[ keypath ] = true;\n\t\t\t\t}\n\t\t\t\tif ( options.noCascade ) {\n\t\t\t\t\tthis.noCascade[ keypath ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( computation = this.computations[ keypath ] ) {\n\t\t\t\tcomputation.invalidate();\n\t\t\t}\n\t\t\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\t\t\tthis.changes.push( keypath );\n\t\t\t}\n\t\t\tthis.clearCache( keypath );\n\t\t};\n\t\n\t\t/* viewmodel/prototype/merge/mapOldToNewIndex.js */\n\t\tvar viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {\n\t\t\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\t\t\tusedIndices = {};\n\t\t\tfirstUnusedIndex = 0;\n\t\t\tnewIndices = oldArray.map( function( item, i ) {\n\t\t\t\tvar index, start, len;\n\t\t\t\tstart = firstUnusedIndex;\n\t\t\t\tlen = newArray.length;\n\t\t\t\tdo {\n\t\t\t\t\tindex = newArray.indexOf( item, start );\n\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tstart = index + 1;\n\t\t\t\t} while ( usedIndices[ index ] && start < len );\n\t\t\t\t// keep track of the first unused index, so we don't search\n\t\t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\t\t\tif ( index === firstUnusedIndex ) {\n\t\t\t\t\tfirstUnusedIndex += 1;\n\t\t\t\t}\n\t\t\t\tif ( index !== i ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tusedIndices[ index ] = true;\n\t\t\t\treturn index;\n\t\t\t} );\n\t\t\treturn newIndices;\n\t\t};\n\t\n\t\t/* viewmodel/prototype/merge.js */\n\t\tvar viewmodel$merge = function( warn, mapOldToNewIndex ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar comparators = {};\n\t\t\t__export = function Viewmodel$merge( keypath, currentArray, array, options ) {\n\t\t\t\tvar oldArray, newArray, comparator, newIndices;\n\t\t\t\tthis.mark( keypath );\n\t\t\t\tif ( options && options.compare ) {\n\t\t\t\t\tcomparator = getComparatorFunction( options.compare );\n\t\t\t\t\ttry {\n\t\t\t\t\t\toldArray = currentArray.map( comparator );\n\t\t\t\t\t\tnewArray = array.map( comparator );\n\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t\t\t\t// to do more DOM manipulation than we thought...\n\t\t\t\t\t\t// ...unless we're in debug mode of course\n\t\t\t\t\t\tif ( this.debug ) {\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn( 'Merge operation: comparison failed. Falling back to identity checking' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\toldArray = currentArray;\n\t\t\t\t\t\tnewArray = array;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toldArray = currentArray;\n\t\t\t\t\tnewArray = array;\n\t\t\t\t}\n\t\t\t\t// find new indices for members of oldArray\n\t\t\t\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\t\t\t\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n\t\t\t};\n\t\n\t\t\tfunction stringify( item ) {\n\t\t\t\treturn JSON.stringify( item );\n\t\t\t}\n\t\n\t\t\tfunction getComparatorFunction( comparator ) {\n\t\t\t\t// If `compare` is `true`, we use JSON.stringify to compare\n\t\t\t\t// objects that are the same shape, but non-identical - i.e.\n\t\t\t\t// { foo: 'bar' } !== { foo: 'bar' }\n\t\t\t\tif ( comparator === true ) {\n\t\t\t\t\treturn stringify;\n\t\t\t\t}\n\t\t\t\tif ( typeof comparator === 'string' ) {\n\t\t\t\t\tif ( !comparators[ comparator ] ) {\n\t\t\t\t\t\tcomparators[ comparator ] = function( item ) {\n\t\t\t\t\t\t\treturn item[ comparator ];\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn comparators[ comparator ];\n\t\t\t\t}\n\t\t\t\tif ( typeof comparator === 'function' ) {\n\t\t\t\t\treturn comparator;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( warn, viewmodel$merge_mapOldToNewIndex );\n\t\n\t\t/* viewmodel/prototype/register.js */\n\t\tvar viewmodel$register = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Viewmodel$register( keypath, dependant ) {\n\t\t\t\tvar group = arguments[ 2 ];\n\t\t\t\tif ( group === void 0 )\n\t\t\t\t\tgroup = 'default';\n\t\t\t\tvar depsByKeypath, deps;\n\t\t\t\tif ( dependant.isStatic ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\t\t\tdeps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );\n\t\t\t\tdeps.push( dependant );\n\t\t\t\tif ( !keypath ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t\t};\n\t\n\t\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t\t// update dependants map\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\twhile ( keys.length ) {\n\t\t\t\t\tkeys.pop();\n\t\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\t\tmap = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );\n\t\t\t\t\tparent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );\n\t\t\t\t\tif ( parent[ keypath ] === undefined ) {\n\t\t\t\t\t\tparent[ keypath ] = 0;\n\t\t\t\t\t\tparent.push( keypath );\n\t\t\t\t\t}\n\t\t\t\t\tparent[ keypath ] += 1;\n\t\t\t\t\tkeypath = parentKeypath;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/prototype/release.js */\n\t\tvar viewmodel$release = function Viewmodel$release() {\n\t\t\treturn this.captureGroups.pop();\n\t\t};\n\t\n\t\t/* viewmodel/prototype/set.js */\n\t\tvar viewmodel$set = function( isEqual, createBranch ) {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Viewmodel$set( keypath, value, silent ) {\n\t\t\t\tvar computation, wrapper, dontTeardownWrapper;\n\t\t\t\tcomputation = this.computations[ keypath ];\n\t\t\t\tif ( computation ) {\n\t\t\t\t\tif ( computation.setting ) {\n\t\t\t\t\t\t// let the other computation set() handle things...\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcomputation.set( value );\n\t\t\t\t\tvalue = computation.get();\n\t\t\t\t}\n\t\t\t\tif ( isEqual( this.cache[ keypath ], value ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twrapper = this.wrapped[ keypath ];\n\t\t\t\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t\t\t\t// `reset()` method returns false, the wrapper should be torn down, and\n\t\t\t\t// (most likely) a new one should be created later\n\t\t\t\tif ( wrapper && wrapper.reset ) {\n\t\t\t\t\tdontTeardownWrapper = wrapper.reset( value ) !== false;\n\t\t\t\t\tif ( dontTeardownWrapper ) {\n\t\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !computation && !dontTeardownWrapper ) {\n\t\t\t\t\tresolveSet( this, keypath, value );\n\t\t\t\t}\n\t\t\t\tif ( !silent ) {\n\t\t\t\t\tthis.mark( keypath );\n\t\t\t\t} else {\n\t\t\t\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t\t\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t\t\t\t// not mark it as a change\n\t\t\t\t\tthis.clearCache( keypath );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction resolveSet( viewmodel, keypath, value ) {\n\t\t\t\tvar keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;\n\t\t\t\twrapperSet = function() {\n\t\t\t\t\tif ( wrapper.set ) {\n\t\t\t\t\t\twrapper.set( lastKey, value );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentValue = wrapper.get();\n\t\t\t\t\t\tvalueSet();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvalueSet = function() {\n\t\t\t\t\tif ( !parentValue ) {\n\t\t\t\t\t\tparentValue = createBranch( lastKey );\n\t\t\t\t\t\tviewmodel.set( parentKeypath, parentValue, true );\n\t\t\t\t\t}\n\t\t\t\t\tparentValue[ lastKey ] = value;\n\t\t\t\t};\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tlastKey = keys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\twrapper = viewmodel.wrapped[ parentKeypath ];\n\t\t\t\tif ( wrapper ) {\n\t\t\t\t\twrapperSet();\n\t\t\t\t} else {\n\t\t\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\t\t\t// may have been wrapped via the above .get()\n\t\t\t\t\t// call on viewmodel if this is first access via .set()!\n\t\t\t\t\tif ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\t\t\twrapperSet();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueSet();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( isEqual, createBranch );\n\t\n\t\t/* viewmodel/prototype/smartUpdate.js */\n\t\tvar viewmodel$smartUpdate = function() {\n\t\n\t\t\tvar __export;\n\t\t\tvar implicitOption = {\n\t\t\t\t\timplicit: true\n\t\t\t\t},\n\t\t\t\tnoCascadeOption = {\n\t\t\t\t\tnoCascade: true\n\t\t\t\t};\n\t\t\t__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar dependants, oldLength;\n\t\t\t\toldLength = newIndices.length;\n\t\t\t\t// Indices that are being removed should be marked as dirty\n\t\t\t\tnewIndices.forEach( function( newIndex, oldIndex ) {\n\t\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\t\tthis$0.mark( keypath + '.' + oldIndex, noCascadeOption );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\t// Update the model\n\t\t\t\t// TODO allow existing array to be updated in place, rather than replaced?\n\t\t\t\tthis.set( keypath, array, true );\n\t\t\t\tif ( dependants = this.deps[ 'default' ][ keypath ] ) {\n\t\t\t\t\tdependants.filter( canShuffle ).forEach( function( d ) {\n\t\t\t\t\t\treturn d.shuffle( newIndices, array );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tif ( oldLength !== array.length ) {\n\t\t\t\t\tthis.mark( keypath + '.length', implicitOption );\n\t\t\t\t\tfor ( var i = oldLength; i < array.length; i += 1 ) {\n\t\t\t\t\t\tthis.mark( keypath + '.' + i );\n\t\t\t\t\t}\n\t\t\t\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t\t\t\tfor ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {\n\t\t\t\t\t\tthis.mark( keypath + '.' + i$0, noCascadeOption );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction canShuffle( dependant ) {\n\t\t\t\treturn typeof dependant.shuffle === 'function';\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/prototype/teardown.js */\n\t\tvar viewmodel$teardown = function Viewmodel$teardown() {\n\t\t\tvar this$0 = this;\n\t\t\tvar unresolvedImplicitDependency;\n\t\t\t// Clear entire cache - this has the desired side-effect\n\t\t\t// of unwrapping adapted values (e.g. arrays)\n\t\t\tObject.keys( this.cache ).forEach( function( keypath ) {\n\t\t\t\treturn this$0.clearCache( keypath );\n\t\t\t} );\n\t\t\t// Teardown any failed lookups - we don't need them to resolve any more\n\t\t\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\t\t\tunresolvedImplicitDependency.teardown();\n\t\t\t}\n\t\t};\n\t\n\t\t/* viewmodel/prototype/unregister.js */\n\t\tvar viewmodel$unregister = function() {\n\t\n\t\t\tvar __export;\n\t\t\t__export = function Viewmodel$unregister( keypath, dependant ) {\n\t\t\t\tvar group = arguments[ 2 ];\n\t\t\t\tif ( group === void 0 )\n\t\t\t\t\tgroup = 'default';\n\t\t\t\tvar deps, index;\n\t\t\t\tif ( dependant.isStatic ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdeps = this.deps[ group ][ keypath ];\n\t\t\t\tindex = deps.indexOf( dependant );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t\t\t\t}\n\t\t\t\tdeps.splice( index, 1 );\n\t\t\t\tif ( !keypath ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t\t};\n\t\n\t\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t\t// update dependants map\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\twhile ( keys.length ) {\n\t\t\t\t\tkeys.pop();\n\t\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\t\tmap = viewmodel.depsMap[ group ];\n\t\t\t\t\tparent = map[ parentKeypath ];\n\t\t\t\t\tparent[ keypath ] -= 1;\n\t\t\t\t\tif ( !parent[ keypath ] ) {\n\t\t\t\t\t\t// remove from parent deps map\n\t\t\t\t\t\tparent.splice( parent.indexOf( keypath ), 1 );\n\t\t\t\t\t\tparent[ keypath ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tkeypath = parentKeypath;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}();\n\t\n\t\t/* viewmodel/adaptConfig.js */\n\t\tvar adaptConfig = function() {\n\t\n\t\t\t// should this be combined with prototype/adapt.js?\n\t\t\tvar configure = {\n\t\t\t\tlookup: function( target, adaptors ) {\n\t\t\t\t\tvar i, adapt = target.adapt;\n\t\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\t\treturn adapt;\n\t\t\t\t\t}\n\t\t\t\t\tif ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tvar adaptor = adapt[ i ];\n\t\t\t\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\t\t\t\tadapt[ i ] = adaptors[ adaptor ] || adaptor;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn adapt;\n\t\t\t\t},\n\t\t\t\tcombine: function( parent, adapt ) {\n\t\t\t\t\t// normalize 'Foo' to [ 'Foo' ]\n\t\t\t\t\tparent = arrayIfString( parent );\n\t\t\t\t\tadapt = arrayIfString( adapt );\n\t\t\t\t\t// no parent? return adapt\n\t\t\t\t\tif ( !parent || !parent.length ) {\n\t\t\t\t\t\treturn adapt;\n\t\t\t\t\t}\n\t\t\t\t\t// no adapt? return 'copy' of parent\n\t\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\t\treturn parent.slice();\n\t\t\t\t\t}\n\t\t\t\t\t// add parent adaptors to options\n\t\t\t\t\tparent.forEach( function( a ) {\n\t\t\t\t\t\t// don't put in duplicates\n\t\t\t\t\t\tif ( adapt.indexOf( a ) === -1 ) {\n\t\t\t\t\t\t\tadapt.push( a );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn adapt;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction arrayIfString( adapt ) {\n\t\t\t\tif ( typeof adapt === 'string' ) {\n\t\t\t\t\tadapt = [ adapt ];\n\t\t\t\t}\n\t\t\t\treturn adapt;\n\t\t\t}\n\t\t\treturn configure;\n\t\t}();\n\t\n\t\t/* viewmodel/Viewmodel.js */\n\t\tvar Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {\n\t\n\t\t\tvar noMagic;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\t\tvalue: 0\n\t\t\t\t} );\n\t\t\t} catch ( err ) {\n\t\t\t\tnoMagic = true;\n\t\t\t}\n\t\t\tvar Viewmodel = function( ractive ) {\n\t\t\t\tthis.ractive = ractive;\n\t\t\t\t// TODO eventually, we shouldn't need this reference\n\t\t\t\tViewmodel.extend( ractive.constructor, ractive );\n\t\t\t\tthis.cache = {};\n\t\t\t\t// we need to be able to use hasOwnProperty, so can't inherit from null\n\t\t\t\tthis.cacheMap = create( null );\n\t\t\t\tthis.deps = {\n\t\t\t\t\tcomputed: {},\n\t\t\t\t\t'default': {}\n\t\t\t\t};\n\t\t\t\tthis.depsMap = {\n\t\t\t\t\tcomputed: {},\n\t\t\t\t\t'default': {}\n\t\t\t\t};\n\t\t\t\tthis.patternObservers = [];\n\t\t\t\tthis.wrapped = create( null );\n\t\t\t\tthis.computations = create( null );\n\t\t\t\tthis.captureGroups = [];\n\t\t\t\tthis.unresolvedImplicitDependencies = [];\n\t\t\t\tthis.changes = [];\n\t\t\t\tthis.implicitChanges = {};\n\t\t\t\tthis.noCascade = {};\n\t\t\t};\n\t\t\tViewmodel.extend = function( Parent, instance ) {\n\t\t\t\tif ( instance.magic && noMagic ) {\n\t\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t\t}\n\t\t\t\tinstance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];\n\t\t\t\tinstance.adapt = adaptConfig.lookup( instance, instance.adaptors );\n\t\t\t};\n\t\t\tViewmodel.prototype = {\n\t\t\t\tadapt: adapt,\n\t\t\t\tapplyChanges: applyChanges,\n\t\t\t\tcapture: capture,\n\t\t\t\tclearCache: clearCache,\n\t\t\t\tcompute: compute,\n\t\t\t\tget: get,\n\t\t\t\tinit: init,\n\t\t\t\tmark: mark,\n\t\t\t\tmerge: merge,\n\t\t\t\tregister: register,\n\t\t\t\trelease: release,\n\t\t\t\tset: set,\n\t\t\t\tsmartUpdate: smartUpdate,\n\t\t\t\tteardown: teardown,\n\t\t\t\tunregister: unregister\n\t\t\t};\n\t\t\treturn Viewmodel;\n\t\t}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );\n\t\n\t\t/* Ractive/initialise.js */\n\t\tvar Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar constructHook = new Hook( 'construct' ),\n\t\t\t\tconfigHook = new Hook( 'config' ),\n\t\t\t\tinitHook = new HookQueue( 'init' );\n\t\t\t__export = function initialiseRactiveInstance( ractive ) {\n\t\t\t\tvar options = arguments[ 1 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = {};\n\t\t\t\tvar el;\n\t\t\t\tinitialiseProperties( ractive, options );\n\t\t\t\t// make this option do what would be expected if someone\n\t\t\t\t// did include it on a new Ractive() or new Component() call.\n\t\t\t\t// Silly to do so (put a hook on the very options being used),\n\t\t\t\t// but handle it correctly, consistent with the intent.\n\t\t\t\tconstructHook.fire( config.getConstructTarget( ractive, options ), options );\n\t\t\t\t// init config from Parent and options\n\t\t\t\tconfig.init( ractive.constructor, ractive, options );\n\t\t\t\tconfigHook.fire( ractive );\n\t\t\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t\t\t// avoids certain weird bugs\n\t\t\t\tif ( el = getElement( ractive.el ) ) {\n\t\t\t\t\tif ( !ractive.append ) {\n\t\t\t\t\t\tif ( el.__ractive_instances__ ) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tel.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {\n\t\t\t\t\t\t\t\t\treturn r.teardown();\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tel.innerHTML = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinitHook.begin( ractive );\n\t\t\t\t// TEMPORARY. This is so we can implement Viewmodel gradually\n\t\t\t\tractive.viewmodel = new Viewmodel( ractive );\n\t\t\t\t// hacky circular problem until we get this sorted out\n\t\t\t\t// if viewmodel immediately processes computed properties,\n\t\t\t\t// they may call ractive.get, which calls ractive.viewmodel,\n\t\t\t\t// which hasn't been set till line above finishes.\n\t\t\t\tractive.viewmodel.init();\n\t\t\t\t// Render our *root fragment*\n\t\t\t\tif ( ractive.template ) {\n\t\t\t\t\tractive.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: ractive.template,\n\t\t\t\t\t\troot: ractive,\n\t\t\t\t\t\towner: ractive\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tinitHook.end( ractive );\n\t\t\t\t// render automatically ( if `el` is specified )\n\t\t\t\tif ( el ) {\n\t\t\t\t\tractive.render( el, ractive.append );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction initialiseProperties( ractive, options ) {\n\t\t\t\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t\t\t\t// existed\n\t\t\t\tractive._guid = getNextNumber();\n\t\t\t\t// events\n\t\t\t\tractive._subs = create( null );\n\t\t\t\t// storage for item configuration from instantiation to reset,\n\t\t\t\t// like dynamic functions or original values\n\t\t\t\tractive._config = {};\n\t\t\t\t// two-way bindings\n\t\t\t\tractive._twowayBindings = create( null );\n\t\t\t\t// animations (so we can stop any in progress at teardown)\n\t\t\t\tractive._animations = [];\n\t\t\t\t// nodes registry\n\t\t\t\tractive.nodes = {};\n\t\t\t\t// live queries\n\t\t\t\tractive._liveQueries = [];\n\t\t\t\tractive._liveComponentQueries = [];\n\t\t\t\t// If this is a component, store a reference to the parent\n\t\t\t\tif ( options._parent && options._component ) {\n\t\t\t\t\tractive._parent = options._parent;\n\t\t\t\t\tractive.component = options._component;\n\t\t\t\t\t// And store a reference to the instance on the component\n\t\t\t\t\toptions._component.instance = ractive;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );\n\t\n\t\t/* extend/unwrapExtended.js */\n\t\tvar unwrapExtended = function( wrap, config, circular ) {\n\t\n\t\t\tvar __export;\n\t\t\tvar Ractive;\n\t\t\tcircular.push( function() {\n\t\t\t\tRactive = circular.Ractive;\n\t\t\t} );\n\t\t\t__export = function unwrapExtended( Child ) {\n\t\t\t\tif ( !( Child.prototype instanceof Ractive ) ) {\n\t\t\t\t\treturn Child;\n\t\t\t\t}\n\t\t\t\tvar options = {};\n\t\t\t\twhile ( Child ) {\n\t\t\t\t\tconfig.registries.forEach( function( r ) {\n\t\t\t\t\t\taddRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );\n\t\t\t\t\t} );\n\t\t\t\t\tObject.keys( Child.prototype ).forEach( function( key ) {\n\t\t\t\t\t\tif ( key === 'computed' ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar value = Child.prototype[ key ];\n\t\t\t\t\t\tif ( !( key in options ) ) {\n\t\t\t\t\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t\t\t\t\t} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {\n\t\t\t\t\t\t\tvar result, needsSuper = value._method;\n\t\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\t\tvalue = value._method;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// rewrap bound directly to parent fn\n\t\t\t\t\t\t\tresult = wrap( options[ key ]._method, value );\n\t\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\t\tresult._method = result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toptions[ key ] = result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tif ( Child._parent !== Ractive ) {\n\t\t\t\t\t\tChild = Child._parent;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tChild = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn options;\n\t\t\t};\n\t\n\t\t\tfunction addRegistry( target, options, name ) {\n\t\t\t\tvar registry, keys = Object.keys( target[ name ] );\n\t\t\t\tif ( !keys.length ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !( registry = options[ name ] ) ) {\n\t\t\t\t\tregistry = options[ name ] = {};\n\t\t\t\t}\n\t\t\t\tkeys.filter( function( key ) {\n\t\t\t\t\treturn !( key in registry );\n\t\t\t\t} ).forEach( function( key ) {\n\t\t\t\t\treturn registry[ key ] = target[ name ][ key ];\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn __export;\n\t\t}( wrapMethod, config, circular );\n\t\n\t\t/* extend/_extend.js */\n\t\tvar Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {\n\t\n\t\t\treturn function extend() {\n\t\t\t\tvar options = arguments[ 0 ];\n\t\t\t\tif ( options === void 0 )\n\t\t\t\t\toptions = {};\n\t\t\t\tvar Parent = this,\n\t\t\t\t\tChild, proto, staticProperties;\n\t\t\t\t// if we're extending with another Ractive instance, inherit its\n\t\t\t\t// prototype methods and default options as well\n\t\t\t\toptions = unwrap( options );\n\t\t\t\t// create Child constructor\n\t\t\t\tChild = function( options ) {\n\t\t\t\t\tinitialise( this, options );\n\t\t\t\t};\n\t\t\t\tproto = create( Parent.prototype );\n\t\t\t\tproto.constructor = Child;\n\t\t\t\tstaticProperties = {\n\t\t\t\t\t// each component needs a guid, for managing CSS etc\n\t\t\t\t\t_guid: {\n\t\t\t\t\t\tvalue: getGuid()\n\t\t\t\t\t},\n\t\t\t\t\t// alias prototype as defaults\n\t\t\t\t\tdefaults: {\n\t\t\t\t\t\tvalue: proto\n\t\t\t\t\t},\n\t\t\t\t\t// extendable\n\t\t\t\t\textend: {\n\t\t\t\t\t\tvalue: extend,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t},\n\t\t\t\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t\t\t\t_parent: {\n\t\t\t\t\t\tvalue: Parent\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdefineProperties( Child, staticProperties );\n\t\t\t\t// extend configuration\n\t\t\t\tconfig.extend( Parent, proto, options );\n\t\t\t\tViewmodel.extend( Parent, proto );\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn Child;\n\t\t\t};\n\t\t}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );\n\t\n\t\t/* Ractive.js */\n\t\tvar Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {\n\t\n\t\t\tvar Ractive, properties;\n\t\t\t// Main Ractive required object\n\t\t\tRactive = function( options ) {\n\t\t\t\tinitialise( this, options );\n\t\t\t};\n\t\t\t// Ractive properties\n\t\t\tproperties = {\n\t\t\t\t// static methods:\n\t\t\t\textend: {\n\t\t\t\t\tvalue: extend\n\t\t\t\t},\n\t\t\t\tparse: {\n\t\t\t\t\tvalue: parse\n\t\t\t\t},\n\t\t\t\t// Namespaced constructors\n\t\t\t\tPromise: {\n\t\t\t\t\tvalue: Promise\n\t\t\t\t},\n\t\t\t\t// support\n\t\t\t\tsvg: {\n\t\t\t\t\tvalue: svg\n\t\t\t\t},\n\t\t\t\tmagic: {\n\t\t\t\t\tvalue: magic\n\t\t\t\t},\n\t\t\t\t// version\n\t\t\t\tVERSION: {\n\t\t\t\t\tvalue: '0.6.1'\n\t\t\t\t},\n\t\t\t\t// Plugins\n\t\t\t\tadaptors: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t},\n\t\t\t\tcomponents: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t},\n\t\t\t\tdecorators: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t},\n\t\t\t\teasing: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: easing\n\t\t\t\t},\n\t\t\t\tevents: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t},\n\t\t\t\tinterpolators: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: interpolators\n\t\t\t\t},\n\t\t\t\tpartials: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t},\n\t\t\t\ttransitions: {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: {}\n\t\t\t\t}\n\t\t\t};\n\t\t\t// Ractive properties\n\t\t\tdefineProperties( Ractive, properties );\n\t\t\tRactive.prototype = extendObj( proto, defaults );\n\t\t\tRactive.prototype.constructor = Ractive;\n\t\t\t// alias prototype as defaults\n\t\t\tRactive.defaults = Ractive.prototype;\n\t\t\t// Certain modules have circular dependencies. If we were bundling a\n\t\t\t// module loader, e.g. almond.js, this wouldn't be a problem, but we're\n\t\t\t// not - we're using amdclean as part of the build process. Because of\n\t\t\t// this, we need to wait until all modules have loaded before those\n\t\t\t// circular dependencies can be required.\n\t\t\tcircular.Ractive = Ractive;\n\t\t\twhile ( circular.length ) {\n\t\t\t\tcircular.pop()();\n\t\t\t}\n\t\t\t// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t\t\t// older browsers, these are made available via a shim - here, we do a quick\n\t\t\t// pre-flight check to make sure that either a) we're not in a shit browser,\n\t\t\t// or b) we're using a Ractive-legacy.js build\n\t\t\tvar FUNCTION = 'function';\n\t\t\tif ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {\n\t\t\t\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t\t\t}\n\t\t\treturn Ractive;\n\t\t}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );\n\t\n\t\n\t\t// export as Common JS module...\n\t\tif ( typeof module !== \"undefined\" && module.exports ) {\n\t\t\tmodule.exports = Ractive;\n\t\t}\n\t\n\t\t// ... or as AMD module\n\t\telse if ( true ) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn Ractive;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\n\t\n\t\t// ... or as browser global\n\t\tglobal.Ractive = Ractive;\n\t\n\t\tRactive.noConflict = function() {\n\t\t\tglobal.Ractive = noConflict;\n\t\t\treturn Ractive;\n\t\t};\n\t\n\t}( typeof window !== 'undefined' ? window : this ) );\n\n\n/***/ },\n\n/***/ 276:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(244);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(17)(content, {});\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tmodule.hot.accept(\"!!/home/ubuntu/bemuse/node_modules/css-loader/index.js!/home/ubuntu/bemuse/node_modules/autoprefixer-loader/index.js?browsers=last 2 version!/home/ubuntu/bemuse/node_modules/sass-loader/index.js?outputStyle=expanded!/home/ubuntu/bemuse/src/game/loading-scene/style.scss\", function() {\n\t\t\tvar newContent = require(\"!!/home/ubuntu/bemuse/node_modules/css-loader/index.js!/home/ubuntu/bemuse/node_modules/autoprefixer-loader/index.js?browsers=last 2 version!/home/ubuntu/bemuse/node_modules/sass-loader/index.js?outputStyle=expanded!/home/ubuntu/bemuse/src/game/loading-scene/style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [module.id, newContent, ''];\n\t\t\tupdate(newContent);\n\t\t});\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 363:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n\n/***/ 364:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))\n\n/***/ },\n\n/***/ 367:\n/***/ function(module, exports, __webpack_require__) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n\n/***/ 368:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function isBuffer(arg) {\n\t  return arg && typeof arg === 'object'\n\t    && typeof arg.copy === 'function'\n\t    && typeof arg.fill === 'function'\n\t    && typeof arg.readUInt8 === 'function';\n\t}\n\n/***/ },\n\n/***/ 369:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar View = __webpack_require__(198).View; var template = __webpack_require__(254); module.exports = new View(template);\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** gameMode-7e758bd1f3a7c694c3b8.js\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Use chrome.storage.local if we are in an app\n */\n\nvar storage;\n\nif (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')\n  storage = chrome.storage.local;\nelse\n  storage = window.localStorage;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      storage.removeItem('debug');\n    } else {\n      storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/debug/browser.js\n ** module id = 5\n ** module chunks = 0 1 2 3 7\n **/","//  Ramda v0.9.1\n//  https://github.com/ramda/ramda\n//  (c) 2013-2015 Scott Sauyet and Michael Hurley\n//  Ramda may be freely distributed under the MIT license.\n\n;(function() {\n\n    'use strict';\n\n    var __ = { ramda: 'placeholder' };\n\n    var _add = function _add(a, b) {\n        return a + b;\n    };\n\n    var _all = function _all(fn, list) {\n        var idx = -1;\n        while (++idx < list.length) {\n            if (!fn(list[idx])) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    var _any = function _any(fn, list) {\n        var idx = -1;\n        while (++idx < list.length) {\n            if (fn(list[idx])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Basic, right-associative composition function. Accepts two functions and returns the\n     * composite function; this composite function represents the operation `var h = f(g(x))`,\n     * where `f` is the first argument, `g` is the second argument, and `x` is whatever\n     * argument(s) are passed to `h`.\n     *\n     * This function's main use is to build the more general `compose` function, which accepts\n     * any number of functions.\n     *\n     * @private\n     * @category Function\n     * @param {Function} f A function.\n     * @param {Function} g A function.\n     * @return {Function} A new function that is the equivalent of `f(g(x))`.\n     * @example\n     *\n     *      var double = function(x) { return x * 2; };\n     *      var square = function(x) { return x * x; };\n     *      var squareThenDouble = _compose(double, square);\n     *\n     *      squareThenDouble(5); //≅ double(square(5)) => 50\n     */\n    var _compose = function _compose(f, g) {\n        return function () {\n            return f.call(this, g.apply(this, arguments));\n        };\n    };\n\n    /**\n     * Private `concat` function to merge two array-like objects.\n     *\n     * @private\n     * @param {Array|Arguments} [set1=[]] An array-like object.\n     * @param {Array|Arguments} [set2=[]] An array-like object.\n     * @return {Array} A new, merged array.\n     * @example\n     *\n     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     */\n    var _concat = function _concat(set1, set2) {\n        set1 = set1 || [];\n        set2 = set2 || [];\n        var idx;\n        var len1 = set1.length;\n        var len2 = set2.length;\n        var result = new Array(len1 + len2);\n        idx = -1;\n        while (++idx < len1) {\n            result[idx] = set1[idx];\n        }\n        idx = -1;\n        while (++idx < len2) {\n            result[len1 + idx] = set2[idx];\n        }\n        return result;\n    };\n\n    var _containsWith = function _containsWith(pred, x, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len) {\n            if (pred(x, list[idx])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Create a function which takes a comparator function and a list\n     * and determines the winning value by a compatator. Used internally\n     * by `R.maxBy` and `R.minBy`\n     *\n     * @private\n     * @param {Function} compatator a function to compare two items\n     * @category Math\n     * @return {Function}\n     */\n    var _createMaxMinBy = function _createMaxMinBy(comparator) {\n        return function (valueComputer, list) {\n            if (!(list && list.length > 0)) {\n                return;\n            }\n            var idx = 0, winner = list[idx], computedWinner = valueComputer(winner), computedCurrent;\n            while (++idx < list.length) {\n                computedCurrent = valueComputer(list[idx]);\n                if (comparator(computedCurrent, computedWinner)) {\n                    computedWinner = computedCurrent;\n                    winner = list[idx];\n                }\n            }\n            return winner;\n        };\n    };\n\n    var _filter = function _filter(fn, list) {\n        var idx = -1, len = list.length, result = [];\n        while (++idx < len) {\n            if (fn(list[idx])) {\n                result[result.length] = list[idx];\n            }\n        }\n        return result;\n    };\n\n    var _filterIndexed = function _filterIndexed(fn, list) {\n        var idx = -1, len = list.length, result = [];\n        while (++idx < len) {\n            if (fn(list[idx], idx, list)) {\n                result[result.length] = list[idx];\n            }\n        }\n        return result;\n    };\n\n    var _foldl = function _foldl(fn, acc, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len) {\n            acc = fn(acc, list[idx]);\n        }\n        return acc;\n    };\n\n    // i can't bear not to return *something*\n    var _forEach = function _forEach(fn, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len) {\n            fn(list[idx]);\n        }\n        // i can't bear not to return *something*\n        return list;\n    };\n\n    /**\n     * @private\n     * @param {Function} fn The strategy for extracting function names from an object\n     * @return {Function} A function that takes an object and returns an array of function names.\n     *\n     */\n    var _functionsWith = function _functionsWith(fn) {\n        return function (obj) {\n            return _filter(function (key) {\n                return typeof obj[key] === 'function';\n            }, fn(obj));\n        };\n    };\n\n    var _gt = function _gt(a, b) {\n        return a > b;\n    };\n\n    /**\n     * Internal implementation of `indexOf`.\n     * Returns the position of the first occurrence of an item in an array\n     * (by strict equality),\n     * or -1 if the item is not included in the array.\n     *\n     * @private\n     * @param {Array} list The array to search\n     * @param {*} item the item to find in the Array\n     * @param {Number} from (optional) the index to start searching the Array\n     * @return {Number} The index of the found item, or -1.\n     *\n     */\n    var _indexOf = function _indexOf(list, item, from) {\n        var idx = 0, len = list.length;\n        if (typeof from == 'number') {\n            idx = from < 0 ? Math.max(0, len + from) : from;\n        }\n        while (idx < len) {\n            if (list[idx] === item) {\n                return idx;\n            }\n            ++idx;\n        }\n        return -1;\n    };\n\n    /**\n     * Tests whether or not an object is an array.\n     *\n     * @private\n     * @param {*} val The object to test.\n     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n     * @example\n     *\n     *      _isArray([]); //=> true\n     *      _isArray(null); //=> false\n     *      _isArray({}); //=> false\n     */\n    var _isArray = Array.isArray || function _isArray(val) {\n        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n    };\n\n    /**\n     * Determine if the passed argument is an integer.\n     *\n     * @private\n     * @param {*} n\n     * @category Type\n     * @return {Boolean}\n     */\n    var _isInteger = Number.isInteger || function _isInteger(n) {\n        return n << 0 === n;\n    };\n\n    /**\n     * Tests if a value is a thenable (promise).\n     */\n    var _isThenable = function _isThenable(value) {\n        return value != null && value === Object(value) && typeof value.then === 'function';\n    };\n\n    /**\n     * Internal implementation of `lastIndexOf`.\n     * Returns the position of the last occurrence of an item in an array\n     * (by strict equality),\n     * or -1 if the item is not included in the array.\n     *\n     * @private\n     * @param {Array} list The array to search\n     * @param {*} item the item to find in the Array\n     * @param {Number} from (optional) the index to start searching the Array\n     * @return {Number} The index of the found item, or -1.\n     *\n     */\n    var _lastIndexOf = function _lastIndexOf(list, item, from) {\n        var idx = list.length;\n        if (typeof from == 'number') {\n            idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n        }\n        while (--idx >= 0) {\n            if (list[idx] === item) {\n                return idx;\n            }\n        }\n        return -1;\n    };\n\n    var _lt = function _lt(a, b) {\n        return a < b;\n    };\n\n    var _map = function _map(fn, list) {\n        var idx = -1, len = list.length, result = new Array(len);\n        while (++idx < len) {\n            result[idx] = fn(list[idx]);\n        }\n        return result;\n    };\n\n    var _multiply = function _multiply(a, b) {\n        return a * b;\n    };\n\n    /**\n     * Creates an exception about calling a function with no arguments.\n     *\n     * @private\n     * @return {TypeError} A no arguments exception.\n     */\n    var _noArgsException = function _noArgsException() {\n        return new TypeError('Function called with no arguments');\n    };\n\n    var _nth = function _nth(n, list) {\n        return n < 0 ? list[list.length + n] : list[n];\n    };\n\n    /**\n     * A right-associative two-argument composition function like `_compose`\n     * but with automatic handling of promises (or, more precisely,\n     * \"thenables\"). This function is used to construct a more general\n     * `pCompose` function, which accepts any number of arguments.\n     *\n     * @private\n     * @category Function\n     * @param {Function} f A function.\n     * @param {Function} g A function.\n     * @return {Function} A new function that is the equivalent of `f(g(x))`.\n     * @example\n     *\n     *      var Q = require('q');\n     *      var double = function(x) { return x * 2; };\n     *      var squareAsync = function(x) { return Q.when(x * x); };\n     *      var squareAsyncThenDouble = _pCompose(double, squareAsync);\n     *\n     *      squareAsyncThenDouble(5)\n     *          .then(function(result) {\n     *            // the result is now 50.\n     *          });\n     */\n    var _pCompose = function _pCompose(f, g) {\n        return function () {\n            var context = this;\n            var value = g.apply(this, arguments);\n            if (_isThenable(value)) {\n                return value.then(function (result) {\n                    return f.call(context, result);\n                });\n            } else {\n                return f.call(this, value);\n            }\n        };\n    };\n\n    /**\n     * @private\n     * @param {Function} fn The strategy for extracting keys from an object\n     * @return {Function} A function that takes an object and returns an array of\n     *         key-value arrays.\n     */\n    var _pairWith = function _pairWith(fn) {\n        return function (obj) {\n            return _map(function (key) {\n                return [\n                    key,\n                    obj[key]\n                ];\n            }, fn(obj));\n        };\n    };\n\n    /**\n     * internal path function\n     * Takes an array, paths, indicating the deep set of keys\n     * to find.\n     *\n     * @private\n     * @memberOf R\n     * @category Object\n     * @param {Array} paths An array of strings to map to object properties\n     * @param {Object} obj The object to find the path in\n     * @return {Array} The value at the end of the path or `undefined`.\n     * @example\n     *\n     *      _path(['a', 'b'], {a: {b: 2}}); //=> 2\n     */\n    var _path = function _path(paths, obj) {\n        var idx = -1, length = paths.length, val;\n        if (obj == null) {\n            return;\n        }\n        val = obj;\n        while (val != null && ++idx < length) {\n            val = val[paths[idx]];\n        }\n        return val;\n    };\n\n    /**\n     * Internal implementation of `pickAll`\n     *\n     * @private\n     * @see R.pickAll\n     */\n    var _pickAll = function _pickAll(names, obj) {\n        var copy = {};\n        _forEach(function (name) {\n            copy[name] = obj[name];\n        }, names);\n        return copy;\n    };\n\n    var _prepend = function _prepend(el, list) {\n        return _concat([el], list);\n    };\n\n    /**\n     * internal helper for `where`\n     *\n     * @private\n     * @see R.where\n     */\n    var _satisfiesSpec = function _satisfiesSpec(spec, parsedSpec, testObj) {\n        if (spec === testObj) {\n            return true;\n        }\n        if (testObj == null) {\n            return false;\n        }\n        parsedSpec.fn = parsedSpec.fn || [];\n        parsedSpec.obj = parsedSpec.obj || [];\n        var key, val, idx = -1, fnLen = parsedSpec.fn.length, j = -1, objLen = parsedSpec.obj.length;\n        while (++idx < fnLen) {\n            key = parsedSpec.fn[idx];\n            val = spec[key];\n            if (!(key in testObj)) {\n                return false;\n            }\n            if (!val(testObj[key], testObj)) {\n                return false;\n            }\n        }\n        while (++j < objLen) {\n            key = parsedSpec.obj[j];\n            if (spec[key] !== testObj[key]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * An optimized, private array `slice` implementation.\n     *\n     * @private\n     * @param {Arguments|Array} args The array or arguments object to consider.\n     * @param {Number} [from=0] The array index to slice from, inclusive.\n     * @param {Number} [to=args.length] The array index to slice to, exclusive.\n     * @return {Array} A new, sliced array.\n     * @example\n     *\n     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n     *\n     *      var firstThreeArgs = function(a, b, c, d) {\n     *        return _slice(arguments, 0, 3);\n     *      };\n     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n     */\n    var _slice = function _slice(args, from, to) {\n        switch (arguments.length) {\n        case 0:\n            throw _noArgsException();\n        case 1:\n            return _slice(args, 0, args.length);\n        case 2:\n            return _slice(args, from, args.length);\n        default:\n            var length = Math.max(0, to - from), list = new Array(length), idx = -1;\n            while (++idx < length) {\n                list[idx] = args[from + idx];\n            }\n            return list;\n        }\n    };\n\n    /**\n     * Returns a function that always returns the given value.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig a -> (* -> a)\n     * @param {*} val The value to wrap in a function\n     * @return {Function} A Function :: * -> val.\n     * @example\n     *\n     *      var t = R.always('Tee');\n     *      t(); //=> 'Tee'\n     */\n    var always = function always(val) {\n        return function () {\n            return val;\n        };\n    };\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`\n     * parameters. Unlike `nAry`, which passes only `n` arguments to the wrapped function,\n     * functions produced by `arity` will pass all provided arguments to the wrapped function.\n     *\n     * @func\n     * @memberOf R\n     * @sig (Number, (* -> *)) -> (* -> *)\n     * @category Function\n     * @param {Number} n The desired arity of the returned function.\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is\n     *         guaranteed to be of arity `n`.\n     * @example\n     *\n     *      var takesTwoArgs = function(a, b) {\n     *        return [a, b];\n     *      };\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.arity(1, takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // All arguments are passed through to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, 2]\n     */\n    var arity = function (n, fn) {\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.apply(this, arguments);\n            };\n        case 1:\n            return function (a0) {\n                void a0;\n                return fn.apply(this, arguments);\n            };\n        case 2:\n            return function (a0, a1) {\n                void a1;\n                return fn.apply(this, arguments);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                void a2;\n                return fn.apply(this, arguments);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                void a3;\n                return fn.apply(this, arguments);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                void a4;\n                return fn.apply(this, arguments);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                void a5;\n                return fn.apply(this, arguments);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                void a6;\n                return fn.apply(this, arguments);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                void a7;\n                return fn.apply(this, arguments);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                void a8;\n                return fn.apply(this, arguments);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                void a9;\n                return fn.apply(this, arguments);\n            };\n        default:\n            throw new Error('First argument to arity must be a non-negative integer no greater than ten');\n        }\n    };\n\n    /**\n     * Returns the result of calling its first argument with the remaining\n     * arguments. This is occasionally useful as a converging function for\n     * `R.converge`: the left branch can produce a function while the right\n     * branch produces a value to be passed to that function as an argument.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (*... -> a),*... -> a\n     * @param {Function} fn The function to apply to the remaining arguments.\n     * @param {...*} args Any number of positional arguments.\n     * @return {*}\n     * @example\n     *\n     *      var indentN = R.pipe(R.times(R.always(' ')),\n     *                           R.join(''),\n     *                           R.replace(/^(?!$)/gm));\n     *\n     *      var format = R.converge(R.call,\n     *                              R.pipe(R.prop('indent'), indentN),\n     *                              R.prop('value'));\n     *\n     *      format({indent: 2, value: 'foo\\nbar\\nbaz\\n'}); //=> '  foo\\n  bar\\n  baz\\n'\n     */\n    var call = function call(fn) {\n        return fn.apply(this, _slice(arguments, 1));\n    };\n\n    /**\n     * Makes a comparator function out of a function that reports whether the first element is less than the second.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a, b -> Boolean) -> (a, b -> Number)\n     * @param {Function} pred A predicate function of arity two.\n     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.\n     * @example\n     *\n     *      var cmp = R.comparator(function(a, b) {\n     *        return a.age < b.age;\n     *      });\n     *      var people = [\n     *        // ...\n     *      ];\n     *      R.sort(cmp, people);\n     */\n    var comparator = function comparator(pred) {\n        return function (a, b) {\n            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n        };\n    };\n\n    /**\n     * Returns a function, `fn`, which encapsulates if/else-if/else logic.\n     * Each argument to `R.cond` is a [predicate, transform] pair. All of\n     * the arguments to `fn` are applied to each of the predicates in turn\n     * until one returns a \"truthy\" value, at which point `fn` returns the\n     * result of applying its arguments to the corresponding transformer.\n     * If none of the predicates matches, `fn` returns undefined.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig [(*... -> Boolean),(*... -> *)]... -> (*... -> *)\n     * @param {...Function} functions\n     * @return {Function}\n     * @example\n     *\n     *      var fn = R.cond(\n     *          [R.eq(0),   R.always('water freezes at 0°C')],\n     *          [R.eq(100), R.always('water boils at 100°C')],\n     *          [R.T,       function(temp) { return 'nothing special happens at ' + temp + '°C'; }]\n     *      );\n     *      fn(0); //=> 'water freezes at 0°C'\n     *      fn(50); //=> 'nothing special happens at 50°C'\n     *      fn(100); //=> 'water boils at 100°C'\n     */\n    var cond = function cond() {\n        var pairs = arguments;\n        return function () {\n            var idx = -1;\n            while (++idx < pairs.length) {\n                if (pairs[idx][0].apply(this, arguments)) {\n                    return pairs[idx][1].apply(this, arguments);\n                }\n            }\n        };\n    };\n\n    /**\n     * Accepts at least three functions and returns a new function. When invoked, this new\n     * function will invoke the first function, `after`, passing as its arguments the\n     * results of invoking the subsequent functions with whatever arguments are passed to\n     * the new function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((*... -> c) -> (((* -> a), (* -> b), ...) -> c)\n     * @param {Function} after A function. `after` will be invoked with the return values of\n     *        `fn1` and `fn2` as its arguments.\n     * @param {...Function} functions A variable number of functions.\n     * @return {Function} A new function.\n     * @example\n     *\n     *      var add = function(a, b) { return a + b; };\n     *      var multiply = function(a, b) { return a * b; };\n     *      var subtract = function(a, b) { return a - b; };\n     *\n     *      //≅ multiply( add(1, 2), subtract(1, 2) );\n     *      R.converge(multiply, add, subtract)(1, 2); //=> -3\n     *\n     *      var add3 = function(a, b, c) { return a + b + c; };\n     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4\n     */\n    var converge = function (after) {\n        var fns = _slice(arguments, 1);\n        return function () {\n            var args = arguments;\n            return after.apply(this, _map(function (fn) {\n                return fn.apply(this, args);\n            }, fns));\n        };\n    };\n\n    /**\n     * Returns a new function much like the supplied one, except that the first two arguments'\n     * order is reversed.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n     * @param {Function} fn The function to invoke with its first two parameters reversed.\n     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n     * @example\n     *\n     *      var mergeThree = function(a, b, c) {\n     *        return ([]).concat(a, b, c);\n     *      };\n     *\n     *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n     */\n    var flip = function flip(fn) {\n        return function (a, b) {\n            switch (arguments.length) {\n            case 0:\n                throw _noArgsException();\n            case 1:\n                return function (b) {\n                    return fn.apply(this, [\n                        b,\n                        a\n                    ].concat(_slice(arguments, 1)));\n                };\n            default:\n                return fn.apply(this, _concat([\n                    b,\n                    a\n                ], _slice(arguments, 2)));\n            }\n        };\n    };\n\n    /**\n     * Creates a new object out of a list key-value pairs.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [[k,v]] -> {k: v}\n     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.\n     * @return {Object} The object made by pairing up `keys` and `values`.\n     * @example\n     *\n     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}\n     */\n    var fromPairs = function fromPairs(pairs) {\n        var idx = -1, len = pairs.length, out = {};\n        while (++idx < len) {\n            if (_isArray(pairs[idx]) && pairs[idx].length) {\n                out[pairs[idx][0]] = pairs[idx][1];\n            }\n        }\n        return out;\n    };\n\n    /**\n     * Calls the specified function on the supplied object. Any additional arguments\n     * after `fn` and `obj` are passed in to `fn`. If no additional arguments are passed to `func`,\n     * `fn` is invoked with no arguments.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig k -> {k : v} -> v(*)\n     * @param {String} funcName The name of the property mapped to the function to invoke\n     * @param {Object} obj The object\n     * @return {*} The value of invoking `obj.fn`.\n     * @example\n     *\n     *      R.func('add', R, 1, 2); //=> 3\n     *\n     *      var obj = { f: function() { return 'f called'; } };\n     *      R.func('f', obj); //=> 'f called'\n     */\n    var func = function func(funcName, obj) {\n        switch (arguments.length) {\n        case 0:\n            throw _noArgsException();\n        case 1:\n            return function (obj) {\n                return obj[funcName].apply(obj, _slice(arguments, 1));\n            };\n        default:\n            return obj[funcName].apply(obj, _slice(arguments, 2));\n        }\n    };\n\n    /**\n     * A function that does nothing but return the parameter supplied to it. Good as a default\n     * or placeholder function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig a -> a\n     * @param {*} x The value to return.\n     * @return {*} The input value, `x`.\n     * @example\n     *\n     *      R.identity(1); //=> 1\n     *\n     *      var obj = {};\n     *      R.identity(obj) === obj; //=> true\n     */\n    var identity = function identity(x) {\n        return x;\n    };\n\n    /**\n     * Tests whether or not an object is similar to an array.\n     *\n     * @func\n     * @memberOf R\n     * @category Type\n     * @category List\n     * @param {*} x The object to test.\n     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n     * @example\n     *\n     *      R.isArrayLike([]); //=> true\n     *      R.isArrayLike(true); //=> false\n     *      R.isArrayLike({}); //=> false\n     *      R.isArrayLike({length: 10}); //=> false\n     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n     */\n    var isArrayLike = function isArrayLike(x) {\n        if (_isArray(x)) {\n            return true;\n        }\n        if (!x) {\n            return false;\n        }\n        if (typeof x !== 'object') {\n            return false;\n        }\n        if (x instanceof String) {\n            return false;\n        }\n        if (x.nodeType === 1) {\n            return !!x.length;\n        }\n        if (x.length === 0) {\n            return true;\n        }\n        if (x.length > 0) {\n            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n        }\n        return false;\n    };\n\n    /**\n     * Reports whether the list has zero elements.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig [a] -> Boolean\n     * @param {Array} list\n     * @return {Boolean}\n     * @example\n     *\n     *      R.isEmpty([1, 2, 3]); //=> false\n     *      R.isEmpty([]); //=> true\n     *      R.isEmpty(''); //=> true\n     *      R.isEmpty(null); //=> false\n     */\n    var isEmpty = function isEmpty(list) {\n        return Object(list).length === 0;\n    };\n\n    /**\n     * Checks if the input value is `null` or `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @category Type\n     * @sig * -> Boolean\n     * @param {*} x The value to test.\n     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n     * @example\n     *\n     *     R.isNil(null); //=> true\n     *     R.isNil(undefined); //=> true\n     *     R.isNil(0); //=> false\n     *     R.isNil([]); //=> false\n     */\n    var isNil = function isNil(x) {\n        return x == null;\n    };\n\n    /**\n     * Returns `true` if all elements are unique, otherwise `false`.\n     * Uniqueness is determined using strict equality (`===`).\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> Boolean\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if all elements are unique, else `false`.\n     * @example\n     *\n     *      R.isSet(['1', 1]); //=> true\n     *      R.isSet([1, 1]);   //=> false\n     *      R.isSet([{}, {}]); //=> true\n     */\n    var isSet = function isSet(list) {\n        var len = list.length;\n        var idx = -1;\n        while (++idx < len) {\n            if (_indexOf(list, list[idx], idx + 1) >= 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Returns a list containing the names of all the\n     * properties of the supplied object, including prototype properties.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.keysIn(f); //=> ['x', 'y']\n     */\n    var keysIn = function keysIn(obj) {\n        var prop, ks = [];\n        for (prop in obj) {\n            ks[ks.length] = prop;\n        }\n        return ks;\n    };\n\n    /**\n     * Creates a new function that, when invoked, caches the result of calling `fn` for a given\n     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same\n     * argument set will not result in an additional call to `fn`; instead, the cached result\n     * for that set of arguments will be returned.\n     *\n     * Note that this version of `memoize` effectively handles only string and number\n     * parameters.  Also note that it does not work on variadic functions.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a... -> b) -> (a... -> b)\n     * @param {Function} fn The function to be wrapped by `memoize`.\n     * @return {Function}  Returns a memoized version of `fn`.\n     * @example\n     *\n     *      var numberOfCalls = 0;\n     *      var trackedAdd = function(a, b) {\n     *        numberOfCalls += 1;\n     *        return a + b;\n     *      };\n     *      var memoTrackedAdd = R.memoize(trackedAdd);\n     *\n     *      memoTrackedAdd(1, 2); //=> 3\n     *      numberOfCalls; //=> 1\n     *      memoTrackedAdd(1, 2); //=> 3\n     *      numberOfCalls; //=> 1\n     *      memoTrackedAdd(2, 3); //=> 5\n     *      numberOfCalls; //=> 2\n     *\n     *      // Note that argument order matters\n     *      memoTrackedAdd(2, 1); //=> 3\n     *      numberOfCalls; //=> 3\n     */\n    var memoize = function memoize(fn) {\n        var cache = {};\n        return function () {\n            if (!arguments.length) {\n                return;\n            }\n            var position = _foldl(function (cache, arg) {\n                return cache[arg] || (cache[arg] = {});\n            }, cache, _slice(arguments, 0, arguments.length - 1));\n            var arg = arguments[arguments.length - 1];\n            return position[arg] || (position[arg] = fn.apply(this, arguments));\n        };\n    };\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`\n     * parameters. Any extraneous parameters will not be passed to the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} n The desired arity of the new function.\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity `n`.\n     * @example\n     *\n     *      var takesTwoArgs = function(a, b) {\n     *        return [a, b];\n     *      };\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.nAry(1, takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only `n` arguments are passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var nAry = function (n, fn) {\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.call(this);\n            };\n        case 1:\n            return function (a0) {\n                return fn.call(this, a0);\n            };\n        case 2:\n            return function (a0, a1) {\n                return fn.call(this, a0, a1);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                return fn.call(this, a0, a1, a2);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                return fn.call(this, a0, a1, a2, a3);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                return fn.call(this, a0, a1, a2, a3, a4);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            };\n        default:\n            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');\n        }\n    };\n\n    /**\n     * A function wrapping a call to the given function in a `!` operation.  It will return `true` when the\n     * underlying function would return a false-y value, and `false` when it would return a truth-y one.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @return {Function} a function that applies its arguments to `f` and logically inverts its output.\n     * @example\n     *\n     *      var gt10 = function(x) { return x > 10; };\n     *      var f = R.not(gt10);\n     *      f(11); //=> false\n     *      f(9); //=> true\n     */\n    var not = function not(f) {\n        return function () {\n            return !f.apply(this, arguments);\n        };\n    };\n\n    /**\n     * Returns a function which returns its nth argument.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig Number -> *... -> *\n     * @param {Number} n\n     * @return {Function}\n     * @example\n     *\n     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'\n     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'\n     */\n    var nthArg = function nthArg(n) {\n        return function () {\n            return _nth(n, arguments);\n        };\n    };\n\n    /**\n     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that\n     * `fn` can only ever be called once, no matter how many times the returned function is\n     * invoked.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a... -> b) -> (a... -> b)\n     * @param {Function} fn The function to wrap in a call-only-once wrapper.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var addOneOnce = R.once(function(x){ return x + 1; });\n     *      addOneOnce(10); //=> 11\n     *      addOneOnce(addOneOnce(50)); //=> 11\n     */\n    var once = function once(fn) {\n        var called = false, result;\n        return function () {\n            if (called) {\n                return result;\n            }\n            called = true;\n            result = fn.apply(this, arguments);\n            return result;\n        };\n    };\n\n    /**\n     * Flipped version of R.prepend.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> a -> [a]\n     * @param {Array} list\n     * @param {*} el\n     * @return {Array}\n     * @example\n     *\n     *      R.prependTo(['fi', 'fo', 'fum'], 'fee'); //=> ['fee', 'fi', 'fo', 'fum']\n     */\n    var prependTo = flip(_prepend);\n\n    /**\n     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig s -> {s: a} -> a\n     * @param {String} p The property name\n     * @param {Object} obj The object to query\n     * @return {*} The value at `obj.p`.\n     * @example\n     *\n     *      R.prop('x', {x: 100}); //=> 100\n     *      R.prop('x', {}); //=> undefined\n     */\n    var prop = function prop(p, obj) {\n        switch (arguments.length) {\n        case 0:\n            throw _noArgsException();\n        case 1:\n            return function _prop(obj) {\n                return obj[p];\n            };\n        }\n        return obj[p];\n    };\n\n    /**\n     * Returns the value at the specified property.\n     * The only difference from `prop` is the parameter order.\n     *\n     * @func\n     * @memberOf R\n     * @see R.prop\n     * @category Object\n     * @sig {k: v} -> k -> v\n     * @param {Object} obj The object to query\n     * @param {String} p The property name\n     * @return {*} The value at `obj.p`.\n     * @example\n     *\n     *      R.propOf({x: 100}, 'x'); //=> 100\n     */\n    var propOf = flip(prop);\n\n    /**\n     * Returns a new list with the same elements as the original list, just\n     * in the reverse order.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The list to reverse.\n     * @return {Array} A copy of the list in reverse order.\n     * @example\n     *\n     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n     *      R.reverse([1, 2]);     //=> [2, 1]\n     *      R.reverse([1]);        //=> [1]\n     *      R.reverse([]);         //=> []\n     */\n    var reverse = function reverse(list) {\n        return _slice(list).reverse();\n    };\n\n    /**\n     * Converts an object into an array of key, value arrays.\n     * The object's own properties and prototype properties are used.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [[k,v]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own\n     *         and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n     */\n    var toPairsIn = _pairWith(keysIn);\n\n    /**\n     * Removes (strips) whitespace from both ends of the string.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to trim.\n     * @return {String} Trimmed version of `str`.\n     * @example\n     *\n     *      R.trim('   xyz  '); //=> 'xyz'\n     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n     */\n    var trim = function () {\n        var ws = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\n        var zeroWidth = '\\u200B';\n        var hasProtoTrim = typeof String.prototype.trim === 'function';\n        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {\n            return function trim(str) {\n                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n                return str.replace(beginRx, '').replace(endRx, '');\n            };\n        } else {\n            return function trim(str) {\n                return str.trim();\n            };\n        }\n    }();\n\n    /**\n     * Gives a single-word string description of the (native) type of a value, returning such\n     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user\n     * Object types any further, reporting them all as 'Object'.\n     *\n     * @func\n     * @memberOf R\n     * @category Type\n     * @sig (* -> {*}) -> String\n     * @param {*} val The value to test\n     * @return {String}\n     * @example\n     *\n     *      R.type({}); //=> \"Object\"\n     *      R.type(1); //=> \"Number\"\n     *      R.type(false); //=> \"Boolean\"\n     *      R.type('s'); //=> \"String\"\n     *      R.type(null); //=> \"Null\"\n     *      R.type([]); //=> \"Array\"\n     *      R.type(/[A-z]/); //=> \"RegExp\"\n     */\n    var type = function type(val) {\n        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n    };\n\n    /**\n     * Takes a function `fn`, which takes a single array argument, and returns\n     * a function which:\n     *\n     *   - takes any number of positional arguments;\n     *   - passes these arguments to `fn` as an array; and\n     *   - returns the result.\n     *\n     * In other words, R.unapply derives a variadic function from a function\n     * which takes an array. R.unapply is the inverse of R.apply.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ([*...] -> a) -> (*... -> a)\n     * @param {Function} fn\n     * @return {Function}\n     * @see R.apply\n     * @example\n     *\n     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n     */\n    var unapply = function unapply(fn) {\n        if (arguments.length === 0) {\n            throw _noArgsException();\n        }\n        return function () {\n            return fn(_slice(arguments));\n        };\n    };\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1\n     * parameter. Any extraneous parameters will not be passed to the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (* -> b) -> (a -> b)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 1.\n     * @example\n     *\n     *      var takesTwoArgs = function(a, b) {\n     *        return [a, b];\n     *      };\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.unary(takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only 1 argument is passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var unary = function unary(fn) {\n        return nAry(1, fn);\n    };\n\n    /**\n     * Returns a list of all the properties, including prototype properties,\n     * of the supplied object.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.valuesIn(f); //=> ['X', 'Y']\n     */\n    var valuesIn = function valuesIn(obj) {\n        var prop, vs = [];\n        for (prop in obj) {\n            vs[vs.length] = obj[prop];\n        }\n        return vs;\n    };\n\n    /**\n     * A function that always returns `false`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig * -> false\n     * @see R.always\n     * @return {Boolean} false\n     * @example\n     *\n     *      R.F(); //=> false\n     */\n    var F = always(false);\n\n    /**\n     * @func\n     * @memberOf R\n     * @category Function\n     * @see R.identity\n     */\n    var I = identity;\n\n    /**\n     * A function that always returns `true`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig * -> true\n     * @see R.always\n     * @return {Boolean} `true`.\n     * @example\n     *\n     *      R.T(); //=> true\n     */\n    var T = always(true);\n\n    var _append = function _append(el, list) {\n        return _concat(list, [el]);\n    };\n\n    /**\n     * Copies an object.\n     *\n     * @private\n     * @param {*} value The value to be copied\n     * @param {Array} refFrom Array containing the source references\n     * @param {Array} refTo Array containing the copied source references\n     * @return {*} The copied value.\n     */\n    var _baseCopy = function _baseCopy(value, refFrom, refTo) {\n        var copy = function copy(copiedValue) {\n            var len = refFrom.length;\n            var idx = -1;\n            while (++idx < len) {\n                if (value === refFrom[idx]) {\n                    return refTo[idx];\n                }\n            }\n            refFrom[refFrom.length] = value;\n            refTo[refTo.length] = copiedValue;\n            for (var key in value) {\n                copiedValue[key] = _baseCopy(value[key], refFrom, refTo);\n            }\n            return copiedValue;\n        };\n        switch (type(value)) {\n        case 'Object':\n            return copy({});\n        case 'Array':\n            return copy([]);\n        case 'Date':\n            return new Date(value);\n        default:\n            return value;\n        }\n    };\n\n    /**\n     * Similar to hasMethod, this checks whether a function has a [methodname]\n     * function. If it isn't an array it will execute that function otherwise it will\n     * default to the ramda implementation.\n     *\n     * @private\n     * @param {Function} fn ramda implemtation\n     * @param {String} methodname property to check for a custom implementation\n     * @return {Object} Whatever the return value of the method is.\n     */\n    var _checkForMethod = function _checkForMethod(methodname, fn) {\n        return function (a, b, c) {\n            var length = arguments.length;\n            var obj = arguments[length - 1], callBound = obj && !_isArray(obj) && typeof obj[methodname] === 'function';\n            switch (arguments.length) {\n            case 0:\n                return fn();\n            case 1:\n                return callBound ? obj[methodname]() : fn(a);\n            case 2:\n                return callBound ? obj[methodname](a) : fn(a, b);\n            case 3:\n                return callBound ? obj[methodname](a, b) : fn(a, b, c);\n            }\n        };\n    };\n\n    var _contains = function _contains(a, list) {\n        return _indexOf(list, a) >= 0;\n    };\n\n    /*\n     * Returns a function that makes a multi-argument version of compose from\n     * either _compose or _pCompose.\n     */\n    var _createComposer = function _createComposer(composeFunction) {\n        return function () {\n            switch (arguments.length) {\n            case 0:\n                throw _noArgsException();\n            case 1:\n                return arguments[0];\n            default:\n                var idx = arguments.length - 1, fn = arguments[idx], length = fn.length;\n                while (idx--) {\n                    fn = composeFunction(arguments[idx], fn);\n                }\n                return arity(length, fn);\n            }\n        };\n    };\n\n    /**\n     * Create a function which takes a a list\n     * and determines the winning value by a compatator. Used internally\n     * by `R.max` and `R.min`\n     *\n     * @private\n     * @param {Function} compatator a function to compare two items\n     * @param {*} intialVal, default value if nothing else wins\n     * @category Math\n     * @return {Function}\n     */\n    var _createMaxMin = function _createMaxMin(comparator, initialVal) {\n        return function (list) {\n            if (arguments.length === 0) {\n                throw _noArgsException();\n            }\n            var idx = -1, winner = initialVal, computed;\n            while (++idx < list.length) {\n                computed = +list[idx];\n                if (comparator(computed, winner)) {\n                    winner = computed;\n                }\n            }\n            return winner;\n        };\n    };\n\n    var _createPartialApplicator = function _createPartialApplicator(concat) {\n        return function (fn) {\n            var args = _slice(arguments, 1);\n            return arity(Math.max(0, fn.length - args.length), function () {\n                return fn.apply(this, concat(args, arguments));\n            });\n        };\n    };\n\n    /**\n     * Optimized internal two-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     * @example\n     *\n     *      var addTwo = function(a, b) {\n     *        return a + b;\n     *      };\n     *\n     *      var curriedAddTwo = _curry2(addTwo);\n     */\n    var _curry2 = function _curry2(fn) {\n        return function (a, b) {\n            switch (arguments.length) {\n            case 0:\n                throw _noArgsException();\n            case 1:\n                return function (b) {\n                    return fn(a, b);\n                };\n            default:\n                return fn(a, b);\n            }\n        };\n    };\n\n    /**\n     * Optimized internal three-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     * @example\n     *\n     *      var addThree = function(a, b, c) {\n     *        return a + b + c;\n     *      };\n     *\n     *      var curriedAddThree = _curry3(addThree);\n     */\n    var _curry3 = function _curry3(fn) {\n        return function (a, b, c) {\n            switch (arguments.length) {\n            case 0:\n                throw _noArgsException();\n            case 1:\n                return _curry2(function (b, c) {\n                    return fn(a, b, c);\n                });\n            case 2:\n                return function (c) {\n                    return fn(a, b, c);\n                };\n            default:\n                return fn(a, b, c);\n            }\n        };\n    };\n\n    /**\n     * Private function that determines whether or not a provided object has a given method.\n     * Does not ignore methods stored on the object's prototype chain. Used for dynamically\n     * dispatching Ramda methods to non-Array objects.\n     *\n     * @private\n     * @param {String} methodName The name of the method to check for.\n     * @param {Object} obj The object to test.\n     * @return {Boolean} `true` has a given method, `false` otherwise.\n     * @example\n     *\n     *      var person = { name: 'John' };\n     *      person.shout = function() { alert(this.name); };\n     *\n     *      _hasMethod('shout', person); //=> true\n     *      _hasMethod('foo', person); //=> false\n     */\n    var _hasMethod = function _hasMethod(methodName, obj) {\n        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';\n    };\n\n    /**\n     * `_makeFlat` is a helper function that returns a one-level or fully recursive function\n     * based on the flag passed in.\n     *\n     * @private\n     */\n    var _makeFlat = function _makeFlat(recursive) {\n        return function flatt(list) {\n            var value, result = [], idx = -1, j, ilen = list.length, jlen;\n            while (++idx < ilen) {\n                if (isArrayLike(list[idx])) {\n                    value = recursive ? flatt(list[idx]) : list[idx];\n                    j = -1;\n                    jlen = value.length;\n                    while (++j < jlen) {\n                        result[result.length] = value[j];\n                    }\n                } else {\n                    result[result.length] = list[idx];\n                }\n            }\n            return result;\n        };\n    };\n\n    /**\n     * Internal helper function for making a partial copy of an object\n     *\n     * @private\n     *\n     */\n    var _pickBy = function _pickBy(test, obj) {\n        var copy = {};\n        var prop;\n        var props = keysIn(obj);\n        var len = props.length;\n        var idx = -1;\n        while (++idx < len) {\n            prop = props[idx];\n            if (test(obj[prop], prop, obj)) {\n                copy[prop] = obj[prop];\n            }\n        }\n        return copy;\n    };\n\n    var _pluck = function _pluck(p, list) {\n        return _map(prop(p), list);\n    };\n\n    /**\n     * Adds two numbers (or strings). Equivalent to `a + b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @sig String -> String -> String\n     * @param {Number|String} a The first value.\n     * @param {Number|String} b The second value.\n     * @return {Number|String} The result of `a + b`.\n     * @example\n     *\n     *      var increment = R.add(1);\n     *      increment(10);   //=> 11\n     *      R.add(2, 3);       //=>  5\n     *      R.add(7)(10);      //=> 17\n     */\n    var add = _curry2(_add);\n\n    /**\n     * Returns `true` if all elements of the list match the predicate, `false` if there are any\n     * that don't.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`\n     *         otherwise.\n     * @example\n     *\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      var lessThan3 = R.flip(R.lt)(3);\n     *      var xs = R.range(1, 3);\n     *      xs; //=> [1, 2]\n     *      R.all(lessThan2)(xs); //=> false\n     *      R.all(lessThan3)(xs); //=> true\n     */\n    var all = _curry2(_all);\n\n    /**\n     *\n     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first\n     * function if it is false-y and the result of the second function otherwise.  Note that this is\n     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y\n     * value.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and ANDs their outputs together.\n     * @example\n     *\n     *      var gt10 = function(x) { return x > 10; };\n     *      var even = function(x) { return x % 2 === 0 };\n     *      var f = R.and(gt10, even);\n     *      f(100); //=> true\n     *      f(101); //=> false\n     */\n    var and = _curry2(function and(f, g) {\n        return function _and() {\n            return f.apply(this, arguments) && g.apply(this, arguments);\n        };\n    });\n\n    /**\n     * Returns `true` if at least one of elements of the list match the predicate, `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`\n     *         otherwise.\n     * @example\n     *\n     *      var lessThan0 = R.flip(R.lt)(0);\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      var xs = R.range(1, 3);\n     *      xs; //=> [1, 2]\n     *      R.any(lessThan0)(xs); //=> false\n     *      R.any(lessThan2)(xs); //=> true\n     */\n    var any = _curry2(_any);\n\n    /**\n     * Returns a new list containing the contents of the given list, followed by the given\n     * element.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The element to add to the end of the new list.\n     * @param {Array} list The list whose contents will be added to the beginning of the output\n     *        list.\n     * @return {Array} A new list containing the contents of the old list followed by `el`.\n     * @example\n     *\n     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\n     *      R.append('tests', []); //=> ['tests']\n     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]\n     */\n    var append = _curry2(_append);\n\n    /**\n     * Flipped version of R.append.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> a -> [a]\n     * @param {Array} list\n     * @param {*} el\n     * @return {Array}\n     * @example\n     *\n     *      R.appendTo([], 1); //=> [1]\n     *      R.appendTo([1, 2, 3], 4); //=> [1, 2, 3, 4]\n     *      R.appendTo([1, 2, 3], [4, 5, 6]); //=> [1, 2, 3, [4, 5, 6]]\n     */\n    var appendTo = flip(_append);\n\n    /**\n     * Applies function `fn` to the argument list `args`. This is useful for\n     * creating a fixed-arity function from a variadic function. `fn` should\n     * be a bound function if context is significant.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (*... -> a) -> [*] -> a\n     * @param {Function} fn\n     * @param {Array} args\n     * @return {*}\n     * @example\n     *\n     *      var nums = [1, 2, 3, -99, 42, 6, 7];\n     *      R.apply(Math.max, nums); //=> 42\n     */\n    var apply = _curry2(function apply(fn, args) {\n        return fn.apply(this, args);\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2\n     * parameters. Any extraneous parameters will not be passed to the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (* -> c) -> (a, b -> c)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 2.\n     * @example\n     *\n     *      var takesThreeArgs = function(a, b, c) {\n     *        return [a, b, c];\n     *      };\n     *      takesThreeArgs.length; //=> 3\n     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      var takesTwoArgs = R.binary(takesThreeArgs);\n     *      takesTwoArgs.length; //=> 2\n     *      // Only 2 arguments are passed to the wrapped function\n     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]\n     */\n    var binary = function binary(fn) {\n        return nAry(2, fn);\n    };\n\n    /**\n     * Creates a function that is bound to a context.\n     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @category Object\n     * @sig (* -> *) -> {*} -> (* -> *)\n     * @param {Function} fn The function to bind to context\n     * @param {Object} thisObj The context to bind `fn` to\n     * @return {Function} A function that will execute in the context of `thisObj`.\n     */\n    var bind = _curry2(function bind(fn, thisObj) {\n        return function () {\n            return fn.apply(thisObj, arguments);\n        };\n    });\n\n    /**\n     * Creates a deep copy of the value which may contain (nested) `Array`s and\n     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are\n     * not copied, but assigned by their reference.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {*} -> {*}\n     * @param {*} value The object or array to clone\n     * @return {*} A new object or array.\n     * @example\n     *\n     *      var objects = [{}, {}, {}];\n     *      var objectsClone = R.clone(objects);\n     *      objects[0] === objectsClone[0]; //=> false\n     *\n     */\n    var clone = function clone(value) {\n        return _baseCopy(value, [], []);\n    };\n\n    /**\n     * Creates a new function that runs each of the functions supplied as parameters in turn,\n     * passing the return value of each function invocation to the next function invocation,\n     * beginning with whatever arguments were passed to the initial invocation.\n     *\n     * Note that `compose` is a right-associative function, which means the functions provided\n     * will be invoked in order from right to left. In the example `var h = compose(f, g)`,\n     * the function `h` is equivalent to `f( g(x) )`, where `x` represents the arguments\n     * originally passed to `h`.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((y -> z), (x -> y), ..., (b -> c), (a... -> b)) -> (a... -> z)\n     * @param {...Function} functions A variable number of functions.\n     * @return {Function} A new function which represents the result of calling each of the\n     *         input `functions`, passing the result of each function call to the next, from\n     *         right to left.\n     * @example\n     *\n     *      var triple = function(x) { return x * 3; };\n     *      var double = function(x) { return x * 2; };\n     *      var square = function(x) { return x * x; };\n     *      var squareThenDoubleThenTriple = R.compose(triple, double, square);\n     *\n     *      //≅ triple(double(square(5)))\n     *      squareThenDoubleThenTriple(5); //=> 150\n     */\n    var compose = _createComposer(_compose);\n\n    /**\n     * Returns `true` if the `x` is found in the `list`, using `pred` as an\n     * equality predicate for `x`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {*} x The item to find\n     * @param {Array} list The list to iterate over\n     * @return {Boolean} `true` if `x` is in `list`, else `false`.\n     * @example\n     *\n     *     var xs = [{x: 12}, {x: 11}, {x: 10}];\n     *     R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true\n     *     R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false\n     */\n    var containsWith = _curry3(_containsWith);\n\n    /**\n     * Creates an object containing a single key:value pair.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig String -> a -> {String:a}\n     * @param {String} key\n     * @param {*} val\n     * @return {Object}\n     * @example\n     *\n     *      var matchPhrases = R.compose(\n     *          R.createMapEntry('must'),\n     *          R.map(R.createMapEntry('match_phrase'))\n     *      );\n     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n     */\n    var createMapEntry = _curry2(function (key, val) {\n        var obj = {};\n        obj[key] = val;\n        return obj;\n    });\n\n    /**\n     * Creates a new version of `fn` with given arity that, when invoked,\n     * will return either:\n     * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of\n     * `fn`'s expected arguments have not yet been provided\n     * - `fn`'s result if all of its expected arguments have been provided\n     *\n     * This function is useful in place of `curry`, when the arity of the\n     * function to curry cannot be determined from its signature, e.g. if it's\n     * a variadic function.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} fnArity The arity for the returned function.\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curry\n     * @example\n     *\n     *      var addFourNumbers = function() {\n     *        return R.sum([].slice.call(arguments, 0, 4));\n     *      };\n     *\n     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4);//=> 10\n     */\n    var curryN = _curry2(function curryN(length, fn) {\n        return function recurry(args) {\n            return arity(Math.max(length - (args && args.length || 0), 0), function () {\n                if (arguments.length === 0) {\n                    throw _noArgsException();\n                }\n                var newArgs = _concat(args, arguments);\n                if (newArgs.length >= length) {\n                    return fn.apply(this, newArgs);\n                } else {\n                    return recurry(newArgs);\n                }\n            });\n        }([]);\n    });\n\n    /**\n     * Decrements its argument.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @example\n     *\n     *      R.dec(42); //=> 41\n     */\n    var dec = add(-1);\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @see R.differenceWith\n     * @example\n     *\n     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]\n     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]\n     */\n    var difference = _curry2(function difference(first, second) {\n        var out = [];\n        var idx = -1;\n        var firstLen = first.length;\n        while (++idx < firstLen) {\n            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {\n                out[out.length] = first[idx];\n            }\n        }\n        return out;\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n     * Duplication is determined according to the value returned by applying the supplied predicate to two list\n     * elements.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @see R.difference\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @example\n     *\n     *      function cmp(x, y) { return x.a === y.a; }\n     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];\n     *      var l2 = [{a: 3}, {a: 4}];\n     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]\n     *\n     */\n    var differenceWith = _curry3(function differenceWith(pred, first, second) {\n        var out = [];\n        var idx = -1;\n        var firstLen = first.length;\n        var containsPred = containsWith(pred);\n        while (++idx < firstLen) {\n            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {\n                out[out.length] = first[idx];\n            }\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new list containing all but the first `n` elements of the given `list`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @param {Number} n The number of elements of `list` to skip.\n     * @param {Array} list The array to consider.\n     * @return {Array} The last `n` elements of `list`.\n     * @example\n     *\n     *     R.drop(3, [1,2,3,4,5,6,7]); //=> [4,5,6,7]\n     */\n    var drop = _curry2(_checkForMethod('drop', function drop(n, list) {\n        return n < list.length ? _slice(list, n) : [];\n    }));\n\n    /**\n     * Returns a new list containing the last `n` elements of a given list, passing each value\n     * to the supplied predicate function, skipping elements while the predicate function returns\n     * `true`. The predicate function is passed one argument: *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @example\n     *\n     *      var lteTwo = function(x) {\n     *        return x <= 2;\n     *      };\n     *\n     *      R.dropWhile(lteTwo, [1, 2, 3, 4]); //=> [3, 4]\n     */\n    var dropWhile = _curry2(function dropWhile(pred, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len && pred(list[idx])) {\n        }\n        return _slice(list, idx);\n    });\n\n    /**\n     * `empty` wraps any object in an array. This implementation is compatible with the\n     * Fantasy-land Monoid spec, and will work with types that implement that spec.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig * -> []\n     * @return {Array} An empty array.\n     * @example\n     *\n     *      R.empty([1,2,3,4,5]); //=> []\n     */\n    var empty = function empty(x) {\n        return _hasMethod('empty', x) ? x.empty() : [];\n    };\n\n    /**\n     * Tests if two items are equal.  Equality is strict here, meaning reference equality for objects and\n     * non-coercing equality for primitives.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig a -> b -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      var o = {};\n     *      R.eq(o, o); //=> true\n     *      R.eq(o, {}); //=> false\n     *      R.eq(1, 1); //=> true\n     *      R.eq(1, '1'); //=> false\n     *      R.eq(0, -0); //=> false\n     *      R.eq(NaN, NaN); //=> true\n     */\n    var eq = _curry2(function eq(a, b) {\n        if (a === 0) {\n            return 1 / a === 1 / b;\n        } else {\n            return a === b || a !== a && b !== b;\n        }\n    });\n\n    /**\n     * Reports whether two objects have the same value for the specified property.  Useful as a curried predicate.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig k -> {k: v} -> {k: v} -> Boolean\n     * @param {String} prop The name of the property to compare\n     * @param {Object} obj1\n     * @param {Object} obj2\n     * @return {Boolean}\n     *\n     * @example\n     *\n     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };\n     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };\n     *      R.eqProps('a', o1, o2); //=> false\n     *      R.eqProps('c', o1, o2); //=> true\n     */\n    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {\n        return obj1[prop] === obj2[prop];\n    });\n\n    /**\n     * Returns a new list containing only those items that match a given predicate function.\n     * The predicate function is passed one argument: *(value)*.\n     *\n     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native\n     * `Array.prototype.filter` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} The new filtered array.\n     * @example\n     *\n     *      var isEven = function(n) {\n     *        return n % 2 === 0;\n     *      };\n     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]\n     */\n    var filter = _curry2(_checkForMethod('filter', _filter));\n\n    /**\n     * Like `filter`, but passes additional parameters to the predicate function. The predicate\n     * function is passed three arguments: *(value, index, list)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a, i, [a] -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} The new filtered array.\n     * @example\n     *\n     *      var lastTwo = function(val, idx, list) {\n     *        return list.length - idx <= 2;\n     *      };\n     *      R.filterIndexed(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [0, 9]\n     */\n    var filterIndexed = _curry2(_filterIndexed);\n\n    /**\n     * Returns the first element of the list which matches the predicate, or `undefined` if no\n     * element matches.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     *        desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}\n     *      R.find(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var find = _curry2(function find(fn, list) {\n        var idx = -1;\n        var len = list.length;\n        while (++idx < len) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n        }\n    });\n\n    /**\n     * Returns the index of the first element of the list which matches the predicate, or `-1`\n     * if no element matches.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1\n     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findIndex = _curry2(function findIndex(fn, list) {\n        var idx = -1;\n        var len = list.length;\n        while (++idx < len) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n        }\n        return -1;\n    });\n\n    /**\n     * Returns the last element of the list which matches the predicate, or `undefined` if no\n     * element matches.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}\n     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var findLast = _curry2(function findLast(fn, list) {\n        var idx = list.length;\n        while (idx--) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n        }\n    });\n\n    /**\n     * Returns the index of the last element of the list which matches the predicate, or\n     * `-1` if no element matches.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1\n     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findLastIndex = _curry2(function findLastIndex(fn, list) {\n        var idx = list.length;\n        while (idx--) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n        }\n        return -1;\n    });\n\n    /**\n     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting\n     * them in a new array, depth-first.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [b]\n     * @param {Array} list The array to consider.\n     * @return {Array} The flattened list.\n     * @example\n     *\n     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n     */\n    var flatten = _makeFlat(true);\n\n    /**\n     * Returns a single item by iterating through the list, successively calling the iterator\n     * function and passing it an accumulator value and the current value from the array, and\n     * then passing the result to the next call.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * Note: `R.foldl` does not skip deleted or unassigned indices (sparse arrays), unlike\n     * the native `Array.prototype.reduce` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var numbers = [1, 2, 3];\n     *      var add = function(a, b) {\n     *        return a + b;\n     *      };\n     *\n     *      R.foldl(add, 10, numbers); //=> 16\n     */\n    var foldl = _curry3(_foldl);\n\n    /**\n     * Like `foldl`, but passes additional parameters to the predicate function.\n     *\n     * The iterator function receives four values: *(acc, value, index, list)*\n     *\n     * Note: `R.foldlIndexed` does not skip deleted or unassigned indices (sparse arrays),\n     * unlike the native `Array.prototype.reduce` method. For more details on this behavior,\n     * see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,b,i,[b] -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives four values: the accumulator, the\n     *        current element from `list`, that element's index, and the entire `list` itself.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var letters = ['a', 'b', 'c'];\n     *      var objectify = function(accObject, elem, idx, list) {\n     *        accObject[elem] = idx;\n     *        return accObject;\n     *      };\n     *\n     *      R.foldlIndexed(objectify, {}, letters); //=> { 'a': 0, 'b': 1, 'c': 2 }\n     */\n    var foldlIndexed = _curry3(function foldlIndexed(fn, acc, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len) {\n            acc = fn(acc, list[idx], idx, list);\n        }\n        return acc;\n    });\n\n    /**\n     * Returns a single item by iterating through the list, successively calling the iterator\n     * function and passing it an accumulator value and the current value from the array, and\n     * then passing the result to the next call.\n     *\n     * Similar to `foldl`, except moves through the input list from the right to the left.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * Note: `R.foldr` does not skip deleted or unassigned indices (sparse arrays), unlike\n     * the native `Array.prototype.reduce` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\n     *      var flattenPairs = function(acc, pair) {\n     *        return acc.concat(pair);\n     *      };\n     *\n     *      R.foldr(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]\n     */\n    var foldr = _curry3(function foldr(fn, acc, list) {\n        var idx = list.length;\n        while (idx--) {\n            acc = fn(acc, list[idx]);\n        }\n        return acc;\n    });\n\n    /**\n     * Like `foldr`, but passes additional parameters to the predicate function. Moves through\n     * the input list from the right to the left.\n     *\n     * The iterator function receives four values: *(acc, value, index, list)*.\n     *\n     * Note: `R.foldrIndexed` does not skip deleted or unassigned indices (sparse arrays),\n     * unlike the native `Array.prototype.reduce` method. For more details on this behavior,\n     * see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,b,i,[b] -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives four values: the accumulator, the\n     *        current element from `list`, that element's index, and the entire `list` itself.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var letters = ['a', 'b', 'c'];\n     *      var objectify = function(accObject, elem, idx, list) {\n     *        accObject[elem] = idx;\n     *        return accObject;\n     *      };\n     *\n     *      R.foldrIndexed(objectify, {}, letters); //=> { 'c': 2, 'b': 1, 'a': 0 }\n     */\n    var foldrIndexed = _curry3(function foldrIndexed(fn, acc, list) {\n        var idx = list.length;\n        while (idx--) {\n            acc = fn(acc, list[idx], idx, list);\n        }\n        return acc;\n    });\n\n    /**\n     * Iterate over an input `list`, calling a provided function `fn` for each element in the\n     * list.\n     *\n     * `fn` receives one argument: *(value)*.\n     *\n     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike\n     * the native `Array.prototype.forEach` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n     *\n     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original\n     * array. In some libraries this function is named `each`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> *) -> [a] -> [a]\n     * @param {Function} fn The function to invoke. Receives one argument, `value`.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} The original list.\n     * @example\n     *\n     *      var printXPlusFive = function(x) { console.log(x + 5); };\n     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]\n     *      //-> 6\n     *      //-> 7\n     *      //-> 8\n     */\n    var forEach = _curry2(_forEach);\n\n    /**\n     * Like `forEach`, but but passes additional parameters to the predicate function.\n     *\n     * `fn` receives three arguments: *(value, index, list)*.\n     *\n     * Note: `R.forEachIndexed` does not skip deleted or unassigned indices (sparse arrays),\n     * unlike the native `Array.prototype.forEach` method. For more details on this behavior,\n     * see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n     *\n     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original\n     * array. In some libraries this function is named `each`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a, i, [a] -> ) -> [a] -> [a]\n     * @param {Function} fn The function to invoke. Receives three arguments:\n     *        (`value`, `index`, `list`).\n     * @param {Array} list The list to iterate over.\n     * @return {Array} The original list.\n     * @example\n     *\n     *      // Note that having access to the original `list` allows for\n     *      // mutation. While you *can* do this, it's very un-functional behavior:\n     *      var plusFive = function(num, idx, list) { list[idx] = num + 5 };\n     *      R.forEachIndexed(plusFive, [1, 2, 3]); //=> [6, 7, 8]\n     */\n    // i can't bear not to return *something*\n    var forEachIndexed = _curry2(function forEachIndexed(fn, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len) {\n            fn(list[idx], idx, list);\n        }\n        // i can't bear not to return *something*\n        return list;\n    });\n\n    /**\n     * Returns a list of function names of object's own and prototype functions\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {*} -> [String]\n     * @param {Object} obj The objects with functions in it\n     * @return {Array} A list of the object's own properties and prototype\n     *         properties that map to functions.\n     * @example\n     *\n     *      R.functionsIn(R); // returns list of ramda's own and prototype function names\n     *\n     *      var F = function() { this.x = function(){}; this.y = 1; }\n     *      F.prototype.z = function() {};\n     *      F.prototype.a = 100;\n     *      R.functionsIn(new F()); //=> [\"x\", \"z\"]\n     */\n    var functionsIn = _functionsWith(keysIn);\n\n    /**\n     * @func\n     * @memberOf R\n     * @category Object\n     * @see R.prop\n     */\n    var get = prop;\n\n    /**\n     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function\n     * on each element, and grouping the results according to values returned.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> s) -> [a] -> {s: a}\n     * @param {Function} fn Function :: a -> String\n     * @param {Array} list The array to group\n     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements\n     *         that produced that key when passed to `fn`.\n     * @example\n     *\n     *     var byGrade = R.groupBy(function(student) {\n     *       var score = student.score;\n     *       return (score < 65) ? 'F' : (score < 70) ? 'D' :\n     *              (score < 80) ? 'C' : (score < 90) ? 'B' : 'A';\n     *     });\n     *     var students = [{name: 'Abby', score: 84},\n     *                     {name: 'Eddy', score: 58},\n     *                     // ...\n     *                     {name: 'Jack', score: 69}];\n     *     byGrade(students);\n     *     // {\n     *     //   'A': [{name: 'Dianne', score: 99}],\n     *     //   'B': [{name: 'Abby', score: 84}]\n     *     //   // ...,\n     *     //   'F': [{name: 'Eddy', score: 58}]\n     *     // }\n     */\n    var groupBy = _curry2(function groupBy(fn, list) {\n        return _foldl(function (acc, elt) {\n            var key = fn(elt);\n            acc[key] = _append(elt, acc[key] || (acc[key] = []));\n            return acc;\n        }, {}, list);\n    });\n\n    /**\n     * Returns whether or not an object has an own property with\n     * the specified name\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      var obj = {\n     *        foo: 1,\n     *        bar: 2,\n     *      };\n     *      R.has('foo', obj);  //=> true\n     *\n     *      var list = [{foo: 1}, {foo: 2}, {bar: 3}];\n     *      R.filter(R.has('foo'), list);  //=> [{foo: 1}, {foo: 2}]\n     */\n    var has = _curry2(function (prop, obj) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    });\n\n    /**\n     * Returns whether or not an object or its prototype chain has\n     * a property with the specified name\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      function Rectangle(width, height) {\n     *          this.width = width;\n     *          this.height = height;\n     *      }\n     *      Rectangle.prototype.area = function() {\n     *          return this.width * this.height;\n     *      };\n     *\n     *      var square = new Rectangle(2, 2);\n     *      R.hasIn('width', square);  //=> true\n     *      R.hasIn('area', square);  //=> true\n     */\n    var hasIn = _curry2(function (prop, obj) {\n        return prop in obj;\n    });\n\n    /**\n     * Creates a function that will process either the `onTrue` or the `onFalse` function depending\n     * upon the result of the `condition` predicate.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)\n     * @param {Function} condition A predicate function\n     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.\n     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.\n     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`\n     *                    function depending upon the result of the `condition` predicate.\n     * @example\n     *\n     *      // Flatten all arrays in the list but leave other values alone.\n     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));\n     *\n     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]\n     *      flattenArrays([[[10], 123], [8, [10]], \"hello\"]); //=> [[10, 123], [8, 10], \"hello\"]\n     */\n    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {\n        return function _ifElse() {\n            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n        };\n    });\n\n    /**\n     * Increments its argument.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @example\n     *\n     *      R.inc(42); //=> 43\n     */\n    var inc = add(1);\n\n    /**\n     * Returns the position of the first occurrence of an item in an array\n     * (by strict equality),\n     * or -1 if the item is not included in the array.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} list The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     *\n     * @example\n     *\n     *      R.indexOf(3, [1,2,3,4]); //=> 2\n     *      R.indexOf(10, [1,2,3,4]); //=> -1\n     */\n    var indexOf = _curry2(function indexOf(target, list) {\n        return _indexOf(list, target);\n    });\n\n    /**\n     * Inserts the supplied element into the list, at index `index`.  _Note\n     * that this is not destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> a -> [a] -> [a]\n     * @param {Number} index The position to insert the element\n     * @param {*} elt The element to insert into the Array\n     * @param {Array} list The list to insert into\n     * @return {Array} A new Array with `elt` inserted at `index`.\n     * @example\n     *\n     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]\n     */\n    var insert = _curry3(function insert(idx, elt, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        return _concat(_append(elt, _slice(list, 0, idx)), _slice(list, idx));\n    });\n\n    /**\n     * Inserts the sub-list into the list, at index `index`.  _Note  that this\n     * is not destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> [a] -> [a] -> [a]\n     * @param {Number} index The position to insert the sub-list\n     * @param {Array} elts The sub-list to insert into the Array\n     * @param {Array} list The list to insert the sub-list into\n     * @return {Array} A new Array with `elts` inserted starting at `index`.\n     * @example\n     *\n     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]\n     */\n    var insertAll = _curry3(function insertAll(idx, elts, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));\n    });\n\n    /**\n     * Turns a named method with a specified arity into a function\n     * that can be called directly supplied with arguments and a target object.\n     *\n     * The returned function is curried and accepts `len + 1` parameters where\n     * the final parameter is the target object.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (Number, String) -> (a... -> c -> b)\n     * @param {Number} len Number of arguments the returned function should take\n     *        before the target object.\n     * @param {Function} method Name of the method to call.\n     * @return {Function} A new curried function.\n     * @example\n     *\n     *      var sliceFrom = R.invoker(1, 'slice');\n     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n     *      var sliceFrom6 = R.invoker(2, 'slice', 6);\n     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n     */\n    var invoker = function invoker(arity, method) {\n        var initialArgs = _slice(arguments, 2);\n        var len = arity - initialArgs.length;\n        return curryN(len + 1, function () {\n            var target = arguments[len];\n            var args = initialArgs.concat(_slice(arguments, 0, len));\n            return target[method].apply(target, args);\n        });\n    };\n\n    /**\n     * See if an object (`val`) is an instance of the supplied constructor.\n     * This function will check up the inheritance chain, if any.\n     *\n     * @func\n     * @memberOf R\n     * @category Type\n     * @sig (* -> {*}) -> a -> Boolean\n     * @param {Object} ctor A constructor\n     * @param {*} val The value to test\n     * @return {Boolean}\n     * @example\n     *\n     *      R.is(Object, {}); //=> true\n     *      R.is(Number, 1); //=> true\n     *      R.is(Object, 1); //=> false\n     *      R.is(String, 's'); //=> true\n     *      R.is(String, new String('')); //=> true\n     *      R.is(Object, new String('')); //=> true\n     *      R.is(Object, 's'); //=> false\n     *      R.is(Number, {}); //=> false\n     */\n    var is = _curry2(function is(Ctor, val) {\n        return val != null && val.constructor === Ctor || val instanceof Ctor;\n    });\n\n    /**\n     * Returns a string made by inserting the `separator` between each\n     * element and concatenating all the elements into a single string.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig String -> [a] -> String\n     * @param {Number|String} separator The string used to separate the elements.\n     * @param {Array} xs The elements to join into a string.\n     * @return {String} str The string made by concatenating `xs` with `separator`.\n     * @example\n     *\n     *      var spacer = R.join(' ');\n     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'\n     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'\n     */\n    var join = invoker(1, 'join');\n\n    /**\n     * Returns a list containing the names of all the enumerable own\n     * properties of the supplied object.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own properties.\n     * @example\n     *\n     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n     */\n    // cover IE < 9 keys issues\n    var keys = function () {\n        // cover IE < 9 keys issues\n        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n        var nonEnumerableProps = [\n            'constructor',\n            'valueOf',\n            'isPrototypeOf',\n            'toString',\n            'propertyIsEnumerable',\n            'hasOwnProperty',\n            'toLocaleString'\n        ];\n        return function keys(obj) {\n            if (Object(obj) !== obj) {\n                return [];\n            }\n            if (Object.keys) {\n                return Object.keys(obj);\n            }\n            var prop, ks = [], nIdx;\n            for (prop in obj) {\n                if (has(prop, obj)) {\n                    ks[ks.length] = prop;\n                }\n            }\n            if (hasEnumBug) {\n                nIdx = nonEnumerableProps.length;\n                while (nIdx--) {\n                    prop = nonEnumerableProps[nIdx];\n                    if (has(prop, obj) && !_contains(prop, ks)) {\n                        ks[ks.length] = prop;\n                    }\n                }\n            }\n            return ks;\n        };\n    }();\n\n    /**\n     * Accepts as its arguments a function and any number of values and returns a function that,\n     * when invoked, calls the original function with all of the values prepended to the\n     * original function's arguments list. In some libraries this function is named `applyLeft`.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)\n     * @param {Function} fn The function to invoke.\n     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.\n     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`\n     *         with `args` prepended to `fn`'s arguments list.\n     * @example\n     *\n     *      var multiply = function(a, b) { return a * b; };\n     *      var double = R.lPartial(multiply, 2);\n     *      double(2); //=> 4\n     *\n     *      var greet = function(salutation, title, firstName, lastName) {\n     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *      };\n     *      var sayHello = R.lPartial(greet, 'Hello');\n     *      var sayHelloToMs = R.lPartial(sayHello, 'Ms.');\n     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var lPartial = _createPartialApplicator(_concat);\n\n    /**\n     * Returns the position of the last occurrence of an item (by strict equality) in\n     * an array, or -1 if the item is not included in the array.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} list The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     *\n     * @example\n     *\n     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6\n     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1\n     */\n    var lastIndexOf = _curry2(function lastIndexOf(target, list) {\n        return _lastIndexOf(list, target);\n    });\n\n    /**\n     * Returns the number of elements in the array by returning `list.length`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> Number\n     * @param {Array} list The array to inspect.\n     * @return {Number} The length of the array.\n     * @example\n     *\n     *      R.length([]); //=> 0\n     *      R.length([1, 2, 3]); //=> 3\n     */\n    var length = function length(list) {\n        return list != null && is(Number, list.length) ? list.length : NaN;\n    };\n\n    /**\n     * Creates a lens. Supply a function to `get` values from inside an object, and a `set`\n     * function to change values on an object. (n.b.: This can, and should, be done without\n     * mutating the original object!) The lens is a function wrapped around the input `get`\n     * function, with the `set` function attached as a property on the wrapper. A `map`\n     * function is also attached to the returned function that takes a function to operate\n     * on the specified (`get`) property, which is then `set` before returning. The attached\n     * `set` and `map` functions are curried.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig (k -> v) -> (v -> a -> *) -> (a -> b)\n     * @param {Function} get A function that gets a value by property name\n     * @param {Function} set A function that gets a value by property name\n     * @return {Function} the returned function has `set` and `map` properties that are\n     *         also curried functions.\n     * @example\n     *\n     *     var headLens = R.lens(\n     *         function get(arr) { return arr[0]; },\n     *         function set(val, arr) { return [val].concat(arr.slice(1)); }\n     *     );\n     *     headLens([10, 20, 30, 40]); //=> 10\n     *     headLens.set('mu', [10, 20, 30, 40]); //=> ['mu', 20, 30, 40]\n     *     headLens.map(function(x) { return x + 1; }, [10, 20, 30, 40]); //=> [11, 20, 30, 40]\n     *\n     *     var phraseLens = R.lens(\n     *         function get(obj) { return obj.phrase; },\n     *         function set(val, obj) {\n     *             var out = R.clone(obj);\n     *             out.phrase = val;\n     *             return out;\n     *         }\n     *     );\n     *     var obj1 = { phrase: 'Absolute filth . . . and I LOVED it!'};\n     *     var obj2 = { phrase: \"What's all this, then?\"};\n     *     phraseLens(obj1); // => 'Absolute filth . . . and I LOVED it!'\n     *     phraseLens(obj2); // => \"What's all this, then?\"\n     *     phraseLens.set('Ooh Betty', obj1); //=> { phrase: 'Ooh Betty'}\n     *     phraseLens.map(R.toUpper, obj2); //=> { phrase: \"WHAT'S ALL THIS, THEN?\"}\n     */\n    var lens = _curry2(function lens(get, set) {\n        var lns = function (a) {\n            return get(a);\n        };\n        lns.set = _curry2(set);\n        lns.map = _curry2(function (fn, a) {\n            return set(fn(get(a)), a);\n        });\n        return lns;\n    });\n\n    /**\n     * Returns a new list, constructed by applying the supplied function to every element of the\n     * supplied list.\n     *\n     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the\n     * native `Array.prototype.map` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> b) -> [a] -> [b]\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {Array} list The list to be iterated over.\n     * @return {Array} The new list.\n     * @example\n     *\n     *      var double = function(x) {\n     *        return x * 2;\n     *      };\n     *\n     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n     */\n    var map = _curry2(_checkForMethod('map', _map));\n\n    /**\n     * The mapAccumL function behaves like a combination of map and foldl; it applies a\n     * function to each element of a list, passing an accumulating parameter from left to\n     * right, and returning a final value of this accumulator together with the new list.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var append = function(a, b) {\n     *          return [a + b, a + b];\n     *      }\n     *\n     *      R.mapAccumL(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n     */\n    var mapAccumL = _curry3(function mapAccumL(fn, acc, list) {\n        var idx = -1, len = list.length, result = new Array(len), tuple = [acc];\n        while (++idx < len) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * The mapAccumR function behaves like a combination of map and foldr; it applies a\n     * function to each element of a list, passing an accumulating parameter from right\n     * to left, and returning a final value of this accumulator together with the new list.\n     *\n     * Similar to `mapAccumL`, except moves through the input list from the right to the\n     * left.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var append = function(a, b) {\n     *          return [a + b, a + b];\n     *      }\n     *\n     *      R.mapAccumR(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]\n     */\n    var mapAccumR = _curry3(function mapAccumR(fn, acc, list) {\n        var idx = list.length, len = list.length, result = new Array(len), tuple = [acc];\n        while (idx--) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * Like `map`, but but passes additional parameters to the mapping function.\n     * `fn` receives three arguments: *(value, index, list)*.\n     *\n     * Note: `R.mapIndexed` does not skip deleted or unassigned indices (sparse arrays), unlike\n     * the native `Array.prototype.map` method. For more details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,i,[b] -> b) -> [a] -> [b]\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {Array} list The list to be iterated over.\n     * @return {Array} The new list.\n     * @example\n     *\n     *      var squareEnds = function(elt, idx, list) {\n     *        if (idx === 0 || idx === list.length - 1) {\n     *          return elt * elt;\n     *        }\n     *        return elt;\n     *      };\n     *\n     *      R.mapIndexed(squareEnds, [8, 5, 3, 0, 9]); //=> [64, 5, 3, 0, 81]\n     */\n    var mapIndexed = _curry2(function mapIndexed(fn, list) {\n        var idx = -1, len = list.length, result = new Array(len);\n        while (++idx < len) {\n            result[idx] = fn(list[idx], idx, list);\n        }\n        return result;\n    });\n\n    /**\n     * Map, but for objects. Creates an object with the same keys as `obj` and values\n     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:\n     * *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (v -> v) -> {k: v} -> {k: v}\n     * @param {Function} fn A function called for each property in `obj`. Its return value will\n     * become a new property on the return object.\n     * @param {Object} obj The object to iterate over.\n     * @return {Object} A new object with the same keys as `obj` and values that are the result\n     *         of running each property through `fn`.\n     * @example\n     *\n     *      var values = { x: 1, y: 2, z: 3 };\n     *      var double = function(num) {\n     *        return num * 2;\n     *      };\n     *\n     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }\n     */\n    var mapObj = _curry2(function mapObject(fn, obj) {\n        return _foldl(function (acc, key) {\n            acc[key] = fn(obj[key]);\n            return acc;\n        }, {}, keys(obj));\n    });\n\n    /**\n     * Like `mapObj`, but but passes additional arguments to the predicate function. The\n     * predicate function is passed three arguments: *(value, key, obj)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}\n     * @param {Function} fn A function called for each property in `obj`. Its return value will\n     *        become a new property on the return object.\n     * @param {Object} obj The object to iterate over.\n     * @return {Object} A new object with the same keys as `obj` and values that are the result\n     *         of running each property through `fn`.\n     * @example\n     *\n     *      var values = { x: 1, y: 2, z: 3 };\n     *      var prependKeyAndDouble = function(num, key, obj) {\n     *        return key + (num * 2);\n     *      };\n     *\n     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }\n     */\n    var mapObjIndexed = _curry2(function mapObjectIndexed(fn, obj) {\n        return _foldl(function (acc, key) {\n            acc[key] = fn(obj[key], key, obj);\n            return acc;\n        }, {}, keys(obj));\n    });\n\n    /**\n     * Tests a regular expression against a String\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig RegExp -> String -> [String] | null\n     * @param {RegExp} rx A regular expression.\n     * @param {String} str The string to match against\n     * @return {Array} The list of matches, or null if no matches found.\n     * @see R.invoker\n     * @example\n     *\n     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']\n     */\n    var match = invoker(1, 'match');\n\n    /**\n     * Determines the largest of a list of numbers (or elements that can be cast to numbers)\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig [Number] -> Number\n     * @see R.maxBy\n     * @param {Array} list A list of numbers\n     * @return {Number} The greatest number in the list.\n     * @example\n     *\n     *      R.max([7, 3, 9, 2, 4, 9, 3]); //=> 9\n     */\n    var max = _createMaxMin(_gt, -Infinity);\n\n    /**\n     * Determines the largest of a list of items as determined by pairwise comparisons from the supplied comparator\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig (a -> Number) -> [a] -> a\n     * @param {Function} keyFn A comparator function for elements in the list\n     * @param {Array} list A list of comparable elements\n     * @return {*} The greatest element in the list. `undefined` if the list is empty.\n     * @see R.max\n     * @example\n     *\n     *      function cmp(obj) { return obj.x; }\n     *      var a = {x: 1}, b = {x: 2}, c = {x: 3};\n     *      R.maxBy(cmp, [a, b, c]); //=> {x: 3}\n     */\n    var maxBy = _curry2(_createMaxMinBy(_gt));\n\n    /**\n     * Determines the smallest of a list of numbers (or elements that can be cast to numbers)\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list A list of numbers\n     * @return {Number} The greatest number in the list.\n     * @see R.minBy\n     * @example\n     *\n     *      R.min([7, 3, 9, 2, 4, 9, 3]); //=> 2\n     */\n    var min = _createMaxMin(_lt, Infinity);\n\n    /**\n     * Determines the smallest of a list of items as determined by pairwise comparisons from the supplied comparator\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig (a -> Number) -> [a] -> a\n     * @param {Function} keyFn A comparator function for elements in the list\n     * @param {Array} list A list of comparable elements\n     * @see R.min\n     * @return {*} The greatest element in the list. `undefined` if the list is empty.\n     * @example\n     *\n     *      function cmp(obj) { return obj.x; }\n     *      var a = {x: 1}, b = {x: 2}, c = {x: 3};\n     *      R.minBy(cmp, [a, b, c]); //=> {x: 1}\n     */\n    var minBy = _curry2(_createMaxMinBy(_lt));\n\n    /**\n     * Multiplies two numbers. Equivalent to `a * b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a * b`.\n     * @example\n     *\n     *      var double = R.multiply(2);\n     *      var triple = R.multiply(3);\n     *      double(3);       //=>  6\n     *      triple(4);       //=> 12\n     *      R.multiply(2, 5);  //=> 10\n     */\n    var multiply = _curry2(_multiply);\n\n    /**\n     * Negates its argument.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @example\n     *\n     *      R.negate(42); //=> -42\n     */\n    var negate = multiply(-1);\n\n    /**\n     * Returns the nth element in a list.\n     * If n is negative the element at index length + n is returned.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> a\n     * @param {Number} idx\n     * @param {Array} list\n     * @return {*} The nth element of the list.\n     * @example\n     *\n     *      var list = ['foo', 'bar', 'baz', 'quux'];\n     *      R.nth(1, list); //=> 'bar'\n     *      R.nth(-1, list); //=> 'quux'\n     *      R.nth(-99, list); //=> undefined\n     */\n    var nth = _curry2(_nth);\n\n    /**\n     *\n     * `of` wraps any object in an Array. This implementation is compatible with the\n     * Fantasy-land Applicative spec, and will work with types that implement that spec.\n     * Note this `of` is different from the ES6 `of`; See\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig a -> [a]\n     * @param {*} x any value\n     * @return {Array} An array wrapping `x`.\n     * @example\n     *\n     *      R.of(1); //=> [1]\n     *      R.of([2]); //=> [[2]]\n     *      R.of({}); //=> [{}]\n     */\n    var of = function of(x, container) {\n        return _hasMethod('of', container) ? container.of(x) : [x];\n    };\n\n    /**\n     * Returns a partial copy of an object omitting the keys specified.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to omit from the new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with properties from `names` not on it.\n     * @example\n     *\n     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n     */\n    var omit = _curry2(function omit(names, obj) {\n        return _pickBy(function (val, key) {\n            return !_contains(key, names);\n        }, obj);\n    });\n\n    /**\n     * Uses a placeholder to convert a binary function into something like an infix operation.\n     * When called with the `R.__` placeholder the second argument is applied to the\n     * second position, and it returns a function waiting for its first argument.\n     * This can allow for more natural processing of functions which are really binary operators.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @param {Function} fn The binary operation to adjust\n     * @return {Function} A new function that acts somewhat like an infix operator.\n     * @example\n     *\n     *      var div = R.op(function (a, b) {\n     *          return a / b;\n     *      });\n     *\n     *      div(6, 3); //=> 2\n     *      div(6)(3); //=> 2\n     *      div(R.__, 3)(6); //=> 2\n     *      div(R.__)(3, 6); //=> 2\n     *      div(R.__)(3)(6); //=> 2\n     */\n    var op = function op(fn) {\n        if (fn.length !== 2) {\n            throw new Error('Expected binary function.');\n        }\n        return function _op(a, b) {\n            switch (arguments.length) {\n            case 0:\n                throw _noArgsException();\n            case 1:\n                return a === __ ? flip(_op) : lPartial(fn, a);\n            default:\n                return a === __ ? flip(fn)(b) : fn(a, b);\n            }\n        };\n    };\n\n    /**\n     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first\n     * function if it is truth-y and the result of the second function otherwise.  Note that this is\n     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y\n     * value.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and ORs their outputs together.\n     * @example\n     *\n     *      var gt10 = function(x) { return x > 10; };\n     *      var even = function(x) { return x % 2 === 0 };\n     *      var f = R.or(gt10, even);\n     *      f(101); //=> true\n     *      f(8); //=> true\n     */\n    var or = _curry2(function or(f, g) {\n        return function _or() {\n            return f.apply(this, arguments) || g.apply(this, arguments);\n        };\n    });\n\n    /**\n     * Similar to `compose` but with automatic handling of promises (or, more\n     * precisely, \"thenables\"). The behavior is identical  to that of\n     * compose() if all composed functions return something other than\n     * promises (i.e., objects with a .then() method). If one of the function\n     * returns a promise, however, then the next function in the composition\n     * is called asynchronously, in the success callback of the promise, using\n     * the resolved value as an input. Note that `pCompose` is a right-\n     * associative function, just like `compose`.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((y -> z), (x -> y), ..., (b -> c), (a... -> b)) -> (a... -> z)\n     * @param {...Function} functions A variable number of functions.\n     * @return {Function} A new function which represents the result of calling each of the\n     *         input `functions`, passing either the returned result or the asynchronously\n     *         resolved value) of each function call to the next, from right to left.\n     * @example\n     *\n     *      var Q = require('q');\n     *      var triple = function(x) { return x * 3; };\n     *      var double = function(x) { return x * 2; };\n     *      var squareAsync = function(x) { return Q.when(x * x); };\n     *      var squareAsyncThenDoubleThenTriple = R.pCompose(triple, double, squareAsync);\n     *\n     *      //≅ squareAsync(5).then(function(x) { return triple(double(x)) };\n     *      squareAsyncThenDoubleThenTriple(5)\n     *          .then(function(result) {\n     *              // result is 150\n     *          });\n     */\n    var pCompose = _createComposer(_pCompose);\n\n    /**\n     * Creates a new function that runs each of the functions supplied as parameters in turn,\n     * passing to the next function invocation either the value returned by the previous\n     * function or the resolved value if the returned value is a promise. In other words,\n     * if some of the functions in the sequence return promises, `pPipe` pipes the values\n     * asynchronously. If none of the functions return promises, the behavior is the same as\n     * that of `pipe`.\n     *\n     * `pPipe` is the mirror version of `pCompose`. `pPipe` is left-associative, which means that\n     * each of the functions provided is executed in order from left to right.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((a... -> b), (b -> c), ..., (x -> y), (y -> z)) -> (a... -> z)\n     * @param {...Function} functions A variable number of functions.\n     * @return {Function} A new function which represents the result of calling each of the\n     *         input `functions`, passing either the returned result or the asynchronously\n     *         resolved value) of each function call to the next, from left to right.\n     * @example\n     *\n     *      var Q = require('q');\n     *      var triple = function(x) { return x * 3; };\n     *      var double = function(x) { return x * 2; };\n     *      var squareAsync = function(x) { return Q.when(x * x); };\n     *      var squareAsyncThenDoubleThenTriple = R.pPipe(squareAsync, double, triple);\n     *\n     *      //≅ squareAsync(5).then(function(x) { return triple(double(x)) };\n     *      squareAsyncThenDoubleThenTriple(5)\n     *          .then(function(result) {\n     *              // result is 150\n     *          });\n     */\n    var pPipe = function pPipe() {\n        return pCompose.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Takes a predicate and a list and returns the pair of lists of\n     * elements which do and do not satisfy the predicate, respectively.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [[a],[a]]\n     * @param {Function} pred A predicate to determine which array the element belongs to.\n     * @param {Array} list The array to partition.\n     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,\n     *         and second an array of elements that did not satisfy.\n     * @example\n     *\n     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);\n     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]\n     */\n    var partition = _curry2(function partition(pred, list) {\n        return _foldl(function (acc, elt) {\n            acc[pred(elt) ? 0 : 1].push(elt);\n            return acc;\n        }, [\n            [],\n            []\n        ], list);\n    });\n\n    /**\n     * Determines whether a nested path on an object, seperated by periods,\n     * has a specific value according to strict equality ('==='). Most\n     * likely used to filter a list:\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig String -> v -> {k: v} -> Boolean\n     * @param {String} path The path of the nested property to use\n     * @param {*} val The value to compare the nested property with\n     * @param {Object} obj The object to check the nested property in\n     * @return {Boolean} `true` if the value equals the nested object property,\n     *         `false` otherwise.\n     * @example\n     *\n     *     var user1 = { address: { zipCode: 90210 } };\n     *     var user2 = { address: { zipCode: 55555 } };\n     *     var user3 = { name: 'Bob' };\n     *     var users = [ user1, user2, user3 ]\n     *     var isFamous = R.pathEq('address.zipCode', 90210);\n     *     R.filter(isFamous, users); //=> [ user1 ]\n     */\n    var pathEq = _curry3(function (path, val, obj) {\n        return _path(path.split('.'), obj) === val;\n    });\n\n    /**\n     * Retrieve a nested path on an object separated by the specified\n     * separator value.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig String -> String -> {*} -> *\n     * @param {String} sep The separator to use in `path`.\n     * @param {String} path The path to use.\n     * @return {*} The data at `path`.\n     * @example\n     *\n     *      R.pathOn('/', 'a/b/c', {a: {b: {c: 3}}}); //=> 3\n     */\n    var pathOn = _curry3(function pathOn(sep, str, obj) {\n        return _path(str.split(sep), obj);\n    });\n\n    /**\n     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the\n     * property is ignored.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @example\n     *\n     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n     */\n    var pick = _curry2(function pick(names, obj) {\n        return _pickBy(function (val, key) {\n            return _contains(key, names);\n        }, obj);\n    });\n\n    /**\n     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.pick\n     * @example\n     *\n     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n     */\n    var pickAll = _curry2(_pickAll);\n\n    /**\n     * Returns a partial copy of an object containing only the keys that\n     * satisfy the supplied predicate.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}\n     * @param {Function} pred A predicate to determine whether or not a key\n     *        should be included on the output object.\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties that satisfy `pred`\n     *         on it.\n     * @see R.pick\n     * @example\n     *\n     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }\n     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n     */\n    var pickBy = _curry2(_pickBy);\n\n    /**\n     * Creates a new function that runs each of the functions supplied as parameters in turn,\n     * passing the return value of each function invocation to the next function invocation,\n     * beginning with whatever arguments were passed to the initial invocation.\n     *\n     * `pipe` is the mirror version of `compose`. `pipe` is left-associative, which means that\n     * each of the functions provided is executed in order from left to right.\n     *\n     * In some libraries this function is named `sequence`.\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((a... -> b), (b -> c), ..., (x -> y), (y -> z)) -> (a... -> z)\n     * @param {...Function} functions A variable number of functions.\n     * @return {Function} A new function which represents the result of calling each of the\n     *         input `functions`, passing the result of each function call to the next, from\n     *         left to right.\n     * @example\n     *\n     *      var triple = function(x) { return x * 3; };\n     *      var double = function(x) { return x * 2; };\n     *      var square = function(x) { return x * x; };\n     *      var squareThenDoubleThenTriple = R.pipe(square, double, triple);\n     *\n     *      //≅ triple(double(square(5)))\n     *      squareThenDoubleThenTriple(5); //=> 150\n     */\n    var pipe = function pipe() {\n        return compose.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Returns a new list by plucking the same named property off all objects in the list supplied.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig String -> {*} -> [*]\n     * @param {Number|String} key The key name to pluck off of each object.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of values for the given key.\n     * @example\n     *\n     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n     */\n    var pluck = _curry2(_pluck);\n\n    /**\n     * Returns a new list with the given element at the front, followed by the contents of the\n     * list.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The item to add to the head of the output list.\n     * @param {Array} list The array to add to the tail of the output list.\n     * @return {Array} A new array.\n     * @example\n     *\n     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']\n     */\n    var prepend = _curry2(_prepend);\n\n    /**\n     * Multiplies together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The product of all the numbers in the list.\n     * @see foldl\n     * @example\n     *\n     *      R.product([2,4,6,8,100,1]); //=> 38400\n     */\n    var product = foldl(_multiply, 1);\n\n    /**\n     * Determines whether the given property of an object has a specific\n     * value according to strict equality (`===`).  Most likely used to\n     * filter a list:\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig k -> v -> {k: v} -> Boolean\n     * @param {Number|String} name The property name (or index) to use.\n     * @param {*} val The value to compare the property with.\n     * @return {Boolean} `true` if the properties are equal, `false` otherwise.\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};\n     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};\n     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};\n     *      var kids = [abby, fred, rusty, alois];\n     *      var hasBrownHair = R.propEq('hair', 'brown');\n     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]\n     */\n    var propEq = _curry3(function propEq(name, val, obj) {\n        return obj[name] === val;\n    });\n\n    /**\n     * If the given, non-null object has an own property with the specified name,\n     * returns the value of that property.\n     * Otherwise returns the provided default value.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig s -> v -> {s: x} -> x | v\n     * @param {String} p The name of the property to return.\n     * @param {*} val The default value.\n     * @param {Object} obj The object to query.\n     * @return {*} The value of given property or default value.\n     * @example\n     *\n     *      var alice = {\n     *        name: 'ALICE',\n     *        age: 101\n     *      };\n     *      var favorite = R.prop('favoriteLibrary');\n     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');\n     *\n     *      favorite(alice);  //=> undefined\n     *      favoriteWithDefault(alice);  //=> 'Ramda'\n     */\n    var propOr = _curry3(function propOr(val, p, obj) {\n        return has(p, obj) ? obj[p] : val;\n    });\n\n    /**\n     * Acts as multiple `get`: array of keys in, array of values out. Preserves order.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig [k] -> {k: v} -> [v]\n     * @param {Array} ps The property names to fetch\n     * @param {Object} obj The object to query\n     * @return {Array} The corresponding values or partially applied function.\n     * @example\n     *\n     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]\n     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]\n     *\n     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));\n     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'\n     */\n    var props = _curry2(function props(ps, obj) {\n        var len = ps.length, out = new Array(len), idx = -1;\n        while (++idx < len) {\n            out[idx] = obj[ps[idx]];\n        }\n        return out;\n    });\n\n    /**\n     * Accepts as its arguments a function and any number of values and returns a function that,\n     * when invoked, calls the original function with all of the values appended to the original\n     * function's arguments list.\n     *\n     * Note that `rPartial` is the opposite of `lPartial`: `rPartial` fills `fn`'s arguments\n     * from the right to the left.  In some libraries this function is named `applyRight`.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)\n     * @param {Function} fn The function to invoke.\n     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.\n     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with\n     *         `args` appended to `fn`'s arguments list.\n     * @example\n     *\n     *      var greet = function(salutation, title, firstName, lastName) {\n     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *      };\n     *      var greetMsJaneJones = R.rPartial(greet, 'Ms.', 'Jane', 'Jones');\n     *\n     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var rPartial = _createPartialApplicator(flip(_concat));\n\n    /**\n     * Returns a list of numbers from `from` (inclusive) to `to`\n     * (exclusive).\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> Number -> [Number]\n     * @param {Number} from The first number in the list.\n     * @param {Number} to One more than the last number in the list.\n     * @return {Array} The list of numbers in tthe set `[a, b)`.\n     * @example\n     *\n     *      R.range(1, 5);    //=> [1, 2, 3, 4]\n     *      R.range(50, 53);  //=> [50, 51, 52]\n     */\n    var range = _curry2(function range(from, to) {\n        if (from >= to) {\n            return [];\n        }\n        var idx = 0, result = new Array(Math.floor(to) - Math.ceil(from));\n        while (from < to) {\n            result[idx++] = from++;\n        }\n        return result;\n    });\n\n    /**\n     * Similar to `filter`, except that it keeps only values for which the given predicate\n     * function returns falsy. The predicate function is passed one argument: *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} The new filtered array.\n     * @example\n     *\n     *      var isOdd = function(n) {\n     *        return n % 2 === 1;\n     *      };\n     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n     */\n    var reject = _curry2(function reject(fn, list) {\n        return _filter(not(fn), list);\n    });\n\n    /**\n     * Like `reject`, but passes additional parameters to the predicate function. The predicate\n     * function is passed three arguments: *(value, index, list)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a, i, [a] -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} The new filtered array.\n     * @example\n     *\n     *      var lastTwo = function(val, idx, list) {\n     *        return list.length - idx <= 2;\n     *      };\n     *\n     *      R.rejectIndexed(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=> [8, 6, 7, 5, 3]\n     */\n    var rejectIndexed = _curry2(function rejectIndexed(fn, list) {\n        return _filterIndexed(not(fn), list);\n    });\n\n    /**\n     * Removes the sub-list of `list` starting at index `start` and containing\n     * `count` elements.  _Note that this is not destructive_: it returns a\n     * copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @param {Number} start The position to start removing elements\n     * @param {Number} count The number of elements to remove\n     * @param {Array} list The list to remove from\n     * @return {Array} A new Array with `count` elements from `start` removed.\n     * @example\n     *\n     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n     */\n    var remove = _curry3(function remove(start, count, list) {\n        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n    });\n\n    /**\n     * Replace a substring or regex match in a string with a replacement.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig RegExp|String -> String -> String -> String\n     * @param {RegExp|String} pattern A regular expression or a substring to match.\n     * @param {String} replacement The string to replace the matches with.\n     * @param {String} str The String to do the search and replacement in.\n     * @return {String} A string with all the matches replaced.\n     * @example\n     *\n     *      R.replace(/\\d+/g, 'number', '1 2 three'); //=> 'number number three'\n     *\n     *      var replaceSemicolon = R.replace(';');\n     *      var removeSemicolon = replaceSemicolon('');\n     *      removeSemicolon('return 42;'); //=> 'return 42'\n     */\n    var replace = _curry3(function replace(regex, replacement, str) {\n        return str.replace(regex, replacement);\n    });\n\n    /**\n     * Scanl is similar to foldl, but returns a list of successively reduced values from the left\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> [a]\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} A list of all intermediately reduced values.\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var factorials = R.scanl(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]\n     */\n    var scanl = _curry3(function scanl(fn, acc, list) {\n        var idx = 0, len = list.length + 1, result = new Array(len);\n        result[idx] = acc;\n        while (++idx < len) {\n            acc = fn(acc, list[idx - 1]);\n            result[idx] = acc;\n        }\n        return result;\n    });\n\n    /**\n     * Returns the elements from `xs` starting at `a` and ending at `b - 1`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @param {Number} a The starting index.\n     * @param {Number} b One more than the ending index.\n     * @param {Array} xs The list to take elements from.\n     * @return {Array} The items from `a` to `b - 1` from `xs`.\n     * @example\n     *\n     *      var xs = R.range(0, 10);\n     *      R.slice(2, 5)(xs); //=> [2, 3, 4]\n     */\n    var slice = invoker(2, 'slice');\n\n    /**\n     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a\n     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero\n     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a,a -> Number) -> [a] -> [a]\n     * @param {Function} comparator A sorting function :: a -> b -> Int\n     * @param {Array} list The list to sort\n     * @return {Array} a new array with its elements sorted by the comparator function.\n     * @example\n     *\n     *      var diff = function(a, b) { return a - b; };\n     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]\n     */\n    var sort = _curry2(function sort(comparator, list) {\n        return clone(list).sort(comparator);\n    });\n\n    /**\n     * Sorts the list according to a key generated by the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig (a -> String) -> [a] -> [a]\n     * @param {Function} fn The function mapping `list` items to keys.\n     * @param {Array} list The list to sort.\n     * @return {Array} A new list sorted by the keys generated by `fn`.\n     * @example\n     *\n     *      var sortByFirstItem = R.sortBy(prop(0));\n     *      var sortByNameCaseInsensitive = R.sortBy(compose(R.toLower, prop('name')));\n     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];\n     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]\n     *      var alice = {\n     *         name: 'ALICE',\n     *         age: 101\n     *      };\n     *      var bob = {\n     *         name: 'Bob',\n     *        age: -10\n     *      };\n     *      var clara = {\n     *        name: 'clara',\n     *        age: 314.159\n     *      };\n     *      var people = [clara, bob, alice];\n     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]\n     */\n    var sortBy = _curry2(function sortBy(fn, list) {\n        return clone(list).sort(function (a, b) {\n            var aa = fn(a);\n            var bb = fn(b);\n            return aa < bb ? -1 : aa > bb ? 1 : 0;\n        });\n    });\n\n    /**\n     * Splits a string into an array of strings based on the given\n     * separator.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String -> [String]\n     * @param {String} sep The separator string.\n     * @param {String} str The string to separate into an array.\n     * @return {Array} The array of strings from `str` separated by `str`.\n     * @example\n     *\n     *      var pathComponents = R.split('/');\n     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n     *\n     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n     */\n    var split = invoker(1, 'split');\n\n    /**\n     * Finds the first index of a substring in a string, returning -1 if it's not present\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String -> Number\n     * @param {String} c A string to find.\n     * @param {String} str The string to search in\n     * @return {Number} The first index of `c` or -1 if not found.\n     * @example\n     *\n     *      R.strIndexOf('c', 'abcdefg'); //=> 2\n     */\n    var strIndexOf = _curry2(function strIndexOf(c, str) {\n        return str.indexOf(c);\n    });\n\n    /**\n     *\n     * Finds the last index of a substring in a string, returning -1 if it's not present\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String -> Number\n     * @param {String} c A string to find.\n     * @param {String} str The string to search in\n     * @return {Number} The last index of `c` or -1 if not found.\n     * @example\n     *\n     *      R.strLastIndexOf('a', 'banana split'); //=> 5\n     */\n    var strLastIndexOf = _curry2(function (c, str) {\n        return str.lastIndexOf(c);\n    });\n\n    /**\n     * returns a subset of a string between one index and another.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig Number -> Number -> String -> String\n     * @param {Number} indexA An integer between 0 and the length of the string.\n     * @param {Number} indexB An integer between 0 and the length of the string.\n     * @param {String} str The string to extract from\n     * @return {String} The extracted substring.\n     * @see R.invoker\n     * @example\n     *\n     *      R.substring(2, 5, 'abcdefghijklm'); //=> 'cde'\n     */\n    var substring = invoker(2, 'substring');\n\n    /**\n     * The trailing substring of a String starting with the nth character:\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig Number -> String -> String\n     * @param {Number} indexA An integer between 0 and the length of the string.\n     * @param {String} str The string to extract from\n     * @return {String} The extracted substring.\n     * @example\n     *\n     *      R.substringFrom(8, 'abcdefghijklm'); //=> 'ijklm'\n     */\n    var substringFrom = flip(substring)(void 0);\n\n    /**\n     * The leading substring of a String ending before the nth character:\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig Number -> String -> String\n     * @param {Number} indexA An integer between 0 and the length of the string.\n     * @param {String} str The string to extract from\n     * @return {String} The extracted substring.\n     * @example\n     *\n     *      R.substringTo(8, 'abcdefghijklm'); //=> 'abcdefgh'\n     */\n    var substringTo = substring(0);\n\n    /**\n     * Subtracts two numbers. Equivalent to `a - b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a - b`.\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `R.__` for its first argument.\n     * @example\n     *\n     *      R.subtract(10, 8); //=> 2\n     *\n     *      var minus5 = R.subtract(R.__, 5);\n     *      minus5(17); //=> 12\n     *\n     *      var complementaryAngle = R.subtract(90);\n     *      complementaryAngle(30); //=> 60\n     *      complementaryAngle(72); //=> 18\n     */\n    var subtract = op(function subtract(a, b) {\n        return a - b;\n    });\n\n    /**\n     * Adds together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The sum of all the numbers in the list.\n     * @see foldl\n     * @example\n     *\n     *      R.sum([2,4,6,8,100,1]); //=> 121\n     */\n    var sum = foldl(_add, 0);\n\n    /**\n     * Returns all but the first element of a list. If the list provided has the `tail` method,\n     * it will instead return `list.tail()`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} [list=[]] The array to consider.\n     * @return {Array} A new array containing all but the first element of the input list, or an\n     *         empty list if the input list is empty.\n     * @example\n     *\n     *      R.tail(['fi', 'fo', 'fum']); //=> ['fo', 'fum']\n     */\n    var tail = _checkForMethod('tail', function (list) {\n        return _slice(list, 1);\n    });\n\n    /**\n     * Returns a new list containing the first `n` elements of the given list.  If\n     * `n > * list.length`, returns a list of `list.length` elements.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @param {Number} n The number of elements to return.\n     * @param {Array} list The array to query.\n     * @return {Array} A new array containing the first elements of `list`.\n     */\n    var take = _curry2(_checkForMethod('take', function (n, list) {\n        return _slice(list, 0, Math.min(n, list.length));\n    }));\n\n    /**\n     * Returns a new list containing the first `n` elements of a given list, passing each value\n     * to the supplied predicate function, and terminating when the predicate function returns\n     * `false`. Excludes the element that caused the predicate function to fail. The predicate\n     * function is passed one argument: *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @example\n     *\n     *      var isNotFour = function(x) {\n     *        return !(x === 4);\n     *      };\n     *\n     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]\n     */\n    var takeWhile = _curry2(_checkForMethod('takeWhile', function (fn, list) {\n        var idx = -1, len = list.length;\n        while (++idx < len && fn(list[idx])) {\n        }\n        return _slice(list, 0, idx);\n    }));\n\n    /**\n     * Runs the given function with the supplied object, then returns the object.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a -> *) -> a -> a\n     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n     * @param {*} x\n     * @return {*} `x`.\n     * @example\n     *\n     *      var sayX = function(x) { console.log('x is ' + x); };\n     *      R.tap(sayX, 100); //=> 100\n     *      //-> 'x is 100')\n     */\n    var tap = _curry2(function tap(fn, x) {\n        fn(x);\n        return x;\n    });\n\n    /**\n     * Calls an input function `n` times, returning an array containing the results of those\n     * function calls.\n     *\n     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is\n     * gradually incremented to `n - 1`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (i -> a) -> i -> [a]\n     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n     * @return {Array} An array containing the return values of all calls to `fn`.\n     * @example\n     *\n     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n     */\n    var times = _curry2(function times(fn, n) {\n        var list = new Array(Number(n));\n        var len = list.length;\n        var idx = -1;\n        while (++idx < len) {\n            list[idx] = fn(idx);\n        }\n        return list;\n    });\n\n    /**\n     * The lower case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to lower case.\n     * @return {String} The lower case version of `str`.\n     * @example\n     *\n     *      R.toLower('XYZ'); //=> 'xyz'\n     */\n    var toLower = invoker(0, 'toLowerCase');\n\n    /**\n     * Converts an object into an array of key, value arrays.\n     * Only the object's own properties are used.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [[k,v]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own properties.\n     * @example\n     *\n     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n     */\n    var toPairs = _pairWith(keys);\n\n    /**\n     * The upper case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to upper case.\n     * @return {String} The upper case version of `str`.\n     * @example\n     *\n     *      R.toUpper('abc'); //=> 'ABC'\n     */\n    var toUpper = invoker(0, 'toUpperCase');\n\n    /**\n     * Builds a list from a seed value. Accepts an iterator function, which returns either false\n     * to stop iteration or an array of length 2 containing the value to add to the resulting\n     * list and the seed to be used in the next call to the iterator function.\n     *\n     * The iterator function receives one argument: *(seed)*.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> [b]) -> * -> [b]\n     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n     *        either false to quit iteration or an array of length two to proceed. The element\n     *        at index 0 of this array will be added to the resulting array, and the element\n     *        at index 1 will be passed to the next call to `fn`.\n     * @param {*} seed The seed value.\n     * @return {Array} The final list.\n     * @example\n     *\n     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };\n     *      R.unfoldr(f, 10); //=> [-10, -20, -30, -40, -50]\n     */\n    var unfoldr = _curry2(function unfoldr(fn, seed) {\n        var pair = fn(seed);\n        var result = [];\n        while (pair && pair.length) {\n            result[result.length] = pair[0];\n            pair = fn(pair[1]);\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list containing only one copy of each element in the original list.\n     * Equality is strict here, meaning reference equality for objects and non-coercing equality\n     * for primitives.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n     *      R.uniq([{}, {}]);     //=> [{}, {}]\n     *      R.uniq([1, '1']);     //=> [1, '1']\n     */\n    var uniq = function uniq(list) {\n        var idx = -1, len = list.length;\n        var result = [], item;\n        while (++idx < len) {\n            item = list[idx];\n            if (!_contains(item, result)) {\n                result[result.length] = item;\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Returns a new list containing only one copy of each element in the original list, based\n     * upon the value returned by applying the supplied predicate to two list elements. Prefers\n     * the first item if two items compare equal based on the predicate.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      var strEq = function(a, b) { return String(a) === String(b); };\n     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n     */\n    var uniqWith = _curry2(function uniqWith(pred, list) {\n        var idx = -1, len = list.length;\n        var result = [], item;\n        while (++idx < len) {\n            item = list[idx];\n            if (!_containsWith(pred, item, result)) {\n                result[result.length] = item;\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list by pulling every item at the first level of nesting out, and putting\n     * them in a new array.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [b]\n     * @param {Array} list The array to consider.\n     * @return {Array} The flattened list.\n     * @example\n     *\n     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n     */\n    var unnest = _makeFlat(false);\n\n    /**\n     * Returns a list of all the enumerable own properties of the supplied object.\n     * Note that the order of the output array is not guaranteed across\n     * different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own properties.\n     * @example\n     *\n     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n     */\n    var values = function values(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var vals = new Array(len);\n        var idx = -1;\n        while (++idx < len) {\n            vals[idx] = obj[props[idx]];\n        }\n        return vals;\n    };\n\n    /**\n     * Takes a spec object and a test object and returns true if the test satisfies the spec.\n     * Any property on the spec that is not a function is interpreted as an equality\n     * relation.\n     *\n     * If the spec has a property mapped to a function, then `where` evaluates the function, passing in\n     * the test object's value for the property in question, as well as the whole test object.\n     *\n     * `where` is well suited to declaratively expressing constraints for other functions, e.g.,\n     * `filter`, `find`, `pickBy`, etc.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> {k: v} -> Boolean\n     * @param {Object} spec\n     * @param {Object} testObj\n     * @return {Boolean}\n     * @example\n     *\n     *      var spec = {x: 2};\n     *      R.where(spec, {w: 10, x: 2, y: 300}); //=> true\n     *      R.where(spec, {x: 1, y: 'moo', z: true}); //=> false\n     *\n     *      var spec2 = {x: function(val, obj) { return  val + obj.y > 10; }};\n     *      R.where(spec2, {x: 2, y: 7}); //=> false\n     *      R.where(spec2, {x: 3, y: 8}); //=> true\n     *\n     *      var xs = [{x: 2, y: 1}, {x: 10, y: 2}, {x: 8, y: 3}, {x: 10, y: 4}];\n     *      R.filter(R.where({x: 10}), xs); // ==> [{x: 10, y: 2}, {x: 10, y: 4}]\n     */\n    var where = function where(spec, testObj) {\n        var parsedSpec = groupBy(function (key) {\n            return typeof spec[key] === 'function' ? 'fn' : 'obj';\n        }, keys(spec));\n        switch (arguments.length) {\n        case 0:\n            throw _noArgsException();\n        case 1:\n            return function (testObj) {\n                return _satisfiesSpec(spec, parsedSpec, testObj);\n            };\n        }\n        return _satisfiesSpec(spec, parsedSpec, testObj);\n    };\n\n    /**\n     * Wrap a function inside another to allow you to make adjustments to the parameters, or do\n     * other processing either before the internal function is called or with its results.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)\n     * @param {Function} fn The function to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var greet = function(name) {return 'Hello ' + name;};\n     *\n     *      var shoutedGreet = R.wrap(greet, function(gr, name) {\n     *          return gr(name).toUpperCase();\n     *      });\n     *      shoutedGreet(\"Kathy\"); //=> \"HELLO KATHY\"\n     *\n     *      var shortenedGreet = R.wrap(greet, function(gr, name) {\n     *          return gr(name.substring(0, 3));\n     *      });\n     *      shortenedGreet(\"Robert\"); //=> \"Hello Rob\"\n     *\n     */\n    var wrap = function wrap(fn, wrapper) {\n        return curryN(fn.length, function () {\n            return wrapper.apply(this, _concat([fn], arguments));\n        });\n    };\n\n    /**\n     * Creates a new list out of the two supplied by creating each possible\n     * pair from the lists.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [b] -> [[a,b]]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The list made by combining each possible pair from\n     *         `as` and `bs` into pairs (`[a, b]`).\n     * @example\n     *\n     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n     */\n    // = xprodWith(prepend); (takes about 3 times as long...)\n    // Better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n    var xprod = _curry2(function xprod(a, b) {\n        // = xprodWith(prepend); (takes about 3 times as long...)\n        var idx = -1;\n        var ilen = a.length;\n        var j;\n        var jlen = b.length;\n        // Better to push them all or to do `new Array(ilen * jlen)` and calculate indices?\n        var result = [];\n        while (++idx < ilen) {\n            j = -1;\n            while (++j < jlen) {\n                result[result.length] = [\n                    a[idx],\n                    b[j]\n                ];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by pairing up\n     * equally-positioned items from both lists.  The returned list is\n     * truncated to the length of the shorter of the two input lists.\n     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> b -> [[a,b]]\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n     * @example\n     *\n     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n     */\n    var zip = _curry2(function zip(a, b) {\n        var rv = [];\n        var idx = -1;\n        var len = Math.min(a.length, b.length);\n        while (++idx < len) {\n            rv[idx] = [\n                a[idx],\n                b[idx]\n            ];\n        }\n        return rv;\n    });\n\n    /**\n     * Creates a new object out of a list of keys and a list of values.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig k -> v -> {k: v}\n     * @param {Array} keys The array that will be properties on the output object.\n     * @param {Array} values The list of values on the output object.\n     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n     * @example\n     *\n     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n     */\n    var zipObj = _curry2(function zipObj(keys, values) {\n        var idx = -1, len = keys.length, out = {};\n        while (++idx < len) {\n            out[keys[idx]] = values[idx];\n        }\n        return out;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by applying the function to\n     * each equally-positioned pair in the lists. The returned list is\n     * truncated to the length of the shorter of the two input lists.\n     *\n     * @function\n     * @memberOf R\n     * @category List\n     * @sig (a,b -> c) -> [a] -> [b] -> [c]\n     * @param {Function} fn The function used to combine the two elements into one value.\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n     *         using `fn`.\n     * @example\n     *\n     *      var f = function(x, y) {\n     *        // ...\n     *      };\n     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n     */\n    var zipWith = _curry3(function zipWith(fn, a, b) {\n        var rv = [], idx = -1, len = Math.min(a.length, b.length);\n        while (++idx < len) {\n            rv[idx] = fn(a[idx], b[idx]);\n        }\n        return rv;\n    });\n\n    var _ap = function _ap(fns, vs) {\n        return _hasMethod('ap', fns) ? fns.ap(vs) : _foldl(function (acc, fn) {\n            return _concat(acc, _map(fn, vs));\n        }, [], fns);\n    };\n\n    // The algorithm used to handle cyclic structures is\n    // inspired by underscore's isEqual\n    // RegExp equality algorithm: http://stackoverflow.com/a/10776635\n    var _eqDeep = function _eqDeep(a, b, stackA, stackB) {\n        var typeA = type(a);\n        if (typeA !== type(b)) {\n            return false;\n        }\n        if (eq(a, b)) {\n            return true;\n        }\n        if (typeA == 'RegExp') {\n            // RegExp equality algorithm: http://stackoverflow.com/a/10776635\n            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;\n        }\n        if (Object(a) === a) {\n            if (typeA === 'Date' && a.getTime() != b.getTime()) {\n                return false;\n            }\n            var keysA = keys(a);\n            if (keysA.length !== keys(b).length) {\n                return false;\n            }\n            var idx = stackA.length;\n            while (idx--) {\n                if (stackA[idx] === a) {\n                    return stackB[idx] === b;\n                }\n            }\n            stackA.push(a);\n            stackB.push(b);\n            idx = keysA.length;\n            while (idx--) {\n                var key = keysA[idx];\n                if (!has(key, b) || !_eqDeep(b[key], a[key], stackA, stackB)) {\n                    return false;\n                }\n            }\n            stackA.pop();\n            stackB.pop();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Assigns own enumerable properties of the other object to the destination\n     * object preferring items in other.\n     *\n     * @private\n     * @memberOf R\n     * @category Object\n     * @param {Object} destination The destination object.\n     * @param {Object} other The other object to merge with destination.\n     * @return {Object} The destination object.\n     * @example\n     *\n     *      _extend({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n     *      //=> { 'name': 'fred', 'age': 40 }\n     */\n    var _extend = function _extend(destination, other) {\n        var props = keys(other), idx = -1, length = props.length;\n        while (++idx < length) {\n            destination[props[idx]] = other[props[idx]];\n        }\n        return destination;\n    };\n\n    /**\n     * Create a predicate wrapper which will call a pick function (all/any) for each predicate\n     *\n     * @private\n     * @see R.all\n     * @see R.any\n     */\n    // Call function immediately if given arguments\n    // Return a function which will call the predicates with the provided arguments\n    var _predicateWrap = function _predicateWrap(predPicker) {\n        return function (preds) {\n            var predIterator = function () {\n                var args = arguments;\n                return predPicker(function (predicate) {\n                    return predicate.apply(null, args);\n                }, preds);\n            };\n            return arguments.length > 1 ? // Call function immediately if given arguments\n            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments\n            arity(max(_pluck('length', preds)), predIterator);\n        };\n    };\n\n    /**\n     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} list An array of predicate functions\n     * @param {*} optional Any arguments to pass into the predicates\n     * @return {Function} a function that applies its arguments to each of\n     *         the predicates, returning `true` if all are satisfied.\n     * @example\n     *\n     *      var gt10 = function(x) { return x > 10; };\n     *      var even = function(x) { return x % 2 === 0};\n     *      var f = R.allPass([gt10, even]);\n     *      f(11); //=> false\n     *      f(12); //=> true\n     */\n    var allPass = _predicateWrap(_all);\n\n    /**\n     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.\n     *\n     * @func\n     * @memberOf R\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} list An array of predicate functions\n     * @param {*} optional Any arguments to pass into the predicates\n     * @return {Function} A function that applies its arguments to each of the predicates, returning\n     *         `true` if all are satisfied.\n     * @example\n     *\n     *      var gt10 = function(x) { return x > 10; };\n     *      var even = function(x) { return x % 2 === 0};\n     *      var f = R.anyPass([gt10, even]);\n     *      f(11); //=> true\n     *      f(8); //=> true\n     *      f(9); //=> false\n     */\n    var anyPass = _predicateWrap(_any);\n\n    /**\n     * ap applies a list of functions to a list of values.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig [f] -> [a] -> [f a]\n     * @param {Array} fns An array of functions\n     * @param {Array} vs An array of values\n     * @return {Array} The value of applying each the function `fns` to each value in `vs`.\n     * @example\n     *\n     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n     */\n    var ap = _curry2(_ap);\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the specified\n     * property with the given value.  Note that this copies and flattens\n     * prototype properties onto the new object as well.  All non-primitive\n     * properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig String -> a -> {k: v} -> {k: v}\n     * @param {String} prop the property name to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except for the specified property.\n     * @example\n     *\n     *      var obj1 = {a: 1, b: {c: 2, d: 3}, e: 4, f: 5};\n     *      var obj2 = R.assoc('e', {x: 42}, obj1);\n     *      //=>  {a: 1, b: {c: 2, d: 3}, e: {x: 42}, f: 5}\n     *\n     *      // And moreover, obj2.b is a reference to obj1.b\n     *      // No unnecessary objects are created.\n     */\n    // rather than `clone` to get prototype props too, even though they're flattened\n    var assoc = _curry3(function (prop, val, obj) {\n        // rather than `clone` to get prototype props too, even though they're flattened\n        return _extend(fromPairs(_map(function (key) {\n            return [\n                key,\n                obj[key]\n            ];\n        }, keysIn(obj))), createMapEntry(prop, val));\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the nodes\n     * required to create the given path, and placing the specifiec value at the\n     * tail end of that path.  Note that this copies and flattens prototype\n     * properties onto the new object as well.  All non-primitive properties\n     * are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig String -> a -> {k: v} -> {k: v}\n     * @param {String} path the dot-delimited path to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except along the specified path.\n     * @example\n     *\n     *      var obj1 = {a: {b: 1, c: 2, d: {e: 3}}, f: {g: {h: 4, i: 5, j: {k: 6, l: 7}}}, m: 8};\n     *      var obj2 = R.assocPath('f.g.i', {x: 42}, obj1);\n     *      //=> {a: {b: 1, c: 2, d: {e: 3}}, f: {g: {h: 4, i: {x: 42}, j: {k: 6, l: 7}}}, m: 8}\n     */\n    var assocPath = function () {\n        var setParts = function (parts, val, obj) {\n            if (parts.length === 1) {\n                return assoc(parts[0], val, obj);\n            }\n            var current = obj[parts[0]];\n            return assoc(parts[0], setParts(_slice(parts, 1), val, is(Object, current) ? current : {}), obj);\n        };\n        return function (path, val, obj) {\n            var length = arguments.length;\n            if (length === 0) {\n                throw _noArgsException();\n            }\n            var parts = split('.', path);\n            var fn = _curry2(function (val, obj) {\n                return setParts(parts, val, obj);\n            });\n            switch (length) {\n            case 1:\n                return fn;\n            case 2:\n                return fn(val);\n            default:\n                return fn(val, obj);\n            }\n        };\n    }();\n\n    /**\n     * `chain` maps a function over a list and concatenates the results.\n     * This implementation is compatible with the\n     * Fantasy-land Chain spec, and will work with types that implement that spec.\n     * `chain` is also known as `flatMap` in some libraries\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig (a -> [b]) -> [a] -> [b]\n     * @param {Function} fn\n     * @param {Array} list\n     * @return {Array}\n     * @example\n     *\n     *      var duplicate = function(n) {\n     *        return [n, n];\n     *      };\n     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n     *\n     */\n    var chain = _curry2(_checkForMethod('chain', function chain(f, list) {\n        return unnest(_map(f, list));\n    }));\n\n    /**\n     * The character at the nth position in a String:\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig Number -> String -> String\n     * @param {Number} index An integer between 0 and the length of the string.\n     * @param {String} str The string to extract a char from\n     * @return {String} The character at `index` of `str`.\n     * @see R.invoker\n     * @example\n     *\n     *      R.charAt(8, 'abcdefghijklm'); //=> 'i'\n     */\n    var charAt = invoker(1, 'charAt');\n\n    /**\n     * The ascii code of the character at the nth position in a String:\n     *\n     * @func\n     * @memberOf R\n     * @category String\n     * @sig Number -> String -> Number\n     * @param {Number} index An integer between 0 and the length of the string.\n     * @param {String} str The string to extract a charCode from\n     * @return {Number} The code of the character at `index` of `str`.\n     * @see R.invoker\n     * @example\n     *\n     *      R.charCodeAt(8, 'abcdefghijklm'); //=> 105\n     *      // (... 'a' ~ 97, 'b' ~ 98, ... 'i' ~ 105)\n     */\n    var charCodeAt = invoker(1, 'charCodeAt');\n\n    /**\n     * Turns a list of Functors into a Functor of a list, applying\n     * a mapping function to the elements of the list along the way.\n     *\n     * Note: `commuteMap` may be more useful to convert a list of non-Array Functors (e.g.\n     * Maybe, Either, etc.) to Functor of a list.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @see R.commute\n     * @sig (a -> (b -> c)) -> (x -> [x]) -> [[*]...]\n     * @param {Function} fn The transformation function\n     * @param {Function} of A function that returns the data type to return\n     * @param {Array} list An Array (or other Functor) of Arrays (or other Functors)\n     * @return {Array}\n     * @example\n     *\n     *     var plus10map = R.map(function(x) { return x + 10; });\n     *     var as = [[1], [3, 4]];\n     *     R.commuteMap(R.map(function(x) { return x + 10; }), R.of, as); //=> [[11, 13], [11, 14]]\n     *\n     *     var bs = [[1, 2], [3]];\n     *     R.commuteMap(plus10map, R.of, bs); //=> [[11, 13], [12, 13]]\n     *\n     *     var cs = [[1, 2], [3, 4]];\n     *     R.commuteMap(plus10map, R.of, cs); //=> [[11, 13], [12, 13], [11, 14], [12, 14]]\n     *\n     */\n    var commuteMap = _curry3(function commuteMap(fn, of, list) {\n        function consF(acc, ftor) {\n            return _ap(_map(append, fn(ftor)), acc);\n        }\n        return _foldl(consF, of([]), list);\n    });\n\n    /**\n     * Returns a new list consisting of the elements of the first list followed by the elements\n     * of the second.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} list1 The first list to merge.\n     * @param {Array} list2 The second set to merge.\n     * @return {Array} A new array consisting of the contents of `list1` followed by the\n     *         contents of `list2`. If, instead of an Array for `list1`, you pass an\n     *         object with a `concat` method on it, `concat` will call `list1.concat`\n     *         and pass it the value of `list2`.\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *         be curried right by explicitly passing `R.__` for its first argument.\n     *\n     * @example\n     *\n     *      R.concat([], []); //=> []\n     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     *      R.concat('ABC', 'DEF'); // 'ABCDEF'\n     *\n     *      // operator-style:\n     *      R.concat(R.__)([4, 5, 6], [1, 2, 3]); //=> [1, 2, 3, 4, 5, 6]\n     *\n     */\n    var concat = op(function (set1, set2) {\n        if (_isArray(set2)) {\n            return _concat(set1, set2);\n        } else if (_hasMethod('concat', set1)) {\n            return set1.concat(set2);\n        } else {\n            throw new TypeError('can\\'t concat ' + typeof set1);\n        }\n    });\n\n    /**\n     * Returns `true` if the specified item is somewhere in the list, `false` otherwise.\n     * Equivalent to `indexOf(a)(list) > -1`. Uses strict (`===`) equality checking.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> [a] -> Boolean\n     * @param {Object} a The item to compare against.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the item is in the list, `false` otherwise.\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *       be curried right by explicitly passing `R.__` for its first argument.\n     *\n     * @example\n     *\n     *      R.contains(3)([1, 2, 3]); //=> true\n     *      R.contains(4)([1, 2, 3]); //=> false\n     *      R.contains({})([{}, {}]); //=> false\n     *      var obj = {};\n     *      R.contains(obj)([{}, obj, {}]); //=> true\n     *\n     *      // operator-style\n     *      R.contains(R.__)([1, 2, 3], 3) //=> true\n     *\n     */\n    var contains = op(_contains);\n\n    /**\n     * Counts the elements of a list according to how many match each value\n     * of a key generated by the supplied function. Returns an object\n     * mapping the keys produced by `fn` to the number of occurrences in\n     * the list. Note that all keys are coerced to strings because of how\n     * JavaScript objects work.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig (a -> String) -> [a] -> {*}\n     * @param {Function} fn The function used to map values to keys.\n     * @param {Array} list The list to count elements from.\n     * @return {Object} An object mapping keys to number of occurrences in the list.\n     * @example\n     *\n     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];\n     *      var letters = R.split('', 'abcABCaaaBBc');\n     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}\n     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}\n     */\n    var countBy = _curry2(function countBy(fn, list) {\n        var counts = {};\n        var len = list.length;\n        var idx = -1;\n        while (++idx < len) {\n            var key = fn(list[idx]);\n            counts[key] = (has(key, counts) ? counts[key] : 0) + 1;\n        }\n        return counts;\n    });\n\n    /**\n     * Creates a new version of `fn` that, when invoked, will return either:\n     * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of\n     * `fn`'s expected arguments have not yet been provided\n     * - `fn`'s result if all of its expected arguments have been provided\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (* -> a) -> (* -> a)\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curryN\n     * @example\n     *\n     *      var addFourNumbers = function(a, b, c, d) {\n     *        return a + b + c + d;\n     *      };\n     *\n     *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4);//=> 10\n     */\n    var curry = function curry(fn) {\n        return curryN(fn.length, fn);\n    };\n\n    /**\n     * Divides two numbers. Equivalent to `a / b`.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a / b`.\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `undefined` for its first argument.\n     * @example\n     *\n     *      R.divide(71, 100); //=> 0.71\n     *\n     *      var half = R.divide(R.__, 2);\n     *      half(42); //=> 21\n     *\n     *      var reciprocal = R.divide(1);\n     *      reciprocal(4);   //=> 0.25\n     */\n    var divide = op(function divide(a, b) {\n        return a / b;\n    });\n\n    /**\n     * Performs a deep test on whether two items are equal.\n     * Equality implies the two items are semmatically equivalent.\n     * Cyclic structures are handled as expected\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig a -> b -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      var o = {};\n     *      R.eqDeep(o, o); //=> true\n     *      R.eqDeep(o, {}); //=> true\n     *      R.eqDeep(1, 1); //=> true\n     *      R.eqDeep(1, '1'); //=> false\n     *\n     *      var a = {}; a.v = a;\n     *      var b = {}; b.v = b;\n     *      R.eqDeep(a, b); //=> true\n     */\n    var eqDeep = _curry2(function eqDeep(a, b) {\n        return _eqDeep(a, b, [], []);\n    });\n\n    /**\n     * Creates a new object by evolving a shallow copy of `object`, according to the\n     * `transformation` functions.  All non-primitive properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: (v -> v)} -> {k: v} -> {k: v}\n     * @param {Object} transformations The object specifying transformation functions to apply\n     *        to the object.\n     * @param {Object} object The object to be transformed.\n     * @return {Object} The transformed object.\n     * @example\n     *\n     *      R.evolve({ elapsed: R.add(1), remaining: R.add(-1) }, { name: 'Tomato', elapsed: 100, remaining: 1400 }); //=> { name: 'Tomato', elapsed: 101, remaining: 1399 }\n     */\n    var evolve = _curry2(function evolve(transformations, object) {\n        return _extend(_extend({}, object), mapObjIndexed(function (fn, key) {\n            return fn(object[key]);\n        }, transformations));\n    });\n\n    /**\n     * Returns a list of function names of object's own functions\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {*} -> [String]\n     * @param {Object} obj The objects with functions in it\n     * @return {Array} A list of the object's own properties that map to functions.\n     * @example\n     *\n     *      R.functions(R); // returns list of ramda's own function names\n     *\n     *      var F = function() { this.x = function(){}; this.y = 1; }\n     *      F.prototype.z = function() {};\n     *      F.prototype.a = 100;\n     *      R.functions(new F()); //=> [\"x\"]\n     */\n    var functions = _functionsWith(keys);\n\n    /**\n     * Returns true if the first parameter is greater than the second.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean} a > b\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `undefined` for its first argument.\n     * @example\n     *\n     *      R.gt(2, 6); //=> false\n     *      R.gt(2, 0); //=> true\n     *      R.gt(2, 2); //=> false\n     *      R.gt(R.__, 2)(10); //=> true\n     *      R.gt(2)(10); //=> false\n     */\n    var gt = op(_gt);\n\n    /**\n     * Returns true if the first parameter is greater than or equal to the second.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean} a >= b\n     * @note Operator: this is right-curried by default, but can be called via sections\n     * @example\n     *\n     *      R.gte(2, 6); //=> false\n     *      R.gte(2, 0); //=> true\n     *      R.gte(2, 2); //=> true\n     *      R.gte(R.__, 6)(2); //=> false\n     *      R.gte(2)(0); //=> true\n     *      R.gte(R.__)(1, 2); //=> true\n     */\n    var gte = op(function gte(a, b) {\n        return a >= b;\n    });\n\n    /**\n     * Returns the first element in a list.\n     * In some libraries this function is named `first`.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> a\n     * @param {Array} [list=[]] The array to consider.\n     * @return {*} The first element of the list, or `undefined` if the list is empty.\n     * @example\n     *\n     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'\n     */\n    var head = nth(0);\n\n    /**\n     * Returns all but the last element of a list.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} [list=[]] The array to consider.\n     * @return {Array} A new array containing all but the last element of the input list, or an\n     *         empty list if the input list is empty.\n     * @example\n     *\n     *      R.init(['fi', 'fo', 'fum']); //=> ['fi', 'fo']\n     */\n    var init = slice(0, -1);\n\n    /* global R */\n    /**\n     * Expose the functions from ramda as properties of another object.\n     * If the provided object is the global object then the ramda\n     * functions become global functions.\n     * Warning: This function *will* mutate the object provided.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig -> {*} -> {*}\n     * @param {Object} obj The object to attach ramda functions\n     * @return {Object} a reference to the mutated object.\n     * @example\n     *\n     *      var x = {}\n     *      R.installTo(x); // x now contains ramda functions\n     *      R.installTo(this); // add ramda functions to `this` object\n     */\n    var installTo = function (obj) {\n        return _extend(obj, R);\n    };\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @see R.intersectionWith\n     * @return {Array} The list of elements found in both `list1` and `list2`.\n     * @example\n     *\n     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]\n     */\n    var intersection = _curry2(function intersection(list1, list2) {\n        return uniq(_filter(flip(_contains)(list1), list2));\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists.  Duplication is determined according\n     * to the value returned by applying the supplied predicate to two list\n     * elements.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n     * @param {Function} pred A predicate function that determines whether\n     *        the two supplied elements are equal.\n     * @param {Array} list1 One list of items to compare\n     * @param {Array} list2 A second list of items to compare\n     * @see R.intersection\n     * @return {Array} A new list containing those elements common to both lists.\n     * @example\n     *\n     *      var buffaloSpringfield = [\n     *        {id: 824, name: 'Richie Furay'},\n     *        {id: 956, name: 'Dewey Martin'},\n     *        {id: 313, name: 'Bruce Palmer'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *      var csny = [\n     *        {id: 204, name: 'David Crosby'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 539, name: 'Graham Nash'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *\n     *      var sameId = function(o1, o2) {return o1.id === o2.id;};\n     *\n     *      R.intersectionWith(sameId, buffaloSpringfield, csny);\n     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]\n     */\n    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {\n        var results = [], idx = -1;\n        while (++idx < list1.length) {\n            if (_containsWith(pred, list1[idx], list2)) {\n                results[results.length] = list1[idx];\n            }\n        }\n        return uniqWith(pred, results);\n    });\n\n    /**\n     * Same as R.invertObj, however this accounts for objects\n     * with duplicate values by putting the values into an\n     * array.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {s: x} -> {x: [ s, ... ]}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object with keys\n     * in an array.\n     * @example\n     *\n     *      var raceResultsByFirstName = {\n     *        first: 'alice',\n     *        second: 'jake',\n     *        third: 'alice',\n     *      };\n     *      R.invert(raceResultsByFirstName);\n     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }\n     *\n     */\n    var invert = function invert(obj) {\n        var props = keys(obj), len = props.length, idx = -1, out = {};\n        while (++idx < len) {\n            var key = props[idx], val = obj[key];\n            out[val] = out[val] || [];\n            out[val].push(key);\n        }\n        return out;\n    };\n\n    /**\n     * Returns a new object with the keys of the given object\n     * as values, and the values of the given object as keys.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {s: x} -> {x: s}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object\n     * @example\n     *\n     *      var raceResults = {\n     *        first: 'alice',\n     *        second: 'jake'\n     *      };\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': 'first', 'jake':'second' }\n     *\n     *      // Alternatively:\n     *      var raceResults = ['alice', 'jake'];\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': '0', 'jake':'1' }\n     */\n    var invertObj = function invertObj(obj) {\n        var props = keys(obj), len = props.length, idx = -1, out = {};\n        while (++idx < len) {\n            var key = props[idx];\n            out[obj[key]] = key;\n        }\n        return out;\n    };\n\n    /**\n     * Returns the last element from a list.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig [a] -> a\n     * @param {Array} [list=[]] The array to consider.\n     * @return {*} The last element of the list, or `undefined` if the list is empty.\n     * @example\n     *\n     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n     */\n    var last = nth(-1);\n\n    /**\n     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that many\n     * lists (or other Functors).\n     *\n     * @func\n     * @memberOf R\n     * @see R.lift\n     * @category Function\n     * @sig Number -> (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The function `fn` applicable to mappable objects.\n     * @example\n     *\n     *     var madd3 = R.liftN(3, R.curryN(3, function() {\n     *         return R.foldl(R.add, 0, arguments);\n     *     }));\n     *     madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     */\n    var liftN = _curry2(function liftN(arity, fn) {\n        var lifted = curryN(arity, fn);\n        if (arguments.length === 0) {\n            throw _noArgsException();\n        }\n        return curryN(arity, function () {\n            return _foldl(_ap, _map(lifted, arguments[0]), _slice(arguments, 1));\n        });\n    });\n\n    /**\n     * Returns true if the first parameter is less than the second.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean} a < b\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `undefined` for its first argument.\n     * @example\n     *\n     *      R.lt(2, 6); //=> true\n     *      R.lt(2, 0); //=> false\n     *      R.lt(2, 2); //=> false\n     *      R.lt(5)(10); //=> true\n     *      R.lt(R.__, 5)(10); //=> false // right-sectioned currying\n     */\n    var lt = op(_lt);\n\n    /**\n     * Returns true if the first parameter is less than or equal to the second.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean} a <= b\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `R.__` for its first argument.\n     * @example\n     *\n     *      R.lte(2, 6); //=> true\n     *      R.lte(2, 0); //=> false\n     *      R.lte(2, 2); //=> true\n     *      R.lte(R.__, 2)(1); //=> true\n     *      R.lte(2)(10); //=> true\n     *      R.lte(R.__)(5, 4) // => true\n     */\n    var lte = op(function lte(a, b) {\n        return a <= b;\n    });\n\n    /**\n     * mathMod behaves like the modulo operator should mathematically, unlike the `%`\n     * operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n     * when the modulus is zero or negative.\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} m The dividend.\n     * @param {Number} p the modulus.\n     * @return {Number} The result of `b mod a`.\n     * @see R.moduloBy\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `R.__` for its first argument.\n     * @example\n     *\n     *      R.mathMod(-17, 5);  //=> 3\n     *      R.mathMod(17, 5);   //=> 2\n     *      R.mathMod(17, -5);  //=> NaN\n     *      R.mathMod(17, 0);   //=> NaN\n     *      R.mathMod(17.2, 5); //=> NaN\n     *      R.mathMod(17, 5.3); //=> NaN\n     *\n     *      var clock = R.mathMod(R.__, 12);\n     *      clock(15); //=> 3\n     *      clock(24); //=> 0\n     *\n     *      var seventeenMod = R.mathMod(17);\n     *      seventeenMod(3);  //=> 2\n     *      seventeenMod(4);  //=> 1\n     *      seventeenMod(10); //=> 7\n     */\n    var mathMod = op(function mathMod(m, p) {\n        if (!_isInteger(m)) {\n            return NaN;\n        }\n        if (!_isInteger(p) || p < 1) {\n            return NaN;\n        }\n        return (m % p + p) % p;\n    });\n\n    /**\n     * Create a new object with the own properties of a\n     * merged with the own properties of object b.\n     * This function will *not* mutate passed-in objects.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig {k: v} -> {k: v} -> {k: v}\n     * @param {Object} a source object\n     * @param {Object} b object with higher precedence in output\n     * @return {Object} The destination object.\n     * @example\n     *\n     *      R.mixin({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n     *      //=> { 'name': 'fred', 'age': 40 }\n     */\n    var mixin = _curry2(function mixin(a, b) {\n        return _extend(_extend({}, a), b);\n    });\n\n    /**\n     * Divides the second parameter by the first and returns the remainder.\n     * Note that this functions preserves the JavaScript-style behavior for\n     * modulo. For mathematical modulo see `mathMod`\n     *\n     * @func\n     * @memberOf R\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The value to the divide.\n     * @param {Number} b The pseudo-modulus\n     * @return {Number} The result of `b % a`.\n     * @note Operator: Since this is a non-commutative infix operator converted to prefix, it can\n     *                 be curried right by explicitly passing `R.__` for its first argument.\n     * @see R.mathMod\n     * @example\n     *\n     *      R.modulo(17, 3); //=> 2\n     *      // JS behavior:\n     *      R.modulo(-17, 3); //=> -2\n     *      R.modulo(17, -3); //=> 2\n     *\n     *      var isOdd = R.modulo(R.__, 2);\n     *      isOdd(42); //=> 0\n     *      isOdd(21); //=> 1\n     */\n    var modulo = op(function modulo(a, b) {\n        return a % b;\n    });\n\n    /**\n     * Retrieve a nested path on an object separated by periods\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @sig String -> {*} -> *\n     * @param {String} path The dot path to use.\n     * @return {*} The data at `path`.\n     * @example\n     *\n     *      R.path('a.b', {a: {b: 2}}); //=> 2\n     */\n    var path = pathOn('.');\n\n    /**\n     * Returns a fixed list of size `n` containing a specified identical value.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @sig a -> n -> [a]\n     * @param {*} value The value to repeat.\n     * @param {Number} n The desired size of the output list.\n     * @return {Array} A new array containing `n` `value`s.\n     * @example\n     *\n     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n     *\n     *      var obj = {};\n     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]\n     *      repeatedObjs[0] === repeatedObjs[1]; //=> true\n     */\n    var repeat = _curry2(function repeat(value, n) {\n        return times(always(value), n);\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the\n     * elements of each list.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @example\n     *\n     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n     */\n    var union = _curry2(compose(uniq, _concat));\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is\n     * determined according to the value returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @category Relation\n     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @see R.union\n     * @example\n     *\n     *      function cmp(x, y) { return x.a === y.a; }\n     *      var l1 = [{a: 1}, {a: 2}];\n     *      var l2 = [{a: 1}, {a: 4}];\n     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n     */\n    var unionWith = _curry3(function unionWith(pred, list1, list2) {\n        return uniqWith(pred, _concat(list1, list2));\n    });\n\n    /**\n     * Accepts a function `fn` and any number of transformer functions and returns a new\n     * function. When the new function is invoked, it calls the function `fn` with parameters\n     * consisting of the result of calling each supplied handler on successive arguments to the\n     * new function.\n     *\n     * If more arguments are passed to the returned function than transformer functions, those\n     * arguments are passed directly to `fn` as additional parameters. If you expect additional\n     * arguments that don't need to be transformed, although you can ignore them, it's best to\n     * pass an identity function so that the new function reports the correct arity.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig ((* -> *), (* -> *)...) -> (* -> *)\n     * @param {Function} fn The function to wrap.\n     * @param {...Function} transformers A variable number of transformer functions\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      // Example 1:\n     *\n     *      // Number -> [Person] -> [Person]\n     *      var byAge = R.useWith(R.filter, R.propEq('age'), R.identity);\n     *\n     *      var kids = [\n     *          {name: 'Abbie', age: 6},\n     *          {name: 'Brian', age: 5},\n     *          {name: 'Chris', age: 6},\n     *          {name: 'David', age: 4},\n     *          {name: 'Ellie', age: 5}\n     *      ];\n     *\n     *      byAge(5, kids); //=> [{name: 'Brian', age: 5}, {name: 'Ellie', age: 5}]\n     *\n     *\n     *      // Example 2:\n     *\n     *      var double = function(y) { return y * 2; };\n     *      var square = function(x) { return x * x; };\n     *      var add = function(a, b) { return a + b; };\n     *      // Adds any number of arguments together\n     *      var addAll = function() {\n     *        return R.foldl(add, 0, arguments);\n     *      };\n     *\n     *      // Basic example\n     *      var addDoubleAndSquare = R.useWith(addAll, double, square);\n     *\n     *      //≅ addAll(double(10), square(5));\n     *      addDoubleAndSquare(10, 5); //=> 45\n     *\n     *      // Example of passing more arguments than transformers\n     *      //≅ addAll(double(10), square(5), 100);\n     *      addDoubleAndSquare(10, 5, 100); //=> 145\n     *\n     *      // If there are extra _expected_ arguments that don't need to be transformed, although\n     *      // you can ignore them, it might be best to pass in the identity function so that the new\n     *      // function correctly reports arity.\n     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);\n     *      // addDoubleAndSquareWithExtraParams.length //=> 3\n     *      //≅ addAll(double(10), square(5), R.identity(100));\n     *      addDoubleAndSquare(10, 5, 100); //=> 145\n     */\n    /*, transformers */\n    var useWith = function useWith(fn) {\n        var transformers = _slice(arguments, 1);\n        var tlen = transformers.length;\n        return curry(arity(tlen, function () {\n            var args = [], idx = -1;\n            while (++idx < tlen) {\n                args[args.length] = transformers[idx](arguments[idx]);\n            }\n            return fn.apply(this, args.concat(_slice(arguments, tlen)));\n        }));\n    };\n\n    /**\n     * Turns a list of Functors into a Functor of a list.\n     *\n     * Note: `commute` may be more useful to convert a list of non-Array Functors (e.g.\n     * Maybe, Either, etc.) to Functor of a list.\n     *\n     * @func\n     * @memberOf R\n     * @category List\n     * @see R.commuteMap\n     * @sig (x -> [x]) -> [[*]...]\n     * @param {Function} of A function that returns the data type to return\n     * @param {Array} list An Array (or other Functor) of Arrays (or other Functors)\n     * @return {Array}\n     * @example\n     *\n     *     var as = [[1], [3, 4]];\n     *     R.commute(R.of, as); //=> [[1, 3], [1, 4]]\n     *\n     *     var bs = [[1, 2], [3]];\n     *     R.commute(R.of, bs); //=> [[1, 3], [2, 3]]\n     *\n     *     var cs = [[1, 2], [3, 4]];\n     *     R.commute(R.of, cs); //=> [[1, 3], [2, 3], [1, 4], [2, 4]]\n     */\n    var commute = commuteMap(map(identity));\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called with the same\n     * arguments and returns the same type. The arity of the function returned is specified\n     * to allow using variadic constructor functions.\n     *\n     * NOTE: Does not work with some built-in objects such as Date.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig Number -> (* -> {*}) -> (* -> {*})\n     * @param {Number} n The arity of the constructor function.\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Variadic constructor function\n     *      var Widget = function() {\n     *        this.children = Array.prototype.slice.call(arguments);\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = {\n     *        // ...\n     *      };\n     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets\n     */\n    var constructN = _curry2(function constructN(n, Fn) {\n        var f = function () {\n            var Temp = function () {\n                }, inst, ret;\n            Temp.prototype = Fn.prototype;\n            inst = new Temp();\n            ret = Fn.apply(inst, arguments);\n            return Object(ret) === ret ? ret : inst;\n        };\n        return n > 1 ? curry(nAry(n, f)) : f;\n    });\n\n    /**\n     * \"lifts\" a function of arity > 1 so that it may \"map over\" an Array or\n     * other Functor.\n     *\n     * @func\n     * @memberOf R\n     * @see R.liftN\n     * @category Function\n     * @sig (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The function `fn` applicable to mappable objects.\n     * @example\n     *\n     *     var madd3 = R.lift(R.curryN(3, function(a, b, c) {\n     *         return a + b + c;\n     *     }));\n     *     madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     *\n     *     var madd5 = R.lift(R.curryN(5, function(a, b, c, d, e) {\n     *         return a + b + c + d + e;\n     *     }));\n     *     madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n     */\n    var lift = function lift(fn) {\n        if (arguments.length === 0) {\n            throw _noArgsException();\n        }\n        return liftN(fn.length, fn);\n    };\n\n    /**\n     * Reasonable analog to SQL `select` statement.\n     *\n     * @func\n     * @memberOf R\n     * @category Object\n     * @category Relation\n     * @sig [k] -> [{k: v}] -> [{k: v}]\n     * @param {Array} props The property names to project\n     * @param {Array} objs The objects to query\n     * @return {Array} An array of objects with just the `props` properties.\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};\n     *      var kids = [abby, fred];\n     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n     */\n    // passing `identity` gives correct arity\n    var project = useWith(_map, pickAll, identity);\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called with the same\n     * arguments and returns the same type.\n     *\n     * NOTE: Does not work with some built-in objects such as Date.\n     *\n     * @func\n     * @memberOf R\n     * @category Function\n     * @sig (* -> {*}) -> (* -> {*})\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Constructor function\n     *      var Widget = function(config) {\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = {\n     *        // ...\n     *      };\n     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets\n     */\n    var construct = function construct(Fn) {\n        return constructN(Fn.length, Fn);\n    };\n\n    var R = {\n        F: F,\n        I: I,\n        T: T,\n        __: __,\n        add: add,\n        all: all,\n        allPass: allPass,\n        always: always,\n        and: and,\n        any: any,\n        anyPass: anyPass,\n        ap: ap,\n        append: append,\n        appendTo: appendTo,\n        apply: apply,\n        arity: arity,\n        assoc: assoc,\n        assocPath: assocPath,\n        binary: binary,\n        bind: bind,\n        call: call,\n        chain: chain,\n        charAt: charAt,\n        charCodeAt: charCodeAt,\n        clone: clone,\n        commute: commute,\n        commuteMap: commuteMap,\n        comparator: comparator,\n        compose: compose,\n        concat: concat,\n        cond: cond,\n        construct: construct,\n        constructN: constructN,\n        contains: contains,\n        containsWith: containsWith,\n        converge: converge,\n        countBy: countBy,\n        createMapEntry: createMapEntry,\n        curry: curry,\n        curryN: curryN,\n        dec: dec,\n        difference: difference,\n        differenceWith: differenceWith,\n        divide: divide,\n        drop: drop,\n        dropWhile: dropWhile,\n        empty: empty,\n        eq: eq,\n        eqDeep: eqDeep,\n        eqProps: eqProps,\n        evolve: evolve,\n        filter: filter,\n        filterIndexed: filterIndexed,\n        find: find,\n        findIndex: findIndex,\n        findLast: findLast,\n        findLastIndex: findLastIndex,\n        flatten: flatten,\n        flip: flip,\n        foldl: foldl,\n        foldlIndexed: foldlIndexed,\n        foldr: foldr,\n        foldrIndexed: foldrIndexed,\n        forEach: forEach,\n        forEachIndexed: forEachIndexed,\n        fromPairs: fromPairs,\n        func: func,\n        functions: functions,\n        functionsIn: functionsIn,\n        get: get,\n        groupBy: groupBy,\n        gt: gt,\n        gte: gte,\n        has: has,\n        hasIn: hasIn,\n        head: head,\n        identity: identity,\n        ifElse: ifElse,\n        inc: inc,\n        indexOf: indexOf,\n        init: init,\n        insert: insert,\n        insertAll: insertAll,\n        installTo: installTo,\n        intersection: intersection,\n        intersectionWith: intersectionWith,\n        invert: invert,\n        invertObj: invertObj,\n        invoker: invoker,\n        is: is,\n        isArrayLike: isArrayLike,\n        isEmpty: isEmpty,\n        isNil: isNil,\n        isSet: isSet,\n        join: join,\n        keys: keys,\n        keysIn: keysIn,\n        lPartial: lPartial,\n        last: last,\n        lastIndexOf: lastIndexOf,\n        length: length,\n        lens: lens,\n        lift: lift,\n        liftN: liftN,\n        lt: lt,\n        lte: lte,\n        map: map,\n        mapAccumL: mapAccumL,\n        mapAccumR: mapAccumR,\n        mapIndexed: mapIndexed,\n        mapObj: mapObj,\n        mapObjIndexed: mapObjIndexed,\n        match: match,\n        mathMod: mathMod,\n        max: max,\n        maxBy: maxBy,\n        memoize: memoize,\n        min: min,\n        minBy: minBy,\n        mixin: mixin,\n        modulo: modulo,\n        multiply: multiply,\n        nAry: nAry,\n        negate: negate,\n        not: not,\n        nth: nth,\n        nthArg: nthArg,\n        of: of,\n        omit: omit,\n        once: once,\n        op: op,\n        or: or,\n        pCompose: pCompose,\n        pPipe: pPipe,\n        partition: partition,\n        path: path,\n        pathEq: pathEq,\n        pathOn: pathOn,\n        pick: pick,\n        pickAll: pickAll,\n        pickBy: pickBy,\n        pipe: pipe,\n        pluck: pluck,\n        prepend: prepend,\n        prependTo: prependTo,\n        product: product,\n        project: project,\n        prop: prop,\n        propEq: propEq,\n        propOf: propOf,\n        propOr: propOr,\n        props: props,\n        rPartial: rPartial,\n        range: range,\n        reject: reject,\n        rejectIndexed: rejectIndexed,\n        remove: remove,\n        repeat: repeat,\n        replace: replace,\n        reverse: reverse,\n        scanl: scanl,\n        slice: slice,\n        sort: sort,\n        sortBy: sortBy,\n        split: split,\n        strIndexOf: strIndexOf,\n        strLastIndexOf: strLastIndexOf,\n        substring: substring,\n        substringFrom: substringFrom,\n        substringTo: substringTo,\n        subtract: subtract,\n        sum: sum,\n        tail: tail,\n        take: take,\n        takeWhile: takeWhile,\n        tap: tap,\n        times: times,\n        toLower: toLower,\n        toPairs: toPairs,\n        toPairsIn: toPairsIn,\n        toUpper: toUpper,\n        trim: trim,\n        type: type,\n        unapply: unapply,\n        unary: unary,\n        unfoldr: unfoldr,\n        union: union,\n        unionWith: unionWith,\n        uniq: uniq,\n        uniqWith: uniqWith,\n        unnest: unnest,\n        useWith: useWith,\n        values: values,\n        valuesIn: valuesIn,\n        where: where,\n        wrap: wrap,\n        xprod: xprod,\n        zip: zip,\n        zipObj: zipObj,\n        zipWith: zipWith\n    };\n\n    /* TEST_ENTRY_POINT */\n\n    if (typeof exports === 'object') {\n        module.exports = R;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return R; });\n    } else {\n        this.R = R;\n    }\n\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ramda/dist/ramda.js\n ** module id = 10\n ** module chunks = 0 1 2 3\n **/","\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co['default'] = co.co = co;\n\n/**\n * Wrap the given generator `fn` into a\n * function that returns a promise.\n * This is a separate function so that\n * every `co()` call doesn't create a new,\n * unnecessary closure.\n *\n * @param {GeneratorFunction} fn\n * @return {Function}\n * @api public\n */\n\nco.wrap = function (fn) {\n  return function () {\n    return co.call(this, fn.apply(this, arguments));\n  };\n};\n\n/**\n * Execute the generator function or a generator\n * and return a promise.\n *\n * @param {Function} fn\n * @return {Function}\n * @api public\n */\n\nfunction co(gen) {\n  var ctx = this;\n  if (typeof gen === 'function') gen = gen.call(this);\n  // we wrap everything in a promise to avoid promise chaining,\n  // which leads to memory leak errors.\n  // see https://github.com/tj/co/issues/180\n  return new Promise(function(resolve, reject) {\n    onFulfilled();\n\n    /**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     */\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     */\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     */\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n  });\n}\n\n/**\n * Convert a `yield`ed value into a promise.\n *\n * @param {Mixed} obj\n * @return {Promise}\n * @api private\n */\n\nfunction toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj;\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  if (isObject(obj)) return objectToPromise.call(this, obj);\n  return obj;\n}\n\n/**\n * Convert a thunk to a promise.\n *\n * @param {Function}\n * @return {Promise}\n * @api private\n */\n\nfunction thunkToPromise(fn) {\n  var ctx = this;\n  return new Promise(function (resolve, reject) {\n    fn.call(ctx, function (err, res) {\n      if (err) return reject(err);\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n      resolve(res);\n    });\n  });\n}\n\n/**\n * Convert an array of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Array} obj\n * @return {Promise}\n * @api private\n */\n\nfunction arrayToPromise(obj) {\n  return Promise.all(obj.map(toPromise, this));\n}\n\n/**\n * Convert an object of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Object} obj\n * @return {Promise}\n * @api private\n */\n\nfunction objectToPromise(obj){\n  var results = new obj.constructor();\n  var keys = Object.keys(obj);\n  var promises = [];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var promise = toPromise.call(this, obj[key]);\n    if (promise && isPromise(promise)) defer(promise, key);\n    else results[key] = obj[key];\n  }\n  return Promise.all(promises).then(function () {\n    return results;\n  });\n\n  function defer(promise, key) {\n    // predefine the key in the result\n    results[key] = undefined;\n    promises.push(promise.then(function (res) {\n      results[key] = res;\n    }));\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\nfunction isGeneratorFunction(obj) {\n  var constructor = obj.constructor;\n  var proto = constructor.prototype;\n  var name = constructor.displayName || constructor.name;\n  var nameLooksRight = 'GeneratorFunction' == name;\n  var methodsLooksRight = 'function' == typeof proto.next &&\n                          'function' == typeof proto.throw;\n  return nameLooksRight || methodsLooksRight;\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return Object == val.constructor;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/co/index.js\n ** module id = 11\n ** module chunks = 0 1 2 3 7\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 13\n ** module chunks = 0 1 2 3 7\n **/","\nexport function fixed(total, progress) {\n  if (!progress) return () => {}\n  let loaded = 0\n  progress.report(0, total)\n  return (extra) => progress.report(++loaded, total, extra)\n}\n\nexport function wrapPromise(progress, f) {\n  let current = 0\n  let total = 0\n  return function() {\n    progress.report(current, ++total)\n    return Promise.resolve(f.apply(this, arguments))\n      .tap(() => progress.report(++current, total))\n  }\n}\n\nexport function bind(from, to) {\n  return from.watch(() => to.report(from.current, from.total, from.extra))\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./progress/utils.js\n **/","\nexport default readBlob\n\nexport function readBlob(blob) {\n  return {\n    as(type) {\n      return new Promise(function(resolve, reject) {\n        let reader = new FileReader()\n        reader.onload = function() {\n          resolve(reader.result)\n        }\n        reader.onerror = function() {\n          reject(new Error('Unable to read from Blob'))\n        }\n        switch (type) {\n        case 'arraybuffer':\n          reader.readAsArrayBuffer(blob)\n          break\n        case 'text':\n          reader.readAsText(blob)\n          break\n        }\n      })\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./read-blob/index.js\n **/","var window = require('global/window');\n\nvar Context = window.AudioContext || window.webkitAudioContext;\nif (Context) module.exports = new Context;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/audio-context/index.js\n ** module id = 19\n ** module chunks = 0 1 3 7\n **/","\"use strict\";\n\nif (global._babelPolyfill) {\n  throw new Error(\"only one instance of babel/polyfill is allowed\");\n}\nglobal._babelPolyfill = true;\n\nrequire(\"core-js/shim\");\nrequire(\"regenerator-babel/runtime\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/babel-core/lib/babel/polyfill.js\n ** module id = 20\n ** module chunks = 0 1 2 3 7\n **/","/**\n * Core.js 0.5.4\n * https://github.com/zloirock/core-js\n * License: http://rock.mit-license.org\n * © 2015 Denis Pushkarev\n */\n!function(global, framework, undefined){\n'use strict';\n\n/******************************************************************************\n * Module : common                                                            *\n ******************************************************************************/\n\n  // Shortcuts for [[Class]] & property names\r\nvar OBJECT          = 'Object'\r\n  , FUNCTION        = 'Function'\r\n  , ARRAY           = 'Array'\r\n  , STRING          = 'String'\r\n  , NUMBER          = 'Number'\r\n  , REGEXP          = 'RegExp'\r\n  , DATE            = 'Date'\r\n  , MAP             = 'Map'\r\n  , SET             = 'Set'\r\n  , WEAKMAP         = 'WeakMap'\r\n  , WEAKSET         = 'WeakSet'\r\n  , SYMBOL          = 'Symbol'\r\n  , PROMISE         = 'Promise'\r\n  , MATH            = 'Math'\r\n  , ARGUMENTS       = 'Arguments'\r\n  , PROTOTYPE       = 'prototype'\r\n  , CONSTRUCTOR     = 'constructor'\r\n  , TO_STRING       = 'toString'\r\n  , TO_STRING_TAG   = TO_STRING + 'Tag'\r\n  , TO_LOCALE       = 'toLocaleString'\r\n  , HAS_OWN         = 'hasOwnProperty'\r\n  , FOR_EACH        = 'forEach'\r\n  , ITERATOR        = 'iterator'\r\n  , FF_ITERATOR     = '@@' + ITERATOR\r\n  , PROCESS         = 'process'\r\n  , CREATE_ELEMENT  = 'createElement'\r\n  // Aliases global objects and prototypes\r\n  , Function        = global[FUNCTION]\r\n  , Object          = global[OBJECT]\r\n  , Array           = global[ARRAY]\r\n  , String          = global[STRING]\r\n  , Number          = global[NUMBER]\r\n  , RegExp          = global[REGEXP]\r\n  , Date            = global[DATE]\r\n  , Map             = global[MAP]\r\n  , Set             = global[SET]\r\n  , WeakMap         = global[WEAKMAP]\r\n  , WeakSet         = global[WEAKSET]\r\n  , Symbol          = global[SYMBOL]\r\n  , Math            = global[MATH]\r\n  , TypeError       = global.TypeError\r\n  , RangeError      = global.RangeError\r\n  , setTimeout      = global.setTimeout\r\n  , setImmediate    = global.setImmediate\r\n  , clearImmediate  = global.clearImmediate\r\n  , parseInt        = global.parseInt\r\n  , isFinite        = global.isFinite\r\n  , process         = global[PROCESS]\r\n  , nextTick        = process && process.nextTick\r\n  , document        = global.document\r\n  , html            = document && document.documentElement\r\n  , navigator       = global.navigator\r\n  , define          = global.define\r\n  , ArrayProto      = Array[PROTOTYPE]\r\n  , ObjectProto     = Object[PROTOTYPE]\r\n  , FunctionProto   = Function[PROTOTYPE]\r\n  , Infinity        = 1 / 0\r\n  , DOT             = '.'\r\n  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md\r\n  , CONSOLE_METHODS = 'assert,clear,count,debug,dir,dirxml,error,exception,' +\r\n      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +\r\n      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +\r\n      'timelineEnd,timeStamp,trace,warn';\r\n\r\n// http://jsperf.com/core-js-isobject\r\nfunction isObject(it){\r\n  return it !== null && (typeof it == 'object' || typeof it == 'function');\r\n}\r\nfunction isFunction(it){\r\n  return typeof it == 'function';\r\n}\r\n// Native function?\r\nvar isNative = ctx(/./.test, /\\[native code\\]\\s*\\}\\s*$/, 1);\r\n\r\n// Object internal [[Class]] or toStringTag\r\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring\r\nvar toString = ObjectProto[TO_STRING];\r\nfunction setToStringTag(it, tag, stat){\r\n  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);\r\n}\r\nfunction cof(it){\r\n  return toString.call(it).slice(8, -1);\r\n}\r\nfunction classof(it){\r\n  var O, T;\r\n  return it == undefined ? it === undefined ? 'Undefined' : 'Null'\r\n    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);\r\n}\r\n\r\n// Function\r\nvar call  = FunctionProto.call\r\n  , apply = FunctionProto.apply\r\n  , REFERENCE_GET;\r\n// Partial apply\r\nfunction part(/* ...args */){\r\n  var fn     = assertFunction(this)\r\n    , length = arguments.length\r\n    , args   = Array(length)\r\n    , i      = 0\r\n    , _      = path._\r\n    , holder = false;\r\n  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;\r\n  return function(/* ...args */){\r\n    var that    = this\r\n      , _length = arguments.length\r\n      , i = 0, j = 0, _args;\r\n    if(!holder && !_length)return invoke(fn, args, that);\r\n    _args = args.slice();\r\n    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];\r\n    while(_length > j)_args.push(arguments[j++]);\r\n    return invoke(fn, _args, that);\r\n  }\r\n}\r\n// Optional / simple context binding\r\nfunction ctx(fn, that, length){\r\n  assertFunction(fn);\r\n  if(~length && that === undefined)return fn;\r\n  switch(length){\r\n    case 1: return function(a){\r\n      return fn.call(that, a);\r\n    }\r\n    case 2: return function(a, b){\r\n      return fn.call(that, a, b);\r\n    }\r\n    case 3: return function(a, b, c){\r\n      return fn.call(that, a, b, c);\r\n    }\r\n  } return function(/* ...args */){\r\n      return fn.apply(that, arguments);\r\n  }\r\n}\r\n// Fast apply\r\n// http://jsperf.lnkit.com/fast-apply/5\r\nfunction invoke(fn, args, that){\r\n  var un = that === undefined;\r\n  switch(args.length | 0){\r\n    case 0: return un ? fn()\r\n                      : fn.call(that);\r\n    case 1: return un ? fn(args[0])\r\n                      : fn.call(that, args[0]);\r\n    case 2: return un ? fn(args[0], args[1])\r\n                      : fn.call(that, args[0], args[1]);\r\n    case 3: return un ? fn(args[0], args[1], args[2])\r\n                      : fn.call(that, args[0], args[1], args[2]);\r\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\r\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\r\n    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])\r\n                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);\r\n  } return              fn.apply(that, args);\r\n}\r\nfunction construct(target, argumentsList /*, newTarget*/){\r\n  var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]\r\n    , instance = create(isObject(proto) ? proto : ObjectProto)\r\n    , result   = apply.call(target, instance, argumentsList);\r\n  return isObject(result) ? result : instance;\r\n}\r\n\r\n// Object:\r\nvar create           = Object.create\r\n  , getPrototypeOf   = Object.getPrototypeOf\r\n  , setPrototypeOf   = Object.setPrototypeOf\r\n  , defineProperty   = Object.defineProperty\r\n  , defineProperties = Object.defineProperties\r\n  , getOwnDescriptor = Object.getOwnPropertyDescriptor\r\n  , getKeys          = Object.keys\r\n  , getNames         = Object.getOwnPropertyNames\r\n  , getSymbols       = Object.getOwnPropertySymbols\r\n  , isFrozen         = Object.isFrozen\r\n  , has              = ctx(call, ObjectProto[HAS_OWN], 2)\r\n  // Dummy, fix for not array-like ES3 string in es5 module\r\n  , ES5Object        = Object\r\n  , Dict;\r\nfunction toObject(it){\r\n  return ES5Object(assertDefined(it));\r\n}\r\nfunction returnIt(it){\r\n  return it;\r\n}\r\nfunction returnThis(){\r\n  return this;\r\n}\r\nfunction get(object, key){\r\n  if(has(object, key))return object[key];\r\n}\r\nfunction ownKeys(it){\r\n  assertObject(it);\r\n  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);\r\n}\r\n// 19.1.2.1 Object.assign(target, source, ...)\r\nvar assign = Object.assign || function(target, source){\r\n  var T = Object(assertDefined(target))\r\n    , l = arguments.length\r\n    , i = 1;\r\n  while(l > i){\r\n    var S      = ES5Object(arguments[i++])\r\n      , keys   = getKeys(S)\r\n      , length = keys.length\r\n      , j      = 0\r\n      , key;\r\n    while(length > j)T[key = keys[j++]] = S[key];\r\n  }\r\n  return T;\r\n}\r\nfunction keyOf(object, el){\r\n  var O      = toObject(object)\r\n    , keys   = getKeys(O)\r\n    , length = keys.length\r\n    , index  = 0\r\n    , key;\r\n  while(length > index)if(O[key = keys[index++]] === el)return key;\r\n}\r\n\r\n// Array\r\n// array('str1,str2,str3') => ['str1', 'str2', 'str3']\r\nfunction array(it){\r\n  return String(it).split(',');\r\n}\r\nvar push    = ArrayProto.push\r\n  , unshift = ArrayProto.unshift\r\n  , slice   = ArrayProto.slice\r\n  , splice  = ArrayProto.splice\r\n  , indexOf = ArrayProto.indexOf\r\n  , forEach = ArrayProto[FOR_EACH];\r\n/*\r\n * 0 -> forEach\r\n * 1 -> map\r\n * 2 -> filter\r\n * 3 -> some\r\n * 4 -> every\r\n * 5 -> find\r\n * 6 -> findIndex\r\n */\r\nfunction createArrayMethod(type){\r\n  var isMap       = type == 1\r\n    , isFilter    = type == 2\r\n    , isSome      = type == 3\r\n    , isEvery     = type == 4\r\n    , isFindIndex = type == 6\r\n    , noholes     = type == 5 || isFindIndex;\r\n  return function(callbackfn/*, that = undefined */){\r\n    var O      = Object(assertDefined(this))\r\n      , that   = arguments[1]\r\n      , self   = ES5Object(O)\r\n      , f      = ctx(callbackfn, that, 3)\r\n      , length = toLength(self.length)\r\n      , index  = 0\r\n      , result = isMap ? Array(length) : isFilter ? [] : undefined\r\n      , val, res;\r\n    for(;length > index; index++)if(noholes || index in self){\r\n      val = self[index];\r\n      res = f(val, index, O);\r\n      if(type){\r\n        if(isMap)result[index] = res;             // map\r\n        else if(res)switch(type){\r\n          case 3: return true;                    // some\r\n          case 5: return val;                     // find\r\n          case 6: return index;                   // findIndex\r\n          case 2: result.push(val);               // filter\r\n        } else if(isEvery)return false;           // every\r\n      }\r\n    }\r\n    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;\r\n  }\r\n}\r\nfunction createArrayContains(isContains){\r\n  return function(el /*, fromIndex = 0 */){\r\n    var O      = toObject(this)\r\n      , length = toLength(O.length)\r\n      , index  = toIndex(arguments[1], length);\r\n    if(isContains && el != el){\r\n      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;\r\n    } else for(;length > index; index++)if(isContains || index in O){\r\n      if(O[index] === el)return isContains || index;\r\n    } return !isContains && -1;\r\n  }\r\n}\r\nfunction generic(A, B){\r\n  // strange IE quirks mode bug -> use typeof vs isFunction\r\n  return typeof A == 'function' ? A : B;\r\n}\r\n\r\n// Math\r\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991\r\n  , pow    = Math.pow\r\n  , abs    = Math.abs\r\n  , ceil   = Math.ceil\r\n  , floor  = Math.floor\r\n  , max    = Math.max\r\n  , min    = Math.min\r\n  , random = Math.random\r\n  , trunc  = Math.trunc || function(it){\r\n      return (it > 0 ? floor : ceil)(it);\r\n    }\r\n// 20.1.2.4 Number.isNaN(number)\r\nfunction sameNaN(number){\r\n  return number != number;\r\n}\r\n// 7.1.4 ToInteger\r\nfunction toInteger(it){\r\n  return isNaN(it) ? 0 : trunc(it);\r\n}\r\n// 7.1.15 ToLength\r\nfunction toLength(it){\r\n  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;\r\n}\r\nfunction toIndex(index, length){\r\n  var index = toInteger(index);\r\n  return index < 0 ? max(index + length, 0) : min(index, length);\r\n}\r\nfunction lz(num){\r\n  return num > 9 ? num : '0' + num;\r\n}\r\n\r\nfunction createReplacer(regExp, replace, isStatic){\r\n  var replacer = isObject(replace) ? function(part){\r\n    return replace[part];\r\n  } : replace;\r\n  return function(it){\r\n    return String(isStatic ? it : this).replace(regExp, replacer);\r\n  }\r\n}\r\nfunction createPointAt(toString){\r\n  return function(pos){\r\n    var s = String(assertDefined(this))\r\n      , i = toInteger(pos)\r\n      , l = s.length\r\n      , a, b;\r\n    if(i < 0 || i >= l)return toString ? '' : undefined;\r\n    a = s.charCodeAt(i);\r\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\r\n      ? toString ? s.charAt(i) : a\r\n      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\r\n  }\r\n}\r\n\r\n// Assertion & errors\r\nvar REDUCE_ERROR = 'Reduce of empty object with no initial value';\r\nfunction assert(condition, msg1, msg2){\r\n  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);\r\n}\r\nfunction assertDefined(it){\r\n  if(it == undefined)throw TypeError('Function called on null or undefined');\r\n  return it;\r\n}\r\nfunction assertFunction(it){\r\n  assert(isFunction(it), it, ' is not a function!');\r\n  return it;\r\n}\r\nfunction assertObject(it){\r\n  assert(isObject(it), it, ' is not an object!');\r\n  return it;\r\n}\r\nfunction assertInstance(it, Constructor, name){\r\n  assert(it instanceof Constructor, name, \": use the 'new' operator!\");\r\n}\r\n\r\n// Property descriptors & Symbol\r\nfunction descriptor(bitmap, value){\r\n  return {\r\n    enumerable  : !(bitmap & 1),\r\n    configurable: !(bitmap & 2),\r\n    writable    : !(bitmap & 4),\r\n    value       : value\r\n  }\r\n}\r\nfunction simpleSet(object, key, value){\r\n  object[key] = value;\r\n  return object;\r\n}\r\nfunction createDefiner(bitmap){\r\n  return DESC ? function(object, key, value){\r\n    return defineProperty(object, key, descriptor(bitmap, value));\r\n  } : simpleSet;\r\n}\r\nfunction uid(key){\r\n  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);\r\n}\r\nfunction getWellKnownSymbol(name, setter){\r\n  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);\r\n}\r\n// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\r\nvar DESC = !!function(){\r\n      try {\r\n        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;\r\n      } catch(e){}\r\n    }()\r\n  , sid    = 0\r\n  , hidden = createDefiner(1)\r\n  , set    = Symbol ? simpleSet : hidden\r\n  , safeSymbol = Symbol || uid;\r\nfunction assignHidden(target, src){\r\n  for(var key in src)hidden(target, key, src[key]);\r\n  return target;\r\n}\r\n\r\nvar SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')\r\n  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}\r\n  , SYMBOL_SPECIES     = getWellKnownSymbol('species');\r\nfunction setSpecies(C){\r\n  if(framework || !isNative(C))defineProperty(C, SYMBOL_SPECIES, {\r\n    configurable: true,\r\n    get: returnThis\r\n  });\r\n}\r\n\r\n// Iterators\r\nvar SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR)\r\n  , SYMBOL_TAG      = getWellKnownSymbol(TO_STRING_TAG)\r\n  , SUPPORT_FF_ITER = FF_ITERATOR in ArrayProto\r\n  , ITER  = safeSymbol('iter')\r\n  , KEY   = 1\r\n  , VALUE = 2\r\n  , Iterators = {}\r\n  , IteratorPrototype = {}\r\n  , NATIVE_ITERATORS = SYMBOL_ITERATOR in ArrayProto\r\n    // Safari define byggy iterators w/o `next`\r\n  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());\r\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\r\nsetIterator(IteratorPrototype, returnThis);\r\nfunction setIterator(O, value){\r\n  hidden(O, SYMBOL_ITERATOR, value);\r\n  // Add iterator for FF iterator protocol\r\n  SUPPORT_FF_ITER && hidden(O, FF_ITERATOR, value);\r\n}\r\nfunction createIterator(Constructor, NAME, next, proto){\r\n  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});\r\n  setToStringTag(Constructor, NAME + ' Iterator');\r\n}\r\nfunction defineIterator(Constructor, NAME, value, DEFAULT){\r\n  var proto = Constructor[PROTOTYPE]\r\n    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;\r\n  if(framework){\r\n    // Define iterator\r\n    setIterator(proto, iter);\r\n    if(iter !== value){\r\n      var iterProto = getPrototypeOf(iter.call(new Constructor));\r\n      // Set @@toStringTag to native iterators\r\n      setToStringTag(iterProto, NAME + ' Iterator', true);\r\n      // FF fix\r\n      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);\r\n    }\r\n  }\r\n  // Plug for library\r\n  Iterators[NAME] = iter;\r\n  // FF & v8 fix\r\n  Iterators[NAME + ' Iterator'] = returnThis;\r\n  return iter;\r\n}\r\nfunction defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){\r\n  function createIter(kind){\r\n    return function(){\r\n      return new Constructor(this, kind);\r\n    }\r\n  }\r\n  createIterator(Constructor, NAME, next);\r\n  var entries = createIter(KEY+VALUE)\r\n    , values  = createIter(VALUE);\r\n  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');\r\n  else entries = defineIterator(Base, NAME, entries, 'entries');\r\n  if(DEFAULT){\r\n    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {\r\n      entries: entries,\r\n      keys: IS_SET ? values : createIter(KEY),\r\n      values: values\r\n    });\r\n  }\r\n}\r\nfunction iterResult(done, value){\r\n  return {value: value, done: !!done};\r\n}\r\nfunction isIterable(it){\r\n  var O      = Object(it)\r\n    , Symbol = global[SYMBOL]\r\n    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;\r\n  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));\r\n}\r\nfunction getIterator(it){\r\n  var Symbol  = global[SYMBOL]\r\n    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]\r\n    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];\r\n  return assertObject(getIter.call(it));\r\n}\r\nfunction stepCall(fn, value, entries){\r\n  return entries ? invoke(fn, value) : fn(value);\r\n}\r\nfunction forOf(iterable, entries, fn, that){\r\n  var iterator = getIterator(iterable)\r\n    , f        = ctx(fn, that, entries ? 2 : 1)\r\n    , step;\r\n  while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false)return;\r\n}\r\n\r\n// core\r\nvar NODE = cof(process) == PROCESS\r\n  , core = {}\r\n  , path = framework ? global : core\r\n  , old  = global.core\r\n  , exportGlobal\r\n  // type bitmap\r\n  , FORCED = 1\r\n  , GLOBAL = 2\r\n  , STATIC = 4\r\n  , PROTO  = 8\r\n  , BIND   = 16\r\n  , WRAP   = 32\r\n  , SIMPLE = 64;\r\nfunction $define(type, name, source){\r\n  var key, own, out, exp\r\n    , isGlobal = type & GLOBAL\r\n    , target   = isGlobal ? global : (type & STATIC)\r\n        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]\r\n    , exports  = isGlobal ? core : core[name] || (core[name] = {});\r\n  if(isGlobal)source = name;\r\n  for(key in source){\r\n    // there is a similar native\r\n    own = !(type & FORCED) && target && key in target\r\n      && (!isFunction(target[key]) || isNative(target[key]));\r\n    // export native or passed\r\n    out = (own ? target : source)[key];\r\n    // prevent global pollution for namespaces\r\n    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];\r\n    // bind timers to global for call from export context\r\n    else if(type & BIND && own)exp = ctx(out, global);\r\n    // wrap global constructors for prevent change them in library\r\n    else if(type & WRAP && !framework && target[key] == out){\r\n      exp = function(param){\r\n        return this instanceof out ? new out(param) : out(param);\r\n      }\r\n      exp[PROTOTYPE] = out[PROTOTYPE];\r\n    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;\r\n    // extend global\r\n    if(framework && target && !own){\r\n      if(isGlobal || type & SIMPLE)target[key] = out;\r\n      else delete target[key] && hidden(target, key, out);\r\n    }\r\n    // export\r\n    if(exports[key] != out)hidden(exports, key, exp);\r\n  }\r\n}\r\n// CommonJS export\r\nif(typeof module != 'undefined' && module.exports)module.exports = core;\r\n// RequireJS export\r\nelse if(isFunction(define) && define.amd)define(function(){return core});\r\n// Export to global object\r\nelse exportGlobal = true;\r\nif(exportGlobal || framework){\r\n  core.noConflict = function(){\r\n    global.core = old;\r\n    return core;\r\n  }\r\n  global.core = core;\r\n}\n\n/******************************************************************************\n * Module : es6.symbol                                                        *\n ******************************************************************************/\n\n// ECMAScript 6 symbols shim\r\n!function(TAG, SymbolRegistry, AllSymbols, setter){\r\n  // 19.4.1.1 Symbol([description])\r\n  if(!isNative(Symbol)){\r\n    Symbol = function(description){\r\n      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);\r\n      var tag = uid(description)\r\n        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);\r\n      AllSymbols[tag] = sym;\r\n      DESC && setter && defineProperty(ObjectProto, tag, {\r\n        configurable: true,\r\n        set: function(value){\r\n          hidden(this, tag, value);\r\n        }\r\n      });\r\n      return sym;\r\n    }\r\n    hidden(Symbol[PROTOTYPE], TO_STRING, function(){\r\n      return this[TAG];\r\n    });\r\n  }\r\n  $define(GLOBAL + WRAP, {Symbol: Symbol});\r\n  \r\n  var symbolStatics = {\r\n    // 19.4.2.1 Symbol.for(key)\r\n    'for': function(key){\r\n      return has(SymbolRegistry, key += '')\r\n        ? SymbolRegistry[key]\r\n        : SymbolRegistry[key] = Symbol(key);\r\n    },\r\n    // 19.4.2.4 Symbol.iterator\r\n    iterator: SYMBOL_ITERATOR,\r\n    // 19.4.2.5 Symbol.keyFor(sym)\r\n    keyFor: part.call(keyOf, SymbolRegistry),\r\n    // 19.4.2.10 Symbol.species\r\n    species: SYMBOL_SPECIES,\r\n    // 19.4.2.13 Symbol.toStringTag\r\n    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),\r\n    // 19.4.2.14 Symbol.unscopables\r\n    unscopables: SYMBOL_UNSCOPABLES,\r\n    pure: safeSymbol,\r\n    set: set,\r\n    useSetter: function(){setter = true},\r\n    useSimple: function(){setter = false}\r\n  };\r\n  // 19.4.2.2 Symbol.hasInstance\r\n  // 19.4.2.3 Symbol.isConcatSpreadable\r\n  // 19.4.2.6 Symbol.match\r\n  // 19.4.2.8 Symbol.replace\r\n  // 19.4.2.9 Symbol.search\r\n  // 19.4.2.11 Symbol.split\r\n  // 19.4.2.12 Symbol.toPrimitive\r\n  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),\r\n    function(it){\r\n      symbolStatics[it] = getWellKnownSymbol(it);\r\n    }\r\n  );\r\n  $define(STATIC, SYMBOL, symbolStatics);\r\n  \r\n  setToStringTag(Symbol, SYMBOL);\r\n  \r\n  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {\r\n    // 19.1.2.7 Object.getOwnPropertyNames(O)\r\n    getOwnPropertyNames: function(it){\r\n      var names = getNames(toObject(it)), result = [], key, i = 0;\r\n      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);\r\n      return result;\r\n    },\r\n    // 19.1.2.8 Object.getOwnPropertySymbols(O)\r\n    getOwnPropertySymbols: function(it){\r\n      var names = getNames(toObject(it)), result = [], key, i = 0;\r\n      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);\r\n      return result;\r\n    }\r\n  });\r\n}(safeSymbol('tag'), {}, {}, true);\n\n/******************************************************************************\n * Module : es6.object                                                        *\n ******************************************************************************/\n\n!function(tmp){\r\n  var objectStatic = {\r\n    // 19.1.3.1 Object.assign(target, source)\r\n    assign: assign,\r\n    // 19.1.3.10 Object.is(value1, value2)\r\n    is: function(x, y){\r\n      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\r\n    }\r\n  };\r\n  // 19.1.3.19 Object.setPrototypeOf(O, proto)\r\n  // Works with __proto__ only. Old v8 can't works with null proto objects.\r\n  '__proto__' in ObjectProto && function(buggy, set){\r\n    try {\r\n      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);\r\n      set({}, ArrayProto);\r\n    } catch(e){ buggy = true }\r\n    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){\r\n      assertObject(O);\r\n      assert(proto === null || isObject(proto), proto, \": can't set as prototype!\");\r\n      if(buggy)O.__proto__ = proto;\r\n      else set(O, proto);\r\n      return O;\r\n    }\r\n  }();\r\n  $define(STATIC, OBJECT, objectStatic);\r\n  \r\n  if(framework){\r\n    // 19.1.3.6 Object.prototype.toString()\r\n    tmp[SYMBOL_TAG] = DOT;\r\n    if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){\r\n      return '[object ' + classof(this) + ']';\r\n    });\r\n  }\r\n  \r\n  // 20.2.1.9 Math[@@toStringTag]\r\n  setToStringTag(Math, MATH, true);\r\n  // 24.3.3 JSON[@@toStringTag]\r\n  setToStringTag(global.JSON, 'JSON', true);\r\n}({});\n\n/******************************************************************************\n * Module : es6.object.statics-accept-primitives                              *\n ******************************************************************************/\n\n!function(){\r\n  // Object static methods accept primitives\r\n  function wrapObjectMethod(key, MODE){\r\n    var fn  = Object[key]\r\n      , exp = core[OBJECT][key]\r\n      , f   = 0\r\n      , o   = {};\r\n    if(!exp || isNative(exp)){\r\n      o[key] = MODE == 1 ? function(it){\r\n        return isObject(it) ? fn(it) : it;\r\n      } : MODE == 2 ? function(it){\r\n        return isObject(it) ? fn(it) : true;\r\n      } : MODE == 3 ? function(it){\r\n        return isObject(it) ? fn(it) : false;\r\n      } : MODE == 4 ? function(it, key){\r\n        return fn(toObject(it), key);\r\n      } : function(it){\r\n        return fn(toObject(it));\r\n      };\r\n      try { fn(DOT) }\r\n      catch(e){ f = 1 }\r\n      $define(STATIC + FORCED * f, OBJECT, o);\r\n    }\r\n  }\r\n  wrapObjectMethod('freeze', 1);\r\n  wrapObjectMethod('seal', 1);\r\n  wrapObjectMethod('preventExtensions', 1);\r\n  wrapObjectMethod('isFrozen', 2);\r\n  wrapObjectMethod('isSealed', 2);\r\n  wrapObjectMethod('isExtensible', 3);\r\n  wrapObjectMethod('getOwnPropertyDescriptor', 4);\r\n  wrapObjectMethod('getPrototypeOf');\r\n  wrapObjectMethod('keys');\r\n  wrapObjectMethod('getOwnPropertyNames');\r\n}();\n\n/******************************************************************************\n * Module : es6.function                                                      *\n ******************************************************************************/\n\n!function(NAME){\r\n  // 19.2.4.2 name\r\n  NAME in FunctionProto || defineProperty(FunctionProto, NAME, {\r\n    configurable: true,\r\n    get: function(){\r\n      var match = String(this).match(/^\\s*function ([^ (]*)/)\r\n        , name  = match ? match[1] : '';\r\n      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));\r\n      return name;\r\n    },\r\n    set: function(value){\r\n      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));\r\n    }\r\n  });\r\n}('name');\n\n/******************************************************************************\n * Module : es6.number.constructor                                            *\n ******************************************************************************/\n\nNumber('0o1') && Number('0b1') || function(_Number, NumberProto){\r\n  function toNumber(it){\r\n    if(isObject(it))it = toPrimitive(it);\r\n    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){\r\n      var binary = false;\r\n      switch(it.charCodeAt(1)){\r\n        case 66 : case 98  : binary = true;\r\n        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);\r\n      }\r\n    } return +it;\r\n  }\r\n  function toPrimitive(it){\r\n    var fn, val;\r\n    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;\r\n    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;\r\n    throw TypeError(\"Can't convert object to number\");\r\n  }\r\n  Number = function Number(it){\r\n    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);\r\n  }\r\n  forEach.call(DESC ? getNames(_Number)\r\n  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){\r\n    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));\r\n  });\r\n  Number[PROTOTYPE] = NumberProto;\r\n  NumberProto[CONSTRUCTOR] = Number;\r\n  hidden(global, NUMBER, Number);\r\n}(Number, Number[PROTOTYPE]);\n\n/******************************************************************************\n * Module : es6.number                                                        *\n ******************************************************************************/\n\n!function(isInteger){\r\n  $define(STATIC, NUMBER, {\r\n    // 20.1.2.1 Number.EPSILON\r\n    EPSILON: pow(2, -52),\r\n    // 20.1.2.2 Number.isFinite(number)\r\n    isFinite: function(it){\r\n      return typeof it == 'number' && isFinite(it);\r\n    },\r\n    // 20.1.2.3 Number.isInteger(number)\r\n    isInteger: isInteger,\r\n    // 20.1.2.4 Number.isNaN(number)\r\n    isNaN: sameNaN,\r\n    // 20.1.2.5 Number.isSafeInteger(number)\r\n    isSafeInteger: function(number){\r\n      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;\r\n    },\r\n    // 20.1.2.6 Number.MAX_SAFE_INTEGER\r\n    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\r\n    // 20.1.2.10 Number.MIN_SAFE_INTEGER\r\n    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,\r\n    // 20.1.2.12 Number.parseFloat(string)\r\n    parseFloat: parseFloat,\r\n    // 20.1.2.13 Number.parseInt(string, radix)\r\n    parseInt: parseInt\r\n  });\r\n// 20.1.2.3 Number.isInteger(number)\r\n}(Number.isInteger || function(it){\r\n  return !isObject(it) && isFinite(it) && floor(it) === it;\r\n});\n\n/******************************************************************************\n * Module : es6.math                                                          *\n ******************************************************************************/\n\n// ECMAScript 6 shim\r\n!function(){\r\n  // 20.2.2.28 Math.sign(x)\r\n  var E    = Math.E\r\n    , exp  = Math.exp\r\n    , log  = Math.log\r\n    , sqrt = Math.sqrt\r\n    , sign = Math.sign || function(x){\r\n        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\r\n      };\r\n  \r\n  // 20.2.2.5 Math.asinh(x)\r\n  function asinh(x){\r\n    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));\r\n  }\r\n  // 20.2.2.14 Math.expm1(x)\r\n  function expm1(x){\r\n    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;\r\n  }\r\n    \r\n  $define(STATIC, MATH, {\r\n    // 20.2.2.3 Math.acosh(x)\r\n    acosh: function(x){\r\n      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;\r\n    },\r\n    // 20.2.2.5 Math.asinh(x)\r\n    asinh: asinh,\r\n    // 20.2.2.7 Math.atanh(x)\r\n    atanh: function(x){\r\n      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;\r\n    },\r\n    // 20.2.2.9 Math.cbrt(x)\r\n    cbrt: function(x){\r\n      return sign(x = +x) * pow(abs(x), 1 / 3);\r\n    },\r\n    // 20.2.2.11 Math.clz32(x)\r\n    clz32: function(x){\r\n      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;\r\n    },\r\n    // 20.2.2.12 Math.cosh(x)\r\n    cosh: function(x){\r\n      return (exp(x = +x) + exp(-x)) / 2;\r\n    },\r\n    // 20.2.2.14 Math.expm1(x)\r\n    expm1: expm1,\r\n    // 20.2.2.16 Math.fround(x)\r\n    // TODO: fallback for IE9-\r\n    fround: function(x){\r\n      return new Float32Array([x])[0];\r\n    },\r\n    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\r\n    hypot: function(value1, value2){\r\n      var sum  = 0\r\n        , len1 = arguments.length\r\n        , len2 = len1\r\n        , args = Array(len1)\r\n        , larg = -Infinity\r\n        , arg;\r\n      while(len1--){\r\n        arg = args[len1] = +arguments[len1];\r\n        if(arg == Infinity || arg == -Infinity)return Infinity;\r\n        if(arg > larg)larg = arg;\r\n      }\r\n      larg = arg || 1;\r\n      while(len2--)sum += pow(args[len2] / larg, 2);\r\n      return larg * sqrt(sum);\r\n    },\r\n    // 20.2.2.18 Math.imul(x, y)\r\n    imul: function(x, y){\r\n      var UInt16 = 0xffff\r\n        , xn = +x\r\n        , yn = +y\r\n        , xl = UInt16 & xn\r\n        , yl = UInt16 & yn;\r\n      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);\r\n    },\r\n    // 20.2.2.20 Math.log1p(x)\r\n    log1p: function(x){\r\n      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);\r\n    },\r\n    // 20.2.2.21 Math.log10(x)\r\n    log10: function(x){\r\n      return log(x) / Math.LN10;\r\n    },\r\n    // 20.2.2.22 Math.log2(x)\r\n    log2: function(x){\r\n      return log(x) / Math.LN2;\r\n    },\r\n    // 20.2.2.28 Math.sign(x)\r\n    sign: sign,\r\n    // 20.2.2.30 Math.sinh(x)\r\n    sinh: function(x){\r\n      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);\r\n    },\r\n    // 20.2.2.33 Math.tanh(x)\r\n    tanh: function(x){\r\n      var a = expm1(x = +x)\r\n        , b = expm1(-x);\r\n      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\r\n    },\r\n    // 20.2.2.34 Math.trunc(x)\r\n    trunc: trunc\r\n  });\r\n}();\n\n/******************************************************************************\n * Module : es6.string                                                        *\n ******************************************************************************/\n\n!function(fromCharCode){\r\n  function assertNotRegExp(it){\r\n    if(cof(it) == REGEXP)throw TypeError();\r\n  }\r\n  \r\n  $define(STATIC, STRING, {\r\n    // 21.1.2.2 String.fromCodePoint(...codePoints)\r\n    fromCodePoint: function(x){\r\n      var res = []\r\n        , len = arguments.length\r\n        , i   = 0\r\n        , code\r\n      while(len > i){\r\n        code = +arguments[i++];\r\n        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\r\n        res.push(code < 0x10000\r\n          ? fromCharCode(code)\r\n          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\r\n        );\r\n      } return res.join('');\r\n    },\r\n    // 21.1.2.4 String.raw(callSite, ...substitutions)\r\n    raw: function(callSite){\r\n      var raw = toObject(callSite.raw)\r\n        , len = toLength(raw.length)\r\n        , sln = arguments.length\r\n        , res = []\r\n        , i   = 0;\r\n      while(len > i){\r\n        res.push(String(raw[i++]));\r\n        if(i < sln)res.push(String(arguments[i]));\r\n      } return res.join('');\r\n    }\r\n  });\r\n  \r\n  $define(PROTO, STRING, {\r\n    // 21.1.3.3 String.prototype.codePointAt(pos)\r\n    codePointAt: createPointAt(false),\r\n    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\r\n    endsWith: function(searchString /*, endPosition = @length */){\r\n      assertNotRegExp(searchString);\r\n      var that = String(assertDefined(this))\r\n        , endPosition = arguments[1]\r\n        , len = toLength(that.length)\r\n        , end = endPosition === undefined ? len : min(toLength(endPosition), len);\r\n      searchString += '';\r\n      return that.slice(end - searchString.length, end) === searchString;\r\n    },\r\n    // 21.1.3.7 String.prototype.includes(searchString, position = 0)\r\n    includes: function(searchString /*, position = 0 */){\r\n      assertNotRegExp(searchString);\r\n      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);\r\n    },\r\n    // 21.1.3.13 String.prototype.repeat(count)\r\n    repeat: function(count){\r\n      var str = String(assertDefined(this))\r\n        , res = ''\r\n        , n   = toInteger(count);\r\n      if(0 > n || n == Infinity)throw RangeError(\"Count can't be negative\");\r\n      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\r\n      return res;\r\n    },\r\n    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])\r\n    startsWith: function(searchString /*, position = 0 */){\r\n      assertNotRegExp(searchString);\r\n      var that  = String(assertDefined(this))\r\n        , index = toLength(min(arguments[1], that.length));\r\n      searchString += '';\r\n      return that.slice(index, index + searchString.length) === searchString;\r\n    }\r\n  });\r\n}(String.fromCharCode);\n\n/******************************************************************************\n * Module : es6.array                                                         *\n ******************************************************************************/\n\n!function(){\r\n  $define(STATIC, ARRAY, {\r\n    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\r\n    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\r\n      var O       = Object(assertDefined(arrayLike))\r\n        , mapfn   = arguments[1]\r\n        , mapping = mapfn !== undefined\r\n        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined\r\n        , index   = 0\r\n        , length, result, iter, step;\r\n      if(isIterable(O))for(iter = getIterator(O), result = new (generic(this, Array)); !(step = iter.next()).done; index++){\r\n        result[index] = mapping ? f(step.value, index) : step.value;\r\n      } else for(result = new (generic(this, Array))(length = toLength(O.length)); length > index; index++){\r\n        result[index] = mapping ? f(O[index], index) : O[index];\r\n      }\r\n      result.length = index;\r\n      return result;\r\n    },\r\n    // 22.1.2.3 Array.of( ...items)\r\n    of: function(/* ...args */){\r\n      var index  = 0\r\n        , length = arguments.length\r\n        , result = new (generic(this, Array))(length);\r\n      while(length > index)result[index] = arguments[index++];\r\n      result.length = length;\r\n      return result;\r\n    }\r\n  });\r\n  \r\n  $define(PROTO, ARRAY, {\r\n    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\r\n    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){\r\n      var O     = Object(assertDefined(this))\r\n        , len   = toLength(O.length)\r\n        , to    = toIndex(target, len)\r\n        , from  = toIndex(start, len)\r\n        , end   = arguments[2]\r\n        , fin   = end === undefined ? len : toIndex(end, len)\r\n        , count = min(fin - from, len - to)\r\n        , inc   = 1;\r\n      if(from < to && to < from + count){\r\n        inc  = -1;\r\n        from = from + count - 1;\r\n        to   = to + count - 1;\r\n      }\r\n      while(count-- > 0){\r\n        if(from in O)O[to] = O[from];\r\n        else delete O[to];\r\n        to += inc;\r\n        from += inc;\r\n      } return O;\r\n    },\r\n    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\r\n    fill: function(value /*, start = 0, end = @length */){\r\n      var O      = Object(assertDefined(this))\r\n        , length = toLength(O.length)\r\n        , index  = toIndex(arguments[1], length)\r\n        , end    = arguments[2]\r\n        , endPos = end === undefined ? length : toIndex(end, length);\r\n      while(endPos > index)O[index++] = value;\r\n      return O;\r\n    },\r\n    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\r\n    find: createArrayMethod(5),\r\n    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\r\n    findIndex: createArrayMethod(6)\r\n  });\r\n  \r\n  if(framework){\r\n    // 22.1.3.31 Array.prototype[@@unscopables]\r\n    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){\r\n      ArrayUnscopables[it] = true;\r\n    });\r\n    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);\r\n  }  \r\n  \r\n  setSpecies(Array);\r\n}();\n\n/******************************************************************************\n * Module : es6.iterators                                                     *\n ******************************************************************************/\n\n!function(at){\r\n  // 22.1.3.4 Array.prototype.entries()\r\n  // 22.1.3.13 Array.prototype.keys()\r\n  // 22.1.3.29 Array.prototype.values()\r\n  // 22.1.3.30 Array.prototype[@@iterator]()\r\n  defineStdIterators(Array, ARRAY, function(iterated, kind){\r\n    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});\r\n  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\r\n  }, function(){\r\n    var iter  = this[ITER]\r\n      , O     = iter.o\r\n      , kind  = iter.k\r\n      , index = iter.i++;\r\n    if(!O || index >= O.length){\r\n      iter.o = undefined;\r\n      return iterResult(1);\r\n    }\r\n    if(kind == KEY)  return iterResult(0, index);\r\n    if(kind == VALUE)return iterResult(0, O[index]);\r\n                     return iterResult(0, [index, O[index]]);\r\n  }, VALUE);\r\n  \r\n  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\r\n  Iterators[ARGUMENTS] = Iterators[ARRAY];\r\n  \r\n  // 21.1.3.27 String.prototype[@@iterator]()\r\n  defineStdIterators(String, STRING, function(iterated){\r\n    set(this, ITER, {o: String(iterated), i: 0});\r\n  // 21.1.5.2.1 %StringIteratorPrototype%.next()\r\n  }, function(){\r\n    var iter  = this[ITER]\r\n      , O     = iter.o\r\n      , index = iter.i\r\n      , point;\r\n    if(index >= O.length)return iterResult(1);\r\n    point = at.call(O, index);\r\n    iter.i += point.length;\r\n    return iterResult(0, point);\r\n  });\r\n}(createPointAt(true));\n\n/******************************************************************************\n * Module : es6.regexp                                                        *\n ******************************************************************************/\n\n!function(RegExpProto, _RegExp){\r\n  function assertRegExpWrapper(fn){\r\n    return function(){\r\n      assert(cof(this) === REGEXP);\r\n      return fn(this);\r\n    }\r\n  }\r\n  \r\n  // RegExp allows a regex with flags as the pattern\r\n  if(DESC && !function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){\r\n    RegExp = function RegExp(pattern, flags){\r\n      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined\r\n        ? pattern.source : pattern, flags);\r\n    }\r\n    forEach.call(getNames(_RegExp), function(key){\r\n      key in RegExp || defineProperty(RegExp, key, {\r\n        configurable: true,\r\n        get: function(){ return _RegExp[key] },\r\n        set: function(it){ _RegExp[key] = it }\r\n      });\r\n    });\r\n    RegExpProto[CONSTRUCTOR] = RegExp;\r\n    RegExp[PROTOTYPE] = RegExpProto;\r\n    hidden(global, REGEXP, RegExp);\r\n  }\r\n  \r\n  // 21.2.5.3 get RegExp.prototype.flags()\r\n  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {\r\n    configurable: true,\r\n    get: assertRegExpWrapper(createReplacer(/^.*\\/(\\w*)$/, '$1', true))\r\n  });\r\n  \r\n  // 21.2.5.12 get RegExp.prototype.sticky()\r\n  // 21.2.5.15 get RegExp.prototype.unicode()\r\n  forEach.call(array('sticky,unicode'), function(key){\r\n    key in /./ || defineProperty(RegExpProto, key, DESC ? {\r\n      configurable: true,\r\n      get: assertRegExpWrapper(function(){\r\n        return false;\r\n      })\r\n    } : descriptor(5, false));\r\n  });\r\n  \r\n  setSpecies(RegExp);\r\n}(RegExp[PROTOTYPE], RegExp);\n\n/******************************************************************************\n * Module : web.immediate                                                     *\n ******************************************************************************/\n\n// setImmediate shim\r\n// Node.js 0.9+ & IE10+ has setImmediate, else:\r\nisFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){\r\n  var postMessage      = global.postMessage\r\n    , addEventListener = global.addEventListener\r\n    , MessageChannel   = global.MessageChannel\r\n    , counter          = 0\r\n    , queue            = {}\r\n    , defer, channel, port;\r\n  setImmediate = function(fn){\r\n    var args = [], i = 1;\r\n    while(arguments.length > i)args.push(arguments[i++]);\r\n    queue[++counter] = function(){\r\n      invoke(isFunction(fn) ? fn : Function(fn), args);\r\n    }\r\n    defer(counter);\r\n    return counter;\r\n  }\r\n  clearImmediate = function(id){\r\n    delete queue[id];\r\n  }\r\n  function run(id){\r\n    if(has(queue, id)){\r\n      var fn = queue[id];\r\n      delete queue[id];\r\n      fn();\r\n    }\r\n  }\r\n  function listner(event){\r\n    run(event.data);\r\n  }\r\n  // Node.js 0.8-\r\n  if(NODE){\r\n    defer = function(id){\r\n      nextTick(part.call(run, id));\r\n    }\r\n  // Modern browsers, skip implementation for WebWorkers\r\n  // IE8 has postMessage, but it's sync & typeof its postMessage is object\r\n  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){\r\n    defer = function(id){\r\n      postMessage(id, '*');\r\n    }\r\n    addEventListener('message', listner, false);\r\n  // WebWorkers\r\n  } else if(isFunction(MessageChannel)){\r\n    channel = new MessageChannel;\r\n    port    = channel.port2;\r\n    channel.port1.onmessage = listner;\r\n    defer = ctx(port.postMessage, port, 1);\r\n  // IE8-\r\n  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){\r\n    defer = function(id){\r\n      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){\r\n        html.removeChild(this);\r\n        run(id);\r\n      }\r\n    }\r\n  // Rest old browsers\r\n  } else {\r\n    defer = function(id){\r\n      setTimeout(run, 0, id);\r\n    }\r\n  }\r\n}('onreadystatechange');\r\n$define(GLOBAL + BIND, {\r\n  setImmediate:   setImmediate,\r\n  clearImmediate: clearImmediate\r\n});\n\n/******************************************************************************\n * Module : es6.promise                                                       *\n ******************************************************************************/\n\n// ES6 promises shim\r\n// Based on https://github.com/getify/native-promise-only/\r\n!function(Promise, test){\r\n  isFunction(Promise) && isFunction(Promise.resolve)\r\n  && Promise.resolve(test = new Promise(function(){})) == test\r\n  || function(asap, DEF){\r\n    function isThenable(o){\r\n      var then;\r\n      if(isObject(o))then = o.then;\r\n      return isFunction(then) ? then : false;\r\n    }\r\n    function notify(def){\r\n      var chain = def.chain;\r\n      chain.length && asap(function(){\r\n        var msg = def.msg\r\n          , ok  = def.state == 1\r\n          , i   = 0;\r\n        while(chain.length > i)!function(react){\r\n          var cb = ok ? react.ok : react.fail\r\n            , ret, then;\r\n          try {\r\n            if(cb){\r\n              ret = cb === true ? msg : cb(msg);\r\n              if(ret === react.P){\r\n                react.rej(TypeError(PROMISE + '-chain cycle'));\r\n              } else if(then = isThenable(ret)){\r\n                then.call(ret, react.res, react.rej);\r\n              } else react.res(ret);\r\n            } else react.rej(msg);\r\n          } catch(err){\r\n            react.rej(err);\r\n          }\r\n        }(chain[i++]);\r\n        chain.length = 0;\r\n      });\r\n    }\r\n    function resolve(msg){\r\n      var def = this\r\n        , then, wrapper;\r\n      if(def.done)return;\r\n      def.done = true;\r\n      def = def.def || def; // unwrap\r\n      try {\r\n        if(then = isThenable(msg)){\r\n          wrapper = {def: def, done: false}; // wrap\r\n          then.call(msg, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));\r\n        } else {\r\n          def.msg = msg;\r\n          def.state = 1;\r\n          notify(def);\r\n        }\r\n      } catch(err){\r\n        reject.call(wrapper || {def: def, done: false}, err); // wrap\r\n      }\r\n    }\r\n    function reject(msg){\r\n      var def = this;\r\n      if(def.done)return;\r\n      def.done = true;\r\n      def = def.def || def; // unwrap\r\n      def.msg = msg;\r\n      def.state = 2;\r\n      notify(def);\r\n    }\r\n    function getConstructor(C){\r\n      var S = assertObject(C)[SYMBOL_SPECIES];\r\n      return S != undefined ? S : C;\r\n    }\r\n    // 25.4.3.1 Promise(executor)\r\n    Promise = function(executor){\r\n      assertFunction(executor);\r\n      assertInstance(this, Promise, PROMISE);\r\n      var def = {chain: [], state: 0, done: false, msg: undefined};\r\n      hidden(this, DEF, def);\r\n      try {\r\n        executor(ctx(resolve, def, 1), ctx(reject, def, 1));\r\n      } catch(err){\r\n        reject.call(def, err);\r\n      }\r\n    }\r\n    assignHidden(Promise[PROTOTYPE], {\r\n      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\r\n      then: function(onFulfilled, onRejected){\r\n        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];\r\n        var react = {\r\n          ok:   isFunction(onFulfilled) ? onFulfilled : true,\r\n          fail: isFunction(onRejected)  ? onRejected  : false\r\n        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){\r\n          react.res = assertFunction(resolve);\r\n          react.rej = assertFunction(reject);\r\n        }), def = this[DEF];\r\n        def.chain.push(react);\r\n        def.state && notify(def);\r\n        return P;\r\n      },\r\n      // 25.4.5.1 Promise.prototype.catch(onRejected)\r\n      'catch': function(onRejected){\r\n        return this.then(undefined, onRejected);\r\n      }\r\n    });\r\n    assignHidden(Promise, {\r\n      // 25.4.4.1 Promise.all(iterable)\r\n      all: function(iterable){\r\n        var Promise = getConstructor(this)\r\n          , values  = [];\r\n        return new Promise(function(resolve, reject){\r\n          forOf(iterable, false, push, values);\r\n          var remaining = values.length\r\n            , results   = Array(remaining);\r\n          if(remaining)forEach.call(values, function(promise, index){\r\n            Promise.resolve(promise).then(function(value){\r\n              results[index] = value;\r\n              --remaining || resolve(results);\r\n            }, reject);\r\n          });\r\n          else resolve(results);\r\n        });\r\n      },\r\n      // 25.4.4.4 Promise.race(iterable)\r\n      race: function(iterable){\r\n        var Promise = getConstructor(this);\r\n        return new Promise(function(resolve, reject){\r\n          forOf(iterable, false, function(promise){\r\n            Promise.resolve(promise).then(resolve, reject);\r\n          });\r\n        });\r\n      },\r\n      // 25.4.4.5 Promise.reject(r)\r\n      reject: function(r){\r\n        return new (getConstructor(this))(function(resolve, reject){\r\n          reject(r);\r\n        });\r\n      },\r\n      // 25.4.4.6 Promise.resolve(x)\r\n      resolve: function(x){\r\n        return isObject(x) && DEF in x && getPrototypeOf(x) === this[PROTOTYPE]\r\n          ? x : new (getConstructor(this))(function(resolve, reject){\r\n            resolve(x);\r\n          });\r\n      }\r\n    });\r\n  }(nextTick || setImmediate, safeSymbol('def'));\r\n  setToStringTag(Promise, PROMISE);\r\n  setSpecies(Promise);\r\n  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});\r\n}(global[PROMISE]);\n\n/******************************************************************************\n * Module : es6.collections                                                   *\n ******************************************************************************/\n\n// ECMAScript 6 collections shim\r\n!function(){\r\n  var UID   = safeSymbol('uid')\r\n    , O1    = safeSymbol('O1')\r\n    , WEAK  = safeSymbol('weak')\r\n    , LEAK  = safeSymbol('leak')\r\n    , LAST  = safeSymbol('last')\r\n    , FIRST = safeSymbol('first')\r\n    , SIZE  = DESC ? safeSymbol('size') : 'size'\r\n    , uid   = 0\r\n    , tmp   = {};\r\n  \r\n  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){\r\n    var ADDER = isMap ? 'set' : 'add'\r\n      , proto = C && C[PROTOTYPE]\r\n      , O     = {};\r\n    function initFromIterable(that, iterable){\r\n      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);\r\n      return that;\r\n    }\r\n    function fixSVZ(key, chain){\r\n      var method = proto[key];\r\n      if(framework)proto[key] = function(a, b){\r\n        var result = method.call(this, a === 0 ? 0 : a, b);\r\n        return chain ? this : result;\r\n      };\r\n    }\r\n    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){\r\n      // create collection constructor\r\n      C = isWeak\r\n        ? function(iterable){\r\n            assertInstance(this, C, NAME);\r\n            set(this, UID, uid++);\r\n            initFromIterable(this, iterable);\r\n          }\r\n        : function(iterable){\r\n            var that = this;\r\n            assertInstance(that, C, NAME);\r\n            set(that, O1, create(null));\r\n            set(that, SIZE, 0);\r\n            set(that, LAST, undefined);\r\n            set(that, FIRST, undefined);\r\n            initFromIterable(that, iterable);\r\n          };\r\n      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);\r\n      isWeak || defineProperty(C[PROTOTYPE], 'size', {get: function(){\r\n        return assertDefined(this[SIZE]);\r\n      }});\r\n    } else {\r\n      var Native = C\r\n        , inst   = new C\r\n        , chain  = inst[ADDER](isWeak ? {} : -0, 1)\r\n        , buggyZero;\r\n      // wrap to init collections from iterable\r\n      if(!NATIVE_ITERATORS || !C.length){\r\n        C = function(iterable){\r\n          assertInstance(this, C, NAME);\r\n          return initFromIterable(new Native, iterable);\r\n        }\r\n        C[PROTOTYPE] = proto;\r\n        if(framework)proto[CONSTRUCTOR] = C;\r\n      }\r\n      isWeak || inst[FOR_EACH](function(val, key){\r\n        buggyZero = 1 / key === -Infinity;\r\n      });\r\n      // fix converting -0 key to +0\r\n      if(buggyZero){\r\n        fixSVZ('delete');\r\n        fixSVZ('has');\r\n        isMap && fixSVZ('get');\r\n      }\r\n      // + fix .add & .set for chaining\r\n      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);\r\n    }\r\n    setToStringTag(C, NAME);\r\n    setSpecies(C);\r\n    \r\n    O[NAME] = C;\r\n    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);\r\n    \r\n    // add .keys, .values, .entries, [@@iterator]\r\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\r\n    isWeak || defineStdIterators(C, NAME, function(iterated, kind){\r\n      set(this, ITER, {o: iterated, k: kind});\r\n    }, function(){\r\n      var iter  = this[ITER]\r\n        , kind  = iter.k\r\n        , entry = iter.l;\r\n      // revert to the last existing entry\r\n      while(entry && entry.r)entry = entry.p;\r\n      // get next entry\r\n      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){\r\n        // or finish the iteration\r\n        iter.o = undefined;\r\n        return iterResult(1);\r\n      }\r\n      // return step by kind\r\n      if(kind == KEY)  return iterResult(0, entry.k);\r\n      if(kind == VALUE)return iterResult(0, entry.v);\r\n                       return iterResult(0, [entry.k, entry.v]);   \r\n    }, isMap ? KEY+VALUE : VALUE, !isMap);\r\n    \r\n    return C;\r\n  }\r\n  \r\n  function fastKey(it, create){\r\n    // return primitive with prefix\r\n    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;\r\n    // can't set id to frozen object\r\n    if(isFrozen(it))return 'F';\r\n    if(!has(it, UID)){\r\n      // not necessary to add id\r\n      if(!create)return 'E';\r\n      // add missing object id\r\n      hidden(it, UID, ++uid);\r\n    // return object id with prefix\r\n    } return 'O' + it[UID];\r\n  }\r\n  function getEntry(that, key){\r\n    // fast case\r\n    var index = fastKey(key), entry;\r\n    if(index != 'F')return that[O1][index];\r\n    // frozen object case\r\n    for(entry = that[FIRST]; entry; entry = entry.n){\r\n      if(entry.k == key)return entry;\r\n    }\r\n  }\r\n  function def(that, key, value){\r\n    var entry = getEntry(that, key)\r\n      , prev, index;\r\n    // change existing entry\r\n    if(entry)entry.v = value;\r\n    // create new entry\r\n    else {\r\n      that[LAST] = entry = {\r\n        i: index = fastKey(key, true), // <- index\r\n        k: key,                        // <- key\r\n        v: value,                      // <- value\r\n        p: prev = that[LAST],          // <- previous entry\r\n        n: undefined,                  // <- next entry\r\n        r: false                       // <- removed\r\n      };\r\n      if(!that[FIRST])that[FIRST] = entry;\r\n      if(prev)prev.n = entry;\r\n      that[SIZE]++;\r\n      // add to index\r\n      if(index != 'F')that[O1][index] = entry;\r\n    } return that;\r\n  }\r\n\r\n  var collectionMethods = {\r\n    // 23.1.3.1 Map.prototype.clear()\r\n    // 23.2.3.2 Set.prototype.clear()\r\n    clear: function(){\r\n      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){\r\n        entry.r = true;\r\n        if(entry.p)entry.p = entry.p.n = undefined;\r\n        delete data[entry.i];\r\n      }\r\n      that[FIRST] = that[LAST] = undefined;\r\n      that[SIZE] = 0;\r\n    },\r\n    // 23.1.3.3 Map.prototype.delete(key)\r\n    // 23.2.3.4 Set.prototype.delete(value)\r\n    'delete': function(key){\r\n      var that  = this\r\n        , entry = getEntry(that, key);\r\n      if(entry){\r\n        var next = entry.n\r\n          , prev = entry.p;\r\n        delete that[O1][entry.i];\r\n        entry.r = true;\r\n        if(prev)prev.n = next;\r\n        if(next)next.p = prev;\r\n        if(that[FIRST] == entry)that[FIRST] = next;\r\n        if(that[LAST] == entry)that[LAST] = prev;\r\n        that[SIZE]--;\r\n      } return !!entry;\r\n    },\r\n    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\r\n    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\r\n    forEach: function(callbackfn /*, that = undefined */){\r\n      var f = ctx(callbackfn, arguments[1], 3)\r\n        , entry;\r\n      while(entry = entry ? entry.n : this[FIRST]){\r\n        f(entry.v, entry.k, this);\r\n        // revert to the last existing entry\r\n        while(entry && entry.r)entry = entry.p;\r\n      }\r\n    },\r\n    // 23.1.3.7 Map.prototype.has(key)\r\n    // 23.2.3.7 Set.prototype.has(value)\r\n    has: function(key){\r\n      return !!getEntry(this, key);\r\n    }\r\n  }\r\n  \r\n  // 23.1 Map Objects\r\n  Map = getCollection(Map, MAP, {\r\n    // 23.1.3.6 Map.prototype.get(key)\r\n    get: function(key){\r\n      var entry = getEntry(this, key);\r\n      return entry && entry.v;\r\n    },\r\n    // 23.1.3.9 Map.prototype.set(key, value)\r\n    set: function(key, value){\r\n      return def(this, key === 0 ? 0 : key, value);\r\n    }\r\n  }, collectionMethods, true);\r\n  \r\n  // 23.2 Set Objects\r\n  Set = getCollection(Set, SET, {\r\n    // 23.2.3.1 Set.prototype.add(value)\r\n    add: function(value){\r\n      return def(this, value = value === 0 ? 0 : value, value);\r\n    }\r\n  }, collectionMethods);\r\n  \r\n  function defWeak(that, key, value){\r\n    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);\r\n    else {\r\n      has(key, WEAK) || hidden(key, WEAK, {});\r\n      key[WEAK][that[UID]] = value;\r\n    } return that;\r\n  }\r\n  function leakStore(that){\r\n    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];\r\n  }\r\n  \r\n  var weakMethods = {\r\n    // 23.3.3.2 WeakMap.prototype.delete(key)\r\n    // 23.4.3.3 WeakSet.prototype.delete(value)\r\n    'delete': function(key){\r\n      if(!isObject(key))return false;\r\n      if(isFrozen(key))return leakStore(this)['delete'](key);\r\n      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];\r\n    },\r\n    // 23.3.3.4 WeakMap.prototype.has(key)\r\n    // 23.4.3.4 WeakSet.prototype.has(value)\r\n    has: function(key){\r\n      if(!isObject(key))return false;\r\n      if(isFrozen(key))return leakStore(this).has(key);\r\n      return has(key, WEAK) && has(key[WEAK], this[UID]);\r\n    }\r\n  };\r\n  \r\n  // 23.3 WeakMap Objects\r\n  WeakMap = getCollection(WeakMap, WEAKMAP, {\r\n    // 23.3.3.3 WeakMap.prototype.get(key)\r\n    get: function(key){\r\n      if(isObject(key)){\r\n        if(isFrozen(key))return leakStore(this).get(key);\r\n        if(has(key, WEAK))return key[WEAK][this[UID]];\r\n      }\r\n    },\r\n    // 23.3.3.5 WeakMap.prototype.set(key, value)\r\n    set: function(key, value){\r\n      return defWeak(this, key, value);\r\n    }\r\n  }, weakMethods, true, true);\r\n  \r\n  // IE11 WeakMap frozen keys fix\r\n  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){\r\n    forEach.call(array('delete,has,get,set'), function(key){\r\n      var method = WeakMap[PROTOTYPE][key];\r\n      WeakMap[PROTOTYPE][key] = function(a, b){\r\n        // store frozen objects on leaky map\r\n        if(isObject(a) && isFrozen(a)){\r\n          var result = leakStore(this)[key](a, b);\r\n          return key == 'set' ? this : result;\r\n        // store all the rest on native weakmap\r\n        } return method.call(this, a, b);\r\n      };\r\n    });\r\n  }\r\n  \r\n  // 23.4 WeakSet Objects\r\n  WeakSet = getCollection(WeakSet, WEAKSET, {\r\n    // 23.4.3.1 WeakSet.prototype.add(value)\r\n    add: function(value){\r\n      return defWeak(this, value, true);\r\n    }\r\n  }, weakMethods, false, true);\r\n}();\n\n/******************************************************************************\n * Module : es6.reflect                                                       *\n ******************************************************************************/\n\n!function(){\r\n  function Enumerate(iterated){\r\n    var keys = [], key;\r\n    for(key in iterated)keys.push(key);\r\n    set(this, ITER, {o: iterated, a: keys, i: 0});\r\n  }\r\n  createIterator(Enumerate, OBJECT, function(){\r\n    var iter = this[ITER]\r\n      , keys = iter.a\r\n      , key;\r\n    do {\r\n      if(iter.i >= keys.length)return iterResult(1);\r\n    } while(!((key = keys[iter.i++]) in iter.o));\r\n    return iterResult(0, key);\r\n  });\r\n  \r\n  function wrap(fn){\r\n    return function(it){\r\n      assertObject(it);\r\n      try {\r\n        return fn.apply(undefined, arguments), true;\r\n      } catch(e){\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function reflectGet(target, propertyKey/*, receiver*/){\r\n    var receiver = arguments.length < 3 ? target : arguments[2]\r\n      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;\r\n    if(desc)return has(desc, 'value')\r\n      ? desc.value\r\n      : desc.get === undefined\r\n        ? undefined\r\n        : desc.get.call(receiver);\r\n    return isObject(proto = getPrototypeOf(target))\r\n      ? reflectGet(proto, propertyKey, receiver)\r\n      : undefined;\r\n  }\r\n  function reflectSet(target, propertyKey, V/*, receiver*/){\r\n    var receiver = arguments.length < 4 ? target : arguments[3]\r\n      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)\r\n      , existingDescriptor, proto;\r\n    if(!ownDesc){\r\n      if(isObject(proto = getPrototypeOf(target))){\r\n        return reflectSet(proto, propertyKey, V, receiver);\r\n      }\r\n      ownDesc = descriptor(0);\r\n    }\r\n    if(has(ownDesc, 'value')){\r\n      if(ownDesc.writable === false || !isObject(receiver))return false;\r\n      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);\r\n      existingDescriptor.value = V;\r\n      return defineProperty(receiver, propertyKey, existingDescriptor), true;\r\n    }\r\n    return ownDesc.set === undefined\r\n      ? false\r\n      : (ownDesc.set.call(receiver, V), true);\r\n  }\r\n  var isExtensible = Object.isExtensible || returnIt;\r\n  \r\n  var reflect = {\r\n    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\r\n    apply: ctx(call, apply, 3),\r\n    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\r\n    construct: construct,\r\n    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\r\n    defineProperty: wrap(defineProperty),\r\n    // 26.1.4 Reflect.deleteProperty(target, propertyKey)\r\n    deleteProperty: function(target, propertyKey){\r\n      var desc = getOwnDescriptor(assertObject(target), propertyKey);\r\n      return desc && !desc.configurable ? false : delete target[propertyKey];\r\n    },\r\n    // 26.1.5 Reflect.enumerate(target)\r\n    enumerate: function(target){\r\n      return new Enumerate(assertObject(target));\r\n    },\r\n    // 26.1.6 Reflect.get(target, propertyKey [, receiver])\r\n    get: reflectGet,\r\n    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\r\n    getOwnPropertyDescriptor: function(target, propertyKey){\r\n      return getOwnDescriptor(assertObject(target), propertyKey);\r\n    },\r\n    // 26.1.8 Reflect.getPrototypeOf(target)\r\n    getPrototypeOf: function(target){\r\n      return getPrototypeOf(assertObject(target));\r\n    },\r\n    // 26.1.9 Reflect.has(target, propertyKey)\r\n    has: function(target, propertyKey){\r\n      return propertyKey in target;\r\n    },\r\n    // 26.1.10 Reflect.isExtensible(target)\r\n    isExtensible: function(target){\r\n      return !!isExtensible(assertObject(target));\r\n    },\r\n    // 26.1.11 Reflect.ownKeys(target)\r\n    ownKeys: ownKeys,\r\n    // 26.1.12 Reflect.preventExtensions(target)\r\n    preventExtensions: wrap(Object.preventExtensions || returnIt),\r\n    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\r\n    set: reflectSet\r\n  }\r\n  // 26.1.14 Reflect.setPrototypeOf(target, proto)\r\n  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){\r\n    return setPrototypeOf(assertObject(target), proto), true;\r\n  };\r\n  \r\n  $define(GLOBAL, {Reflect: {}});\r\n  $define(STATIC, 'Reflect', reflect);\r\n}();\n\n/******************************************************************************\n * Module : es7.proposals                                                     *\n ******************************************************************************/\n\n!function(){\r\n  $define(PROTO, ARRAY, {\r\n    // https://github.com/domenic/Array.prototype.includes\r\n    includes: createArrayContains(true)\r\n  });\r\n  $define(PROTO, STRING, {\r\n    // https://github.com/mathiasbynens/String.prototype.at\r\n    at: createPointAt(true)\r\n  });\r\n  \r\n  function createObjectToArray(isEntries){\r\n    return function(object){\r\n      var O      = toObject(object)\r\n        , keys   = getKeys(object)\r\n        , length = keys.length\r\n        , i      = 0\r\n        , result = Array(length)\r\n        , key;\r\n      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];\r\n      else while(length > i)result[i] = O[keys[i++]];\r\n      return result;\r\n    }\r\n  }\r\n  $define(STATIC, OBJECT, {\r\n    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues\r\n    values: createObjectToArray(false),\r\n    entries: createObjectToArray(true)\r\n  });\r\n  $define(STATIC, REGEXP, {\r\n    // https://gist.github.com/kangax/9698100\r\n    escape: createReplacer(/([\\\\\\-[\\]{}()*+?.,^$|])/g, '\\\\$1', true)\r\n  });\r\n}();\n\n/******************************************************************************\n * Module : es7.abstract-refs                                                 *\n ******************************************************************************/\n\n// https://github.com/zenparsing/es-abstract-refs\r\n!function(REFERENCE){\r\n  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);\r\n  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)\r\n    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);\r\n  \r\n  $define(STATIC, SYMBOL, {\r\n    referenceGet: REFERENCE_GET,\r\n    referenceSet: REFERENCE_SET,\r\n    referenceDelete: REFERENCE_DELETE\r\n  });\r\n  \r\n  hidden(FunctionProto, REFERENCE_GET, returnThis);\r\n  \r\n  function setMapMethods(Constructor){\r\n    if(Constructor){\r\n      var MapProto = Constructor[PROTOTYPE];\r\n      hidden(MapProto, REFERENCE_GET, MapProto.get);\r\n      hidden(MapProto, REFERENCE_SET, MapProto.set);\r\n      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);\r\n    }\r\n  }\r\n  setMapMethods(Map);\r\n  setMapMethods(WeakMap);\r\n}('reference');\n\n/******************************************************************************\n * Module : js.array.statics                                                  *\n ******************************************************************************/\n\n// JavaScript 1.6 / Strawman array statics shim\r\n!function(arrayStatics){\r\n  function setArrayStatics(keys, length){\r\n    forEach.call(array(keys), function(key){\r\n      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);\r\n    });\r\n  }\r\n  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);\r\n  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);\r\n  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +\r\n                  'reduce,reduceRight,copyWithin,fill,turn');\r\n  $define(STATIC, ARRAY, arrayStatics);\r\n}({});\n\n/******************************************************************************\n * Module : web.dom.itarable                                                  *\n ******************************************************************************/\n\n!function(NodeList){\r\n  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){\r\n    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);\r\n  }\r\n  Iterators.NodeList = Iterators[ARRAY];\r\n}(global.NodeList);\n}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/babel-core/~/core-js/shim.js\n ** module id = 21\n ** module chunks = 0 1 2 3 7\n **/","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    return new Promise(function(resolve, reject) {\n      var generator = wrap(innerFn, outerFn, self, tryLocsList);\n      var callNext = step.bind(generator.next);\n      var callThrow = step.bind(generator[\"throw\"]);\n\n      function step(arg) {\n        var record = tryCatch(this, null, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n          return;\n        }\n\n        var info = record.arg;\n        if (info.done) {\n          resolve(info.value);\n        } else {\n          Promise.resolve(info.value).then(callNext, callThrow);\n        }\n      }\n\n      callNext();\n    });\n  };\n\n  function Generator(innerFn, outerFn, self, tryLocsList) {\n    var generator = outerFn ? Object.create(outerFn.prototype) : this;\n    var context = new Context(tryLocsList);\n    var state = GenStateSuspendedStart;\n\n    function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          if (state === GenStateSuspendedStart &&\n              typeof arg !== \"undefined\") {\n            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n            throw new TypeError(\n              \"attempt to send \" + JSON.stringify(arg) + \" to newborn generator\"\n            );\n          }\n\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            delete context.sent;\n          }\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n\n          if (method === \"next\") {\n            context.dispatchException(record.arg);\n          } else {\n            arg = record.arg;\n          }\n        }\n      }\n    }\n\n    generator.next = invoke.bind(generator, \"next\");\n    generator[\"throw\"] = invoke.bind(generator, \"throw\");\n    generator[\"return\"] = invoke.bind(generator, \"return\");\n\n    return generator;\n  }\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset();\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function() {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      // Pre-initialize at least 20 temporary variables to enable hidden\n      // class optimizations for simple generators.\n      for (var tempIndex = 0, tempName;\n           hasOwn.call(this, tempName = \"t\" + tempIndex) || tempIndex < 20;\n           ++tempIndex) {\n        this[tempName] = null;\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    _findFinallyEntry: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") && (\n              entry.finallyLoc === finallyLoc ||\n              this.prev < entry.finallyLoc)) {\n          return entry;\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      var entry = this._findFinallyEntry();\n      var record = entry ? entry.completion : {};\n\n      record.type = type;\n      record.arg = arg;\n\n      if (entry) {\n        this.next = entry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      var entry = this._findFinallyEntry(finallyLoc);\n      return this.complete(entry.completion, entry.afterLoc);\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window : this\n);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/babel-core/~/regenerator-babel/runtime.js\n ** module id = 22\n ** module chunks = 0 1 2 3 7\n **/","module.exports = require(\"./lib/babel/polyfill\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/babel-core/polyfill.js\n ** module id = 23\n ** module chunks = 0 1 2 3 7\n **/","\nimport 'babel-core/polyfill'\nimport debug    from 'debug'\nimport Bluebird from 'bluebird'\n\nglobal.DEBUG = debug\nglobal.Promise = Bluebird\n\nPromise.prototype.log = function(...args) {\n  return this.tap(value => console.log(...args.concat([value])))\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./polyfill/index.js\n **/","/* @preserve\n * The MIT License (MIT)\n * \n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n/**\n * bluebird build version 2.9.12\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, progress, cancel, using, filter, any, each, timers\n*/\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n},{}],2:[function(_dereq_,module,exports){\n\"use strict\";\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = _dereq_(\"./schedule.js\");\nvar Queue = _dereq_(\"./queue.js\");\nvar _process = typeof process !== \"undefined\" ? process : undefined;\n\nfunction Async() {\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule =\n        schedule.isStatic ? schedule(this.drainQueues) : schedule;\n}\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._normalQueue.length() > 0;\n};\n\nAsync.prototype._withDomain = function(fn) {\n    if (_process !== undefined &&\n        _process.domain != null &&\n        !fn.domain) {\n        fn = _process.domain.bind(fn);\n    }\n    return fn;\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    fn = this._withDomain(fn);\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n    }\n};\n\nAsync.prototype.invokeLater = function (fn, receiver, arg) {\n    fn = this._withDomain(fn);\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype.invokeFirst = function (fn, receiver, arg) {\n    fn = this._withDomain(fn);\n    this._normalQueue.unshift(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype.invoke = function (fn, receiver, arg) {\n    fn = this._withDomain(fn);\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype.settlePromises = function(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n};\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = new Async();\nmodule.exports.firstLineError = firstLineError;\n\n},{\"./queue.js\":28,\"./schedule.js\":31}],3:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise) {\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    this._setBoundTo(thisArg);\n    if (this._isPending()) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, ret._progress, ret, context);\n    } else {\n        ret._setBoundTo(thisArg);\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 131072;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~131072);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 131072) === 131072;\n};\n\nPromise.bind = function (thisArg, value) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n\n    if (maybePromise instanceof Promise) {\n        maybePromise._then(function(thisArg) {\n            ret._setBoundTo(thisArg);\n            ret._resolveCallback(value);\n        }, ret._reject, ret._progress, ret, null);\n    } else {\n        ret._setBoundTo(thisArg);\n        ret._resolveCallback(value);\n    }\n    return ret;\n};\n};\n\n},{}],4:[function(_dereq_,module,exports){\n\"use strict\";\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = _dereq_(\"./promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n},{\"./promise.js\":23}],5:[function(_dereq_,module,exports){\n\"use strict\";\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = _dereq_(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (!true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n    if (!true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n},{\"./util.js\":38}],6:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar errors = _dereq_(\"./errors.js\");\nvar async = _dereq_(\"./async.js\");\nvar CancellationError = errors.CancellationError;\n\nPromise.prototype._cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    var parent;\n    var promiseToReject = this;\n    while ((parent = promiseToReject._cancellationParent) !== undefined &&\n        parent.isCancellable()) {\n        promiseToReject = parent;\n    }\n    this._unsetCancellable();\n    promiseToReject._target()._rejectCallback(reason, false, true);\n};\n\nPromise.prototype.cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    if (reason === undefined) reason = new CancellationError();\n    async.invokeLater(this._cancel, this, reason);\n    return this;\n};\n\nPromise.prototype.cancellable = function () {\n    if (this._cancellable()) return this;\n    this._setCancellable();\n    this._cancellationParent = undefined;\n    return this;\n};\n\nPromise.prototype.uncancellable = function () {\n    var ret = this.then();\n    ret._unsetCancellable();\n    return ret;\n};\n\nPromise.prototype.fork = function (didFulfill, didReject, didProgress) {\n    var ret = this._then(didFulfill, didReject, didProgress,\n                         undefined, undefined);\n\n    ret._setCancellable();\n    ret._cancellationParent = undefined;\n    return ret;\n};\n};\n\n},{\"./async.js\":2,\"./errors.js\":13}],7:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function() {\nvar async = _dereq_(\"./async.js\");\nvar util = _dereq_(\"./util.js\");\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar warn;\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.parent = function() {\n    return this._parent;\n};\n\nCapturedTrace.prototype.hasParent = function() {\n    return this._parent !== undefined;\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = CapturedTrace.parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    error.stack = reconstructStack(message, stacks);\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = stackFramePattern.test(line) ||\n            \"    (No stack trace)\" === line;\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0) {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nCapturedTrace.parseStackAndMessage = function(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: cleanStack(stack)\n    };\n};\n\nCapturedTrace.formatAndLogError = function(error, title) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (typeof error === \"object\" || typeof error === \"function\") {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof warn === \"function\") {\n            warn(message);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n};\n\nCapturedTrace.unhandledRejection = function (reason) {\n    CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n};\n\nCapturedTrace.isSupported = function () {\n    return typeof captureStackTrace === \"function\";\n};\n\nCapturedTrace.fireRejectionEvent =\nfunction(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent(name, reason, promise);\n    } catch (e) {\n        globalEventFired = true;\n        async.throwLater(e);\n    }\n\n    var domEventFired = false;\n    if (fireDomEvent) {\n        try {\n            domEventFired = fireDomEvent(name.toLowerCase(), {\n                reason: reason,\n                promise: promise\n            });\n        } catch (e) {\n            domEventFired = true;\n            async.throwLater(e);\n        }\n    }\n\n    if (!globalEventFired && !localEventFired && !domEventFired &&\n        name === \"unhandledRejection\") {\n        CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n    }\n};\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj.toString();\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\nCapturedTrace.setBounds = function(firstLineError, lastLineError) {\n    if (!CapturedTrace.isSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit = Error.stackTraceLimit + 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow) {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nvar fireDomEvent;\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function(name, reason, promise) {\n            if (name === \"rejectionHandled\") {\n                return process.emit(name, promise);\n            } else {\n                return process.emit(name, reason, promise);\n            }\n        };\n    } else {\n        var customEventWorks = false;\n        var anyEventWorks = true;\n        try {\n            var ev = new self.CustomEvent(\"test\");\n            customEventWorks = ev instanceof CustomEvent;\n        } catch (e) {}\n        if (!customEventWorks) {\n            try {\n                var event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(\"testingtheevent\", false, true, {});\n                self.dispatchEvent(event);\n            } catch (e) {\n                anyEventWorks = false;\n            }\n        }\n        if (anyEventWorks) {\n            fireDomEvent = function(type, detail) {\n                var event;\n                if (customEventWorks) {\n                    event = new self.CustomEvent(type, {\n                        detail: detail,\n                        bubbles: false,\n                        cancelable: true\n                    });\n                } else if (self.dispatchEvent) {\n                    event = document.createEvent(\"CustomEvent\");\n                    event.initCustomEvent(type, false, true, detail);\n                }\n\n                return event ? !self.dispatchEvent(event) : false;\n            };\n        }\n\n        var toWindowMethodNameMap = {};\n        toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" +\n            \"unhandledRejection\").toLowerCase();\n        toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" +\n            \"rejectionHandled\").toLowerCase();\n\n        return function(name, reason, promise) {\n            var methodName = toWindowMethodNameMap[name];\n            var method = self[methodName];\n            if (!method) return false;\n            if (name === \"rejectionHandled\") {\n                method.call(self, promise);\n            } else {\n                method.call(self, reason, promise);\n            }\n            return true;\n        };\n    }\n})();\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    warn = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        warn = function(message) {\n            process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        warn = function(message) {\n            console.warn(\"%c\" + message, \"color: red\");\n        };\n    }\n}\n\nreturn CapturedTrace;\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],8:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(NEXT_FILTER) {\nvar util = _dereq_(\"./util.js\");\nvar errors = _dereq_(\"./errors.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar keys = _dereq_(\"./es5.js\").keys;\nvar TypeError = errors.TypeError;\n\nfunction CatchFilter(instances, callback, promise) {\n    this._instances = instances;\n    this._callback = callback;\n    this._promise = promise;\n}\n\nfunction safePredicate(predicate, e) {\n    var safeObject = {};\n    var retfilter = tryCatch(predicate).call(safeObject, e);\n\n    if (retfilter === errorObj) return retfilter;\n\n    var safeKeys = keys(safeObject);\n    if (safeKeys.length) {\n        errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n        return errorObj;\n    }\n    return retfilter;\n}\n\nCatchFilter.prototype.doFilter = function (e) {\n    var cb = this._callback;\n    var promise = this._promise;\n    var boundTo = promise._boundTo;\n    for (var i = 0, len = this._instances.length; i < len; ++i) {\n        var item = this._instances[i];\n        var itemIsErrorType = item === Error ||\n            (item != null && item.prototype instanceof Error);\n\n        if (itemIsErrorType && e instanceof item) {\n            var ret = tryCatch(cb).call(boundTo, e);\n            if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n            }\n            return ret;\n        } else if (typeof item === \"function\" && !itemIsErrorType) {\n            var shouldHandle = safePredicate(item, e);\n            if (shouldHandle === errorObj) {\n                e = errorObj.e;\n                break;\n            } else if (shouldHandle) {\n                var ret = tryCatch(cb).call(boundTo, e);\n                if (ret === errorObj) {\n                    NEXT_FILTER.e = ret.e;\n                    return NEXT_FILTER;\n                }\n                return ret;\n            }\n        }\n    }\n    NEXT_FILTER.e = e;\n    return NEXT_FILTER;\n};\n\nreturn CatchFilter;\n};\n\n},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],9:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, CapturedTrace, isDebugging) {\nvar contextStack = [];\nfunction Context() {\n    this._trace = new CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.pop();\n    }\n};\n\nfunction createContext() {\n    if (isDebugging()) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\n\nPromise.prototype._peekContext = peekContext;\nPromise.prototype._pushContext = Context.prototype._pushContext;\nPromise.prototype._popContext = Context.prototype._popContext;\n\nreturn createContext;\n};\n\n},{}],10:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, CapturedTrace) {\nvar async = _dereq_(\"./async.js\");\nvar Warning = _dereq_(\"./errors.js\").Warning;\nvar util = _dereq_(\"./util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar debugging = false || (util.isNode &&\n                    (!!process.env[\"BLUEBIRD_DEBUG\"] ||\n                     process.env[\"NODE_ENV\"] === \"development\"));\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    CapturedTrace.fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._getCarriedStackTrace() || this._settledValue;\n        this._setUnhandledRejectionIsNotified();\n        CapturedTrace.fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 524288;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~524288);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 524288) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 2097152;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~2097152);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 2097152) > 0;\n};\n\nPromise.prototype._setCarriedStackTrace = function (capturedTrace) {\n    this._bitField = this._bitField | 1048576;\n    this._fulfillmentHandler0 = capturedTrace;\n};\n\nPromise.prototype._isCarryingStackTrace = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._getCarriedStackTrace = function () {\n    return this._isCarryingStackTrace()\n        ? this._fulfillmentHandler0\n        : undefined;\n};\n\nPromise.prototype._captureStackTrace = function () {\n    if (debugging) {\n        this._trace = new CapturedTrace(this._peekContext());\n    }\n    return this;\n};\n\nPromise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n    if (debugging && canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = CapturedTrace.parseStackAndMessage(error);\n            error.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n};\n\nPromise.prototype._warn = function(message) {\n    var warning = new Warning(message);\n    var ctx = this._peekContext();\n    if (ctx) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = CapturedTrace.parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n    CapturedTrace.formatAndLogError(warning, \"\");\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    possiblyUnhandledRejection = typeof fn === \"function\" ? fn : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    unhandledRejectionHandled = typeof fn === \"function\" ? fn : undefined;\n};\n\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() &&\n        debugging === false\n   ) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n    }\n    debugging = CapturedTrace.isSupported();\n};\n\nPromise.hasLongStackTraces = function () {\n    return debugging && CapturedTrace.isSupported();\n};\n\nif (!CapturedTrace.isSupported()) {\n    Promise.longStackTraces = function(){};\n    debugging = false;\n}\n\nreturn function() {\n    return debugging;\n};\n};\n\n},{\"./async.js\":2,\"./errors.js\":13,\"./util.js\":38}],11:[function(_dereq_,module,exports){\n\"use strict\";\nvar util = _dereq_(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\nvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\n\nmodule.exports = function(Promise) {\nvar returner = function () {\n    return this;\n};\nvar thrower = function () {\n    throw this;\n};\n\nvar wrapper = function (value, action) {\n    if (action === 1) {\n        return function () {\n            throw value;\n        };\n    } else if (action === 2) {\n        return function () {\n            return value;\n        };\n    }\n};\n\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (wrapsPrimitiveReceiver && isPrimitive(value)) {\n        return this._then(\n            wrapper(value, 2),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    }\n    return this._then(returner, undefined, undefined, value, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {\n        return this._then(\n            wrapper(reason, 1),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    }\n    return this._then(thrower, undefined, undefined, reason, undefined);\n};\n};\n\n},{\"./util.js\":38}],12:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, null, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, null, INTERNAL);\n};\n};\n\n},{}],13:[function(_dereq_,module,exports){\n\"use strict\";\nvar es5 = _dereq_(\"./es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = _dereq_(\"./util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n},{\"./es5.js\":14,\"./util.js\":38}],14:[function(_dereq_,module,exports){\nvar isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n},{}],15:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n},{}],16:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {\nvar util = _dereq_(\"./util.js\");\nvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\nvar isPrimitive = util.isPrimitive;\nvar thrower = util.thrower;\n\nfunction returnThis() {\n    return this;\n}\nfunction throwThis() {\n    throw this;\n}\nfunction return$(r) {\n    return function() {\n        return r;\n    };\n}\nfunction throw$(r) {\n    return function() {\n        throw r;\n    };\n}\nfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n    var then;\n    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {\n        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n    } else {\n        then = isFulfilled ? returnThis : throwThis;\n    }\n    return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n}\n\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundTo)\n                    : handler();\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, reasonOrValue,\n                                    promise.isFulfilled());\n        }\n    }\n\n    if (promise.isRejected()) {\n        NEXT_FILTER.e = reasonOrValue;\n        return NEXT_FILTER;\n    } else {\n        return reasonOrValue;\n    }\n}\n\nfunction tapHandler(value) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundTo, value)\n                    : handler(value);\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, value, true);\n        }\n    }\n    return value;\n}\n\nPromise.prototype._passThroughHandler = function (handler, isFinally) {\n    if (typeof handler !== \"function\") return this.then();\n\n    var promiseAndHandler = {\n        promise: this,\n        handler: handler\n    };\n\n    return this._then(\n            isFinally ? finallyHandler : tapHandler,\n            isFinally ? finallyHandler : undefined, undefined,\n            promiseAndHandler, undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThroughHandler(handler, true);\n};\n\nPromise.prototype.tap = function (handler) {\n    return this._passThroughHandler(handler, false);\n};\n};\n\n},{\"./util.js\":38}],17:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise) {\nvar errors = _dereq_(\"./errors.js\");\nvar TypeError = errors.TypeError;\nvar util = _dereq_(\"./util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    var promise = this._promise = new Promise(INTERNAL);\n    promise._captureStackTrace();\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n}\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._next(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    if (result === errorObj) {\n        return this._promise._rejectCallback(result.e, false, true);\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._promise._resolveCallback(value);\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._throw(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise._then(\n            this._next,\n            this._throw,\n            undefined,\n            this,\n            null\n       );\n    }\n};\n\nPromiseSpawn.prototype._throw = function (reason) {\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._next = function (value) {\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        spawn._generator = generator;\n        spawn._next(undefined);\n        return spawn.promise();\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],18:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (!true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var caller = function(count) {\n        var values = [];\n        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n        return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n    };\n    var thenCallbacks = [];\n    var callers = [undefined];\n    for (var i = 1; i <= 5; ++i) {\n        thenCallbacks.push(thenCallback(i));\n        callers.push(caller(i));\n    }\n\n    var Holder = function(total, fn) {\n        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n        this.fn = fn;\n        this.total = total;\n        this.now = 0;\n    };\n\n    Holder.prototype.callers = callers;\n    Holder.prototype.checkFulfillment = function(promise) {\n        var now = this.now;\n        now++;\n        var total = this.total;\n        if (now >= total) {\n            var handler = this.callers[total];\n            promise._pushContext();\n            var ret = tryCatch(handler)(this);\n            promise._popContext();\n            if (ret === errorObj) {\n                promise._rejectCallback(ret.e, false, true);\n            } else {\n                promise._resolveCallback(ret);\n            }\n        } else {\n            this.now = now;\n        }\n    };\n\n    var reject = function (reason) {\n        this._reject(reason);\n    };\n}\n}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (!true) {\n            if (last < 6 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var holder = new Holder(last, fn);\n                var callbacks = thenCallbacks;\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        if (maybePromise._isPending()) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                        } else if (maybePromise._isFulfilled()) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else {\n                            ret._reject(maybePromise._reason());\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n},{\"./util.js\":38}],19:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar PENDING = {};\nvar EMPTY_ARRAY = [];\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    this._callback = fn;\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n    this._init$(undefined, -2);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (values[index] === PENDING) {\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var callback = this._callback;\n        var receiver = this._promise._boundTo;\n        this._promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        this._promise._popContext();\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n\n    }\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    var limit = typeof options === \"object\" && options !== null\n        ? options.concurrency\n        : 0;\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter);\n}\n\nPromise.prototype.map = function (fn, options) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n    return map(this, fn, options, null).promise();\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    return map(promises, fn, options, _filter).promise();\n};\n\n\n};\n\n},{\"./util.js\":38}],20:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        ret._popContext();\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value = util.isArray(args)\n        ? tryCatch(fn).apply(ctx, args)\n        : tryCatch(fn).call(ctx, args);\n    ret._popContext();\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false, true);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n},{\"./util.js\":38}],21:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar util = _dereq_(\"./util.js\");\nvar async = _dereq_(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundTo;\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var target = promise._target();\n        var newReason = target._getCarriedStackTrace();\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundTo, reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.nodeify = function (nodeback, options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],22:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray) {\nvar util = _dereq_(\"./util.js\");\nvar async = _dereq_(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nPromise.prototype.progressed = function (handler) {\n    return this._then(undefined, undefined, handler, undefined, undefined);\n};\n\nPromise.prototype._progress = function (progressValue) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._target()._progressUnchecked(progressValue);\n\n};\n\nPromise.prototype._progressHandlerAt = function (index) {\n    return index === 0\n        ? this._progressHandler0\n        : this[(index << 2) + index - 5 + 2];\n};\n\nPromise.prototype._doProgressWith = function (progression) {\n    var progressValue = progression.value;\n    var handler = progression.handler;\n    var promise = progression.promise;\n    var receiver = progression.receiver;\n\n    var ret = tryCatch(handler).call(receiver, progressValue);\n    if (ret === errorObj) {\n        if (ret.e != null &&\n            ret.e.name !== \"StopProgressPropagation\") {\n            var trace = util.canAttachTrace(ret.e)\n                ? ret.e : new Error(util.toString(ret.e));\n            promise._attachExtraTrace(trace);\n            promise._progress(ret.e);\n        }\n    } else if (ret instanceof Promise) {\n        ret._then(promise._progress, null, null, promise, undefined);\n    } else {\n        promise._progress(ret);\n    }\n};\n\n\nPromise.prototype._progressUnchecked = function (progressValue) {\n    var len = this._length();\n    var progress = this._progress;\n    for (var i = 0; i < len; i++) {\n        var handler = this._progressHandlerAt(i);\n        var promise = this._promiseAt(i);\n        if (!(promise instanceof Promise)) {\n            var receiver = this._receiverAt(i);\n            if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n            } else if (receiver instanceof PromiseArray &&\n                       !receiver._isResolved()) {\n                receiver._promiseProgressed(progressValue, promise);\n            }\n            continue;\n        }\n\n        if (typeof handler === \"function\") {\n            async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n            });\n        } else {\n            async.invoke(progress, promise, progressValue);\n        }\n    }\n};\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],23:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n};\nvar reflect = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nvar util = _dereq_(\"./util.js\");\nvar async = _dereq_(\"./async.js\");\nvar errors = _dereq_(\"./errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nPromise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {e: null};\nvar tryConvertToPromise = _dereq_(\"./thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    _dereq_(\"./promise_array.js\")(Promise, INTERNAL,\n                                    tryConvertToPromise, apiRejection);\nvar CapturedTrace = _dereq_(\"./captured_trace.js\")();\nvar isDebugging = _dereq_(\"./debuggability.js\")(Promise, CapturedTrace);\n /*jshint unused:false*/\nvar createContext =\n    _dereq_(\"./context.js\")(Promise, CapturedTrace, isDebugging);\nvar CatchFilter = _dereq_(\"./catch_filter.js\")(NEXT_FILTER);\nvar PromiseResolver = _dereq_(\"./promise_resolver.js\");\nvar nodebackForPromise = PromiseResolver._nodebackForPromise;\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction Promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n    }\n    if (this.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._progressHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settledValue = undefined;\n    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(\n                    new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        var catchFilter = new CatchFilter(catchInstances, fn, this);\n        return this._then(undefined, catchFilter.doFilter, undefined,\n            catchFilter, undefined);\n    }\n    return this._then(undefined, fn, undefined, undefined, undefined);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflect, reflect, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject, didProgress) {\n    if (isDebugging() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject, didProgress) {\n    var promise = this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (didFulfill, didReject) {\n    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n};\n\nPromise.prototype.isCancellable = function () {\n    return !this.isResolved() &&\n        this._cancellable();\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = function(fn) {\n    var ret = new Promise(INTERNAL);\n    var result = tryCatch(fn)(nodebackForPromise(ret));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true, true);\n    }\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.defer = Promise.pending = function () {\n    var promise = new Promise(INTERNAL);\n    return new PromiseResolver(promise);\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        var val = ret;\n        ret = new Promise(INTERNAL);\n        ret._fulfillUnchecked(val);\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var prev = async._schedule;\n    async._schedule = fn;\n    return prev;\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    didProgress,\n    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n    if (!haveInternalData) {\n        ret._propagateFrom(this, 4 | 1);\n        ret._captureStackTrace();\n    }\n\n    var target = this._target();\n    if (target !== this) {\n        if (receiver === undefined) receiver = this._boundTo;\n        if (!haveInternalData) ret._setIsMigrated();\n    }\n\n    var callbackIndex =\n        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);\n\n    if (target._isResolved() && !target._isSettlePromisesQueued()) {\n        async.invoke(\n            target._settlePromiseAtPostResolution, target, callbackIndex);\n    }\n\n    return ret;\n};\n\nPromise.prototype._settlePromiseAtPostResolution = function (index) {\n    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n    this._settlePromiseAt(index);\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 131071;\n};\n\nPromise.prototype._isFollowingOrFulfilledOrRejected = function () {\n    return (this._bitField & 939524096) > 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 536870912) === 536870912;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -131072) |\n        (len & 131071);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 536870912;\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 33554432;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 33554432) > 0;\n};\n\nPromise.prototype._cancellable = function () {\n    return (this._bitField & 67108864) > 0;\n};\n\nPromise.prototype._setCancellable = function () {\n    this._bitField = this._bitField | 67108864;\n};\n\nPromise.prototype._unsetCancellable = function () {\n    this._bitField = this._bitField & (~67108864);\n};\n\nPromise.prototype._setIsMigrated = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._unsetIsMigrated = function () {\n    this._bitField = this._bitField & (~4194304);\n};\n\nPromise.prototype._isMigrated = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0\n        ? this._receiver0\n        : this[\n            index * 5 - 5 + 4];\n    if (ret === undefined && this._isBound()) {\n        return this._boundTo;\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return index === 0\n        ? this._promise0\n        : this[index * 5 - 5 + 3];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return index === 0\n        ? this._fulfillmentHandler0\n        : this[index * 5 - 5 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return index === 0\n        ? this._rejectionHandler0\n        : this[index * 5 - 5 + 1];\n};\n\nPromise.prototype._migrateCallbacks = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var progress = follower._progressHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (promise instanceof Promise) promise._setIsMigrated();\n    this._addCallbacks(fulfill, reject, progress, promise, receiver);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    progress,\n    promise,\n    receiver\n) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        if (receiver !== undefined) this._receiver0 = receiver;\n        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace())\n            this._fulfillmentHandler0 = fulfill;\n        if (typeof reject === \"function\") this._rejectionHandler0 = reject;\n        if (typeof progress === \"function\") this._progressHandler0 = progress;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promise;\n        this[base + 4] = receiver;\n        if (typeof fulfill === \"function\")\n            this[base + 0] = fulfill;\n        if (typeof reject === \"function\")\n            this[base + 1] = reject;\n        if (typeof progress === \"function\")\n            this[base + 2] = progress;\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n    if (index === 0) {\n        this._promise0 = promiseSlotValue;\n        this._receiver0 = receiver;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promiseSlotValue;\n        this[base + 4] = receiver;\n    }\n    this._setLength(index + 1);\n};\n\nPromise.prototype._proxyPromiseArray = function (promiseArray, index) {\n    this._setProxyHandlers(promiseArray, index);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false, true);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    var propagationFlags = 1 | (shouldBind ? 4 : 0);\n    this._propagateFrom(maybePromise, propagationFlags);\n    var promise = maybePromise._target();\n    if (promise._isPending()) {\n        var len = this._length();\n        for (var i = 0; i < len; ++i) {\n            promise._migrateCallbacks(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (promise._isFulfilled()) {\n        this._fulfillUnchecked(promise._value());\n    } else {\n        this._rejectUnchecked(promise._reason(),\n            promise._getCarriedStackTrace());\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n    if (!shouldNotMarkOriginatingFromRejection) {\n        util.markAsOriginatingFromRejection(reason);\n    }\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason, hasStack ? undefined : trace);\n};\n\nPromise.prototype._resolveFromResolver = function (resolver) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = tryCatch(resolver)(function(value) {\n        if (promise === null) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }, function (reason) {\n        if (promise === null) return;\n        promise._rejectCallback(reason, synchronous);\n        promise = null;\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined && r === errorObj && promise !== null) {\n        promise._rejectCallback(r.e, true, true);\n        promise = null;\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    if (promise._isRejected()) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY && !this._isRejected()) {\n        x = tryCatch(handler).apply(this._boundTo, value);\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    promise._popContext();\n\n    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n        var err = x === promise ? makeSelfResolutionError() : x.e;\n        promise._rejectCallback(err, false, true);\n    } else {\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._cleanValues = function () {\n    if (this._cancellable()) {\n        this._cancellationParent = undefined;\n    }\n};\n\nPromise.prototype._propagateFrom = function (parent, flags) {\n    if ((flags & 1) > 0 && parent._cancellable()) {\n        this._setCancellable();\n        this._cancellationParent = parent;\n    }\n    if ((flags & 4) > 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n};\n\nPromise.prototype._fulfill = function (value) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._fulfillUnchecked(value);\n};\n\nPromise.prototype._reject = function (reason, carriedStackTrace) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._rejectUnchecked(reason, carriedStackTrace);\n};\n\nPromise.prototype._settlePromiseAt = function (index) {\n    var promise = this._promiseAt(index);\n    var isPromise = promise instanceof Promise;\n\n    if (isPromise && promise._isMigrated()) {\n        promise._unsetIsMigrated();\n        return async.invoke(this._settlePromiseAt, this, index);\n    }\n    var handler = this._isFulfilled()\n        ? this._fulfillmentHandlerAt(index)\n        : this._rejectionHandlerAt(index);\n\n    var carriedStackTrace =\n        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n    var value = this._settledValue;\n    var receiver = this._receiverAt(index);\n\n\n    this._clearCallbackDataAtIndex(index);\n\n    if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof PromiseArray) {\n        if (!receiver._isResolved()) {\n            if (this._isFulfilled()) {\n                receiver._promiseFulfilled(value, promise);\n            }\n            else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (this._isFulfilled()) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value, carriedStackTrace);\n        }\n    }\n\n    if (index >= 4 && (index & 31) === 4)\n        async.invokeLater(this._setLength, this, 0);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    if (index === 0) {\n        if (!this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 = undefined;\n        }\n        this._rejectionHandler0 =\n        this._progressHandler0 =\n        this._receiver0 =\n        this._promise0 = undefined;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] =\n        this[base + 4] =\n        this[base + 0] =\n        this[base + 1] =\n        this[base + 2] = undefined;\n    }\n};\n\nPromise.prototype._isSettlePromisesQueued = function () {\n    return (this._bitField &\n            -1073741824) === -1073741824;\n};\n\nPromise.prototype._setSettlePromisesQueued = function () {\n    this._bitField = this._bitField | -1073741824;\n};\n\nPromise.prototype._unsetSettlePromisesQueued = function () {\n    this._bitField = this._bitField & (~-1073741824);\n};\n\nPromise.prototype._queueSettlePromises = function() {\n    async.settlePromises(this);\n    this._setSettlePromisesQueued();\n};\n\nPromise.prototype._fulfillUnchecked = function (value) {\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err, undefined);\n    }\n    this._setFulfilled();\n    this._settledValue = value;\n    this._cleanValues();\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    }\n};\n\nPromise.prototype._rejectUncheckedCheckError = function (reason) {\n    var trace = util.ensureErrorObject(reason);\n    this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n};\n\nPromise.prototype._rejectUnchecked = function (reason, trace) {\n    if (reason === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err);\n    }\n    this._setRejected();\n    this._settledValue = reason;\n    this._cleanValues();\n\n    if (this._isFinal()) {\n        async.throwLater(function(e) {\n            if (\"stack\" in e) {\n                async.invokeFirst(\n                    CapturedTrace.unhandledRejection, undefined, e);\n            }\n            throw e;\n        }, trace === undefined ? reason : trace);\n        return;\n    }\n\n    if (trace !== undefined && trace !== reason) {\n        this._setCarriedStackTrace(trace);\n    }\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    this._unsetSettlePromisesQueued();\n    var len = this._length();\n    for (var i = 0; i < len; i++) {\n        this._settlePromiseAt(i);\n    }\n};\n\nPromise._makeSelfResolutionError = makeSelfResolutionError;\n_dereq_(\"./method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n_dereq_(\"./bind.js\")(Promise, INTERNAL, tryConvertToPromise);\n_dereq_(\"./finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\n_dereq_(\"./direct_resolve.js\")(Promise);\n_dereq_(\"./synchronous_inspection.js\")(Promise);\n_dereq_(\"./join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\nPromise.Promise = Promise;\n_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);\n_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);\n_dereq_('./nodeify.js')(Promise);\n_dereq_('./cancel.js')(Promise);\n_dereq_('./promisify.js')(Promise, INTERNAL);\n_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n_dereq_('./settle.js')(Promise, PromiseArray);\n_dereq_('./call_get.js')(Promise);\n_dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n_dereq_('./progress.js')(Promise, PromiseArray);\n_dereq_('./any.js')(Promise);\n_dereq_('./each.js')(Promise, INTERNAL);\n_dereq_('./timers.js')(Promise, INTERNAL);\n_dereq_('./filter.js')(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._progressHandler0 = value;                                         \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n        p._settledValue = value;                                             \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       \n    return Promise;                                                          \n\n};\n\n},{\"./any.js\":1,\"./async.js\":2,\"./bind.js\":3,\"./call_get.js\":5,\"./cancel.js\":6,\"./captured_trace.js\":7,\"./catch_filter.js\":8,\"./context.js\":9,\"./debuggability.js\":10,\"./direct_resolve.js\":11,\"./each.js\":12,\"./errors.js\":13,\"./filter.js\":15,\"./finally.js\":16,\"./generators.js\":17,\"./join.js\":18,\"./map.js\":19,\"./method.js\":20,\"./nodeify.js\":21,\"./progress.js\":22,\"./promise_array.js\":24,\"./promise_resolver.js\":25,\"./promisify.js\":26,\"./props.js\":27,\"./race.js\":29,\"./reduce.js\":30,\"./settle.js\":32,\"./some.js\":33,\"./synchronous_inspection.js\":34,\"./thenables.js\":35,\"./timers.js\":36,\"./using.js\":37,\"./util.js\":38}],24:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    var parent;\n    if (values instanceof Promise) {\n        parent = values;\n        promise._propagateFrom(parent, 1 | 4);\n    }\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        this._values = values;\n        if (values._isFulfilled()) {\n            values = values._value();\n            if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n                this.__hardReject__(err);\n                return;\n            }\n        } else if (values._isPending()) {\n            values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n            return;\n        } else {\n            this._reject(values._reason());\n            return;\n        }\n    } else if (!isArray(values)) {\n        this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var promise = this._promise;\n    for (var i = 0; i < len; ++i) {\n        var isResolved = this._isResolved();\n        var maybePromise = tryConvertToPromise(values[i], promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (isResolved) {\n                maybePromise._unsetRejectionIsUnhandled();\n            } else if (maybePromise._isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                this._promiseFulfilled(maybePromise._value(), i);\n            } else {\n                this._promiseRejected(maybePromise._reason(), i);\n            }\n        } else if (!isResolved) {\n            this._promiseFulfilled(maybePromise, i);\n        }\n    }\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype.__hardReject__ =\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false, true);\n};\n\nPromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n    this._promise._progress({\n        index: index,\n        value: progressValue\n    });\n};\n\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nPromiseArray.prototype._promiseRejected = function (reason, index) {\n    this._totalResolved++;\n    this._reject(reason);\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n},{\"./util.js\":38}],25:[function(_dereq_,module,exports){\n\"use strict\";\nvar util = _dereq_(\"./util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = _dereq_(\"./errors.js\");\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar haveGetters = util.haveGetters;\nvar es5 = _dereq_(\"./es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise) {\n    return function(err, value) {\n        if (promise === null) return;\n\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (arguments.length > 2) {\n            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n            promise._fulfill(args);\n        } else {\n            promise._fulfill(value);\n        }\n\n        promise = null;\n    };\n}\n\n\nvar PromiseResolver;\nif (!haveGetters) {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n        this.asCallback = nodebackForPromise(promise);\n        this.callback = this.asCallback;\n    };\n}\nelse {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n    };\n}\nif (haveGetters) {\n    var prop = {\n        get: function() {\n            return nodebackForPromise(this.promise);\n        }\n    };\n    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n}\n\nPromiseResolver._nodebackForPromise = nodebackForPromise;\n\nPromiseResolver.prototype.toString = function () {\n    return \"[object PromiseResolver]\";\n};\n\nPromiseResolver.prototype.resolve =\nPromiseResolver.prototype.fulfill = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._resolveCallback(value);\n};\n\nPromiseResolver.prototype.reject = function (reason) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._rejectCallback(reason);\n};\n\nPromiseResolver.prototype.progress = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._progress(value);\n};\n\nPromiseResolver.prototype.cancel = function (err) {\n    this.promise.cancel(err);\n};\n\nPromiseResolver.prototype.timeout = function () {\n    this.reject(new TimeoutError(\"timeout\"));\n};\n\nPromiseResolver.prototype.isResolved = function () {\n    return this.promise.isResolved();\n};\n\nPromiseResolver.prototype.toJSON = function () {\n    return this.promise.toJSON();\n};\n\nmodule.exports = PromiseResolver;\n\n},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],26:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = _dereq_(\"./util.js\");\nvar nodebackForPromise = _dereq_(\"./promise_resolver.js\")\n    ._nodebackForPromise;\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = _dereq_(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyPropsPattern =\n    /^(?:length|name|arguments|caller|prototype|__isPromisified__)$/;\nvar defaultFilter = function(name, func) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        !util.isClass(func);\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (!true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"INTERNAL\",\"'use strict';                            \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise);                      \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        ret.__isPromisified__ = true;                                        \\n\\\n        return ret;                                                          \\n\\\n        \"\n        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode))(\n            Promise,\n            fn,\n            receiver,\n            withAppended,\n            maybeWrapAsError,\n            nodebackForPromise,\n            util.tryCatch,\n            util.errorObj,\n            INTERNAL\n        );\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        return promise;\n    }\n    promisified.__isPromisified__ = true;\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        obj[promisifiedKey] = promisifier === makeNodePromisified\n                ? makeNodePromisified(key, THIS, key, fn, suffix)\n                : promisifier(fn, function() {\n                    return makeNodePromisified(key, THIS, key, fn, suffix);\n                });\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver) {\n    return makeNodePromisified(callback, receiver, undefined, callback);\n}\n\nPromise.promisify = function (fn, receiver) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n    }\n    options = Object(options);\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier);\n            promisifyAll(value, suffix, filter, promisifier);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier);\n};\n};\n\n\n},{\"./errors\":13,\"./promise_resolver.js\":25,\"./util.js\":38}],27:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar isObject = util.isObject;\nvar es5 = _dereq_(\"./es5.js\");\n\nfunction PropertiesPromiseArray(obj) {\n    var keys = es5.keys(obj);\n    var len = keys.length;\n    var values = new Array(len * 2);\n    for (var i = 0; i < len; ++i) {\n        var key = keys[i];\n        values[i] = obj[key];\n        values[i + len] = key;\n    }\n    this.constructor$(values);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {\n    this._init$(undefined, -3) ;\n};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val = {};\n        var keyOffset = this.length();\n        for (var i = 0, len = this.length(); i < len; ++i) {\n            val[this._values[i + keyOffset]] = this._values[i];\n        }\n        this._resolve(val);\n    }\n};\n\nPropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n    this._promise._progress({\n        key: this._values[index + this.length()],\n        value: value\n    });\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 4);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n},{\"./es5.js\":14,\"./util.js\":38}],28:[function(_dereq_,module,exports){\n\"use strict\";\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype._unshiftOne = function(value) {\n    var capacity = this._capacity;\n    this._checkCapacity(this.length() + 1);\n    var front = this._front;\n    var i = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = value;\n    this._front = i;\n    this._length = this.length() + 1;\n};\n\nQueue.prototype.unshift = function(fn, receiver, arg) {\n    this._unshiftOne(arg);\n    this._unshiftOne(receiver);\n    this._unshiftOne(fn);\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n},{}],29:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar isArray = _dereq_(\"./util.js\").isArray;\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else if (!isArray(promises)) {\n        return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 4 | 1);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n},{\"./util.js\":38}],30:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nfunction ReductionPromiseArray(promises, fn, accum, _each) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    this._preservedValues = _each === INTERNAL ? [] : null;\n    this._zerothIsAccum = (accum === undefined);\n    this._gotAccum = false;\n    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n    this._valuesPhase = undefined;\n    var maybePromise = tryConvertToPromise(accum, this._promise);\n    var rejected = false;\n    var isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        maybePromise = maybePromise._target();\n        if (maybePromise._isPending()) {\n            maybePromise._proxyPromiseArray(this, -1);\n        } else if (maybePromise._isFulfilled()) {\n            accum = maybePromise._value();\n            this._gotAccum = true;\n        } else {\n            this._reject(maybePromise._reason());\n            rejected = true;\n        }\n    }\n    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n    this._callback = fn;\n    this._accum = accum;\n    if (!rejected) this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._init = function () {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function () {\n    if (this._gotAccum || this._zerothIsAccum) {\n        this._resolve(this._preservedValues !== null\n                        ? [] : this._accum);\n    }\n};\n\nReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    values[index] = value;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var isEach = preservedValues !== null;\n    var gotAccum = this._gotAccum;\n    var valuesPhase = this._valuesPhase;\n    var valuesPhaseIndex;\n    if (!valuesPhase) {\n        valuesPhase = this._valuesPhase = new Array(length);\n        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n            valuesPhase[valuesPhaseIndex] = 0;\n        }\n    }\n    valuesPhaseIndex = valuesPhase[index];\n\n    if (index === 0 && this._zerothIsAccum) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n        valuesPhase[index] = ((valuesPhaseIndex === 0)\n            ? 1 : 2);\n    } else if (index === -1) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n    } else {\n        if (valuesPhaseIndex === 0) {\n            valuesPhase[index] = 1;\n        } else {\n            valuesPhase[index] = 2;\n            this._accum = value;\n        }\n    }\n    if (!gotAccum) return;\n\n    var callback = this._callback;\n    var receiver = this._promise._boundTo;\n    var ret;\n\n    for (var i = this._reducingIndex; i < length; ++i) {\n        valuesPhaseIndex = valuesPhase[i];\n        if (valuesPhaseIndex === 2) {\n            this._reducingIndex = i + 1;\n            continue;\n        }\n        if (valuesPhaseIndex !== 1) return;\n        value = values[i];\n        this._promise._pushContext();\n        if (isEach) {\n            preservedValues.push(value);\n            ret = tryCatch(callback).call(receiver, value, i, length);\n        }\n        else {\n            ret = tryCatch(callback)\n                .call(receiver, this._accum, value, i, length);\n        }\n        this._promise._popContext();\n\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n\n        this._reducingIndex = i + 1;\n        this._accum = ret;\n    }\n\n    this._resolve(isEach ? preservedValues : this._accum);\n};\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n};\n\n},{\"./util.js\":38}],31:[function(_dereq_,module,exports){\n\"use strict\";\nvar schedule;\nif (_dereq_(\"./util.js\").isNode) {\n    var version = process.versions.node.split(\".\").map(Number);\n    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)\n        ? global.setImmediate : process.nextTick;\n}\nelse if (typeof MutationObserver !== \"undefined\") {\n    schedule = function(fn) {\n        var div = document.createElement(\"div\");\n        var observer = new MutationObserver(fn);\n        observer.observe(div, {attributes: true});\n        return function() { div.classList.toggle(\"foo\"); };\n    };\n    schedule.isStatic = true;\n}\nelse if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n}\nelse {\n    schedule = function() {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n    };\n}\nmodule.exports = schedule;\n\n},{\"./util.js\":38}],32:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\n    function(Promise, PromiseArray) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = _dereq_(\"./util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 268435456;\n    ret._settledValue = value;\n    this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 134217728;\n    ret._settledValue = reason;\n    this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return new SettledPromiseArray(this).promise();\n};\n};\n\n},{\"./util.js\":38}],33:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar RangeError = _dereq_(\"./errors.js\").RangeError;\nvar AggregateError = _dereq_(\"./errors.js\").AggregateError;\nvar isArray = util.isArray;\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n    }\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            e.push(this._values[i]);\n        }\n        this._reject(e);\n    }\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],34:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValue = promise._settledValue;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValue = undefined;\n    }\n}\n\nPromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.isFulfilled =\nPromise.prototype._isFulfilled = function () {\n    return (this._bitField & 268435456) > 0;\n};\n\nPromiseInspection.prototype.isRejected =\nPromise.prototype._isRejected = function () {\n    return (this._bitField & 134217728) > 0;\n};\n\nPromiseInspection.prototype.isPending =\nPromise.prototype._isPending = function () {\n    return (this._bitField & 402653184) === 0;\n};\n\nPromiseInspection.prototype.isResolved =\nPromise.prototype._isResolved = function () {\n    return (this._bitField & 402653184) > 0;\n};\n\nPromise.prototype.isPending = function() {\n    return this._target()._isPending();\n};\n\nPromise.prototype.isRejected = function() {\n    return this._target()._isRejected();\n};\n\nPromise.prototype.isFulfilled = function() {\n    return this._target()._isFulfilled();\n};\n\nPromise.prototype.isResolved = function() {\n    return this._target()._isResolved();\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue;\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue;\n};\n\nPromise.prototype.value = function() {\n    var target = this._target();\n    if (!target.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return target._settledValue;\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    if (!target.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    target._unsetRejectionIsUnhandled();\n    return target._settledValue;\n};\n\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n},{}],35:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) {\n            return obj;\n        }\n        else if (isAnyBluebirdPromise(obj)) {\n            var ret = new Promise(INTERNAL);\n            obj._then(\n                ret._fulfillUnchecked,\n                ret._rejectUncheckedCheckError,\n                ret._progressUnchecked,\n                ret,\n                null\n            );\n            return ret;\n        }\n        var then = util.tryCatch(getThen)(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction getThen(obj) {\n    return obj.then;\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    return hasProp.call(obj, \"_promise0\");\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x,\n                                        resolveFromThenable,\n                                        rejectFromThenable,\n                                        progressFromThenable);\n    synchronous = false;\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolveFromThenable(value) {\n        if (!promise) return;\n        if (x === value) {\n            promise._rejectCallback(\n                Promise._makeSelfResolutionError(), false, true);\n        } else {\n            promise._resolveCallback(value);\n        }\n        promise = null;\n    }\n\n    function rejectFromThenable(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n\n    function progressFromThenable(value) {\n        if (!promise) return;\n        if (typeof promise._progress === \"function\") {\n            promise._progress(value);\n        }\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n},{\"./util.js\":38}],36:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nvar afterTimeout = function (promise, message) {\n    if (!promise.isPending()) return;\n    if (typeof message !== \"string\") {\n        message = \"operation timed out\";\n    }\n    var err = new TimeoutError(message);\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._cancel(err);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (value, ms) {\n    if (ms === undefined) {\n        ms = value;\n        value = undefined;\n        var ret = new Promise(INTERNAL);\n        setTimeout(function() { ret._fulfill(); }, ms);\n        return ret;\n    }\n    ms = +ms;\n    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(this, ms);\n};\n\nfunction successClear(value) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret = this.then().cancellable();\n    ret._cancellationParent = this;\n    var handle = setTimeout(function timeoutTimeout() {\n        afterTimeout(ret, message);\n    }, ms);\n    return ret._then(successClear, failureClear, undefined, handle, undefined);\n};\n\n};\n\n},{\"./util.js\":38}],37:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext) {\n    var TypeError = _dereq_(\"./errors.js\").TypeError;\n    var inherits = _dereq_(\"./util.js\").inherits;\n    var PromiseInspection = Promise.PromiseInspection;\n\n    function inspectionMapper(inspections) {\n        var len = inspections.length;\n        for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n            if (inspection.isRejected()) {\n                return Promise.reject(inspection.error());\n            }\n            inspections[i] = inspection._settledValue;\n        }\n        return inspections;\n    }\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = Promise.defer();\n        function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret.promise;\n    }\n\n    function disposerSuccess(value) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = value;\n        inspection._bitField = 268435456;\n        return dispose(this, inspection).thenReturn(value);\n    }\n\n    function disposerFail(reason) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = reason;\n        inspection._bitField = 134217728;\n        return dispose(this, inspection).thenThrow(reason);\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return null;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== null\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n        len--;\n        var resources = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = arguments[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var promise = Promise.settle(resources)\n            .then(inspectionMapper)\n            .then(function(vals) {\n                promise._pushContext();\n                var ret;\n                try {\n                    ret = fn.apply(undefined, vals);\n                } finally {\n                    promise._popContext();\n                }\n                return ret;\n            })\n            ._then(\n                disposerSuccess, disposerFail, undefined, resources, undefined);\n        resources.promise = promise;\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 262144;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 262144) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~262144);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],38:[function(_dereq_,module,exports){\n\"use strict\";\nvar es5 = _dereq_(\"./es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\nvar haveGetters = (function(){\n    try {\n        var o = {};\n        es5.defineProperty(o, \"f\", {\n            get: function () {\n                return 3;\n            }\n        });\n        return o.f === 3;\n    }\n    catch (e) {\n        return false;\n    }\n\n})();\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return !isPrimitive(value);\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\n\nvar wrapsPrimitiveReceiver = (function() {\n    return this !== \"string\";\n}).call(\"string\");\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    if (es5.isES5) {\n        var oProto = Object.prototype;\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && obj !== oProto) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        return function(obj) {\n            var ret = [];\n            /*jshint forin:false */\n            for (var key in obj) {\n                ret.push(key);\n            }\n            return ret;\n        };\n    }\n\n})();\n\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n            if (es5.isES5) return keys.length > 1;\n            return keys.length > 0 &&\n                   !(keys.length === 1 && keys[0] === \"constructor\");\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027*/\n    function f() {}\n    f.prototype = obj;\n    return f;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            es5.defineProperty(to, key, es5.getDescriptor(from, key));\n        }\n    }\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    haveGetters: haveGetters,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    isNode: typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\"\n};\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n},{\"./es5.js\":14}]},{},[4])(4)\n});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bluebird/js/browser/bluebird.js\n ** module id = 25\n ** module chunks = 0 1 2 3 7\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/debug/debug.js\n ** module id = 26\n ** module chunks = 0 1 2 3 7\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/debug/~/ms/index.js\n ** module id = 27\n ** module chunks = 0 1 2 3 7\n **/","\nimport readBlob from '../read-blob'\nimport defaultAudioContext from 'audio-context'\n\nexport class SamplingMaster {\n\n  constructor(audioContext) {\n    this._audioContext = audioContext || defaultAudioContext\n    this._samples = []\n    this._instances = new Set()\n  }\n\n  /**\n   * Connects a dummy node to the audio, thereby unmuting the audio system on\n   * iOS devices.\n   */\n  unmute() {\n    let ctx = this._audioContext\n    let gain = ctx.createGain()\n    gain.connect(ctx.destination)\n    gain.disconnect()\n  }\n\n  get audioContext() {\n    return this._audioContext\n  }\n\n  destroy() {\n    if (this._destroyed) return\n    this._destroyed = true\n    for (let sample of this._samples) sample.destroy()\n    for (let instance of this._instances) instance.destroy()\n    this._samples = null\n    this._instances = null\n  }\n\n  sample(blobOrArrayBuffer) {\n    return this._coerceToArrayBuffer(blobOrArrayBuffer)\n    .then(arrayBuffer => this._decodeAudio(arrayBuffer))\n    .then(audioBuffer => {\n      if (this._destroyed) throw new Error('SamplingMaster already destroyed!')\n      var sample = new Sample(this, audioBuffer)\n      this._samples.push(sample)\n      return sample\n    })\n  }\n\n  _coerceToArrayBuffer(blobOrArrayBuffer) {\n    if (blobOrArrayBuffer instanceof ArrayBuffer) {\n      return Promise.resolve(blobOrArrayBuffer)\n    } else {\n      return readBlob(blobOrArrayBuffer).as('arraybuffer')\n    }\n  }\n\n  _decodeAudio(arrayBuffer) {\n    return new Promise((resolve, reject) => {\n      this.audioContext.decodeAudioData(arrayBuffer,\n        function decodeAudioDataSuccess(audioBuffer) {\n          resolve(audioBuffer)\n        },\n        function decodeAudioDataFailure(e) {\n          reject('Unable to decode audio: ' + e)\n        }\n      )\n    })\n  }\n\n  _startPlaying(instance) {\n    this._instances.add(instance)\n  }\n\n  _stoppedPlaying(instance) {\n    this._instances.delete(instance)\n  }\n\n}\n\nclass Sample {\n\n  constructor(samplingMaster, audioBuffer) {\n    this._master = samplingMaster\n    this._buffer = audioBuffer\n  }\n\n  play(delay, node) {\n    return new PlayInstance(this._master, this._buffer, delay, node)\n  }\n\n  destroy() {\n    this._master = null\n    this._buffer = null\n  }\n\n}\n\nclass PlayInstance {\n\n  constructor(samplingMaster, buffer, delay, node) {\n    this._master = samplingMaster\n    let context = samplingMaster.audioContext\n    let source = context.createBufferSource()\n    source.buffer = buffer\n    let gain = context.createGain()\n    source.connect(gain)\n    gain.connect(node || context.destination)\n    this._source = source\n    this._gain = gain\n    source.start(!delay ? 0 : Math.max(0, context.currentTime + delay))\n    setTimeout(() => this.stop(), (delay + buffer.duration + 0.01) * 1000)\n    this._master._startPlaying(this)\n  }\n\n  stop() {\n    if (!this._source) return\n    this._source.stop(0)\n    this._source.disconnect()\n    this._gain.disconnect()\n    this._source = null\n    this._gain = null\n    this._master._stoppedPlaying(this)\n    if (this.onstop) this.onstop()\n  }\n\n  destroy() {\n    this.stop()\n  }\n\n}\n\nexport default SamplingMaster\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./sampling-master/index.js\n **/","\nmodule.exports = DataStructure\n\nfunction DataStructure() {\n\n  var schemas = [].slice.call(arguments)\n\n  function Constructor(object) {\n    Constructor.validate(object)\n    return object\n  }\n\n  Constructor.validate = function(object) {\n    for (var i = 0; i < schemas.length; i ++) {\n      validate(schemas[i], object)\n    }\n  }\n\n  return Constructor\n\n}\n\nDataStructure.maybe = function maybe(schema) {\n  function MaybeValidator(object) {\n    MaybeValidator.validate(object)\n    return object\n  }\n  MaybeValidator.validate = function(value) {\n    if (value === null || value === undefined) return\n    validate(schema, value)\n  }\n  return MaybeValidator\n}\n\nfunction validate(schema, value) {\n  if (schema === Number) schema = 'number'\n  if (schema === String) schema = 'string'\n  if (typeof schema === 'string') {\n    if (typeof value !== schema) throw new Error('should be a ' + schema)\n  } else if (typeof schema === 'function') {\n    if (typeof schema.validate === 'function') {\n      schema.validate(value)\n    } else if (!(value instanceof schema)) {\n      throw new Error('should be an instance of ' + schema)\n    }\n  } else if (typeof schema === 'object') {\n    if (!value) throw new Error('should be an object')\n    validateObject(schema, value)\n  } else {\n    throw new Error('invalid schema')\n  }\n}\n\nfunction validateObject(schema, object) {\n  for (var prop in schema) {\n    if (!(prop in object)) {\n      throw new Error('missing property: \"' + prop + '\"')\n    }\n    try {\n      validate(schema[prop], object[prop])\n    } catch (e) {\n      throw new Error('error in property \"' + prop + '\": ' + e.message)\n    }\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/data-structure/index.js\n ** module id = 33\n ** module chunks = 2 3 7\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar kMaxLength = 0x3fffffff\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = subject > 0 ? subject >>> 0 : 0\n  else if (type === 'string') {\n    if (encoding === 'base64')\n      subject = base64clean(subject)\n    length = Buffer.byteLength(subject, encoding)\n  } else if (type === 'object' && subject !== null) { // assume object is array-like\n    if (subject.type === 'Buffer' && isArray(subject.data))\n      subject = subject.data\n    length = +subject.length > 0 ? Math.floor(+subject.length) : 0\n  } else\n    throw new TypeError('must start with number, buffer, array or string')\n\n  if (this.length > kMaxLength)\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n      'size: 0x' + kMaxLength.toString(16) + ' bytes')\n\n  var buf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    if (Buffer.isBuffer(subject)) {\n      for (i = 0; i < length; i++)\n        buf[i] = subject.readUInt8(i)\n    } else {\n      for (i = 0; i < length; i++)\n        buf[i] = ((subject[i] % 256) + 256) % 256\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))\n    throw new TypeError('Arguments must be Buffers')\n\n  var x = a.length\n  var y = b.length\n  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (totalLength === undefined) {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str + ''\n  switch (encoding || 'utf8') {\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    case 'hex':\n      ret = str.length >>> 1\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    default:\n      ret = str.length\n  }\n  return ret\n}\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function (encoding, start, end) {\n  var loweredCase = false\n\n  start = start >>> 0\n  end = end === undefined || end === Infinity ? this.length : end >>> 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase)\n          throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.equals = function (b) {\n  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max)\n      str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  return Buffer.compare(this, b)\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(byte)) throw new Error('Invalid hex string')\n    buf[offset + i] = byte\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction utf16leWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new TypeError('Unknown encoding: ' + encoding)\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  return asciiSlice(buf, start, end)\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len;\n    if (start < 0)\n      start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0)\n      end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start)\n    end = start\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0)\n    throw new RangeError('offset is not uint')\n  if (offset + ext > length)\n    throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n      ((this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      this[offset + 3])\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80))\n    return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16) |\n      (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  if (!noAssert)\n    checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new TypeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new TypeError('index out of range')\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else objectWriteUInt16(this, value, offset, true)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else objectWriteUInt16(this, value, offset, false)\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else objectWriteUInt32(this, value, offset, true)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else objectWriteUInt32(this, value, offset, false)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else objectWriteUInt16(this, value, offset, true)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else objectWriteUInt16(this, value, offset, false)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else objectWriteUInt32(this, value, offset, true)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else objectWriteUInt32(this, value, offset, false)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new TypeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new TypeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert)\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert)\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  if (end < start) throw new TypeError('sourceEnd < sourceStart')\n  if (target_start < 0 || target_start >= target.length)\n    throw new TypeError('targetStart out of bounds')\n  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')\n  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + target_start] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new TypeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F) {\n      byteArray.push(b)\n    } else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++) {\n        byteArray.push(parseInt(h[j], 16))\n      }\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length, unitSize) {\n  if (unitSize) length -= length % unitSize;\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/buffer/index.js\n ** module id = 37\n ** module chunks = 0 2 3\n **/","if (typeof window !== \"undefined\") {\n    module.exports = window;\n} else if (typeof global !== \"undefined\") {\n    module.exports = global;\n} else {\n    module.exports = {};\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/audio-context/~/global/window.js\n ** module id = 38\n ** module chunks = 0 1 3 7\n **/","\nexport function download(url) {\n  return {\n    as(type, progress) {\n      return new Promise((resolve, reject) => {\n        var xh = new XMLHttpRequest()\n        xh.open('GET', url, true)\n        xh.responseType = type\n        xh.onload  = () => {\n          if (+xh.status === 200) {\n            resolve(xh.response)\n          } else {\n            reject(new Error(`Unable to download ${url}: HTTP ${xh.status}`))\n          }\n        }\n        xh.onerror = () => reject(new Error(`Unable to download ${url}`))\n        if (progress) xh.onprogress = e => progress.report(e.loaded, e.total)\n        xh.send(null)\n      })\n    }\n  }\n}\n\nexport default download\n\n\n\n/** WEBPACK FOOTER **\n ** ./download/index.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/url/url.js\n ** module id = 42\n ** module chunks = 0 2 3\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/buildin/module.js\n ** module id = 47\n ** module chunks = 0 2 3\n **/","\nmodule.exports = function(det, rec, confidence, name, lang) {\n  this.confidence = confidence;\n  this.name = name || rec.name(det);\n  this.lang = lang;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/match.js\n ** module id = 56\n ** module chunks = 3\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js\n ** module id = 108\n ** module chunks = 0 2 3\n **/","exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isLE ? (nBytes - 1) : 0,\n      d = isLE ? -1 : 1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isLE ? 0 : (nBytes - 1),\n      d = isLE ? 1 : -1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/buffer/~/ieee754/index.js\n ** module id = 109\n ** module chunks = 0 2 3\n **/","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/buffer/~/is-array/index.js\n ** module id = 110\n ** module chunks = 0 2 3\n **/","/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/punycode/punycode.js\n ** module id = 111\n ** module chunks = 0 2 3\n **/","\n/**\n * `BMSChart` holds information about a particular BMS notechart.\n *\n * @module bms/chart\n */\n\nvar BMSHeaders = require('./headers')\nvar BMSObjects = require('./objects')\nvar TimeSignatures = require('../time-signatures')\n\nmodule.exports = BMSChart\n\n/**\n * Generates an empty `BMSChart`.\n *\n * @class BMSChart\n * @constructor\n */\nfunction BMSChart() {\n  this.headers = new BMSHeaders()\n  this.objects = new BMSObjects()\n  this.timeSignatures = new TimeSignatures()\n}\n\n/**\n * Converts measure+fraction into beat.\n *\n * @method measureToBeat\n * @param {Number} measure   Measure number starting from 0\n * @param {Number} fraction  Fraction inside the measure (0 to 1)\n * @return {Number} The beat number starting from 0\n */\nBMSChart.prototype.measureToBeat = function(measure, fraction) {\n  return this.timeSignatures.measureToBeat(measure, fraction)\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/bms/chart.js\n ** module id = 112\n ** module chunks = 3 7\n **/","\n/**\n * @module bms/headers\n */\nmodule.exports = BMSHeaders\n\n/**\n * @class BMSHeaders\n * @constructor\n */\nfunction BMSHeaders() {\n  this._data = { }\n  this._dataAll = { }\n}\n\n/**\n * Invokes a function at each header.\n *\n * @method each\n * @param  {Function} callback function to be invoked\n * @return {BMSHeaders} self\n */\nBMSHeaders.prototype.each = function(callback) {\n  for (var i in this._data) {\n    callback(i, this._data[i])\n  }\n}\n\n/**\n * Retrieves the header.\n *\n * @method get\n * @param  {String} name The header name (case-insensitive)\n * @return {String} The value of specified header\n */\nBMSHeaders.prototype.get = function(name) {\n  return this._data[name.toLowerCase()]\n}\n\n/**\n * Retrieves all headers (when header is specified multiple times).\n *\n * @method get\n * @param  {String} name The header name (case-insensitive)\n * @return {String[]} The values of specified header\n */\nBMSHeaders.prototype.getAll = function(name) {\n  return this._dataAll[name.toLowerCase()]\n}\n\n/**\n * Sets the header.\n *\n * @method set\n * @param  {String} name The header name (case-insensitive)\n * @param  {String} value The value to set\n */\nBMSHeaders.prototype.set = function(name, value) {\n  var key = name.toLowerCase()\n  this._data[key] = value\n  ;(this._dataAll[key] || (this._dataAll[key] = [])).push(value)\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/bms/headers.js\n ** module id = 113\n ** module chunks = 3 7\n **/","\n/**\n * @module bms/objects\n */\nmodule.exports = BMSObjects\n\n/**\n * Holds a collection of objects inside a BMS notechart.\n *\n * @class BMSObjects\n * @constructor\n */\nfunction BMSObjects() {\n  this._objects = []\n}\n\n/**\n * Adds a new object to the collection. If an object already exists on the\n * same channel and position, the object is replaced (except for autokeysound\n * tracks).\n *\n * @method add\n * @param {BMSObject} object\n */\nBMSObjects.prototype.add = function(object) {\n  if (object.channel !== '01') {\n    for (var i = 0; i < this._objects.length; i ++) {\n      var test = this._objects[i]\n      if (test.channel === object.channel &&\n          test.measure === object.measure &&\n          test.fraction === object.fraction) {\n        this._objects[i] = object\n        return\n      }\n    }\n  }\n  this._objects.push(object)\n}\n\n/**\n * Returns a list of all objects.\n *\n * @method all\n * @return {BMSObject[]}\n */\nBMSObjects.prototype.all = function() {\n  return this._objects.slice()\n}\n\n/**\n * Returns a sorted list of all objects.\n *\n * @method all\n * @return {BMSObject[]}\n */\nBMSObjects.prototype.allSorted = function() {\n  var list = this.all()\n  list.sort(function(a, b) {\n    return (a.measure + a.fraction) - (b.measure + b.fraction)\n  })\n  return list\n}\n\n\n/**\n * @class BMSObject\n */\n/**\n * The raw two-character BMS channel of this object.\n *\n * @property channel\n * @type String\n */\n/**\n * The measure number, starting at 0 (corresponds to `#000`)\n *\n * @property measure\n * @type Number\n */\n/**\n * The fractional position inside the measure, ranging from 0 (inclusive)\n * to 1 (exclusive). 0 means that the object is at the start of the measure,\n * where 1 means that the object is at the end of the measure.\n *\n * @property fraction\n * @type Number\n */\n/**\n * The raw value of the BMS object — a two-character string.\n *\n * @property value\n * @type String\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/bms/objects.js\n ** module id = 114\n ** module chunks = 3 7\n **/","\nvar Segment = require('./segment')\n\n/**\n * Speedcore is a library to help compute the speed and position\n * of linear motion. A Speedcore is constructed from an array of Segments.\n *\n * @module speedcore\n */\nmodule.exports = Speedcore\n\n/**\n * Construct a new `Speedcore` from segments\n *\n * @class Speedcore\n * @constructor\n * @param {Segment[]} segments  An array of segments.\n */\nfunction Speedcore(segments) {\n  this._segments = segments.map(Segment)\n}\n\nSpeedcore.prototype.t = function(x) {\n  for (var i = 0; i < this._segments.length; i ++) {\n    if (i + 1 >= this._segments.length || x <= this._segments[i + 1].x) {\n      var segment = this._segments[i]\n      return segment.t + (x - segment.x) / segment.dx\n    }\n  }\n}\n\nSpeedcore.prototype.x = function(t) {\n  for (var i = 0; i < this._segments.length; i ++) {\n    if (i + 1 >= this._segments.length || t <= this._segments[i + 1].t) {\n      var segment = this._segments[i]\n      return segment.x + (t - segment.t) * segment.dx\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/speedcore/index.js\n ** module id = 115\n ** module chunks = 3 7\n **/","\n/**\n * @module time-signatures\n */\nmodule.exports = TimeSignatures\n\n/**\n * @class TimeSignatures\n * @constructor\n */\nfunction TimeSignatures() {\n  this._values = { }\n}\n\n/**\n * @method set\n * @param {Number} measure  The measure number\n * @param {Number} value    The time signature value. 1 represents 4/4, and\n *                          0.75 represents 3/4. You get the idea.\n */\nTimeSignatures.prototype.set = function(measure, value) {\n  this._values[measure] = value\n}\n\n/**\n * @method get\n * @param {Number} measure\n * @return {Number}\n */\nTimeSignatures.prototype.get = function(measure) {\n  return this._values[measure] || 1\n}\n\n/**\n * @method getBeats\n * @param {Number} measure\n * @return {Number}\n */\nTimeSignatures.prototype.getBeats = function(measure) {\n  return this.get(measure) * 4\n}\n\n/**\n * @method measureToBeat\n * @param {Number} measure\n * @param {Number} fraction\n */\nTimeSignatures.prototype.measureToBeat = function(measure, fraction) {\n  var sum = 0\n  for (var i = 0; i < measure; i ++) sum += this.getBeats(i)\n  return sum + this.getBeats(measure) * fraction\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/time-signatures/index.js\n ** module id = 116\n ** module chunks = 3 7\n **/","\nmodule.exports = match\n\nfunction match(text) {\n  var matched = false\n  return {\n    when: function(pattern, callback) {\n      if (matched) return this\n      var match = text.match(pattern)\n      if (match) {\n        matched = true\n        callback(match)\n      }\n      return this\n    },\n    else: function(callback) {\n      if (matched) return this\n      callback()\n    }\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/util/match.js\n ** module id = 117\n ** module chunks = 3 7\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/util/util.js\n ** module id = 128\n ** module chunks = 3\n **/","\nimport R from 'ramda'\nimport SamplingMaster from 'bemuse/sampling-master'\nimport * as ProgressUtils from 'bemuse/progress/utils'\n\nexport class AudioLoader {\n  constructor(assets, master) {\n    this._assets = assets\n    this._master = master || new SamplingMaster()\n  }\n  loadFrom(keysounds, loadProgress, decodeProgress) {\n    let files     = keysounds.files()\n    let onload    = ProgressUtils.fixed(files.length, loadProgress)\n    let ondecode  = ProgressUtils.fixed(files.length, decodeProgress)\n    let load      = name => this._loadSample(name, onload, ondecode)\n    return Promise.map(files, load).then(R.fromPairs)\n  }\n  _loadSample(name, onload, ondecode) {\n    return this._getFile(name).then(\n      file => file.read()\n        .tap(() => onload(name))\n        .then(buffer => this._decode(buffer))\n        .tap(() => ondecode(name))\n        .then(sample => [name, sample])\n        .catch(e => {\n          console.error('Unable to decode: ' + name, e)\n          return null\n        }),\n      () => null\n    )\n  }\n  _decode(buffer) {\n    return this._master.sample(buffer)\n  }\n  _getFile(name) {\n    return this._assets.file(name)\n      .catch(() => this._assets.file(name.replace(/\\.\\w+$/, '.mp3')))\n  }\n}\n\nexport default AudioLoader\n\n\n\n/** WEBPACK FOOTER **\n ** ./game/audio-loader.js\n **/","\nimport { resolve }        from 'url'\nimport addLazyProperty    from 'lazy-property'\nimport R                  from 'ramda'\nimport download           from 'bemuse/download'\nimport readBlob           from 'bemuse/read-blob'\nimport throat             from 'throat'\nimport * as ProgressUtils from 'bemuse/progress/utils'\nimport Progress           from 'bemuse/progress'\n\nexport class BemusePackageResources {\n  constructor(url) {\n    let lazy = addLazyProperty.bind(null, this)\n    this._url = url\n    lazy('metadata', () =>\n      download(resolve(this._url, 'metadata.json')).as('text')\n        .then(str => JSON.parse(str)))\n    lazy('refs', () =>\n      this.metadata.then(\n        metadata => metadata.refs.map(spec => new Ref(this, spec))))\n    this.progress = {\n      all:      new Progress(),\n      current:  new Progress(),\n    }\n    this._loadPayload = ProgressUtils.wrapPromise(this.progress.all,\n      throat(1, (url) => download(url).as('blob', this.progress.current)\n        .then(getPayload)))\n  }\n  get url() {\n    return this._url\n  }\n  file(name) {\n    return this.metadata.then(metadata => {\n      let file = R.find(file => file.name === name, metadata.files)\n      if (!file) throw new Error('Unable to find: ' + name)\n      return new BemusePackageFileResource(this, file.ref)\n    })\n  }\n  getBlob(ref) {\n    let [index, start, end] = ref\n    return this.refs\n      .then(refs => refs[index])\n      .then(ref => ref.load())\n      .then(payload => payload.slice(start, end))\n  }\n}\n\nclass BemusePackageFileResource {\n  constructor(resources, ref) {\n    this._resources = resources\n    this._ref = ref\n  }\n  read() {\n    return this._resources.getBlob(this._ref)\n      .then(blob => readBlob(blob).as('arraybuffer'))\n  }\n}\n\nclass Ref {\n  constructor(resources, spec) {\n    this._resources = resources\n    this._url = resolve(resources.url, spec.path)\n  }\n  load() {\n    return this._promise || (this._promise =\n      this._resources._loadPayload(this._url))\n  }\n}\n\nexport default BemusePackageResources\n\nfunction getPayload(blob) {\n  return readBlob(blob.slice(0, 10)).as('text')\n    .then(magic => {\n      if (magic !== 'BEMUSEPACK') {\n        throw new Error('Invalid magic number')\n      }\n      return readBlob(blob.slice(10, 14)).as('arraybuffer')\n    })\n    .then(buffer => {\n      let array = new Uint8Array(buffer)\n      let length = array[0] +\n                  (array[1] << 8) +\n                  (array[2] << 16) +\n                  (array[3] << 24)\n      return length\n    })\n    .then(metadataLength => blob.slice(14 + metadataLength))\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./resources/bemuse-package.js\n **/","\nvar match = require('../util/match')\nvar BMSChart = require('../bms/chart')\n\nexports.compile = function(text) {\n\n  var chart = new BMSChart()\n\n  var result = {\n    headerSentences: 0,\n    channelSentences: 0,\n    malformedSentences: 0,\n    chart: chart,\n    warnings: []\n  }\n\n  eachLine(text, function(text, lineNumber) {\n    void lineNumber\n    if (text.charAt(0) !== '#') return\n    match(text)\n    .when(/^#(\\d\\d\\d)02:(\\S*)$/, function(m) {\n      result.channelSentences += 1\n      chart.timeSignatures.set(+m[1], +m[2])\n    })\n    .when(/^#(\\d\\d\\d)(\\S\\S):(\\S*)$/, function(m) {\n      result.channelSentences += 1\n      handleChannelSentence(+m[1], m[2], m[3], lineNumber)\n    })\n    .when(/^#(\\w+)(?:\\s+(\\S.*))?$/, function(m) {\n      result.headerSentences += 1\n      chart.headers.set(m[1], m[2])\n    })\n    .else(function() {\n      warn(lineNumber, 'Invalid command')\n    })\n  })\n\n  return result\n\n  function handleChannelSentence(measure, channel, string, lineNumber) {\n    var items = Math.floor(string.length / 2)\n    if (items === 0) return\n    for (var i = 0; i < items; i ++) {\n      var value = string.substr(i * 2, 2)\n      var fraction = i / items\n      if (value === '00') continue\n      chart.objects.add({\n        measure: measure, \n        fraction: fraction,\n        value: value,\n        channel: channel,\n        lineNumber: lineNumber,\n      })\n    }\n  }\n\n  function warn(lineNumber, message) {\n    result.warnings.push({\n      lineNumber: lineNumber,\n      message: message,\n    })\n  }\n\n}\n\nfunction eachLine(text, callback) {\n  text.split(/\\r\\n|\\r|\\n/)\n      .map(function(line) { return line.trim() })\n      .forEach(function(line, index) {\n    callback(line, index + 1)\n  })\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/compiler/index.js\n ** module id = 132\n ** module chunks = 3 7\n **/","\nvar Note = require('./note')\n\nmodule.exports = Notes\n\nvar CHANNEL_MAPPING = {\n  IIDX_P1: {\n    '11': { column: '1'  },\n    '12': { column: '2'  },\n    '13': { column: '3'  },\n    '14': { column: '4'  },\n    '15': { column: '5'  },\n    '18': { column: '6'  },\n    '19': { column: '7'  },\n    '16': { column: 'SC' },\n  },\n}\n\n/**\n * The Notes class holds the Note objects in the game. A note object may or\n * may not be playable.\n *\n * @class Notes\n * @constructor\n */\nfunction Notes(notes) {\n  notes.forEach(Note.validate)\n  this._notes = notes\n}\n\n/**\n * Returns the number of notes in this object.\n *\n * @method count\n * @return {Number}\n */\nNotes.prototype.count = function() {\n  return this._notes.length\n}\n\n/**\n * Returns an Array of all notes.\n *\n * @method all\n * @return {Note[]}\n */\nNotes.prototype.all = function() {\n  return this._notes.slice()\n}\n\n/**\n * Creates a Notes object from a BMSChart.\n *\n * @static\n * @method fromBMSChart\n * @param {BMSChart} chart    the chart to process\n * @param {Object}   options  the note options\n */\nNotes.fromBMSChart = function(chart, options) {\n  options = options || { }\n  var builder = new BMSNoteBuilder(chart)\n  return builder.build()\n}\n\nfunction BMSNoteBuilder(chart) {\n  this._chart = chart\n}\n\nBMSNoteBuilder.prototype.build = function() {\n  this._notes = []\n  this._activeLN = { }\n  this._channelMapping = CHANNEL_MAPPING.IIDX_P1\n  this._objects = this._chart.objects.allSorted()\n  this._objects.forEach(function(object) {\n    this._handle(object)\n  }.bind(this))\n  return new Notes(this._notes)\n}\n\nBMSNoteBuilder.prototype._handle = function(object) {\n  if (object.channel === '01') {\n    this._handleNormalNote(object)\n  } else {\n    switch (object.channel.charAt(0)) {\n    case '1': case '2':\n      this._handleNormalNote(object)\n      break\n    case '5': case '6':\n      this._handleLongNote(object)\n      break\n    }\n  }\n}\n\nBMSNoteBuilder.prototype._handleNormalNote = function(object) {\n  var channel = this._normalizeChannel(object.channel)\n  var beat = this._getBeat(object)\n  this._notes.push({\n    beat: beat,\n    column: this._getColumn(channel),\n  })\n}\n\nBMSNoteBuilder.prototype._handleLongNote = function(object) {\n  var channel = this._normalizeChannel(object.channel)\n  var beat = this._getBeat(object)\n  if (this._activeLN[channel]) {\n    var note = this._activeLN[channel]\n    note.endBeat = beat\n    this._notes.push(note)\n    ;delete this._activeLN[channel]\n  } else {\n    this._activeLN[channel] = {\n      beat: beat,\n      keysound: object.value,\n      column: this._getColumn(object.channel),\n    }\n  }\n}\n\nBMSNoteBuilder.prototype._getBeat = function(object) {\n  return this._chart.measureToBeat(object.measure, object.fraction)\n}\n\nBMSNoteBuilder.prototype._getColumn = function(channel) {\n  return this._channelMapping[channel]\n}\n\nBMSNoteBuilder.prototype._normalizeChannel = function(channel) {\n  return channel.replace(/^5/, '1').replace(/^6/, '2')\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/notes/index.js\n ** module id = 133\n ** module chunks = 3 7\n **/","\nvar DataStructure = require('data-structure')\n\nvar Column = new DataStructure({\n  column: String,\n})\n\n/**\n * @class Note\n */\nmodule.exports = new DataStructure({\n\n  /**\n   * @property beat\n   * @type Number\n   */\n  beat: Number,\n\n  /**\n   * @property column\n   * @type Column|undefined\n   */\n  column: DataStructure.maybe(Column),\n\n  /**\n   * @property keysound\n   * @type String\n   */\n  keysound: String,\n\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/notes/note.js\n ** module id = 134\n ** module chunks = 3 7\n **/","\nvar DataStructure = require('data-structure')\n\n/**\n * @class Segment\n */\nmodule.exports = new DataStructure({\n\n  /**\n   * @property t\n   * @type Number\n   */\n  t: Number,\n\n  /**\n   * @property x\n   * @type Number\n   */\n  x: Number,\n\n  /**\n   * @property dx\n   * @type Number\n   */\n  dx: Number,\n\n})\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/speedcore/segment.js\n ** module id = 135\n ** module chunks = 3 7\n **/","\n// The Timing module converts between beats and seconds.\n// They are created from a notechart.\n\nvar Speedcore = require('../speedcore')\n\n/**\n * @module timing\n */\nmodule.exports = Timing\n\nvar precedence = { bpm: 1, stop: 2 }\n\nfunction Timing(initialBPM, actions) {\n  var state = { bpm: initialBPM, beat: 0, seconds: 0 }\n  var segments = [{ t: 0, x: 0, dx: initialBPM / 60 }]\n  actions = actions.slice()\n  actions.sort(function(a, b) {\n    return a.beat - b.beat || precedence[a.type] - precedence[b.type]\n  })\n  actions.forEach(function(action) {\n    var beat    = action.beat\n    var seconds = state.seconds + (beat - state.beat) * 60 / state.bpm\n    switch (action.type) {\n    case 'bpm':\n      state.bpm = action.bpm\n      segments.push({ t: seconds, x: beat, dx: state.bpm / 60 })\n      break\n    case 'stop':\n      segments.push({ t: seconds, x: beat, dx: 0 })\n      seconds += (action.stopBeats || 0) * 60 / state.bpm\n      segments.push({ t: seconds, x: beat, dx: state.bpm / 60 })\n      break\n    default:\n      throw new Error(\"Unrecognized segment object!\")\n    }\n    state.beat    = beat\n    state.seconds = seconds\n  })\n  this._speedcore = new Speedcore(segments)\n}\n\nTiming.prototype.beatToSeconds = function(beat) {\n  return this._speedcore.t(beat)\n}\n\nTiming.prototype.secondsToBeat = function(seconds) {\n  return this._speedcore.x(seconds)\n}\n\nTiming.fromBMSChart = function(chart) {\n  var actions = []\n  chart.objects.all().forEach(function(object) {\n    var bpm\n    var beat = chart.measureToBeat(object.measure, object.fraction)\n    if (object.channel === '03') {\n      bpm = parseInt(object.value, 16)\n      actions.push({ type: 'bpm', beat: beat, bpm: bpm })\n    } else if (object.channel === '08') {\n      bpm = chart.headers.get('bpm' + object.value)\n      actions.push({ type: 'bpm', beat: beat, bpm: bpm })\n    } else if (object.channel === '09') {\n      var stopBeats = chart.headers.get('stop' + object.value) / 48\n      actions.push({ type: 'stop', beat: beat, stopBeats: stopBeats })\n    }\n  })\n  return new Timing(+chart.headers.get('bpm') || 60, actions)\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/timing/index.js\n ** module id = 136\n ** module chunks = 3 7\n **/","\"use strict\"\n\nfunction addLazyProperty(object, name, initializer, enumerable) {\n  Object.defineProperty(object, name, {\n    get: function() {\n      var v = initializer.call(this)\n      Object.defineProperty(this, name, { value: v, enumerable: !!enumerable, writable: true })\n      return v\n    },\n    set: function(v) {\n      Object.defineProperty(this, name, { value: v, enumerable: !!enumerable, writable: true })\n      return v\n    },\n    enumerable: !!enumerable,\n    configurable: true\n  })\n}\n\nmodule.exports = addLazyProperty\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/lazy-property/lazyProperty.js\n ** module id = 138\n ** module chunks = 0 3\n **/","'use strict'\n\nmodule.exports = function (PromiseArgument) {\n  var Promise;\n  function throat(size, fn) {\n    var queue = []\n    function run(fn, self, args) {\n      if (size) {\n        size--\n        var result = new Promise(function (resolve) {\n          resolve(fn.apply(self, args))\n        })\n        result.then(release, release)\n        return result\n      } else {\n        return new Promise(function (resolve) {\n          queue.push(new Delayed(resolve, fn, self, args))\n        })\n      }\n    }\n    function release() {\n      size++\n      if (queue.length) {\n        var next = queue.shift()\n        next.resolve(run(next.fn, next.self, next.args))\n      }\n    }\n    if (typeof size === 'function' && typeof fn === 'number') {\n      var temp = fn;\n      fn = size;\n      size = temp;\n    }\n    if (typeof fn === 'function') {\n      return function () {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args)\n      }\n    } else {\n      return function (fn) {\n        var args = [];\n        for (var i = 1; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        return run(fn, this, args)\n      }\n    }\n  }\n  if (typeof arguments[0] === 'number' || typeof arguments[1] === 'number') {\n    Promise = module.exports.Promise;\n    if (typeof Promise !== 'function') {\n      throw new Error('You must provide a Promise polyfill for this library to work in older environments');\n    }\n    return throat(arguments[0], arguments[1]);\n  } else {\n    Promise = PromiseArgument;\n    return throat;\n  }\n}\n\n/* istanbul ignore next */\nif (typeof Promise === 'function') {\n  module.exports.Promise = Promise;\n}\n\nfunction Delayed(resolve, fn, self, args) {\n  this.resolve = resolve\n  this.fn = fn\n  this.self = self || null\n  this.args = args\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/throat/index.js\n ** module id = 139\n ** module chunks = 0 3\n **/","\nimport SCENE_MANAGER from 'bemuse/scene-manager'\nimport LoadingScene from './loading-scene'\nimport GameLoader from './game-loader'\n\nimport URLResource from 'bemuse/resources/url'\nimport BemusePackageResources from 'bemuse/resources/bemuse-package'\n\nexport function main() {\n  let song = {\n        title: 'オリヴィアの幻術',\n        subtitles: [\n          '[Tonalite]',\n        ],\n        artist: '葵',\n        genre: 'Sexy Dance',\n        subartists: [\n          'mov:いとう まさき/obj:止ヒ糸',\n        ],\n      }\n  let loader = new GameLoader()\n  let promise = loader.load({\n    bms:    new URLResource('/music/[aoi]olivia/olivia_SPpp.bml'),\n    assets: new BemusePackageResources('/music/[aoi]olivia/assets/'),\n  })\n  SCENE_MANAGER.display(new LoadingScene({ loader, song }))\n  promise.then(function() {\n    SCENE_MANAGER.display(null)\n  })\n  .done()\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./game/index.js\n **/","\nimport co from 'co'\nimport BMS from 'bms'\n\nimport Progress           from 'bemuse/progress'\nimport * as ProgressUtils from 'bemuse/progress/utils'\n\nimport { EventEmitter } from 'events'\nimport LoadingContext   from 'bemuse/boot/loading-context'\n\nimport AudioLoader      from './audio-loader'\nimport bytes            from 'bytes'\n\nlet Formatters = {\n  NORMAL: progress =>\n            progress.total ? `${progress.current} / ${progress.total}` : '',\n  EXTRA:  progress =>\n            progress.extra,\n  BYTES:  progress =>\n            progress.total ?\n              `${bytes(progress.current)} / ${bytes(progress.total)}` : '',\n}\n\nexport class GameLoader extends EventEmitter {\n  constructor() {\n    this._tasks = []\n  }\n  get tasks() {\n    return this._tasks\n  }\n  load(song) {\n    return co(function*() {\n      let promises = {\n        graphics: this._loadEngine(),\n        song:     this._loadSong(song),\n      }\n      yield Promise.all([promises.graphics, promises.song])\n    }.bind(this))\n  }\n  _loadEngine() {\n    let progress = {\n      engine: this._task('Loading game engine',     Formatters.BYTES),\n      skin:   this._task('Loading skin'),\n    }\n    return co(function*() {\n      let Scintillator  = yield loadEngineModule(progress.engine)\n      let skin          = yield Scintillator.load('/skins/default/skin.xml',\n                                  progress.skin)\n      let context       = new Scintillator.Context(skin)\n      return { skin, context }\n    }.bind(this))\n  }\n  _loadSong(song) {\n    let { bms, assets } = song\n    let progress = {\n      bms:    this._task('Loading ' + bms.name,     Formatters.BYTES),\n      cpack:  this._task('Loading package',         Formatters.BYTES),\n      pack:   this._task('Loading song packages'),\n      audio:  this._task('Loading audio'),\n      bga:    this._task('Loading BGA'),\n      decode: this._task('Decoding audio',          Formatters.EXTRA),\n    }\n    if (assets.progress) {\n      if (assets.progress.current) {\n        ProgressUtils.bind(assets.progress.current, progress.cpack)\n      }\n      if (assets.progress.all) {\n        ProgressUtils.bind(assets.progress.all, progress.pack)\n      }\n    }\n    return co(function*() {\n      let buffer        = yield bms.read(progress.bms)\n      let source        = yield readBMS(buffer)\n      let compileResult = BMS.Compiler.compile(source)\n      let chart         = compileResult.chart\n      let keysounds     = BMS.Keysounds.fromBMSChart(chart)\n      let audioLoader   = new AudioLoader(assets)\n      let audio         = yield audioLoader.loadFrom(keysounds,\n                            progress.audio, progress.decode)\n      console.log(audio)\n    }.bind(this))\n  }\n  _task(text, formatter) {\n    formatter = formatter || Formatters.NORMAL\n    let progress = new Progress()\n    let task = { text: text, progress: null, progressText: '' }\n    this._tasks.push(task)\n    progress.watch(() => {\n      task.progressText = formatter(progress)\n      task.progress     = progress.progress\n      this.emit('progress')\n    })\n    return progress\n  }\n}\n\nfunction loadEngineModule(progress) {\n  return new Promise((resolve) => {\n    let context = new LoadingContext(progress)\n    context.use(function() {\n      require.ensure(\n        ['bemuse/scintillator'],\n        (require) => resolve(require('bemuse/scintillator')),\n        'gameEngine'\n      )\n    })\n  })\n}\n\nfunction readBMS(buffer) {\n  buffer = new Buffer(new Uint8Array(buffer))\n  return Promise.promisify(BMS.Reader.readAsync)(buffer)\n}\n\nexport default GameLoader\n\n\n\n/** WEBPACK FOOTER **\n ** ./game/game-loader.js\n **/","\nimport View from 'bemuse/view!./view.jade'\nimport './style.scss'\n\nexport default function LoadingScene({ loader, song }) {\n  function getData() {\n    return {\n      song,\n      items: loader.tasks.map(({ text, progressText, progress }) => ({\n        text:     text,\n        progress: progressText ? ` (${progressText})` : '',\n        width:    Math.round((progress * 100) || 0) + '%',\n      })),\n    }\n  }\n  return function(container) {\n    let data = getData()\n    let view = new View({ el: container, data })\n    loader.on('progress', () => view.set(getData()))\n    return function() {\n      container.classList.add('is-exiting')\n      return Promise.delay(500)\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./game/loading-scene/index.js\n **/","\nimport download from 'bemuse/download'\nimport { basename } from 'path'\n\nexport class URLResource {\n  constructor(url) {\n    this._url = url\n  }\n  read(progress) {\n    return download(this._url).as('arraybuffer', progress)\n  }\n  get name() {\n    return basename(this._url)\n  }\n}\n\nexport default URLResource\n\n\n\n/** WEBPACK FOOTER **\n ** ./resources/url.js\n **/","\nimport 'bemuse/polyfill'\nimport co from 'co'\n\nexport class SceneManager {\n  constructor() {\n  }\n  display(scene) {\n    return co(function*() {\n      if (this.exit) {\n        yield Promise.resolve(this.exit())\n        detach(this.currentElement)\n      }\n      var element = document.createElement('div')\n      element.className = 'scene'\n      document.body.appendChild(element)\n      this.exit = scene(element)\n    })\n  }\n}\n\nfunction detach(element) {\n  if (element && element.parentNode === document.body) {\n    document.body.removeChild(element)\n  }\n}\n\nexport let instance = new SceneManager()\nexport default instance\n\n\n\n/** WEBPACK FOOTER **\n ** ./scene-manager/index.js\n **/","\nimport Ractive from 'ractive'\n\nexport function View(template) {\n  return function ViewInstance(options) {\n    return new Ractive(Object.assign({ template }, options))\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/index.js\n **/","\nexports.Reader          = require('./reader')\nexports.Compiler        = require('./compiler')\n\nexports.BMSChart        = require('./bms/chart')\nexports.BMSHeaders      = require('./bms/headers')\nexports.BMSObjects      = require('./bms/objects')\n\nexports.Speedcore       = require('./speedcore')\nexports.TimeSignatures  = require('./time-signatures')\nexports.Notes           = require('./notes')\nexports.Timing          = require('./timing')\nexports.SongInfo        = require('./song-info')\nexports.Keysounds       = require('./keysounds')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/index.js\n ** module id = 199\n ** module chunks = 3\n **/","\nvar _ = require('lodash')\n\nfunction Keysounds(map) {\n  this._map = map\n}\n\nKeysounds.prototype.get = function(id) {\n  return this._map[id.toLowerCase()]\n}\n\nKeysounds.prototype.files = function() {\n  return _.uniq(_.values(this._map))\n}\n\nKeysounds.fromBMSChart = function(chart) {\n  var map = {}\n  chart.headers.each(function(name, value) {\n    var match = name.match(/^wav(\\S\\S)$/i)\n    if (!match) return\n    map[match[1].toLowerCase()] = value\n  })\n  return new Keysounds(map)\n}\n\nmodule.exports = Keysounds\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/keysounds/index.js\n ** module id = 200\n ** module chunks = 3\n **/","\nvar utf8  = require('./encoding/utf8'),\n  unicode = require('./encoding/unicode'),\n  mbcs    = require('./encoding/mbcs'),\n  sbcs    = require('./encoding/sbcs'),\n  iso2022 = require('./encoding/iso2022');\n\nvar self = this;\n\nvar recognisers = [\n  new utf8,\n  new unicode.UTF_16BE,\n  new unicode.UTF_16LE,\n  new mbcs.sjis,\n  new mbcs.euc_kr\n];\n\nmodule.exports.detect = function(buffer) {\n\n  // Tally up the byte occurence statistics.\n  var fByteStats = [];\n  for (var i = 0; i < 256; i++)\n    fByteStats[i] = 0;\n\n  for (var i = buffer.length - 1; i >= 0; i--)\n    fByteStats[buffer[i] & 0x00ff]++;\n\n  var fC1Bytes = false;\n  for (var i = 0x80; i <= 0x9F; i += 1) {\n    if (fByteStats[i] != 0) {\n      fC1Bytes = true;\n      break;\n    }\n  }\n\n  var context = {\n    fByteStats:  fByteStats,\n    fC1Bytes:    fC1Bytes,\n    fRawInput:   buffer,\n    fRawLength:  buffer.length,\n    fInputBytes: buffer,\n    fInputLen:   buffer.length\n  };\n\n  var match = recognisers.map(function(rec) {\n    return rec.match(context);\n  }).filter(function(match) {\n    return !!match;\n  }).sort(function(a, b) {\n    return a.confidence - b.confidence;\n  }).pop();\n\n  return match ? match.name : null;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/bemuse-chardet.js\n ** module id = 201\n ** module chunks = 3\n **/","var util = require('util'),\n  Match = require ('../match');\n\n\n/**\n * This is a superclass for the individual detectors for\n * each of the detectable members of the ISO 2022 family\n * of encodings.\n */\n\nfunction ISO_2022() {}\n\nISO_2022.prototype.match = function(det) {\n\n  /**\n   * Matching function shared among the 2022 detectors JP, CN and KR\n   * Counts up the number of legal an unrecognized escape sequences in\n   * the sample of text, and computes a score based on the total number &\n   * the proportion that fit the encoding.\n   *\n   *\n   * @param text the byte buffer containing text to analyse\n   * @param textLen  the size of the text in the byte.\n   * @param escapeSequences the byte escape sequences to test for.\n   * @return match quality, in the range of 0-100.\n   */\n\n  var i, j;\n  var escN;\n  var hits   = 0;\n  var misses = 0;\n  var shifts = 0;\n  var quality;\n\n  // TODO: refactor me\n  var text = det.fInputBytes;\n  var textLen = det.fInputLen;\n\n  scanInput:\n    for (i = 0; i < textLen; i++) {\n      if (text[i] == 0x1b) {\n        checkEscapes:\n          for (escN = 0; escN < this.escapeSequences.length; escN++) {\n            var seq = this.escapeSequences[escN];\n\n            if ((textLen - i) < seq.length)\n              continue checkEscapes;\n\n            for (j = 1; j < seq.length; j++)\n              if (seq[j] != text[i + j])\n                continue checkEscapes;\n\n\n            hits++;\n            i += seq.length - 1;\n            continue scanInput;\n          }\n\n          misses++;\n      }\n\n      // Shift in/out\n      if (text[i] == 0x0e || text[i] == 0x0f)\n        shifts++;\n\n    }\n\n  if (hits == 0)\n    return null;\n\n  //\n  // Initial quality is based on relative proportion of recongized vs.\n  //   unrecognized escape sequences.\n  //   All good:  quality = 100;\n  //   half or less good: quality = 0;\n  //   linear inbetween.\n  quality = (100 * hits - 100 * misses) / (hits + misses);\n\n  // Back off quality if there were too few escape sequences seen.\n  //   Include shifts in this computation, so that KR does not get penalized\n  //   for having only a single Escape sequence, but many shifts.\n  if (hits + shifts < 5)\n    quality -= (5 - (hits + shifts)) * 10;\n\n  return quality <= 0 ? null : new Match(det, this, quality);\n};\n\nmodule.exports.ISO_2022_JP = function() {\n  this.name = function() {\n    return 'ISO-2022-JP';\n  };\n  this.escapeSequences = [\n    [ 0x1b, 0x24, 0x28, 0x43 ],   // KS X 1001:1992\n    [ 0x1b, 0x24, 0x28, 0x44 ],   // JIS X 212-1990\n    [ 0x1b, 0x24, 0x40 ],         // JIS C 6226-1978\n    [ 0x1b, 0x24, 0x41 ],         // GB 2312-80\n    [ 0x1b, 0x24, 0x42 ],         // JIS X 208-1983\n    [ 0x1b, 0x26, 0x40 ],         // JIS X 208 1990, 1997\n    [ 0x1b, 0x28, 0x42 ],         // ASCII\n    [ 0x1b, 0x28, 0x48 ],         // JIS-Roman\n    [ 0x1b, 0x28, 0x49 ],         // Half-width katakana\n    [ 0x1b, 0x28, 0x4a ],         // JIS-Roman\n    [ 0x1b, 0x2e, 0x41 ],         // ISO 8859-1\n    [ 0x1b, 0x2e, 0x46 ]          // ISO 8859-7\n  ];\n};\nutil.inherits(module.exports.ISO_2022_JP, ISO_2022);\n\n\n\nmodule.exports.ISO_2022_KR = function() {\n  this.name = function() {\n    return 'ISO-2022-KR';\n  };\n  this.escapeSequences = [\n    [ 0x1b, 0x24, 0x29, 0x43 ]\n  ];\n};\nutil.inherits(module.exports.ISO_2022_KR, ISO_2022);\n\n\n\nmodule.exports.ISO_2022_CN = function() {\n  this.name = function() {\n    return 'ISO-2022-CN';\n  };\n  this.escapeSequences = [\n    [ 0x1b, 0x24, 0x29, 0x41 ],   // GB 2312-80\n    [ 0x1b, 0x24, 0x29, 0x47 ],   // CNS 11643-1992 Plane 1\n    [ 0x1b, 0x24, 0x2A, 0x48 ],   // CNS 11643-1992 Plane 2\n    [ 0x1b, 0x24, 0x29, 0x45 ],   // ISO-IR-165\n    [ 0x1b, 0x24, 0x2B, 0x49 ],   // CNS 11643-1992 Plane 3\n    [ 0x1b, 0x24, 0x2B, 0x4A ],   // CNS 11643-1992 Plane 4\n    [ 0x1b, 0x24, 0x2B, 0x4B ],   // CNS 11643-1992 Plane 5\n    [ 0x1b, 0x24, 0x2B, 0x4C ],   // CNS 11643-1992 Plane 6\n    [ 0x1b, 0x24, 0x2B, 0x4D ],   // CNS 11643-1992 Plane 7\n    [ 0x1b, 0x4e ],               // SS2\n    [ 0x1b, 0x4f ]                // SS3\n  ];\n};\nutil.inherits(module.exports.ISO_2022_CN, ISO_2022);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/encoding/iso2022.js\n ** module id = 202\n ** module chunks = 3\n **/","var util = require('util'),\n  Match = require ('../match');\n\n/**\n * Binary search implementation (recursive)\n */\nfunction binarySearch(arr, searchValue) {\n  function find(arr, searchValue, left, right) {\n    if (right < left)\n      return -1;\n\n    /*\n    int mid = mid = (left + right) / 2;\n    There is a bug in the above line;\n    Joshua Bloch suggests the following replacement:\n    */\n    var mid = Math.floor((left + right) >>> 1);\n    if (searchValue > arr[mid])\n      return find(arr, searchValue, mid + 1, right);\n\n    if (searchValue < arr[mid])\n      return find(arr, searchValue, left, mid - 1);\n\n    return mid;\n  };\n\n  return find(arr, searchValue, 0, arr.length - 1);\n};\n\n// 'Character'  iterated character class.\n//    Recognizers for specific mbcs encodings make their 'characters' available\n//    by providing a nextChar() function that fills in an instance of iteratedChar\n//    with the next char from the input.\n//    The returned characters are not converted to Unicode, but remain as the raw\n//    bytes (concatenated into an int) from the codepage data.\n//\n//  For Asian charsets, use the raw input rather than the input that has been\n//   stripped of markup.  Detection only considers multi-byte chars, effectively\n//   stripping markup anyway, and double byte chars do occur in markup too.\n//\nfunction IteratedChar() {\n\n  this.charValue = 0; // 1-4 bytes from the raw input data\n  this.index     = 0;\n  this.nextIndex = 0;\n  this.error     = false;\n  this.done      = false;\n\n  this.reset = function() {\n    this.charValue = 0;\n    this.index     = -1;\n    this.nextIndex = 0;\n    this.error     = false;\n    this.done      = false;\n  };\n\n  this.nextByte = function(det) {\n    if (this.nextIndex >= det.fRawLength) {\n      this.done = true;\n      return -1;\n    }\n    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n    return byteValue;\n  };\n};\n\n\n\n/**\n * Asian double or multi-byte - charsets.\n * Match is determined mostly by the input data adhering to the\n * encoding scheme for the charset, and, optionally,\n * frequency-of-occurence of characters.\n */\n\nfunction mbcs() {};\n\n/**\n * Test the match of this charset with the input text data\n *      which is obtained via the CharsetDetector object.\n *\n * @param det  The CharsetDetector, which contains the input text\n *             to be checked for being in this charset.\n * @return     Two values packed into one int  (Damn java, anyhow)\n *             bits 0-7:  the match confidence, ranging from 0-100\n *             bits 8-15: The match reason, an enum-like value.\n */\nmbcs.prototype.match = function(det) {\n\n  var singleByteCharCount = 0,  //TODO Do we really need this?\n    doubleByteCharCount = 0,\n    commonCharCount     = 0,\n    badCharCount        = 0,\n    totalCharCount      = 0,\n    confidence          = 0;\n\n  var iter = new IteratedChar();\n\n  detectBlock: {\n    for (iter.reset(); this.nextChar(iter, det);) {\n      totalCharCount++;\n      if (iter.error) {\n        badCharCount++;\n      } else {\n        var cv = iter.charValue & 0xFFFFFFFF;\n\n        if (cv <= 0xff) {\n          singleByteCharCount++;\n        } else {\n          doubleByteCharCount++;\n          if (this.commonChars != null) {\n            // NOTE: This assumes that there are no 4-byte common chars.\n            if (binarySearch(this.commonChars, cv) >= 0) {\n              commonCharCount++;\n            }\n          }\n        }\n      }\n      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n        // console.log('its here!')\n        // Bail out early if the byte data is not matching the encoding scheme.\n        break detectBlock;\n      }\n    }\n\n    if (doubleByteCharCount <= 10 && badCharCount== 0) {\n      // Not many multi-byte chars.\n      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n        // We don't have enough data to have any confidence.\n        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n        confidence = 0;\n      }\n      else {\n        //   ASCII or ISO file?  It's probably not our encoding,\n        //   but is not incompatible with our encoding, so don't give it a zero.\n        confidence = 10;\n      }\n      break detectBlock;\n    }\n\n    //\n    //  No match if there are too many characters that don't fit the encoding scheme.\n    //    (should we have zero tolerance for these?)\n    //\n    if (doubleByteCharCount < 20 * badCharCount) {\n      confidence = 0;\n      break detectBlock;\n    }\n\n    if (this.commonChars == null) {\n      // We have no statistics on frequently occuring characters.\n      //  Assess confidence purely on having a reasonable number of\n      //  multi-byte characters (the more the better\n      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n      if (confidence > 100) {\n        confidence = 100;\n      }\n    } else {\n      //\n      // Frequency of occurence statistics exist.\n      //\n      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n      var scaleFactor = 90.0 / maxVal;\n      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n      confidence = Math.min(confidence, 100);\n    }\n  }   // end of detectBlock:\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\n/**\n * Get the next character (however many bytes it is) from the input data\n *    Subclasses for specific charset encodings must implement this function\n *    to get characters according to the rules of their encoding scheme.\n *\n *  This function is not a method of class iteratedChar only because\n *   that would require a lot of extra derived classes, which is awkward.\n * @param it  The iteratedChar 'struct' into which the returned char is placed.\n * @param det The charset detector, which is needed to get at the input byte data\n *            being iterated over.\n * @return    True if a character was returned, false at end of input.\n */\n\nmbcs.prototype.nextChar = function(iter, det) {};\n\n\n\n/**\n * Shift-JIS charset recognizer.\n */\nmodule.exports.sjis = function() {\n  this.name = function() {\n    return 'Shift-JIS';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,\n    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,\n    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,\n    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,\n    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,\n    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa\n  ];\n\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte;\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0)\n      return false;\n\n    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))\n      return true;\n\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (firstByte << 8) | secondByte;\n    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {\n      // Illegal second byte value.\n      iter.error = true;\n    }\n    return true;\n  };\n};\nutil.inherits(module.exports.sjis, mbcs);\n\n\n\n/**\n *   Big5 charset recognizer.\n */\nmodule.exports.big5 = function() {\n  this.name = function() {\n    return 'Big5';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,\n    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,\n    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,\n    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,\n    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,\n    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,\n    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,\n    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,\n    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,\n    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f\n  ];\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte = iter.charValue = iter.nextByte(det);\n\n    if (firstByte < 0)\n      return false;\n\n    // single byte character.\n    if (firstByte <= 0x7f || firstByte == 0xff)\n      return true;\n\n    var secondByte = iter.nextByte(det);\n\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (iter.charValue << 8) | secondByte;\n\n    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)\n      iter.error = true;\n\n    return true;\n  };\n};\nutil.inherits(module.exports.big5, mbcs);\n\n\n\n/**\n *  EUC charset recognizers.  One abstract class that provides the common function\n *  for getting the next character according to the EUC encoding scheme,\n *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n *\n *  Get the next character value for EUC based encodings.\n *  Character 'value' is simply the raw bytes that make up the character\n *     packed into an int.\n */\nfunction eucNextChar(iter, det) {\n  iter.index = iter.nextIndex;\n  iter.error = false;\n  var firstByte  = 0;\n  var secondByte = 0;\n  var thirdByte  = 0;\n  //int fourthByte = 0;\n  buildChar: {\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) {\n      // Ran off the end of the input data\n      iter.done = true;\n      break buildChar;\n    }\n    if (firstByte <= 0x8d) {\n      // single byte char\n      break buildChar;\n    }\n    secondByte = iter.nextByte(det);\n    iter.charValue = (iter.charValue << 8) | secondByte;\n    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n      // Two byte Char\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8e) {\n      // Code Set 2.\n      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n      // We don't know which we've got.\n      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n      //   bytes will look like a well formed 2 byte char.\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8f) {\n      // Code set 3.\n      // Three byte total char size, two bytes of actual char value.\n      thirdByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | thirdByte;\n      if (thirdByte < 0xa1) {\n        iter.error = true;\n      }\n    }\n  }\n  return iter.done == false;\n};\n\n\n\n/**\n * The charset recognize for EUC-JP.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_jp = function() {\n  this.name = function() {\n    return 'EUC-JP';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,\n    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,\n    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,\n    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,\n    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,\n    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,\n    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,\n    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,\n    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,\n    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_jp, mbcs);\n\n\n\n/**\n * The charset recognize for EUC-KR.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_kr = function() {\n  this.name = function() {\n    return 'EUC-KR';\n  };\n  this.language = function() {\n    return 'ko';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,\n    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,\n    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,\n    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,\n    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,\n    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,\n    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,\n    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,\n    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,\n    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_kr, mbcs);\n\n\n\n/**\n *   GB-18030 recognizer. Uses simplified Chinese statistics.\n */\nmodule.exports.gb_18030 = function() {\n  this.name = function() {\n    return 'GB18030';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n\n  /*\n   *  Get the next character value for EUC based encodings.\n   *  Character 'value' is simply the raw bytes that make up the character\n   *     packed into an int.\n   */\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte  = 0;\n    var secondByte = 0;\n    var thirdByte  = 0;\n    var fourthByte = 0;\n    buildChar: {\n      firstByte = iter.charValue = iter.nextByte(det);\n      if (firstByte < 0) {\n        // Ran off the end of the input data\n        iter.done = true;\n        break buildChar;\n      }\n      if (firstByte <= 0x80) {\n        // single byte char\n        break buildChar;\n      }\n      secondByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | secondByte;\n      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n        // Two byte Char\n        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {\n          break buildChar;\n        }\n        // Four byte char\n        if (secondByte >= 0x30 && secondByte <= 0x39) {\n          thirdByte = iter.nextByte(det);\n          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n            fourthByte = iter.nextByte(det);\n            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;\n              break buildChar;\n            }\n          }\n        }\n        iter.error = true;\n        break buildChar;\n      }\n    }\n    return iter.done == false;\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,\n    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,\n    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,\n    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,\n    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,\n    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,\n    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,\n    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,\n    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,\n    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0\n  ];\n};\nutil.inherits(module.exports.gb_18030, mbcs);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/encoding/mbcs.js\n ** module id = 203\n ** module chunks = 3\n **/","var util = require('util'),\n  Match = require ('../match');\n\n/**\n * This class recognizes single-byte encodings. Because the encoding scheme is so\n * simple, language statistics are used to do the matching.\n */\n\nfunction NGramParser(theNgramList, theByteMap) {\n  var N_GRAM_MASK = 0xFFFFFF;\n\n  this.byteIndex = 0;\n  this.ngram = 0;\n\n  this.ngramList = theNgramList;\n  this.byteMap = theByteMap;\n\n  this.ngramCount = 0;\n  this.hitCount = 0;\n\n  this.spaceChar;\n\n  /*\n   * Binary search for value in table, which must have exactly 64 entries.\n   */\n  this.search = function(table, value) {\n    var index = 0;\n\n    if (table[index + 32] <= value) index += 32;\n    if (table[index + 16] <= value) index += 16;\n    if (table[index + 8]  <= value) index += 8;\n    if (table[index + 4]  <= value) index += 4;\n    if (table[index + 2]  <= value) index += 2;\n    if (table[index + 1]  <= value) index += 1;\n    if (table[index]      > value)  index -= 1;\n\n    if (index < 0 || table[index] != value)\n      return -1;\n\n    return index;\n  };\n\n  this.lookup = function(thisNgram) {\n    this.ngramCount += 1;\n    if (this.search(this.ngramList, thisNgram) >= 0) {\n      this.hitCount += 1;\n    }\n  };\n\n  this.addByte = function(b) {\n    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;\n    this.lookup(this.ngram);\n  }\n\n  this.nextByte = function(det) {\n    if (this.byteIndex >= det.fInputLen)\n      return -1;\n\n    return det.fInputBytes[this.byteIndex++] & 0xFF;\n  }\n\n  this.parse = function(det, spaceCh) {\n    var b, ignoreSpace = false;\n    this.spaceChar = spaceCh;\n\n    while ((b = this.nextByte(det)) >= 0) {\n      var mb = this.byteMap[b];\n\n      // TODO: 0x20 might not be a space in all character sets...\n      if (mb != 0) {\n        if (!(mb == this.spaceChar && ignoreSpace)) {\n          this.addByte(mb);\n        }\n\n        ignoreSpace = (mb == this.spaceChar);\n      }\n    }\n\n    // TODO: Is this OK? The buffer could have ended in the middle of a word...\n    this.addByte(this.spaceChar);\n\n    var rawPercent = this.hitCount / this.ngramCount;\n\n    // TODO - This is a bit of a hack to take care of a case\n    // were we were getting a confidence of 135...\n    if (rawPercent > 0.33)\n      return 98;\n\n    return Math.floor(rawPercent * 300.0);\n  };\n};\n\nfunction NGramsPlusLang(la, ng) {\n  this.fLang = la;\n  this.fNGrams = ng;\n};\n\nfunction sbcs() {};\nsbcs.prototype.spaceChar = 0x20;\nsbcs.prototype.ngrams = function() {};\nsbcs.prototype.byteMap = function() {};\nsbcs.prototype.match = function(det) {\n\n  var ngrams = this.ngrams();\n  var multiple = (Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang);\n\n  if (!multiple) {\n    var parser = new NGramParser(ngrams, this.byteMap());\n    var confidence = parser.parse(det, this.spaceChar);\n    return confidence <= 0 ? null : new Match(det, this, confidence);\n  }\n\n  var bestConfidenceSoFar = -1;\n  var lang = null;\n\n  for (var i = ngrams.length - 1; i >= 0; i--) {\n    var ngl = ngrams[i];\n\n    var parser = new NGramParser(ngl.fNGrams, this.byteMap());\n    var confidence = parser.parse(det, this.spaceChar);\n    if (confidence > bestConfidenceSoFar) {\n      bestConfidenceSoFar = confidence;\n      lang = ngl.fLang;\n    }\n  }\n\n  var name = this.name(det);\n  return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);\n};\n\n\nmodule.exports.ISO_8859_1 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      new NGramsPlusLang('da', [\n        0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,\n        0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,\n        0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574,\n        0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,\n        0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67,\n        0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,\n        0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065,\n        0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572\n      ]),\n      new NGramsPlusLang('de', [\n        0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765,\n        0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,\n        0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E,\n        0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,\n        0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65,\n        0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,\n        0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368,\n        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572\n      ]),\n      new NGramsPlusLang('en', [\n        0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E,\n        0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,\n        0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465,\n        0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,\n        0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20,\n        0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,\n        0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,\n        0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320\n      ]),\n      new NGramsPlusLang('es', [\n        0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E,\n        0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n        0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369,\n        0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,\n        0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320,\n        0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,\n        0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573,\n        0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20\n      ]),\n      new NGramsPlusLang('fr', [\n        0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61,\n        0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,\n        0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520,\n        0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,\n        0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420,\n        0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,\n        0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064,\n        0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220\n      ]),\n      new NGramsPlusLang('it', [\n        0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E,\n        0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,\n        0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064,\n        0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,\n        0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20,\n        0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,\n        0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572,\n        0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F\n      ]),\n      new NGramsPlusLang('nl', [\n        0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765,\n        0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,\n        0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220,\n        0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,\n        0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520,\n        0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,\n        0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368,\n        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F\n      ]),\n      new NGramsPlusLang('no', [\n        0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,\n        0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,\n        0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574,\n        0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,\n        0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520,\n        0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,\n        0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465,\n        0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572\n      ]),\n      new NGramsPlusLang('pt', [\n        0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61,\n        0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n        0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20,\n        0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,\n        0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120,\n        0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,\n        0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,\n        0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F\n      ]),\n      new NGramsPlusLang('sv', [\n        0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E,\n        0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,\n        0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474,\n        0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,\n        0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564,\n        0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,\n        0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073,\n        0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,\n      ])\n    ];\n  };\n\n  this.name = function(det) {\n    return (det && det.fC1Bytes) ? 'windows-1252' : 'ISO-8859-1';\n  };\n};\nutil.inherits(module.exports.ISO_8859_1, sbcs);\n\n\nmodule.exports.ISO_8859_2 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20,\n      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,\n      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7,\n      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20\n    ];\n  }\n\n  this.ngrams = function() {\n    return [\n      new NGramsPlusLang('cs', [\n        0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64,\n        0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,\n        0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073,\n        0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,\n        0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E,\n        0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,\n        0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20,\n        0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,\n      ]),\n      new NGramsPlusLang('hu', [\n        0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F,\n        0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,\n        0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073,\n        0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,\n        0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920,\n        0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,\n        0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74,\n        0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,\n      ]),\n      new NGramsPlusLang('pl', [\n        0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61,\n        0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,\n        0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79,\n        0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,\n        0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920,\n        0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,\n        0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69,\n        0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,\n      ]),\n      new NGramsPlusLang('ro', [\n        0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469,\n        0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,\n        0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172,\n        0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,\n        0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063,\n        0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,\n        0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520,\n        0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,\n      ])\n    ];\n  };\n\n  this.name = function(det) {\n    return (det && det.fC1Bytes) ? 'windows-1250' : 'ISO-8859-2';\n  };\n};\nutil.inherits(module.exports.ISO_8859_2, sbcs);\n\n\nmodule.exports.ISO_8859_5 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0,\n      0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,\n      0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2,\n      0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,\n      0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF,\n      0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,\n      0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2,\n      0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520\n    ];\n  };\n\n  this.name = function(det) {\n    return 'ISO-8859-5';\n  };\n\n  this.language = function() {\n    return 'ru';\n  };\n};\nutil.inherits(module.exports.ISO_8859_5, sbcs);\n\n\nmodule.exports.ISO_8859_6 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n      0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7,\n      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,\n      0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5,\n      0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,\n      0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,\n      0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,\n      0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4,\n      0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620\n    ];\n  };\n\n  this.name = function(det) {\n    return 'ISO-8859-6';\n  };\n\n  this.language = function() {\n    return 'ar';\n  };\n};\nutil.inherits(module.exports.ISO_8859_6, sbcs);\n\n\nmodule.exports.ISO_8859_7 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20,\n      0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE,\n      0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5,\n      0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,\n      0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220,\n      0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,\n      0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0,\n      0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,\n      0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9,\n      0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20\n    ];\n  };\n\n  this.name = function(det) {\n    return (det && det.fC1Bytes) ? 'windows-1253' : 'ISO-8859-7';\n  };\n\n  this.language = function() {\n    return 'el';\n  };\n};\nutil.inherits(module.exports.ISO_8859_7, sbcs);\n\nmodule.exports.ISO_8859_8 = function() {\n\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      new NGramsPlusLang('he', [\n        0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5,\n        0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,\n        0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE,\n        0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,\n        0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0,\n        0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,\n        0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4,\n        0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,\n      ]),\n      new NGramsPlusLang('he', [\n        0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2,\n        0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,\n        0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4,\n        0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,\n        0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020,\n        0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,\n        0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420,\n        0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,\n      ])\n    ];\n  };\n\n  this.name = function(det) {\n    return (det && det.fC1Bytes) ? 'windows-1255' : 'ISO-8859-8';\n  };\n\n  this.language = function() {\n    return 'he';\n  };\n\n};\nutil.inherits(module.exports.ISO_8859_8, sbcs);\n\n\nmodule.exports.ISO_8859_9 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C,\n      0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,\n      0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261,\n      0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,\n      0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20,\n      0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,\n      0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E,\n      0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD\n    ];\n  };\n\n  this.name = function(det) {\n    return (det && det.fC1Bytes) ? 'windows-1254' : 'ISO-8859-9';\n  };\n\n  this.language = function() {\n    return 'tr';\n  };\n};\nutil.inherits(module.exports.ISO_8859_9, sbcs);\n\n\nmodule.exports.windows_1251 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,\n      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,\n      0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20,\n      0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF,\n      0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20,\n      0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0,\n      0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,\n      0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2,\n      0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,\n      0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF,\n      0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,\n      0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2,\n      0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520\n    ];\n  };\n\n  this.name = function(det) {\n    return 'windows-1251';\n  };\n\n  this.language = function() {\n    return 'ru';\n  };\n};\nutil.inherits(module.exports.windows_1251, sbcs);\n\n\nmodule.exports.windows_1256 = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,\n      0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F,\n      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20,\n      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,\n      0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20,\n      0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7,\n      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,\n      0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3,\n      0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,\n      0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,\n      0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,\n      0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1,\n      0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420\n    ];\n  };\n\n  this.name = function(det) {\n    return 'windows-1256';\n  };\n\n  this.language = function() {\n    return 'ar';\n  };\n};\nutil.inherits(module.exports.windows_1256, sbcs);\n\n\nmodule.exports.KOI8_R = function() {\n  this.byteMap = function() {\n    return [\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,\n      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,\n      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,\n      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,\n      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n      0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF,\n      0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,\n      0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420,\n      0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,\n      0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3,\n      0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,\n      0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1,\n      0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF\n    ];\n  };\n\n  this.name = function(det) {\n    return 'KOI8-R';\n  };\n\n  this.language = function() {\n    return 'ru';\n  };\n};\nutil.inherits(module.exports.KOI8_R, sbcs);\n\n\n/*\nmodule.exports.ISO_8859_7 = function() {\n  this.byteMap = function() {\n    return [\n\n    ];\n  };\n\n  this.ngrams = function() {\n    return [\n\n    ];\n  };\n\n  this.name = function(det) {\n    if (typeof det == 'undefined')\n      return 'ISO-8859-7';\n    return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';\n  };\n\n  this.language = function() {\n    return 'el';\n  };\n};\nutil.inherits(module.exports.ISO_8859_7, sbcs);\n*/\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/encoding/sbcs.js\n ** module id = 204\n ** module chunks = 3\n **/","var util = require('util'),\n  Match = require ('../match');\n\n/**\n * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n * BOM will be used if it is present.\n */\nmodule.exports.UTF_16BE = function() {\n  this.name = function() {\n    return 'UTF-16BE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff))\n      return new Match(det, this, confidence = 100);\n\n    // TODO: Do some statistics to check for unsigned UTF-16BE\n    return null;\n  };\n};\n\nmodule.exports.UTF_16LE = function() {\n  this.name = function() {\n    return 'UTF-16LE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {\n       // An LE BOM is present.\n       if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00)\n         // It is probably UTF-32 LE, not UTF-16\n         return null;\n\n       return new Match(det, this, confidence = 100);\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16LE\n    return null;\n  }\n};\n\nfunction UTF_32() {};\nUTF_32.prototype.match = function(det) {\n  var input      = det.fRawInput,\n    limit      = (det.fRawLength / 4) * 4,\n    numValid   = 0,\n    numInvalid = 0,\n    hasBOM     = false,\n    confidence = 0;\n\n  if (limit == 0)\n    return null;\n\n  if (this.getChar(input, 0) == 0x0000FEFF)\n    hasBOM = true;\n\n  for (var i = 0; i < limit; i += 4) {\n    var ch = this.getChar(input, i);\n\n    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF))\n      numInvalid += 1;\n    else\n      numValid += 1;\n  }\n\n  // Cook up some sort of confidence score, based on presence of a BOM\n  //    and the existence of valid and/or invalid multi-byte sequences.\n  if (hasBOM && numInvalid == 0) {\n    confidence = 100;\n  } else if (hasBOM && numValid > numInvalid * 10) {\n    confidence = 80;\n  } else if (numValid > 3 && numInvalid == 0) {\n    confidence = 100;\n  } else if (numValid > 0 && numInvalid == 0) {\n    confidence = 80;\n  } else if (numValid > numInvalid * 10) {\n    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n    confidence = 25;\n  }\n\n  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\nmodule.exports.UTF_32BE = function() {\n  this.name = function() {\n    return 'UTF-32BE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |\n         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32BE, UTF_32);\n\nmodule.exports.UTF_32LE = function() {\n  this.name = function() {\n    return 'UTF-32LE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |\n         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32LE, UTF_32);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/encoding/unicode.js\n ** module id = 205\n ** module chunks = 3\n **/","\nvar Match = require ('../match');\n\n/**\n * Charset recognizer for UTF-8\n */\nmodule.exports = function() {\n  this.name = function() {\n    return 'UTF-8';\n  };\n  this.match = function(det) {\n\n    var hasBOM = false,\n      numValid = 0,\n      numInvalid = 0,\n      input = det.fRawInput,\n      trailBytes = 0,\n      confidence;\n\n    if (det.fRawLength >= 3 &&\n      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n      hasBOM = true;\n    }\n\n    // Scan for multi-byte sequences\n    for (var i = 0; i < det.fRawLength; i++) {\n      var b = input[i];\n      if ((b & 0x80) == 0)\n        continue; // ASCII\n\n      // Hi bit on char found.  Figure out how long the sequence should be\n      if ((b & 0x0e0) == 0x0c0) {\n        trailBytes = 1;\n      } else if ((b & 0x0f0) == 0x0e0) {\n        trailBytes = 2;\n      } else if ((b & 0x0f8) == 0xf0) {\n        trailBytes = 3;\n      } else {\n        numInvalid++;\n        if (numInvalid > 5)\n          break;\n        trailBytes = 0;\n      }\n\n      // Verify that we've got the right number of trail bytes in the sequence\n      for (;;) {\n        i++;\n        if (i >= det.fRawLength)\n          break;\n\n        if ((input[i] & 0xc0) != 0x080) {\n          numInvalid++;\n          break;\n        }\n        if (--trailBytes == 0) {\n          numValid++;\n          break;\n        }\n      }\n    }\n\n    // Cook up some sort of confidence score, based on presense of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n    confidence = 0;\n    if (hasBOM && numInvalid == 0)\n      confidence = 100;\n    else if (hasBOM && numValid > numInvalid * 10)\n      confidence = 80;\n    else if (numValid > 3 && numInvalid == 0)\n      confidence = 100;\n    else if (numValid > 0 && numInvalid == 0)\n      confidence = 80;\n    else if (numValid == 0 && numInvalid == 0)\n      // Plain ASCII.\n      confidence = 10;\n    else if (numValid > numInvalid * 10)\n      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n      confidence = 25;\n    else\n      return null\n\n    return new Match(det, this, confidence);\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/bemuse-chardet/encoding/utf8.js\n ** module id = 206\n ** module chunks = 3\n **/","/**\n * @license\n * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -d -o ./index.js`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '3.2.0';\n\n  /** Used to compose bitmasks for wrapper metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      REARG_FLAG = 128,\n      ARY_FLAG = 256;\n\n  /** Used as default options for `_.trunc`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect when a function becomes hot. */\n  var HOT_COUNT = 150,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 0,\n      LAZY_MAP_FLAG = 1,\n      LAZY_WHILE_FLAG = 2;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reUnescapedHtml = /[&<>\"'`]/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /**\n   * Used to match ES template delimiters.\n   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)\n   * for more details.\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect named functions. */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to detect hexadecimal string values. */\n  var reHexPrefix = /^0[xX]/;\n\n  /** Used to detect host constructors (Safari > 5). */\n  var reHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /**\n   * Used to match `RegExp` special characters.\n   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n   * for more details.\n   */\n  var reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n      reHasRegExpChars = RegExp(reRegExpChars.source);\n\n  /** Used to detect functions containing a `this` reference. */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to match words to create compound words. */\n  var reWords = (function() {\n    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\n    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n  }());\n\n  /** Used to detect and test for whitespace. */\n  var whitespace = (\n    // Basic whitespace characters.\n    ' \\t\\x0b\\f\\xa0\\ufeff' +\n\n    // Line terminators.\n    '\\n\\r\\u2028\\u2029' +\n\n    // Unicode category \"Zs\" space separators.\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',\n    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    'window', 'WinRTError'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[mapTag] = cloneableTags[setTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used as an internal `_.debounce` options object by `_.throttle`. */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\n  var deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /**\n   * Used as a reference to the global object.\n   *\n   * The `this` value is used if it is the global object to avoid Greasemonkey's\n   * restricted `window` object, otherwise the `window` object is used.\n   */\n  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `compareAscending` which compares values and\n   * sorts them in ascending order without guaranteeing a stable sort.\n   *\n   * @private\n   * @param {*} value The value to compare to `other`.\n   * @param {*} other The value to compare to `value`.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function baseCompareAscending(value, other) {\n    if (value !== other) {\n      var valIsReflexive = value === value,\n          othIsReflexive = other === other;\n\n      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {\n        return 1;\n      }\n      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = (fromIndex || 0) - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`\n   * to define the sort order of `array` and replaces criteria objects with their\n   * corresponding values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * Converts `value` to a string if it is not one. An empty string is returned\n   * for `null` or `undefined` values.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    if (typeof value == 'string') {\n      return value;\n    }\n    return value == null ? '' : (value + '');\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback for string values.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the code unit of the first character of the string.\n   */\n  function charAtCallback(string) {\n    return string.charCodeAt(0);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the first character not found in `chars`.\n   */\n  function charsLeftIndex(string, chars) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the last character not found in `chars`.\n   */\n  function charsRightIndex(string, chars) {\n    var index = string.length;\n\n    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n   * sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareAscending(object, other) {\n    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n  }\n\n  /**\n   * Used by `_.sortByAll` to compare multiple properties of each element\n   * in a collection and stable sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultipleAscending(object, other) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length;\n\n    while (++index < length) {\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        return result;\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  /**\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   * If `fromRight` is provided elements of `array` are iterated from right to left.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} [fromIndex] The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is object-like.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   */\n  function isObjectLike(value) {\n    return (value && typeof value == 'object') || false;\n  }\n\n  /**\n   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n   * character code is whitespace.\n   *\n   * @private\n   * @param {number} charCode The character code to inspect.\n   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n   */\n  function isSpace(charCode) {\n    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      if (array[index] === placeholder) {\n        array[index] = PLACEHOLDER;\n        result[++resIndex] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * An implementation of `_.uniq` optimized for sorted arrays without support\n   * for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The function invoked per iteration.\n   * @returns {Array} Returns the new duplicate-value-free array.\n   */\n  function sortedUniq(array, iteratee) {\n    var seen,\n        index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value, index, array) : value;\n\n      if (!index || seen !== computed) {\n        seen = computed;\n        result[++resIndex] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the first non-whitespace character.\n   */\n  function trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedRightIndex(string) {\n    var index = string.length;\n\n    while (index-- && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the given `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utility\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'add': function(a, b) { return a + b; } });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });\n   *\n   * _.isFunction(_.add);\n   * // => true\n   * _.isFunction(_.sub);\n   * // => false\n   *\n   * lodash.isFunction(lodash.add);\n   * // => false\n   * lodash.isFunction(lodash.sub);\n   * // => true\n   *\n   * // using `context` to mock `Date#getTime` use in `_.now`\n   * var mock = _.runInContext({\n   *   'Date': function() {\n   *     return { 'getTime': getTimeMock };\n   *   }\n   * });\n   *\n   * // or creating a suped-up `defer` in Node.js\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See https://es5.github.io/#x11.1.5 for more details.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for native method references. */\n    var arrayProto = Array.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect DOM support. */\n    var document = (document = context.window) && document.document;\n\n    /** Used to resolve the decompiled source of functions. */\n    var fnToString = Function.prototype.toString;\n\n    /** Used to the length of n-tuples for `_.unzip`. */\n    var getLength = baseProperty('length');\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /**\n     * Used to resolve the `toStringTag` of values.\n     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n     * for more details.\n     */\n    var objToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = context._;\n\n    /** Used to detect if a method is native. */\n    var reNative = RegExp('^' +\n      escapeRegExp(objToString)\n      .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Native method references. */\n    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,\n        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,\n        ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        push = arrayProto.push,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        Set = isNative(Set = context.Set) && Set,\n        setTimeout = context.setTimeout,\n        splice = arrayProto.splice,\n        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,\n        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;\n\n    /** Used to clone array buffers. */\n    var Float64Array = (function() {\n      // Safari 5 errors when using an array buffer to initialize a typed array\n      // where the array buffer's `byteLength` is not a multiple of the typed\n      // array's `BYTES_PER_ELEMENT`.\n      try {\n        var func = isNative(func = context.Float64Array) && func,\n            result = new func(new ArrayBuffer(10), 0, 1) && func;\n      } catch(e) {}\n      return result;\n    }());\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsFinite = context.isFinite,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = isNative(nativeNow = Date.now) && nativeNow,\n        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used as references for `-Infinity` and `Infinity`. */\n    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n    /** Used as references for the maximum length and index of an array. */\n    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,\n        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,\n        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n    /** Used as the size, in bytes, of each `Float64Array` element. */\n    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;\n\n    /**\n     * Used as the maximum length of an array-like value.\n     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n     * for more details.\n     */\n    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n     * Methods that operate on and return arrays, collections, and functions can\n     * be chained together. Methods that return a boolean or single value will\n     * automatically end the chain returning the unwrapped value. Explicit chaining\n     * may be enabled using `_.chain`. The execution of chained methods is lazy,\n     * that is, execution is deferred until `_#value` is implicitly or explicitly\n     * called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n     * fusion is an optimization that merges iteratees to avoid creating intermediate\n     * arrays and reduce the number of iteratee executions.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n     * and `where`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,\n     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,\n     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,\n     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,\n     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,\n     * `keysIn`, `map`, `mapValues`, `matches`, `memoize`, `merge`, `mixin`,\n     * `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,\n     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,\n     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,\n     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,\n     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,\n     * `zip`, and `zipObject`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,\n     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,\n     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,\n     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,\n     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,\n     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,\n     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,\n     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,\n     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,\n     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,\n     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,\n     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`\n     *\n     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n     * otherwise an unwrapped value is returned.\n     *\n     * @name _\n     * @constructor\n     * @category Chain\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, n) { return sum + n; });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(n) { return n * n; });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n     */\n    function LodashWrapper(value, chainAll, actions) {\n      this.__wrapped__ = value;\n      this.__actions__ = actions || [];\n      this.__chain__ = !!chainAll;\n    }\n\n    /**\n     * An object environment feature flags.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    (function(x) {\n\n      /**\n       * Detect if functions can be decompiled by `Function#toString`\n       * (all but Firefox OS certified apps, older Opera mobile browsers, and\n       * the PlayStation 3; forced `false` for Windows 8 apps).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n      /**\n       * Detect if `Function#name` is supported (all but IE).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcNames = typeof Function.name == 'string';\n\n      /**\n       * Detect if the DOM is supported.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.dom = document.createDocumentFragment().nodeType === 11;\n      } catch(e) {\n        support.dom = false;\n      }\n\n      /**\n       * Detect if `arguments` object indexes are non-enumerable.\n       *\n       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n       * checks for indexes that exceed their function's formal parameters with\n       * associated values of `0`.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n      } catch(e) {\n        support.nonEnumArgs = true;\n      }\n    }(0, 0));\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = null;\n      this.__dir__ = 1;\n      this.__dropCount__ = 0;\n      this.__filtered__ = false;\n      this.__iteratees__ = null;\n      this.__takeCount__ = POSITIVE_INFINITY;\n      this.__views__ = null;\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var actions = this.__actions__,\n          iteratees = this.__iteratees__,\n          views = this.__views__,\n          result = new LazyWrapper(this.__wrapped__);\n\n      result.__actions__ = actions ? arrayCopy(actions) : null;\n      result.__dir__ = this.__dir__;\n      result.__dropCount__ = this.__dropCount__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = views ? arrayCopy(views) : null;\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value();\n      if (!isArray(array)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var dir = this.__dir__,\n          isRight = dir < 0,\n          view = getView(0, array.length, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          dropCount = this.__dropCount__,\n          takeCount = nativeMin(length, this.__takeCount__),\n          index = isRight ? end : start - 1,\n          iteratees = this.__iteratees__,\n          iterLength = iteratees ? iteratees.length : 0,\n          resIndex = 0,\n          result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              computed = iteratee(value, index, array),\n              type = data.type;\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        if (dropCount) {\n          dropCount--;\n        } else {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     *\n     * @private\n     * @static\n     * @name Cache\n     * @memberOf _.memoize\n     */\n    function MapCache() {\n      this.__data__ = {};\n    }\n\n    /**\n     * Removes `key` and its value from the cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n     */\n    function mapDelete(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n\n    /**\n     * Gets the cached value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the cached value.\n     */\n    function mapGet(key) {\n      return key == '__proto__' ? undefined : this.__data__[key];\n    }\n\n    /**\n     * Checks if a cached value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapHas(key) {\n      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n    }\n\n    /**\n     * Adds `value` to `key` of the cache.\n     *\n     * @private\n     * @name set\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to cache.\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache object.\n     */\n    function mapSet(key, value) {\n      if (key != '__proto__') {\n        this.__data__[key] = value;\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates a cache object to store unique values.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var length = values ? values.length : 0;\n\n      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n      while (length--) {\n        this.push(values[length]);\n      }\n    }\n\n    /**\n     * Checks if `value` is in `cache` mimicking the return signature of\n     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n     *\n     * @private\n     * @param {Object} cache The cache to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `0` if `value` is found, else `-1`.\n     */\n    function cacheIndexOf(cache, value) {\n      var data = cache.data,\n          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n      return result ? 0 : -1;\n    }\n\n    /**\n     * Adds `value` to the cache.\n     *\n     * @private\n     * @name push\n     * @memberOf SetCache\n     * @param {*} value The value to cache.\n     */\n    function cachePush(value) {\n      var data = this.data;\n      if (typeof value == 'string' || isObject(value)) {\n        data.set.add(value);\n      } else {\n        data.hash[value] = true;\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayCopy(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEach` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEachRight` for arrays without support for\n     * callback shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEachRight(array, iteratee) {\n      var length = array.length;\n\n      while (length--) {\n        if (iteratee(array[length], length, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.every` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     */\n    function arrayEvery(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `_.filter` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function arrayFilter(array, predicate) {\n      var index = -1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.map` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function arrayMap(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.max` for arrays without support for iteratees.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     */\n    function arrayMax(array) {\n      var index = -1,\n          length = array.length,\n          result = NEGATIVE_INFINITY;\n\n      while (++index < length) {\n        var value = array[index];\n        if (value > result) {\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.min` for arrays without support for iteratees.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     */\n    function arrayMin(array) {\n      var index = -1,\n          length = array.length,\n          result = POSITIVE_INFINITY;\n\n      while (++index < length) {\n        var value = array[index];\n        if (value < result) {\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.reduce` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the first element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n      var index = -1,\n          length = array.length;\n\n      if (initFromArray && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.reduceRight` for arrays without support for\n     * callback shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the last element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n      var length = array.length;\n      if (initFromArray && length) {\n        accumulator = array[--length];\n      }\n      while (length--) {\n        accumulator = iteratee(accumulator, array[length], length, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.some` for arrays without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function arraySome(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assign` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignDefaults(objectValue, sourceValue) {\n      return typeof objectValue == 'undefined' ? sourceValue : objectValue;\n    }\n\n    /**\n     * Used by `_.template` to customize its `_.assign` use.\n     *\n     * **Note:** This method is like `assignDefaults` except that it ignores\n     * inherited property values when checking if a property is `undefined`.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @param {string} key The key associated with the object and source values.\n     * @param {Object} object The destination object.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))\n        ? sourceValue\n        : objectValue;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize assigning values.\n     * @returns {Object} Returns the destination object.\n     */\n    function baseAssign(object, source, customizer) {\n      var props = keys(source);\n      if (!customizer) {\n        return baseCopy(source, object, props);\n      }\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key],\n            result = customizer(value, source[key], key, object, source);\n\n        if ((result === result ? result !== value : value === value) ||\n            (typeof value == 'undefined' && !(key in object))) {\n          object[key] = result;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.at` without support for strings and individual\n     * key arguments.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.\n     * @returns {Array} Returns the new array of picked elements.\n     */\n    function baseAt(collection, props) {\n      var index = -1,\n          length = collection.length,\n          isArr = isLength(length),\n          propsLength = props.length,\n          result = Array(propsLength);\n\n      while(++index < propsLength) {\n        var key = props[index];\n        if (isArr) {\n          key = parseFloat(key);\n          result[index] = isIndex(key, length) ? collection[key] : undefined;\n        } else {\n          result[index] = collection[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Array} props The property names to copy.\n     * @returns {Object} Returns `object`.\n     */\n    function baseCopy(source, object, props) {\n      if (!props) {\n        props = object;\n        object = {};\n      }\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        object[key] = source[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.bindAll` without support for individual\n     * method name arguments.\n     *\n     * @private\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {string[]} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     */\n    function baseBindAll(object, methodNames) {\n      var index = -1,\n          length = methodNames.length;\n\n      while (++index < length) {\n        var key = methodNames[index];\n        object[key] = createWrapper(object[key], BIND_FLAG, object);\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.callback` which supports specifying the\n     * number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function baseCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (type == 'function') {\n        return (typeof thisArg != 'undefined' && isBindable(func))\n          ? bindCallback(func, thisArg, argCount)\n          : func;\n      }\n      if (func == null) {\n        return identity;\n      }\n      if (type == 'object') {\n        return baseMatches(func);\n      }\n      return typeof thisArg == 'undefined'\n        ? baseProperty(func + '')\n        : baseMatchesProperty(func + '', thisArg);\n    }\n\n    /**\n     * The base implementation of `_.clone` without support for argument juggling\n     * and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The object `value` belongs to.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object) : customizer(value);\n      }\n      if (typeof result != 'undefined') {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return arrayCopy(value, result);\n        }\n      } else {\n        var tag = objToString.call(value),\n            isFunc = tag == funcTag;\n\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return baseCopy(value, result, keys(value));\n          }\n        } else {\n          return cloneableTags[tag]\n            ? initCloneByTag(value, tag, isDeep)\n            : (object ? value : {});\n        }\n      }\n      // Check for circular references and return corresponding clone.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length];\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate it with its clone.\n      stackA.push(value);\n      stackB.push(result);\n\n      // Recursively populate clone (susceptible to call stack limits).\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function Object() {}\n      return function(prototype) {\n        if (isObject(prototype)) {\n          Object.prototype = prototype;\n          var result = new Object;\n          Object.prototype = null;\n        }\n        return result || context.Object();\n      };\n    }());\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts an index\n     * of where to slice the arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Object} args The `arguments` object to slice and provide to `func`.\n     * @returns {number} Returns the timer id.\n     */\n    function baseDelay(func, wait, args, fromIndex) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);\n    }\n\n    /**\n     * The base implementation of `_.difference` which accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var length = array ? array.length : 0,\n          result = [];\n\n      if (!length) {\n        return result;\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          cache = isCommon && values.length >= 200 && createCache(values),\n          valuesLength = values.length;\n\n      if (cache) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n        values = cache;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index];\n\n        if (isCommon && value === value) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === value) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    function baseEach(collection, iteratee) {\n      var length = collection ? collection.length : 0;\n      if (!isLength(length)) {\n        return baseForOwn(collection, iteratee);\n      }\n      var index = -1,\n          iterable = toObject(collection);\n\n      while (++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    }\n\n    /**\n     * The base implementation of `_.forEachRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    function baseEachRight(collection, iteratee) {\n      var length = collection ? collection.length : 0;\n      if (!isLength(length)) {\n        return baseForOwnRight(collection, iteratee);\n      }\n      var iterable = toObject(collection);\n      while (length--) {\n        if (iteratee(iterable[length], length, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    }\n\n    /**\n     * The base implementation of `_.every` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : end >>> 0;\n      start >>>= 0;\n\n      while (start < length) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n     * without support for callback shorthands and `this` binding, which iterates\n     * over `collection` using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @param {boolean} [retKey] Specify returning the key of the found element\n     *  instead of the element itself.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFind(collection, predicate, eachFunc, retKey) {\n      var result;\n      eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n          result = retKey ? key : value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with added support for restricting\n     * flattening and specifying the start index.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isDeep, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {\n          if (isDeep) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            value = baseFlatten(value, isDeep, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[++resIndex] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iterator functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    function baseFor(object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = toObject(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForRight(object, iteratee, keysFunc) {\n      var iterable = toObject(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[length];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n      return baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from those provided.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the new array of filtered property names.\n     */\n    function baseFunctions(object, props) {\n      var index = -1,\n          length = props.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var key = props[index];\n        if (isFunction(object[key])) {\n          result[++resIndex] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invoke` which requires additional arguments\n     * to be provided as an array of arguments rather than individually.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {Array} [args] The arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     */\n    function baseInvoke(collection, methodName, args) {\n      var index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = isLength(length) ? Array(length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? methodName : (value != null && value[methodName]);\n        result[++index] = func ? func.apply(value, args) : undefined;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` without support for `this` binding\n     * `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isWhere] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {\n      // Exit early for identical values.\n      if (value === other) {\n        // Treat `+0` vs. `-0` as not equal.\n        return value !== 0 || (1 / value == 1 / other);\n      }\n      var valType = typeof value,\n          othType = typeof other;\n\n      // Exit early for unlike primitive values.\n      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||\n          value == null || other == null) {\n        // Return `false` unless both values are `NaN`.\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @param {boolean} [isWhere] Specify performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = objToString.call(object);\n        if (objTag == argsTag) {\n          objTag = objectTag;\n        } else if (objTag != objectTag) {\n          objIsArr = isTypedArray(object);\n        }\n      }\n      if (!othIsArr) {\n        othTag = objToString.call(other);\n        if (othTag == argsTag) {\n          othTag = objectTag;\n        } else if (othTag != objectTag) {\n          othIsArr = isTypedArray(other);\n        }\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !(objIsArr || objIsObj)) {\n        return equalByTag(object, other, objTag);\n      }\n      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (valWrapped || othWrapped) {\n        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      // For more information on detecting circular references see https://es5.github.io/#JO.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == object) {\n          return stackB[length] == other;\n        }\n      }\n      // Add `object` and `other` to the stack of traversed objects.\n      stackA.push(object);\n      stackB.push(other);\n\n      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);\n\n      stackA.pop();\n      stackB.pop();\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The source property names to match.\n     * @param {Array} values The source values to match.\n     * @param {Array} strictCompareFlags Strict comparison flags for source values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      var index = -1,\n          noCustomizer = !customizer;\n\n      while (++index < length) {\n        if ((noCustomizer && strictCompareFlags[index])\n              ? values[index] !== object[props[index]]\n              : !hasOwnProperty.call(object, props[index])\n            ) {\n          return false;\n        }\n      }\n      index = -1;\n      while (++index < length) {\n        var key = props[index];\n        if (noCustomizer && strictCompareFlags[index]) {\n          var result = hasOwnProperty.call(object, key);\n        } else {\n          var objValue = object[key],\n              srcValue = values[index];\n\n          result = customizer ? customizer(objValue, srcValue, key) : undefined;\n          if (typeof result == 'undefined') {\n            result = baseIsEqual(srcValue, objValue, customizer, true);\n          }\n        }\n        if (!result) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for callback shorthands\n     * or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var result = [];\n      baseEach(collection, function(value, key, collection) {\n        result.push(iteratee(value, key, collection));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which does not clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatches(source) {\n      var props = keys(source),\n          length = props.length;\n\n      if (length == 1) {\n        var key = props[0],\n            value = source[key];\n\n        if (isStrictComparable(value)) {\n          return function(object) {\n            return object != null && value === object[key] && hasOwnProperty.call(object, key);\n          };\n        }\n      }\n      var values = Array(length),\n          strictCompareFlags = Array(length);\n\n      while (length--) {\n        value = source[props[length]];\n        values[length] = value;\n        strictCompareFlags[length] = isStrictComparable(value);\n      }\n      return function(object) {\n        return baseIsMatch(object, props, values, strictCompareFlags);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which does not coerce `key`\n     * to a string.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} value The value to compare.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatchesProperty(key, value) {\n      if (isStrictComparable(value)) {\n        return function(object) {\n          return object != null && object[key] === value;\n        };\n      }\n      return function(object) {\n        return object != null && baseIsEqual(value, object[key], null, true);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {Object} Returns the destination object.\n     */\n    function baseMerge(object, source, customizer, stackA, stackB) {\n      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));\n\n      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {\n        if (isObjectLike(srcValue)) {\n          stackA || (stackA = []);\n          stackB || (stackB = []);\n          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n        }\n        var value = object[key],\n            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n            isCommon = typeof result == 'undefined';\n\n        if (isCommon) {\n          result = srcValue;\n        }\n        if ((isSrcArr || typeof result != 'undefined') &&\n            (isCommon || (result === result ? result !== value : value === value))) {\n          object[key] = result;\n        }\n      });\n      return object;\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n      var length = stackA.length,\n          srcValue = source[key];\n\n      while (length--) {\n        if (stackA[length] == srcValue) {\n          object[key] = stackB[length];\n          return;\n        }\n      }\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = typeof result == 'undefined';\n\n      if (isCommon) {\n        result = srcValue;\n        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {\n          result = isArray(value)\n            ? value\n            : (value ? arrayCopy(value) : []);\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          result = isArguments(value)\n            ? toPlainObject(value)\n            : (isPlainObject(value) ? value : {});\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate\n      // it with its merged value.\n      stackA.push(srcValue);\n      stackB.push(result);\n\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n      } else if (result === result ? result !== value : value === value) {\n        object[key] = result;\n      }\n    }\n\n    /**\n     * The base implementation of `_.property` which does not coerce `key` to a string.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * index arguments.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     */\n    function basePullAt(array, indexes) {\n      var length = indexes.length,\n          result = baseAt(array, indexes);\n\n      indexes.sort(baseCompareAscending);\n      while (length--) {\n        var index = parseFloat(indexes[length]);\n        if (index != previous && isIndex(index)) {\n          var previous = index;\n          splice.call(array, index, 1);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for argument juggling\n     * and returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.reduce` and `_.reduceRight` without support\n     * for callback shorthands or `this` binding, which iterates over `collection`\n     * using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} accumulator The initial value.\n     * @param {boolean} initFromCollection Specify using the first or last element\n     *  of `collection` as the initial value.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the accumulated value.\n     */\n    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n      eachFunc(collection, function(value, index, collection) {\n        accumulator = initFromCollection\n          ? (initFromCollection = false, value)\n          : iteratee(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop detection.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : (end - start) >>> 0;\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for callback shorthands\n     * or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The function invoked per iteration.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     */\n    function baseUniq(array, iteratee) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array.length,\n          isCommon = indexOf == baseIndexOf,\n          isLarge = isCommon && length >= 200,\n          seen = isLarge && createCache(),\n          result = [];\n\n      if (seen) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n      } else {\n        isLarge = false;\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value, index, array) : value;\n\n        if (isCommon && value === value) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (indexOf(seen, computed) < 0) {\n          if (iteratee || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * returned by `keysFunc`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, props) {\n      var index = -1,\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved unwrapped value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      var index = -1,\n          length = actions.length;\n\n      while (++index < length) {\n        var args = [result],\n            action = actions[index];\n\n        push.apply(args, action.args);\n        result = action.func.apply(action.thisArg, args);\n      }\n      return result;\n    }\n\n    /**\n     * Performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest, instead\n     *  of the lowest, index at which a value should be inserted into `array`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (retHighest ? (computed <= value) : (computed < value)) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return binaryIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * This function is like `binaryIndex` except that it invokes `iteratee` for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [retHighest] Specify returning the highest, instead\n     *  of the lowest, index at which a value should be inserted into `array`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsUndef = typeof value == 'undefined';\n\n      while (low < high) {\n        var mid = floor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            isReflexive = computed === computed;\n\n        if (valIsNaN) {\n          var setLow = isReflexive || retHighest;\n        } else if (valIsUndef) {\n          setLow = isReflexive && (retHighest || typeof computed != 'undefined');\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * A specialized version of `baseCallback` which only supports `this` binding\n     * and specifying the number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function bindCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      if (typeof thisArg == 'undefined') {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n        case 5: return function(value, other, key, object, source) {\n          return func.call(thisArg, value, other, key, object, source);\n        };\n      }\n      return function() {\n        return func.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * Creates a clone of the given array buffer.\n     *\n     * @private\n     * @param {ArrayBuffer} buffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function bufferClone(buffer) {\n      return bufferSlice.call(buffer, 0);\n    }\n    if (!bufferSlice) {\n      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.\n      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {\n        var byteLength = buffer.byteLength,\n            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,\n            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,\n            result = new ArrayBuffer(byteLength);\n\n        if (floatLength) {\n          var view = new Float64Array(result, 0, floatLength);\n          view.set(new Float64Array(buffer, 0, floatLength));\n        }\n        if (byteLength != offset) {\n          view = new Uint8Array(result, offset);\n          view.set(new Uint8Array(buffer, offset));\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders) {\n      var holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partials.length,\n          result = Array(argsLength + leftLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders) {\n      var holdersIndex = -1,\n          holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partials.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var pad = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[pad + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[pad + holders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an accumulator\n     * object composed from the results of running each element in the collection\n     * through an iteratee.\n     *\n     * @private\n     * @param {Function} setter The function to set keys and values of the accumulator object.\n     * @param {Function} [initializer] The function to initialize the accumulator object.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee, thisArg) {\n        var result = initializer ? initializer() : {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, iteratee(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, iteratee(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that assigns properties of source object(s) to a given\n     * destination object.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return function() {\n        var length = arguments.length,\n            object = arguments[0];\n\n        if (length < 2 || object == null) {\n          return object;\n        }\n        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {\n          length = 2;\n        }\n        // Juggle arguments.\n        if (length > 3 && typeof arguments[length - 2] == 'function') {\n          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);\n        } else if (length > 2 && typeof arguments[length - 1] == 'function') {\n          customizer = arguments[--length];\n        }\n        var index = 0;\n        while (++index < length) {\n          var source = arguments[index];\n          if (source) {\n            assigner(object, source, customizer);\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createBindWrapper(func, thisArg) {\n      var Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `Set` cache object to optimize linear searches of large arrays.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n     */\n    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {\n      return new SetCache(values);\n    };\n\n    /**\n     * Creates a function that produces compound words out of the words in a\n     * given string.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        var index = -1,\n            array = words(deburr(string)),\n            length = array.length,\n            result = '';\n\n        while (++index < length) {\n          result = callback(result, array[index], index);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtorWrapper(Ctor) {\n      return function() {\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, arguments);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that gets the extremum value of a collection.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to get the extremum value from an array.\n     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,\n     *  extremum value.\n     * @returns {Function} Returns the new extremum function.\n     */\n    function createExtremum(arrayFunc, isMin) {\n      return function(collection, iteratee, thisArg) {\n        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n          iteratee = null;\n        }\n        var func = getCallback(),\n            noIteratee = iteratee == null;\n\n        if (!(func === baseCallback && noIteratee)) {\n          noIteratee = false;\n          iteratee = func(iteratee, thisArg, 3);\n        }\n        if (noIteratee) {\n          var isArr = isArray(collection);\n          if (!isArr && isString(collection)) {\n            iteratee = charAtCallback;\n          } else {\n            return arrayFunc(isArr ? collection : toIterable(collection));\n          }\n        }\n        return extremumBy(collection, iteratee, isMin);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with optional `this`\n     * binding of, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG;\n\n      var Ctor = !isBindKey && createCtorWrapper(func),\n          key = func;\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it to other functions.\n        var length = arguments.length,\n            index = length,\n            args = Array(length);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight);\n        }\n        if (isCurry || isCurryRight) {\n          var placeholder = wrapper.placeholder,\n              argsHolders = replaceHolders(args, placeholder);\n\n          length -= argsHolders.length;\n          if (length < arity) {\n            var newArgPos = argPos ? arrayCopy(argPos) : null,\n                newArity = nativeMax(arity - length, 0),\n                newsHolders = isCurry ? argsHolders : null,\n                newHoldersRight = isCurry ? null : argsHolders,\n                newPartials = isCurry ? args : null,\n                newPartialsRight = isCurry ? null : args;\n\n            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n            if (!isCurryBound) {\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n            }\n            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);\n            result.placeholder = placeholder;\n            return result;\n          }\n        }\n        var thisBinding = isBind ? thisArg : this;\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (argPos) {\n          args = reorder(args, argPos);\n        }\n        if (isAry && ary < args.length) {\n          args.length = ary;\n        }\n        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates the pad required for `string` based on the given padding length.\n     * The `chars` string may be truncated if the number of padding characters\n     * exceeds the padding length.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the pad for `string`.\n     */\n    function createPad(string, length, chars) {\n      var strLength = string.length;\n      length = +length;\n\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars == null ? ' ' : (chars + '');\n      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the optional `this`\n     * binding of `thisArg` and the `partials` prepended to those provided to\n     * the wrapper.\n     *\n     * @private\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it `func`.\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(argsLength + leftLength);\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = null;\n      }\n      length -= (holders ? holders.length : 0);\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = null;\n      }\n      var data = !isBindKey && getData(func),\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n      if (data && data !== true) {\n        mergeData(newData, data);\n        bitmask = newData[1];\n        arity = newData[9];\n      }\n      newData[9] = arity == null\n        ? (isBindKey ? 0 : func.length)\n        : (nativeMax(arity - length, 0) || 0);\n\n      if (bitmask == BIND_FLAG) {\n        var result = createBindWrapper(newData[0], newData[2]);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n        result = createPartialWrapper.apply(undefined, newData);\n      } else {\n        result = createHybridWrapper.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setter(result, newData);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing arrays.\n     * @param {boolean} [isWhere] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {\n      var index = -1,\n          arrLength = array.length,\n          othLength = other.length,\n          result = true;\n\n      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {\n        return false;\n      }\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (result && ++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        result = undefined;\n        if (customizer) {\n          result = isWhere\n            ? customizer(othValue, arrValue, index)\n            : customizer(arrValue, othValue, index);\n        }\n        if (typeof result == 'undefined') {\n          // Recursively compare arrays (susceptible to call stack limits).\n          if (isWhere) {\n            var othIndex = othLength;\n            while (othIndex--) {\n              othValue = other[othIndex];\n              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n              if (result) {\n                break;\n              }\n            }\n          } else {\n            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n          }\n        }\n      }\n      return !!result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} value The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag) {\n      switch (tag) {\n        case boolTag:\n        case dateTag:\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n          return +object == +other;\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case numberTag:\n          // Treat `NaN` vs. `NaN` as equal.\n          return (object != +object)\n            ? other != +other\n            // But, treat `-0` vs. `+0` as not equal.\n            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings primitives and string\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n          return object == (other + '');\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isWhere] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n      var objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isWhere) {\n        return false;\n      }\n      var hasCtor,\n          index = -1;\n\n      while (++index < objLength) {\n        var key = objProps[index],\n            result = hasOwnProperty.call(other, key);\n\n        if (result) {\n          var objValue = object[key],\n              othValue = other[key];\n\n          result = undefined;\n          if (customizer) {\n            result = isWhere\n              ? customizer(othValue, objValue, key)\n              : customizer(objValue, othValue, key);\n          }\n          if (typeof result == 'undefined') {\n            // Recursively compare objects (susceptible to call stack limits).\n            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);\n          }\n        }\n        if (!result) {\n          return false;\n        }\n        hasCtor || (hasCtor = key == 'constructor');\n      }\n      if (!hasCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Gets the extremum value of `collection` invoking `iteratee` for each value\n     * in `collection` to generate the criterion by which the value is ranked.\n     * The `iteratee` is invoked with three arguments; (value, index, collection).\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [isMin] Specify returning the minimum, instead of the\n     *  maximum, extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function extremumBy(collection, iteratee, isMin) {\n      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,\n          computed = exValue,\n          result = computed;\n\n      baseEach(collection, function(value, index, collection) {\n        var current = iteratee(value, index, collection);\n        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {\n          computed = current;\n          result = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseCallback` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getCallback(func, thisArg, argCount) {\n      var result = lodash.callback || callback;\n      result = result === callback ? baseCallback : result;\n      return argCount ? result(func, thisArg, argCount) : result;\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseIndexOf` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function|number} Returns the chosen function or its result.\n     */\n    function getIndexOf(collection, target, fromIndex) {\n      var result = lodash.indexOf || indexOf;\n      result = result === indexOf ? baseIndexOf : result;\n      return collection ? result(collection, target, fromIndex) : result;\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} [transforms] The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms ? transforms.length : 0;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add array properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      var Ctor = object.constructor;\n      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n        Ctor = Object;\n      }\n      return new Ctor;\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return bufferClone(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          var buffer = object.buffer;\n          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          var result = new Ctor(object.source, reFlags.exec(object));\n          result.lastIndex = object.lastIndex;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `func` is eligible for `this` binding.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.\n     */\n    function isBindable(func) {\n      var support = lodash.support,\n          result = !(support.funcNames ? func.name : support.funcDecomp);\n\n      if (!result) {\n        var source = fnToString.call(func);\n        if (!support.funcNames) {\n          result = !reFuncName.test(source);\n        }\n        if (!result) {\n          // Check if `func` references the `this` keyword and store the result.\n          result = reThis.test(source) || isNative(func);\n          baseSetData(func, result);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      value = +value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return value > -1 && value % 1 == 0 && value < length;\n    }\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number') {\n        var length = object.length,\n            prereq = isLength(length) && isIndex(index, length);\n      } else {\n        prereq = type == 'string' && index in object;\n      }\n      return prereq && object[index] === value;\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is based on ES `ToLength`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n     * for more details.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     */\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers required to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n     * augment function arguments, making the order in which they are executed important,\n     * preventing the merging of metadata. However, we make an exception for a safe\n     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask;\n\n      var arityFlags = ARY_FLAG | REARG_FLAG,\n          bindFlags = BIND_FLAG | BIND_KEY_FLAG,\n          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;\n\n      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),\n          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),\n          argPos = (isRearg ? data : source)[7],\n          ary = (isAry ? data : source)[8];\n\n      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&\n        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);\n\n      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&\n        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = arrayCopy(value);\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * A specialized version of `_.pick` that picks `object` properties specified\n     * by the `props` array.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property names to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByArray(object, props) {\n      object = toObject(object);\n\n      var index = -1,\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        if (key in object) {\n          result[key] = object[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.pick` that picks `object` properties `predicate`\n     * returns truthy for.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByCallback(object, predicate) {\n      var result = {};\n      baseForIn(object, function(value, key, object) {\n        if (predicate(value, key, object)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = arrayCopy(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity function\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = (function() {\n      var count = 0,\n          lastCalled = 0;\n\n      return function(key, value) {\n        var stamp = now(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return key;\n          }\n        } else {\n          count = 0;\n        }\n        return baseSetData(key, value);\n      };\n    }());\n\n    /**\n     * A fallback implementation of `_.isPlainObject` which checks if `value`\n     * is an object created by the `Object` constructor or has a `[[Prototype]]`\n     * of `null`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var Ctor,\n          support = lodash.support;\n\n      // Exit early for non `Object` objects.\n      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||\n          (!hasOwnProperty.call(value, 'constructor') &&\n            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      var result;\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      baseForIn(value, function(subValue, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n      var props = keysIn(object),\n          propsLength = props.length,\n          length = propsLength && object.length,\n          support = lodash.support;\n\n      var allowIndexes = length && isLength(length) &&\n        (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n      var index = -1,\n          result = [];\n\n      while (++index < propsLength) {\n        var key = props[index];\n        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to an array-like object if it is not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array|Object} Returns the array-like object.\n     */\n    function toIterable(value) {\n      if (value == null) {\n        return [];\n      }\n      if (!isLength(value.length)) {\n        return values(value);\n      }\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to an object if it is not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Object} Returns the object.\n     */\n    function toObject(value) {\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      return wrapper instanceof LazyWrapper\n        ? wrapper.clone()\n        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `collection` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new array containing chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n        size = 1;\n      } else {\n        size = nativeMax(+size || 1, 1);\n      }\n      var index = 0,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = Array(ceil(length / size));\n\n      while (index < length) {\n        result[++resIndex] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using\n     * `SameValueZero` for equality comparisons.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3], [5, 2, 10]);\n     * // => [1, 3]\n     */\n    function difference() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var value = arguments[index];\n        if (isArray(value) || isArguments(value)) {\n          break;\n        }\n      }\n      return baseDifference(value, baseFlatten(arguments, false, true, ++index));\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that match the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per element.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRightWhile([1, 2, 3], function(n) { return n > 1; });\n     * // => [1]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.dropRightWhile(users, { 'age': 1, 'active': false }), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n     * // => ['barney']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      predicate = getCallback(predicate, thisArg, 3);\n      while (length-- && predicate(array[length], length, array)) {}\n      return baseSlice(array, 0, length + 1);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per element.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropWhile([1, 2, 3], function(n) { return n < 3; });\n     * // => [3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.dropWhile(users, { 'age': 36, 'active': false }), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n     * // => ['pebbles']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.dropWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var index = -1;\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length && predicate(array[index], index, array)) {}\n      return baseSlice(array, index);\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for, instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.findIndex(users, function(chr) { return chr.age < 40; });\n     * // => 0\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.findIndex(users, { 'age': 40, 'active': true });\n     * // => 1\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.findIndex(users, 'age', 1);\n     * // => 2\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.findIndex(users, 'active');\n     * // => 1\n     */\n    function findIndex(array, predicate, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(chr) { return chr.age < 40; });\n     * // => 2\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.findLastIndex(users, { 'age': 36, 'active': true });\n     * // => 0\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.findLastIndex(users, 'age', 40);\n     * // => 1\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n      predicate = getCallback(predicate, thisArg, 3);\n      while (length--) {\n        if (predicate(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([]);\n     * // => undefined\n     */\n    function first(array) {\n      return array ? array[0] : undefined;\n    }\n\n    /**\n     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n     * flattened, otherwise it is only flattened a single level.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * // using `isDeep`\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, 4];\n     */\n    function flatten(array, isDeep, guard) {\n      var length = array ? array.length : 0;\n      if (guard && isIterateeCall(array, isDeep, guard)) {\n        isDeep = false;\n      }\n      return length ? baseFlatten(array, isDeep) : [];\n    }\n\n    /**\n     * Recursively flattens a nested array.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to recursively flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, true) : [];\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,\n     * it is used as the offset from the end of `array`. If `array` is sorted\n     * providing `true` for `fromIndex` performs a faster binary search.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * // performing a binary search\n     * _.indexOf([4, 4, 5, 5, 6, 6], 5, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      } else if (fromIndex) {\n        var index = binaryIndex(array, value),\n            other = array[index];\n\n        return (value === value ? value === other : other !== other) ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      return dropRight(array, 1);\n    }\n\n    /**\n     * Creates an array of unique values in all provided arrays using `SameValueZero`\n     * for equality comparisons.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = [],\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf;\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(isCommon && value.length >= 120 && createCache(argsIndex && value));\n        }\n      }\n      argsLength = args.length;\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [],\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        value = array[index];\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {\n          argsIndex = argsLength;\n          while (--argsIndex) {\n            var cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(value);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n     *  or `true` to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     *\n     * // performing a binary search\n     * _.lastIndexOf([4, 4, 5, 5, 6, 6], 5, true);\n     * // => 3\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n      } else if (fromIndex) {\n        index = binaryIndex(array, value, true) - 1;\n        var other = array[index];\n        return (value === value ? value === other : other !== other) ? index : -1;\n      }\n      if (value !== value) {\n        return indexOfNaN(array, index, true);\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using `SameValueZero` for equality\n     * comparisons.\n     *\n     * **Notes:**\n     *  - Unlike `_.without`, this method mutates `array`.\n     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,\n     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     *    for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull() {\n      var array = arguments[0];\n      if (!(array && array.length)) {\n        return array;\n      }\n      var index = 0,\n          indexOf = getIndexOf(),\n          length = arguments.length;\n\n      while (++index < length) {\n        var fromIndex = 0,\n            value = arguments[index];\n\n        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to the given indexes and returns\n     * an array of the removed elements. Indexes may be specified as an array of\n     * indexes or as individual arguments.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [5, 10, 15, 20];\n     * var evens = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => [5, 15]\n     *\n     * console.log(evens);\n     * // => [10, 20]\n     */\n    function pullAt(array) {\n      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));\n    }\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is bound to\n     * `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) { return n % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias tail\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function rest(array) {\n      return drop(array, 1);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This function is used instead of `Array#slice` to support node\n     * lists in IE < 9 and to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value` should\n     * be inserted into `array` in order to maintain its sort order. If an iteratee\n     * function is provided it is invoked for `value` and each element of `array`\n     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n     * invoked with one argument; (value).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     *\n     * _.sortedIndex([4, 4, 5, 5, 6, 6], 5);\n     * // => 2\n     *\n     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n     *\n     * // using an iteratee function\n     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n     *   return this.data[word];\n     * }, dict);\n     * // => 1\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 1\n     */\n    function sortedIndex(array, value, iteratee, thisArg) {\n      var func = getCallback(iteratee);\n      return (func === baseCallback && iteratee == null)\n        ? binaryIndex(array, value)\n        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 4, 5, 5, 6, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value, iteratee, thisArg) {\n      var func = getCallback(iteratee);\n      return (func === baseCallback && iteratee == null)\n        ? binaryIndex(array, value, true)\n        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per element.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRightWhile([1, 2, 3], function(n) { return n > 1; });\n     * // => [2, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.takeRightWhile(users, { 'age': 1, 'active': true }), 'user');\n     * // => ['pebbles']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeRightWhile(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      predicate = getCallback(predicate, thisArg, 3);\n      while (length-- && predicate(array[length], length, array)) {}\n      return baseSlice(array, length + 1);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is bound to\n     * `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per element.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeWhile([1, 2, 3], function(n) { return n < 3; });\n     * // => [1, 2]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.takeWhile(users, { 'age': 36, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.takeWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeWhile(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var index = -1;\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length && predicate(array[index], index, array)) {}\n      return baseSlice(array, 0, index);\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * `SameValueZero` for equality comparisons.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, false, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using `SameValueZero`\n     * for equality comparisons. Providing `true` for `isSorted` performs a faster\n     * search algorithm for sorted arrays. If an iteratee function is provided it\n     * is invoked for each value in the array to generate the criterion by which\n     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {boolean} [isSorted] Specify the array is sorted.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     *  If a property name or object is provided it is used to create a \"_.property\"\n     *  or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1]);\n     * // => [1, 2]\n     *\n     * // using `isSorted`\n     * _.uniq([1, 1, 2], true);\n     * // => [1, 2]\n     *\n     * // using an iteratee function\n     * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);\n     * // => [1, 2.5]\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      // Juggle arguments.\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = iteratee;\n        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;\n        isSorted = false;\n      }\n      var func = getCallback();\n      if (!(func === baseCallback && iteratee == null)) {\n        iteratee = func(iteratee, thisArg, 3);\n      }\n      return (isSorted && getIndexOf() == baseIndexOf)\n        ? sortedUniq(array, iteratee)\n        : baseUniq(array, iteratee);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-`_.zip`\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function unzip(array) {\n      var index = -1,\n          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = arrayMap(array, baseProperty(index));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all provided values using `SameValueZero` for\n     * equality comparisons.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, baseSlice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for\n     * more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseDifference(result, array).concat(baseDifference(array, result))\n            : array;\n        }\n      }\n      return result ? baseUniq(result) : [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var length = arguments.length,\n          array = Array(length);\n\n      while (length--) {\n        array[length] = arguments[length];\n      }\n      return unzip(array);\n    }\n\n    /**\n     * Creates an object composed from arrays of property names and values. Provide\n     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of property names and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Array\n     * @param {Array} props The property names.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(props, values) {\n      var index = -1,\n          length = props ? props.length : 0,\n          result = {};\n\n      if (length && !values && !isArray(props[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = props[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method\n     * chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(users)\n     *   .sortBy('age')\n     *   .map(function(chr) { return chr.user + ' is ' + chr.age; })\n     *   .first()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n     * this method is to \"tap into\" a method chain in order to perform operations\n     * on intermediate results within the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor, thisArg) {\n      interceptor.call(thisArg, value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .last()\n     *  .thru(function(value) { return [value]; })\n     *  .value();\n     * // => [3]\n     */\n    function thru(value, interceptor, thisArg) {\n      return interceptor.call(thisArg, value);\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(users).first();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(users).chain()\n     *   .first()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chained sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapper = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapper = wrapper.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapper.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapper = _(array).map(_.partial(Math.pow, _, 2));\n     *\n     * var other = [3, 4];\n     * var otherWrapper = wrapper.plant(other);\n     *\n     * otherWrapper.value();\n     * // => [9, 16]\n     *\n     * wrapper.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof LodashWrapper) {\n        var clone = wrapperClone(parent);\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * Reverses the wrapped array so the first element becomes the last, the\n     * second element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        if (this.__actions__.length) {\n          value = new LazyWrapper(this);\n        }\n        return new LodashWrapper(value.reverse(), this.__chain__);\n      }\n      return this.thru(function(value) {\n        return value.reverse();\n      });\n    }\n\n    /**\n     * Produces the result of coercing the unwrapped value to a string.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chain\n     * @returns {string} Returns the coerced string value.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return (this.value() + '');\n    }\n\n    /**\n     * Executes the chained sequence to extract the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @alias run, toJSON, valueOf\n     * @category Chain\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements corresponding to the given keys, or indexes,\n     * of `collection`. Keys may be specified as individual arguments or as arrays\n     * of keys.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [props] The property names\n     *  or indexes of elements to pick, specified individually or in arrays.\n     * @returns {Array} Returns the new array of picked elements.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var length = collection ? collection.length : 0;\n      if (isLength(length)) {\n        collection = toIterable(collection);\n      }\n      return baseAt(collection, baseFlatten(arguments, false, false, 1));\n    }\n\n    /**\n     * Checks if `value` is in `collection` using `SameValueZero` for equality\n     * comparisons. If `fromIndex` is negative, it is used as the offset from\n     * the end of `collection`.\n     *\n     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,\n     * e.g. `===`, except that `NaN` matches `NaN`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @alias contains, include\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} target The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.includes('pebbles', 'eb');\n     * // => true\n     */\n    function includes(collection, target, fromIndex) {\n      var length = collection ? collection.length : 0;\n      if (!isLength(length)) {\n        collection = values(collection);\n        length = collection.length;\n      }\n      if (!length) {\n        return false;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      } else {\n        fromIndex = 0;\n      }\n      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)\n        : (getIndexOf(collection, target, fromIndex) > -1);\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the number of times the key was returned by `iteratee`.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) { return Math.floor(n); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) { return this.floor(n); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * The predicate is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.every(users, { 'age': 36, 'active': false });\n     * // => false\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.every(users, 'active', false);\n     * // => true\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4], function(n) { return n % 2 == 0; });\n     * // => [2, 4]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.filter(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.filter(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function filter(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.result(_.find(users, function(chr) { return chr.age < 40; }), 'user');\n     * // => 'barney'\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n     * // => 'pebbles'\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.result(_.find(users, 'active', false), 'user');\n     * // => 'fred'\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.result(_.find(users, 'active'), 'user');\n     * // => 'barney'\n     */\n    function find(collection, predicate, thisArg) {\n      if (isArray(collection)) {\n        var index = findIndex(collection, predicate, thisArg);\n        return index > -1 ? collection[index] : undefined;\n      }\n      predicate = getCallback(predicate, thisArg, 3);\n      return baseFind(collection, predicate, baseEach);\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) { return n % 2 == 1; });\n     * // => 3\n     */\n    function findLast(collection, predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 3);\n      return baseFind(collection, predicate, baseEachRight);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning the first element that has equivalent property\n     * values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n     * // => 'barney'\n     *\n     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n     * // => 'fred'\n     */\n    function findWhere(collection, source) {\n      return find(collection, baseMatches(source));\n    }\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Iterator functions may exit iteration early\n     * by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();\n     * // => logs each value from left to right and returns the array\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n     */\n    function forEach(collection, iteratee, thisArg) {\n      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))\n        ? arrayEach(collection, iteratee)\n        : baseEach(collection, bindCallback(iteratee, thisArg, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(n) { console.log(n); }).join(',');\n     * // => logs each value from right to left and returns the array\n     */\n    function forEachRight(collection, iteratee, thisArg) {\n      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))\n        ? arrayEachRight(collection, iteratee)\n        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the last element responsible for generating the key. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in `collection`,\n     * returning an array of the results of each invoked method. Any additional\n     * arguments are provided to each invoked method. If `methodName` is a function\n     * it is invoked for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      return baseInvoke(collection, methodName, baseSlice(arguments, 2));\n    }\n\n    /**\n     * Creates an array of values by running each element in `collection` through\n     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * Many lodash methods are guarded to work as interatees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,\n     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,\n     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,\n     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * _.map([1, 2, 3], function(n) { return n * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });\n     * // => [3, 6, 9] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee, thisArg) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return func(collection, iteratee);\n    }\n\n    /**\n     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     *  If a property name or object is provided it is used to create a \"_.property\"\n     *  or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => -Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(users, function(chr) { return chr.age; });\n     * // => { 'user': 'fred', 'age': 40 };\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.max(users, 'age');\n     * // => { 'user': 'fred', 'age': 40 };\n     */\n    var max = createExtremum(arrayMax);\n\n    /**\n     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n     * `Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     *  If a property name or object is provided it is used to create a \"_.property\"\n     *  or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(users, function(chr) { return chr.age; });\n     * // => { 'user': 'barney', 'age': 36 };\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.min(users, 'age');\n     * // => { 'user': 'barney', 'age': 36 };\n     */\n    var min = createExtremum(arrayMin, true);\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, while the second of which\n     * contains elements `predicate` returns falsey for. The predicate is bound\n     * to `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.partition([1, 2, 3], function(n) { return n % 2; });\n     * // => [[1, 3], [2]]\n     *\n     * _.partition([1.2, 2.3, 3.4], function(n) { return this.floor(n) % 2; }, Math);\n     * // => [[1, 3], [2]]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * var mapper = function(array) { return _.pluck(array, 'user'); };\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n     * // => [['pebbles'], ['barney', 'fred']]\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.map(_.partition(users, 'active', false), mapper);\n     * // => [['barney', 'pebbles'], ['fred']]\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.map(_.partition(users, 'active'), mapper);\n     * // => [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Gets the value of `key` from all elements in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} key The key of the property to pluck.\n     * @returns {Array} Returns the property values.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(users, 'user');\n     * // => ['barney', 'fred']\n     *\n     * var userIndex = _.indexBy(users, 'user');\n     * _.pluck(userIndex, 'age');\n     * // => [36, 40] (iteration order is not guaranteed)\n     */\n    function pluck(collection, key) {\n      return map(collection, baseProperty(key));\n    }\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` through `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not provided the first element of `collection` is used as the initial\n     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as interatees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `merge`, and `sortAllBy`\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, n) { return sum + n; });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator, thisArg) {\n      var func = isArray(collection) ? arrayReduce : baseReduce;\n      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator, thisArg) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce;\n      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4], function(n) { return n % 2 == 0; });\n     * // => [1, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.pluck(_.reject(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.reject(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function reject(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, function(value, index, collection) {\n        return !predicate(value, index, collection);\n      });\n    }\n\n    /**\n     * Gets a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {*} Returns the random sample(s).\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n        collection = toIterable(collection);\n        var length = collection.length;\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      collection = toIterable(collection);\n\n      var index = -1,\n          length = collection.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var rand = baseRandom(0, index);\n        if (index != rand) {\n          result[index] = result[rand];\n        }\n        result[rand] = collection[index];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the size of `collection` by returning `collection.length` for\n     * array-like values or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the size of `collection`.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return isLength(length) ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * The function returns as soon as it finds a passing value and does not iterate\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\n     * with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.some(users, { 'age': 1, 'active': true });\n     * // => false\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.some(users, 'active', false);\n     * // => true\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through `iteratee`. This method performs\n     * a stable sort, that is, it preserves the original sort order of equal elements.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [iteratee=_.identity] The function\n     *  invoked per iteration. If a property name or an object is provided it is\n     *  used to create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var users = [\n     *   { 'user': 'fred' },\n     *   { 'user': 'pebbles' },\n     *   { 'user': 'barney' }\n     * ];\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.pluck(_.sortBy(users, 'user'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function sortBy(collection, iteratee, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = isLength(length) ? Array(length) : [];\n\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = null;\n      }\n      iteratee = getCallback(iteratee, thisArg, 3);\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };\n      });\n      return baseSortBy(result, compareAscending);\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it sorts by property names\n     * instead of an iteratee function.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(string|string[])} props The property names to sort by,\n     *  specified as individual property names or arrays of property names.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 26 },\n     *   { 'user': 'fred',   'age': 30 }\n     * ];\n     *\n     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortByAll(collection) {\n      var args = arguments;\n      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {\n        args = [collection, args[1]];\n      }\n      var index = -1,\n          length = collection ? collection.length : 0,\n          props = baseFlatten(args, false, false, 1),\n          result = isLength(length) ? Array(length) : [];\n\n      baseEach(collection, function(value) {\n        var length = props.length,\n            criteria = Array(length);\n\n        while (length--) {\n          criteria[length] = value == null ? undefined : value[props[length]];\n        }\n        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };\n      });\n      return baseSortBy(result, compareMultipleAscending);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n     * // => ['fred']\n     */\n    function where(collection, source) {\n      return filter(collection, baseMatches(source));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Date\n     * @example\n     *\n     * _.defer(function(stamp) { console.log(_.now() - stamp); }, _.now());\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\n     */\n    var now = nativeNow || function() {\n      return new Date().getTime();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it is called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'done saving!' after the two async saves have completed\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      n = nativeIsFinite(n = +n) ? n : 0;\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that accepts up to `n` arguments ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      if (guard && isIterateeCall(func, n, guard)) {\n        n = null;\n      }\n      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n      return createWrapper(func, ARY_FLAG, null, null, null, null, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it is called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery('#add').on('click', _.before(5, addContactToList));\n     * // => allows adding up to 4 contacts to the list\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        } else {\n          func = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `_.bind` arguments to those provided to the\n     * bound function.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind` this method does not set the `length`\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [args] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var greet = function(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * };\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // using placeholders\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    function bind(func, thisArg) {\n      var bitmask = BIND_FLAG;\n      if (arguments.length > 2) {\n        var partials = baseSlice(arguments, 2),\n            holders = replaceHolders(partials, bind.placeholder);\n\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(func, bitmask, thisArg, partials, holders);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all enumerable function\n     * properties, own and inherited, of `object` are bound.\n     *\n     * **Note:** This method does not set the `length` property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} [methodNames] The object method names to bind,\n     *  specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs' when the element is clicked\n     */\n    function bindAll(object) {\n      return baseBindAll(object,\n        arguments.length > 1\n          ? baseFlatten(arguments, false, false, 1)\n          : functions(object)\n      );\n    }\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `_.bindKey` arguments to those provided to the bound function.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [args] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // using placeholders\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (arguments.length > 2) {\n        var partials = baseSlice(arguments, 2),\n            holders = replaceHolders(partials, bindKey.placeholder);\n\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(key, bitmask, object, partials, holders);\n    }\n\n    /**\n     * Creates a function that accepts one or more arguments of `func` that when\n     * called either invokes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` may be specified\n     * if `func.length` is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the `length` property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      if (guard && isIterateeCall(func, arity, guard)) {\n        arity = null;\n      }\n      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the `length` property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      if (guard && isIterateeCall(func, arity, guard)) {\n        arity = null;\n      }\n      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a function that delays invoking `func` until after `wait` milliseconds\n     * have elapsed since the last time it was invoked. The created function comes\n     * with a `cancel` method to cancel delayed invocations. Provide an options\n     * object to indicate that `func` should be invoked on the leading and/or\n     * trailing edge of the `wait` timeout. Subsequent calls to the debounced\n     * function return the result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n     *  delayed before it is invoked.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }));\n     *\n     * // cancel a debounced call\n     * var todoChanges = _.debounce(batchLog, 1000);\n     * Object.observe(models.todo, todoChanges);\n     *\n     * Object.observe(models, function(changes) {\n     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n     *     todoChanges.cancel();\n     *   }\n     * }, ['delete']);\n     *\n     * // ...at some point `models.todo` is changed\n     * models.todo.completed = true;\n     *\n     * // ...before 1 second has passed `models.todo` is deleted\n     * // which cancels the debounced `todoChanges` call\n     * delete models.todo;\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = wait < 0 ? 0 : wait;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n\n      function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (maxTimeoutId) {\n          clearTimeout(maxTimeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n      }\n\n      function delayed() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      }\n\n      function maxDelayed() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      }\n\n      function debounced() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      return baseDelay(func, 1, arguments, 1);\n    }\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      return baseDelay(func, wait, arguments, 2);\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the provided\n     * functions with the `this` binding of the created function, where each\n     * successive invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function add(x, y) {\n     *   return x + y;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow(add, square);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    function flow() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      if (!length) {\n        return function() { return arguments[0]; };\n      }\n      if (!arrayEvery(funcs, isFunction)) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var index = 0,\n            result = funcs[index].apply(this, arguments);\n\n        while (++index < length) {\n          result = funcs[index].call(this, result);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the provided functions from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias backflow, compose\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function add(x, y) {\n     *   return x + y;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight(square, add);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    function flowRight() {\n      var funcs = arguments,\n          fromIndex = funcs.length - 1;\n\n      if (fromIndex < 0) {\n        return function() { return arguments[0]; };\n      }\n      if (!arrayEvery(funcs, isFunction)) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var index = fromIndex,\n            result = funcs[index].apply(this, arguments);\n\n        while (index--) {\n          result = funcs[index].call(this, result);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is coerced to a string and used as the\n     * cache key. The `func` is invoked with the `this` binding of the memoized\n     * function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the ES `Map` method interface\n     * of `get`, `has`, and `set`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var upperCase = _.memoize(function(string) {\n     *   return string.toUpperCase();\n     * });\n     *\n     * upperCase('fred');\n     * // => 'FRED'\n     *\n     * // modifying the result cache\n     * upperCase.cache.set('fred', 'BARNEY');\n     * upperCase('fred');\n     * // => 'BARNEY'\n     *\n     * // replacing `_.memoize.Cache`\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'barney' };\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'fred' }\n     *\n     * _.memoize.Cache = WeakMap;\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'barney' }\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : arguments[0];\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, arguments);\n        cache.set(key, result);\n        return result;\n      };\n      memoized.cache = new memoize.Cache;\n      return memoized;\n    }\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first call. The `func` is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` invokes `createApplication` once\n     */\n    function once(func) {\n      return before(func, 2);\n    }\n\n    /**\n     * Creates a function that invokes `func` with `partial` arguments prepended\n     * to those provided to the new function. This method is like `_.bind` except\n     * it does **not** alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the `length` property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [args] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // using placeholders\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      var partials = baseSlice(arguments, 1),\n          holders = replaceHolders(partials, partial.placeholder);\n\n      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);\n    }\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the `length` property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [args] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // using placeholders\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    function partialRight(func) {\n      var partials = baseSlice(arguments, 1),\n          holders = replaceHolders(partials, partialRight.placeholder);\n\n      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);\n    }\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified indexes where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, 2, 0, 1);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     *\n     * var map = _.rearg(_.map, [1, 0]);\n     * map(function(n) { return n * 3; }, [1, 2, 3]);\n     * // => [3, 6, 9]\n     */\n    function rearg(func) {\n      var indexes = baseFlatten(arguments, false, false, 1);\n      return createWrapper(func, REARG_FLAG, null, null, null, indexes);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and the array of arguments provided to the created\n     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @returns {*} Returns the new function.\n     * @example\n     *\n     * var spread = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * spread(['Fred', 'hello']);\n     * // => 'Fred says hello'\n     *\n     * // with a Promise\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * var add = function(x, y) {\n     *   return x + y;\n     * };\n     *\n     * numbers.then(_.spread(add));\n     * // => a Promise of 76\n     */\n    function spread(func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function(array) {\n        return func.apply(this, array);\n      };\n    }\n\n    /**\n     * Creates a function that only invokes `func` at most once per every `wait`\n     * milliseconds. The created function comes with a `cancel` method to cancel\n     * delayed invocations. Provide an options object to indicate that `func`\n     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n     * Subsequent calls to the throttled function return the result of the last\n     * `func` call.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle invocations to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * var throttled =  _.throttle(renewToken, 300000, { 'trailing': false })\n     * jQuery('.interactive').on('click', throttled);\n     *\n     * // cancel a trailing throttled call\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = +wait;\n      debounceOptions.trailing = trailing;\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Any additional arguments provided to the function are\n     * appended to those provided to the wrapper function. The wrapper is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n     * otherwise they are assigned by reference. If `customizer` is provided it is\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is bound to\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the structured clone algorithm.\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var shallow = _.clone(users);\n     * shallow[0] === users[0];\n     * // => true\n     *\n     * var deep = _.clone(users, true);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var body = _.clone(document.body, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(false) : undefined;\n     * });\n     *\n     * body === document.body\n     * // => false\n     * body.nodeName\n     * // => BODY\n     * body.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, customizer, thisArg) {\n      // Juggle arguments.\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = customizer;\n        customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;\n        isDeep = false;\n      }\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n      return baseClone(value, isDeep, customizer);\n    }\n\n    /**\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\n     * and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the structured clone algorithm.\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var deep = _.cloneDeep(users);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.cloneDeep(document.body, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * body === document.body\n     * // => false\n     * body.nodeName\n     * // => BODY\n     * body.childNodes.length;\n     * // => 20\n     */\n    function cloneDeep(value, customizer, thisArg) {\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n      return baseClone(value, true, customizer);\n    }\n\n    /**\n     * Checks if `value` is classified as an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })();\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      var length = isObjectLike(value) ? value.length : undefined;\n      return (isLength(length) && objToString.call(value) == argsTag) || false;\n    }\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;\n    };\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return (value && value.nodeType === 1 && isObjectLike(value) &&\n        objToString.call(value).indexOf('Element') > -1) || false;\n    }\n    // Fallback for environments without DOM support.\n    if (!support.dom) {\n      isElement = function(value) {\n        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;\n      };\n    }\n\n    /**\n     * Checks if a value is empty. A value is considered empty unless it is an\n     * `arguments` object, array, string, or jQuery-like collection with a length\n     * greater than `0` or an object with own enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      var length = value.length;\n      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||\n          (isObjectLike(value) && isFunction(value.splice)))) {\n        return !length;\n      }\n      return !keys(value).length;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent. If `customizer` is provided it is invoked to compare values.\n     * If `customizer` returns `undefined` comparisons are handled by the method\n     * instead. The `customizer` is bound to `thisArg` and invoked with three\n     * arguments; (value, other [, index|key]).\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. Functions and DOM nodes\n     * are **not** supported. Provide a customizer function to extend support\n     * for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * object == other;\n     * // => false\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * // using a customizer callback\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqual(array, other, function(value, other) {\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n     * });\n     * // => true\n     */\n    function isEqual(value, other, customizer, thisArg) {\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {\n        return value === other;\n      }\n      var result = customizer ? customizer(value, other) : undefined;\n      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on ES `Number.isFinite`. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(10);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => false\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite(Object(10));\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    var isFinite = nativeNumIsFinite || function(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    };\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n      // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n      return typeof value == 'function' || false;\n    }\n    // Fallback for environments that return incorrect `typeof` operator results.\n    if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {\n      isFunction = function(value) {\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in older versions of Chrome and Safari which return 'function' for regexes\n        // and Safari 8 equivalents which return 'object' for typed array constructors.\n        return objToString.call(value) == funcTag;\n      };\n    }\n\n    /**\n     * Checks if `value` is the language type of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // Avoid a V8 JIT bug in Chrome 19-20.\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n      var type = typeof value;\n      return type == 'function' || (value && type == 'object') || false;\n    }\n\n    /**\n     * Performs a deep comparison between `object` and `source` to determine if\n     * `object` contains equivalent property values. If `customizer` is provided\n     * it is invoked to compare values. If `customizer` returns `undefined`\n     * comparisons are handled by the method instead. The `customizer` is bound\n     * to `thisArg` and invoked with three arguments; (value, other, index|key).\n     *\n     * **Note:** This method supports comparing properties of arrays, booleans,\n     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n     * and DOM nodes are **not** supported. Provide a customizer function to extend\n     * support for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.isMatch(object, { 'age': 40 });\n     * // => true\n     *\n     * _.isMatch(object, { 'age': 36 });\n     * // => false\n     *\n     * // using a customizer callback\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatch(object, source, function(value, other) {\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n     * });\n     * // => true\n     */\n    function isMatch(object, source, customizer, thisArg) {\n      var props = keys(source),\n          length = props.length;\n\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n      if (!customizer && length == 1) {\n        var key = props[0],\n            value = source[key];\n\n        if (isStrictComparable(value)) {\n          return object != null && value === object[key] && hasOwnProperty.call(object, key);\n        }\n      }\n      var values = Array(length),\n          strictCompareFlags = Array(length);\n\n      while (length--) {\n        value = values[length] = source[props[length]];\n        strictCompareFlags[length] = isStrictComparable(value);\n      }\n      return baseIsMatch(object, props, values, strictCompareFlags, customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is not the same as native `isNaN` which returns `true`\n     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (value == null) {\n        return false;\n      }\n      if (objToString.call(value) == funcTag) {\n        return reNative.test(fnToString.call(value));\n      }\n      return (isObjectLike(value) && reHostCtor.test(value)) || false;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n     * as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4);\n     * // => true\n     *\n     * _.isNumber(NaN);\n     * // => true\n     *\n     * _.isNumber('8.4');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * **Note:** This method assumes objects created by the `Object` constructor\n     * have no inherited enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && objToString.call(value) == objectTag)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;\n    }\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3);\n     * // => [2, 3]\n     */\n    function toArray(value) {\n      var length = value ? value.length : 0;\n      if (!isLength(length)) {\n        return values(value);\n      }\n      if (!length) {\n        return [];\n      }\n      return arrayCopy(value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return baseCopy(value, keysIn(value));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources overwrite property assignments of previous sources.\n     * If `customizer` is provided it is invoked to produce the assigned values.\n     * The `customizer` is bound to `thisArg` and invoked with five arguments;\n     * (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using a customizer callback\n     * var defaults = _.partialRight(_.assign, function(value, other) {\n     *   return typeof value == 'undefined' ? other : value;\n     * });\n     *\n     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var assign = createAssigner(baseAssign);\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties, guard) {\n      var result = baseCreate(prototype);\n      if (guard && isIterateeCall(prototype, properties, guard)) {\n        properties = null;\n      }\n      return properties ? baseCopy(properties, result, keys(properties)) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property are ignored.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    function defaults(object) {\n      if (object == null) {\n        return object;\n      }\n      var args = arrayCopy(arguments);\n      args.push(assignDefaults);\n      return assign.apply(undefined, args);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element `predicate` returns truthy for, instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(chr) { return chr.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.findKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 3);\n      return baseFind(object, predicate, baseForOwn, true);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * If a property name is provided for `predicate` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(chr) { return chr.age < 40; });\n     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n     *\n     * // using the \"_.matches\" callback shorthand\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // using the \"_.matchesProperty\" callback shorthand\n     * _.findLastKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 3);\n      return baseFind(object, predicate, baseForOwnRight, true);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object invoking\n     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n     * with three arguments; (value, key, object). Iterator functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n     */\n    function forIn(object, iteratee, thisArg) {\n      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {\n        iteratee = bindCallback(iteratee, thisArg, 3);\n      }\n      return baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n     */\n    function forInRight(object, iteratee, thisArg) {\n      iteratee = bindCallback(iteratee, thisArg, 3);\n      return baseForRight(object, iteratee, keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object invoking `iteratee`\n     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n     * three arguments; (value, key, object). Iterator functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (iteration order is not guaranteed)\n     */\n    function forOwn(object, iteratee, thisArg) {\n      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {\n        iteratee = bindCallback(iteratee, thisArg, 3);\n      }\n      return baseForOwn(object, iteratee);\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, iteratee, thisArg) {\n      iteratee = bindCallback(iteratee, thisArg, 3);\n      return baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * Creates an array of function property names from all enumerable properties,\n     * own and inherited, of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', ...]\n     */\n    function functions(object) {\n      return baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Checks if `key` exists as a direct property of `object` instead of an\n     * inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite property\n     * assignments of previous values unless `multiValue` is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiValue] Allow multiple values per key.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     *\n     * // without `multiValue`\n     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });\n     * // => { 'fred': 'third', 'barney': 'second' }\n     *\n     * // with `multiValue`\n     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);\n     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }\n     */\n    function invert(object, multiValue, guard) {\n      if (guard && isIterateeCall(object, multiValue, guard)) {\n        multiValue = null;\n      }\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (multiValue) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (object) {\n        var Ctor = object.constructor,\n            length = object.length;\n      }\n      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n         (typeof object != 'function' && (length && isLength(length)))) {\n        return shimKeys(object);\n      }\n      return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      if (object == null) {\n        return [];\n      }\n      if (!isObject(object)) {\n        object = Object(object);\n      }\n      var length = object.length;\n      length = (length && isLength(length) &&\n        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n      var Ctor = object.constructor,\n          index = -1,\n          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n          result = Array(length),\n          skipIndexes = length > 0;\n\n      while (++index < length) {\n        result[index] = (index + '');\n      }\n      for (var key in object) {\n        if (!(skipIndexes && isIndex(key, length)) &&\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through `iteratee`. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `iteratee` the created \"_.property\"\n     * style callback returns the property value of the given element.\n     *\n     * If value is also provided for `thisArg` the created \"_.matchesProperty\"\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created \"_.matches\" style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration. If a property name or object is provided it is used to\n     *  create a \"_.property\" or \"_.matches\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(n) { return n * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using the \"_.property\" callback shorthand\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee, thisArg) {\n      var result = {};\n      iteratee = getCallback(iteratee, thisArg, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        result[key] = iteratee(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * overwrite property assignments of previous sources. If `customizer` is\n     * provided it is invoked to produce the merged values of the destination and\n     * source properties. If `customizer` returns `undefined` merging is handled\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n     * with five arguments; (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n     * };\n     *\n     * var ages = {\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n     * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     *\n     * // using a customizer callback\n     * var object = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var other = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(object, other, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var merge = createAssigner(baseMerge);\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that are not omitted.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If `predicate` is provided it is invoked for each property\n     * of `object` omitting the properties `predicate` returns truthy for. The\n     * predicate is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to omit, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.omit(object, 'age');\n     * // => { 'user': 'fred' }\n     *\n     * _.omit(object, _.isNumber);\n     * // => { 'user': 'fred' }\n     */\n    function omit(object, predicate, thisArg) {\n      if (object == null) {\n        return {};\n      }\n      if (typeof predicate != 'function') {\n        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);\n        return pickByArray(object, baseDifference(keysIn(object), props));\n      }\n      predicate = bindCallback(predicate, thisArg, 3);\n      return pickByCallback(object, function(value, key, object) {\n        return !predicate(value, key, object);\n      });\n    }\n\n    /**\n     * Creates a two dimensional array of the key-value pairs for `object`,\n     * e.g. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties. Property\n     * names may be specified as individual arguments or as arrays of property\n     * names. If `predicate` is provided it is invoked for each property of `object`\n     * picking the properties `predicate` returns truthy for. The predicate is\n     * bound to `thisArg` and invoked with three arguments; (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.pick(object, 'user');\n     * // => { 'user': 'fred' }\n     *\n     * _.pick(object, _.isString);\n     * // => { 'user': 'fred' }\n     */\n    function pick(object, predicate, thisArg) {\n      if (object == null) {\n        return {};\n      }\n      return typeof predicate == 'function'\n        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))\n        : pickByArray(object, baseFlatten(arguments, false, false, 1));\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If the value of `key` is\n     * a function it is invoked with the `this` binding of `object` and its result\n     * is returned, else the property value is returned. If the property value is\n     * `undefined` the `defaultValue` is used in its place.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the property value\n     *  resolves to `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': _.constant(40) };\n     *\n     * _.result(object, 'user');\n     * // => 'fred'\n     *\n     * _.result(object, 'age');\n     * // => 40\n     *\n     * _.result(object, 'status', 'busy');\n     * // => 'busy'\n     *\n     * _.result(object, 'status', _.constant('busy'));\n     * // => 'busy'\n     */\n    function result(object, key, defaultValue) {\n      var value = object == null ? undefined : object[key];\n      if (typeof value == 'undefined') {\n        value = defaultValue;\n      }\n      return isFunction(value) ? value.call(object) : value;\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own enumerable\n     * properties through `iteratee`, with each invocation potentially mutating\n     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n     * with four arguments; (accumulator, value, key, object). Iterator functions\n     * may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6], function(result, n) {\n     *   n *= n;\n     *   if (n % 2) {\n     *     return result.push(n) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, iteratee, accumulator, thisArg) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = getCallback(iteratee, thisArg, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor : [];\n          } else {\n            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values\n     * of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number is returned.\n     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n     * number is returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      if (floating && isIterateeCall(min, max, floating)) {\n        max = floating = null;\n      }\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (noMax && typeof min == 'boolean') {\n          floating = min;\n          min = 1;\n        }\n        else if (typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n        noMax = false;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to camel case.\n     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__foo_bar__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n    });\n\n    /**\n     * Capitalizes the first character of `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('fred');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      string = baseToString(string);\n      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n    }\n\n    /**\n     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.\n     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = baseToString(string);\n      return string && string.replace(reLatin1, deburrLetter);\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = baseToString(string);\n      target = (target + '');\n\n      var length = string.length;\n      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and '`', in `string` to\n     * their corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional characters\n     * use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't require escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value.\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * Backticks are escaped because in Internet Explorer < 9, they can break out\n     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),\n     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of\n     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.\n     *\n     * When working with HTML you should always quote attribute values to reduce\n     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n      string = baseToString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n     * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = baseToString(string);\n      return (string && reHasRegExpChars.test(string))\n        ? string.replace(reRegExpChars, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to kebab case (a.k.a. spinal case).\n     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for\n     * more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__foo_bar__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Pads `string` on the left and right sides if it is shorter then the given\n     * padding length. The `chars` string may be truncated if the number of padding\n     * characters can't be evenly divided by the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = baseToString(string);\n      length = +length;\n\n      var strLength = string.length;\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = floor(mid),\n          rightLength = ceil(mid);\n\n      chars = createPad('', rightLength, chars);\n      return chars.slice(0, leftLength) + string + chars;\n    }\n\n    /**\n     * Pads `string` on the left side if it is shorter then the given padding\n     * length. The `chars` string may be truncated if the number of padding\n     * characters exceeds the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padLeft('abc', 6);\n     * // => '   abc'\n     *\n     * _.padLeft('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padLeft('abc', 3);\n     * // => 'abc'\n     */\n    function padLeft(string, length, chars) {\n      string = baseToString(string);\n      return string && (createPad(string, length, chars) + string);\n    }\n\n    /**\n     * Pads `string` on the right side if it is shorter then the given padding\n     * length. The `chars` string may be truncated if the number of padding\n     * characters exceeds the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padRight('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padRight('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padRight('abc', 3);\n     * // => 'abc'\n     */\n    function padRight(string, length, chars) {\n      string = baseToString(string);\n      return string && (string + createPad(string, length, chars));\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the ES5 implementation of `parseInt`.\n     * See the [ES5 spec](https://es5.github.io/#E) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard && isIterateeCall(string, radix, guard)) {\n        radix = 0;\n      }\n      return nativeParseInt(string, radix);\n    }\n    // Fallback for environments with pre-ES5 implementations.\n    if (nativeParseInt(whitespace + '08') != 8) {\n      parseInt = function(string, radix, guard) {\n        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n        // Chrome fails to trim leading <BOM> whitespace characters.\n        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n          radix = 0;\n        } else if (radix) {\n          radix = +radix;\n        }\n        string = trim(string);\n        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));\n      };\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      var result = '';\n      string = baseToString(string);\n      n = +n;\n      if (n < 1 || !string || !nativeIsFinite(n)) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = floor(n / 2);\n        string += string;\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * Converts `string` to snake case.\n     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--foo-bar');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string` to start case.\n     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__foo_bar__');\n     * // => 'Foo Bar'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = baseToString(string);\n      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is provided it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.\n     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for more details.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // using custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using backslashes to treat delimiters as plain text\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // using the `imports` option to import `jQuery` as `jq`\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '';\n     *   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, otherOptions) {\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n        options = otherOptions = null;\n      }\n      string = baseToString(string);\n      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\n      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar]\n     */\n    function trim(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n      }\n      chars = (chars + '');\n      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimLeft('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimLeft('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimLeft(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string));\n      }\n      return string.slice(charsLeftIndex(string, (chars + '')));\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimRight('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimRight('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimRight(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(0, trimmedRightIndex(string) + 1);\n      }\n      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n    }\n\n    /**\n     * Truncates `string` if it is longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object|number} [options] The options object or maximum string length.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.trunc('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', 24);\n     * // => 'hi-diddly-ho there, n...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });\n     * //=> 'hi-diddly-ho there...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function trunc(string, options, guard) {\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = null;\n      }\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (options != null) {\n        if (isObject(options)) {\n          var separator = 'separator' in options ? options.separator : separator;\n          length = 'length' in options ? +options.length || 0 : length;\n          omission = 'omission' in options ? baseToString(options.omission) : omission;\n        } else {\n          length = +options || 0;\n        }\n      }\n      string = baseToString(string);\n      if (length >= string.length) {\n        return string;\n      }\n      var end = length - omission.length;\n      if (end < 1) {\n        return omission;\n      }\n      var result = string.slice(0, end);\n      if (separator == null) {\n        return result + omission;\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              newEnd,\n              substring = string.slice(0, end);\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            newEnd = match.index;\n          }\n          result = result.slice(0, newEnd == null ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n     * corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = baseToString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      if (guard && isIterateeCall(string, pattern, guard)) {\n        pattern = null;\n      }\n      string = baseToString(string);\n      return string.match(pattern || reWords) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} func The function to attempt.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // avoid throwing errors for invalid selectors\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    function attempt(func) {\n      try {\n        return func.apply(undefined, baseSlice(arguments, 1));\n      } catch(e) {\n        return isError(e) ? e : new Error(e);\n      }\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and arguments of the created function. If `func` is a property name the\n     * created callback returns the property value for a given element. If `func`\n     * is an object the created callback returns `true` for elements that contain\n     * the equivalent object properties, otherwise it returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias iteratee\n     * @category Utility\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n     *   if (!match) {\n     *     return callback(func, thisArg);\n     *   }\n     *   return function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(users, 'age__gt36');\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function callback(func, thisArg, guard) {\n      if (guard && isIterateeCall(func, thisArg, guard)) {\n        thisArg = null;\n      }\n      return isObjectLike(func)\n        ? matches(func)\n        : baseCallback(func, thisArg);\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function which performs a deep comparison between a given object\n     * and `source`, returning `true` if the given object has equivalent property\n     * values, else `false`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function which compares the property value of `key` on a given\n     * object to `value`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} key The key of the property to get.\n     * @param {*} value The value to compare.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var matchFred = _.matchesProperty('user', 'fred');\n     *\n     * _.find(users, matchFred);\n     * // => { 'user': 'fred', 'age': 40 }\n     */\n    function matchesProperty(key, value) {\n      return baseMatchesProperty(key + '', baseClone(value, true));\n    }\n\n    /**\n     * Adds all own enumerable function properties of a source object to the\n     * destination object. If `object` is a function then methods are added to\n     * its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function|Object} [object=this] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)\n     * var _ = require('lodash').runInContext();\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      if (options == null) {\n        var isObj = isObject(source),\n            props = isObj && keys(source),\n            methodNames = props && props.length && baseFunctions(source, props);\n\n        if (!(methodNames ? methodNames.length : isObj)) {\n          methodNames = false;\n          options = source;\n          source = object;\n          object = this;\n        }\n      }\n      if (!methodNames) {\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = true,\n          index = -1,\n          isFunc = isFunction(object),\n          length = methodNames.length;\n\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      while (++index < length) {\n        var methodName = methodNames[index],\n            func = source[methodName];\n\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = (function(func) {\n            return function() {\n              var chainAll = this.__chain__;\n              if (chain || chainAll) {\n                var result = object(this.__wrapped__);\n                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });\n                result.__chain__ = chainAll;\n                return result;\n              }\n              var args = [this.value()];\n              push.apply(args, arguments);\n              return func.apply(object, args);\n            };\n          }(func));\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function which returns the property value of `key` on a given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred' },\n     *   { 'user': 'barney' }\n     * ];\n     *\n     * var getName = _.property('user');\n     *\n     * _.map(users, getName);\n     * // => ['fred', barney']\n     *\n     * _.pluck(_.sortBy(users, getName), 'user');\n     * // => ['barney', 'fred']\n     */\n    function property(key) {\n      return baseProperty(key + '');\n    }\n\n    /**\n     * The inverse of `_.property`; this method creates a function which returns\n     * the property value of a given key on `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to inspect.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40, 'active': true };\n     * _.map(['active', 'user'], _.propertyOf(object));\n     * // => [true, 'fred']\n     *\n     * var object = { 'a': 3, 'b': 1, 'c': 2 };\n     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));\n     * // => ['b', 'c', 'a']\n     */\n    function propertyOf(object) {\n      return function(key) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. If `start` is less than `end` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      if (step && isIterateeCall(start, end, step)) {\n        end = step = null;\n      }\n      start = +start || 0;\n      step = step == null ? 1 : (+step || 0);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n      var index = -1,\n          length = nativeMax(ceil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the iteratee function `n` times, returning an array of the results\n     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n     * one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also invokes `mage.castSpell(n)` three times\n     */\n    function times(n, iteratee, thisArg) {\n      n = +n;\n\n      // Exit early to avoid a JSC JIT bug in Safari 8\n      // where `Array(0)` is treated as `Array(1)`.\n      if (n < 1 || !nativeIsFinite(n)) {\n        return [];\n      }\n      var index = -1,\n          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\n      iteratee = bindCallback(iteratee, thisArg, 1);\n      while (++index < n) {\n        if (index < MAX_ARRAY_LENGTH) {\n          result[index] = iteratee(index);\n        } else {\n          iteratee(index);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return baseToString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Ensure `new LodashWrapper` is an instance of `lodash`.\n    LodashWrapper.prototype = baseCreate(lodash.prototype);\n\n    // Ensure `new LazyWraper` is an instance of `LodashWrapper`\n    LazyWrapper.prototype = baseCreate(LodashWrapper.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    // Add functions to the `Map` cache.\n    MapCache.prototype['delete'] = mapDelete;\n    MapCache.prototype.get = mapGet;\n    MapCache.prototype.has = mapHas;\n    MapCache.prototype.set = mapSet;\n\n    // Add functions to the `Set` cache.\n    SetCache.prototype.push = cachePush;\n\n    // Assign cache to `_.memoize`.\n    memoize.Cache = MapCache;\n\n    // Add functions that return wrapped values when chaining.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.callback = callback;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortByAll = sortByAll;\n    lodash.spread = spread;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.unzip = unzip;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // Add aliases.\n    lodash.backflow = flowRight;\n    lodash.collect = map;\n    lodash.compose = flowRight;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.iteratee = callback;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n\n    // Add functions to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions that return unwrapped values when chaining.\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.deburr = deburr;\n    lodash.endsWith = endsWith;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.findWhere = findWhere;\n    lodash.first = first;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isMatch = isMatch;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.max = max;\n    lodash.min = min;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padLeft = padLeft;\n    lodash.padRight = padRight;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.template = template;\n    lodash.trim = trim;\n    lodash.trimLeft = trimLeft;\n    lodash.trimRight = trimRight;\n    lodash.trunc = trunc;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.words = words;\n\n    // Add aliases.\n    lodash.all = every;\n    lodash.any = some;\n    lodash.contains = includes;\n    lodash.detect = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.head = first;\n    lodash.include = includes;\n    lodash.inject = reduce;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), false);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions capable of returning wrapped and unwrapped values when chaining.\n    lodash.sample = sample;\n\n    lodash.prototype.sample = function(n) {\n      if (!this.__chain__ && n == null) {\n        return sample(this.value());\n      }\n      return this.thru(function(value) {\n        return sample(value, n);\n      });\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var isFilter = index == LAZY_FILTER_FLAG,\n          isWhile = index == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n        var result = this.clone(),\n            filtered = result.__filtered__,\n            iteratees = result.__iteratees__ || (result.__iteratees__ = []);\n\n        result.__filtered__ = filtered || isFilter || (isWhile && result.__dir__ < 0);\n        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      var countName = '__' + methodName + 'Count__',\n          whileName = methodName + 'While';\n\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);\n\n        var result = this.clone();\n        if (result.__filtered__) {\n          var value = result[countName];\n          result[countName] = index ? nativeMin(value, n) : (value + n);\n        } else {\n          var views = result.__views__ || (result.__views__ = []);\n          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n\n      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {\n        return this.reverse()[whileName](predicate, thisArg).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n    arrayEach(['first', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n    arrayEach(['initial', 'rest'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[dropName](1);\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n    arrayEach(['pluck', 'where'], function(methodName, index) {\n      var operationName = index ? 'filter' : 'map',\n          createCallback = index ? baseMatches : baseProperty;\n\n      LazyWrapper.prototype[methodName] = function(value) {\n        return this[operationName](createCallback(value));\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.dropWhile = function(iteratee, thisArg) {\n      var done;\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return this.filter(function(value, index, array) {\n        return done || (done = !iteratee(value, index, array));\n      });\n    };\n\n    LazyWrapper.prototype.reject = function(iteratee, thisArg) {\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return this.filter(function(value, index, array) {\n        return !iteratee(value, index, array);\n      });\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = start == null ? 0 : (+start || 0);\n      var result = start < 0 ? this.takeRight(-start) : this.drop(start);\n\n      if (typeof end != 'undefined') {\n        end = (+end || 0);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.drop(0);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName],\n          retUnwrapped = /^(?:first|last)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = arguments,\n            chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isLazy = value instanceof LazyWrapper,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (retUnwrapped && !chainAll) {\n          return onlyLazy\n            ? func.call(value)\n            : lodashFunc.call(lodash, this.value());\n        }\n        var interceptor = function(value) {\n          var otherArgs = [value];\n          push.apply(otherArgs, args);\n          return lodashFunc.apply(lodash, otherArgs);\n        };\n        if (isLazy || isArray(value)) {\n          var wrapper = onlyLazy ? value : new LazyWrapper(this),\n              result = func.apply(wrapper, args);\n\n          if (!retUnwrapped && (isHybrid || result.__actions__)) {\n            var actions = result.__actions__ || (result.__actions__ = []);\n            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });\n          }\n          return new LodashWrapper(result, chainAll);\n        }\n        return this.thru(interceptor);\n      };\n    });\n\n    // Add `Array.prototype` functions to `lodash.prototype`.\n    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          return func.apply(this.value(), args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(value, args);\n        });\n      };\n    });\n\n    // Add functions to the lazy wrapper.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chaining functions to the lodash wrapper.\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add function aliases to the lodash wrapper.\n    lodash.prototype.collect = lodash.prototype.map;\n    lodash.prototype.head = lodash.prototype.first;\n    lodash.prototype.select = lodash.prototype.filter;\n    lodash.prototype.tail = lodash.prototype.rest;\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose lodash to the global object when an AMD loader is present to avoid\n    // errors in cases where lodash is loaded by a script tag and not intended\n    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n    // more details.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for Node.js or RingoJS.\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // Export for Narwhal or Rhino -require.\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // Export for a browser or Rhino.\n    root._ = _;\n  }\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/~/lodash/index.js\n ** module id = 207\n ** module chunks = 3\n **/","\nvar chardet = require('bemuse-chardet/bemuse-chardet')\n\nexports.read = function read(buffer) {\n  throw new Error('Synchronous read unsupported in browser!')\n}\n\nexports.readAsync = function read(buffer, callback) {\n  var charset = chardet.detect(buffer)\n  var reader = new FileReader()\n  reader.onload = function() {\n    callback(null, reader.result)\n  }\n  reader.onerror = function() {\n    callback(new Error('cannot read it'))\n  }\n  reader.readAsText(new Blob([buffer]), charset)\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/reader/index.web.js\n ** module id = 208\n ** module chunks = 3\n **/","\nvar match = require('../util/match')\nmodule.exports = SongInfo\n\nfunction SongInfo() {\n  this.title      = 'NO TITLE'\n  this.artist     = 'NO ARTIST'\n  this.genre      = 'NO GENRE'\n  this.subtitles  = []\n  this.subartists = []\n  this.difficulty = 0\n  this.level      = 0\n}\n\nSongInfo.fromBMSChart = function(chart) {\n  var info = new SongInfo()\n  var title      = chart.headers.get('title')\n  var artist     = chart.headers.get('artist')\n  var genre      = chart.headers.get('genre')\n  var difficulty = +chart.headers.get('difficulty')\n  var level      = +chart.headers.get('playlevel')\n  var subtitles  = chart.headers.getAll('subtitle')\n  var subartists = chart.headers.getAll('subartist')\n  if (typeof title === 'string' && !subtitles) {\n    var extractSubtitle = function(m) {\n      title = m[1]\n      subtitles = [m[2]]\n    }\n    match(title)\n    .when(/^(.*\\S)\\s*-(.+?)-$/,   extractSubtitle)\n    .when(/^(.*\\S)\\s*～(.+?)～$/, extractSubtitle)\n    .when(/^(.*\\S)\\s*\\((.+?)\\)$/, extractSubtitle)\n    .when(/^(.*\\S)\\s*\\[(.+?)\\]$/, extractSubtitle)\n    .when(/^(.*\\S)\\s*<(.+?)>$/,   extractSubtitle)\n  }\n  if (title)      info.title      = title\n  if (artist)     info.artist     = artist\n  if (genre)      info.genre      = genre\n  if (subtitles)  info.subtitles  = subtitles\n  if (subartists) info.subartists = subartists\n  if (difficulty) info.difficulty = difficulty\n  if (level)      info.level      = level\n  return info\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bms/song-info/index.js\n ** module id = 209\n ** module chunks = 3\n **/","\n/**\n * Parse byte `size` string.\n *\n * @param {String} size\n * @return {Number}\n * @api public\n */\n\nmodule.exports = function(size) {\n  if ('number' == typeof size) return convert(size);\n  var parts = size.match(/^(\\d+(?:\\.\\d+)?) *(kb|mb|gb|tb)$/)\n    , n = parseFloat(parts[1])\n    , type = parts[2];\n\n  var map = {\n      kb: 1 << 10\n    , mb: 1 << 20\n    , gb: 1 << 30\n    , tb: ((1 << 30) * 1024)\n  };\n\n  return map[type] * n;\n};\n\n/**\n * convert bytes into string.\n *\n * @param {Number} b - bytes to convert\n * @return {String}\n * @api public\n */\n\nfunction convert (b) {\n  var tb = ((1 << 30) * 1024), gb = 1 << 30, mb = 1 << 20, kb = 1 << 10, abs = Math.abs(b);\n  if (abs >= tb) return (Math.round(b / tb * 100) / 100) + 'tb';\n  if (abs >= gb) return (Math.round(b / gb * 100) / 100) + 'gb';\n  if (abs >= mb) return (Math.round(b / mb * 100) / 100) + 'mb';\n  if (abs >= kb) return (Math.round(b / kb * 100) / 100) + 'kb';\n  return b + 'b';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/bytes/index.js\n ** module id = 210\n ** module chunks = 3\n **/","exports = module.exports = require(\"/home/ubuntu/bemuse/node_modules/css-loader/cssToString.js\")();\nexports.push([module.id, \".loading-scene{position:absolute;top:0;right:0;bottom:0;left:0;overflow:hidden;background:url(\"+require(\"assets/bg/a.jpg\")+\") center no-repeat;background-size:cover}.loading-scene--info{position:absolute;top:40%;left:0;right:0;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.loading-scene .loading-scene-song-info{-webkit-animation:loading-scene-song-info-animation 1s ease;animation:loading-scene-song-info-animation 1s ease}.loading-scene .loading-scene-progress{position:absolute;bottom:10px;left:10px}.loading-scene--flash{background:#fff;-webkit-animation:loading-scene--flash-animation .8s ease-out;animation:loading-scene--flash-animation .8s ease-out}.loading-scene--flash,.loading-scene--cover{position:absolute;top:0;right:0;bottom:0;left:0;opacity:0;pointer-events:none}.loading-scene--cover{background:#000}.scene.is-exiting .loading-scene--info{-webkit-animation:loading-scene--info-exit .3s linear;animation:loading-scene--info-exit .3s linear}.scene.is-exiting .loading-scene--flash{-webkit-animation:loading-scene--flash-exit .3s ease;animation:loading-scene--flash-exit .3s ease}.scene.is-exiting .loading-scene--cover{-webkit-animation:loading-scene--cover-exit .3s linear;animation:loading-scene--cover-exit .3s linear;opacity:1}@-webkit-keyframes loading-scene-song-info-animation{0%{-webkit-transform:scale(1.5,.02);transform:scale(1.5,.02)}100%{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes loading-scene-song-info-animation{0%{-webkit-transform:scale(1.5,.02);transform:scale(1.5,.02)}100%{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes loading-scene--info-exit{0%{-webkit-transform:translateY(-50%)scale(1,1);transform:translateY(-50%)scale(1,1)}100%{-webkit-transform:translateY(-50%)scale(2,2);transform:translateY(-50%)scale(2,2)}}@keyframes loading-scene--info-exit{0%{-webkit-transform:translateY(-50%)scale(1,1);transform:translateY(-50%)scale(1,1)}100%{-webkit-transform:translateY(-50%)scale(2,2);transform:translateY(-50%)scale(2,2)}}@-webkit-keyframes loading-scene--cover-exit{0%{opacity:0}100%{opacity:1}}@keyframes loading-scene--cover-exit{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes loading-scene--flash-animation{0%{opacity:1}100%{opacity:0}}@keyframes loading-scene--flash-animation{0%{opacity:1}100%{opacity:0}}@-webkit-keyframes loading-scene--flash-exit{0%{opacity:.5}100%{opacity:0}}@keyframes loading-scene--flash-exit{0%{opacity:.5}100%{opacity:0}}.loading-scene-song-info{background:rgba(255,255,255,.96);color:#191817;text-align:center;padding:25px 0;box-shadow:0 2px 18px rgba(0,0,0,.2)}.loading-scene-song-info--genre{font-size:3vmin}.loading-scene-song-info--title{font-size:8vmin;font-weight:700}.loading-scene-song-info--subtitle{font-size:6vmin}.loading-scene-song-info--artist{font-size:4vmin;margin-top:.8ex}.loading-scene-song-info--subartist{font-size:2.5vmin}.loading-scene-progress{color:#333;font-size:11px}.loading-scene-progress .loading-scene-progress-bar{display:inline-block;vertical-align:middle;width:48px;margin-right:4px;position:relative;top:-1px}.loading-scene-progress-bar{border:1px solid rgba(0,0,0,.6);padding:1px}.loading-scene-progress-bar--bar{height:8px;background:rgba(0,0,0,.6);width:0%}.loading-scene-progress-bar--progress{font-size:83%;opacity:.7}\", \"\"]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader!../~/autoprefixer-loader?browsers=last 2 version!../~/sass-loader?outputStyle=expanded!./game/loading-scene/style.scss\n ** module id = 244\n ** module chunks = 3\n **/","module.exports = __webpack_public_path__ + \"7d6d69a86d70e4e52079c5ce873435c6.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../assets/bg/a.jpg\n ** module id = 246\n ** module chunks = 3\n **/","module.exports={\"v\":1,\"t\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--info\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--genre\"},\"f\":[{\"t\":2,\"r\":\"song.genre\"}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--title\"},\"f\":[{\"t\":2,\"r\":\"song.title\"}]},{\"t\":4,\"r\":\"song.subtitles\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--subtitle\"},\"f\":[{\"t\":2,\"r\":\".\"}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--artist\"},\"f\":[{\"t\":2,\"r\":\"song.artist\"}]},{\"t\":4,\"r\":\"song.subartists\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-song-info--subartist\"},\"f\":[{\"t\":2,\"r\":\".\"}]}]}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress\"},\"f\":[{\"t\":4,\"r\":\"items\",\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress--item\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene-progress-bar\"},\"f\":[{\"t\":7,\"e\":\"div\",\"a\":{\"style\":[\"width:\",{\"t\":2,\"r\":\"width\"}],\"class\":\"loading-scene-progress-bar--bar\"}}]},{\"t\":2,\"r\":\"text\"},{\"t\":7,\"e\":\"span\",\"a\":{\"class\":\"loading-scene-progress-bar--progress\"},\"f\":[{\"t\":2,\"r\":\"progress\"}]}]}]}]},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--flash\"}},{\"t\":7,\"e\":\"div\",\"a\":{\"class\":\"loading-scene--cover\"}}]}]};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ractive-loader!./view/template.loader.js!../~/jade-loader!./game/loading-scene/view.jade\n ** module id = 254\n ** module chunks = 3\n **/","/*\n\tractive.js v0.6.1\n\t2014-10-25 - commit 3a576eb3 \n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n( function( global ) {\n\n\t'use strict';\n\n\tvar noConflict = global.Ractive;\n\n\t/* config/defaults/options.js */\n\tvar options = function() {\n\n\t\tvar defaultOptions = {\n\t\t\t// render placement:\n\t\t\tel: void 0,\n\t\t\tappend: false,\n\t\t\t// template:\n\t\t\ttemplate: {\n\t\t\t\tv: 1,\n\t\t\t\tt: []\n\t\t\t},\n\t\t\tyield: null,\n\t\t\t// parse:\n\t\t\tpreserveWhitespace: false,\n\t\t\tsanitize: false,\n\t\t\tstripComments: true,\n\t\t\t// data & binding:\n\t\t\tdata: {},\n\t\t\tcomputed: {},\n\t\t\tmagic: false,\n\t\t\tmodifyArrays: true,\n\t\t\tadapt: [],\n\t\t\tisolated: false,\n\t\t\ttwoway: true,\n\t\t\tlazy: false,\n\t\t\t// transitions:\n\t\t\tnoIntro: false,\n\t\t\ttransitionsEnabled: true,\n\t\t\tcomplete: void 0,\n\t\t\t// css:\n\t\t\tnoCssTransform: false,\n\t\t\t// debug:\n\t\t\tdebug: false\n\t\t};\n\t\treturn defaultOptions;\n\t}();\n\n\t/* config/defaults/easing.js */\n\tvar easing = {\n\t\tlinear: function( pos ) {\n\t\t\treturn pos;\n\t\t},\n\t\teaseIn: function( pos ) {\n\t\t\treturn Math.pow( pos, 3 );\n\t\t},\n\t\teaseOut: function( pos ) {\n\t\t\treturn Math.pow( pos - 1, 3 ) + 1;\n\t\t},\n\t\teaseInOut: function( pos ) {\n\t\t\tif ( ( pos /= 0.5 ) < 1 ) {\n\t\t\t\treturn 0.5 * Math.pow( pos, 3 );\n\t\t\t}\n\t\t\treturn 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );\n\t\t}\n\t};\n\n\t/* circular.js */\n\tvar circular = [];\n\n\t/* utils/hasOwnProperty.js */\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\t/* utils/isArray.js */\n\tvar isArray = function() {\n\n\t\tvar toString = Object.prototype.toString;\n\t\t// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\t\treturn function( thing ) {\n\t\t\treturn toString.call( thing ) === '[object Array]';\n\t\t};\n\t}();\n\n\t/* utils/isObject.js */\n\tvar isObject = function() {\n\n\t\tvar toString = Object.prototype.toString;\n\t\treturn function( thing ) {\n\t\t\treturn thing && toString.call( thing ) === '[object Object]';\n\t\t};\n\t}();\n\n\t/* utils/isNumeric.js */\n\tvar isNumeric = function( thing ) {\n\t\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t};\n\n\t/* config/defaults/interpolators.js */\n\tvar interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {\n\n\t\tvar interpolators, interpolate, cssLengthPattern;\n\t\tcircular.push( function() {\n\t\t\tinterpolate = circular.interpolate;\n\t\t} );\n\t\tcssLengthPattern = /^([+-]?[0-9]+\\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;\n\t\tinterpolators = {\n\t\t\tnumber: function( from, to ) {\n\t\t\t\tvar delta;\n\t\t\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfrom = +from;\n\t\t\t\tto = +to;\n\t\t\t\tdelta = to - from;\n\t\t\t\tif ( !delta ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\treturn from;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn function( t ) {\n\t\t\t\t\treturn from + t * delta;\n\t\t\t\t};\n\t\t\t},\n\t\t\tarray: function( from, to ) {\n\t\t\t\tvar intermediate, interpolators, len, i;\n\t\t\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tintermediate = [];\n\t\t\t\tinterpolators = [];\n\t\t\t\ti = len = Math.min( from.length, to.length );\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tinterpolators[ i ] = interpolate( from[ i ], to[ i ] );\n\t\t\t\t}\n\t\t\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\t\t\tfor ( i = len; i < from.length; i += 1 ) {\n\t\t\t\t\tintermediate[ i ] = from[ i ];\n\t\t\t\t}\n\t\t\t\tfor ( i = len; i < to.length; i += 1 ) {\n\t\t\t\t\tintermediate[ i ] = to[ i ];\n\t\t\t\t}\n\t\t\t\treturn function( t ) {\n\t\t\t\t\tvar i = len;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tintermediate[ i ] = interpolators[ i ]( t );\n\t\t\t\t\t}\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t},\n\t\t\tobject: function( from, to ) {\n\t\t\t\tvar properties, len, interpolators, intermediate, prop;\n\t\t\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tproperties = [];\n\t\t\t\tintermediate = {};\n\t\t\t\tinterpolators = {};\n\t\t\t\tfor ( prop in from ) {\n\t\t\t\t\tif ( hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) ) {\n\t\t\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ( prop in to ) {\n\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = properties.length;\n\t\t\t\treturn function( t ) {\n\t\t\t\t\tvar i = len,\n\t\t\t\t\t\tprop;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = properties[ i ];\n\t\t\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t\t\t}\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn interpolators;\n\t}( circular, hasOwn, isArray, isObject, isNumeric );\n\n\t/* config/svg.js */\n\tvar svg = function() {\n\n\t\tvar svg;\n\t\tif ( typeof document === 'undefined' ) {\n\t\t\tsvg = false;\n\t\t} else {\n\t\t\tsvg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );\n\t\t}\n\t\treturn svg;\n\t}();\n\n\t/* utils/warn.js */\n\tvar warn = function() {\n\n\t\t/* global console */\n\t\tvar warn, warned = {};\n\t\tif ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {\n\t\t\twarn = function( message, allowDuplicates ) {\n\t\t\t\tif ( !allowDuplicates ) {\n\t\t\t\t\tif ( warned[ message ] ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twarned[ message ] = true;\n\t\t\t\t}\n\t\t\t\tconsole.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );\n\t\t\t};\n\t\t} else {\n\t\t\twarn = function() {};\n\t\t}\n\t\treturn warn;\n\t}();\n\n\t/* config/errors.js */\n\tvar errors = {\n\t\tmissingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',\n\t\tmergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',\n\t\tnoComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',\n\t\tnoTemplateForPartial: 'Could not find template for partial \"{name}\"',\n\t\tnoNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',\n\t\tevaluationError: 'Error evaluating \"{uniqueString}\": {err}',\n\t\tbadArguments: 'Bad arguments \"{arguments}\". I\\'m not allowed to argue unless you\\'ve paid.',\n\t\tfailedComputation: 'Failed to compute \"{key}\": {err}',\n\t\tmissingPlugin: 'Missing \"{name}\" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',\n\t\tbadRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n\t\tnoRegistryFunctionReturn: 'A function was specified for \"{name}\" {registry}, but no {registry} was returned',\n\t\tdefaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',\n\t\tnoElementProxyEventWildcards: 'Only component proxy-events may contain \"*\" wildcards, <{element} on-{event}/> is not valid.',\n\t\tmethodDeprecated: 'The method \"{deprecated}\" has been deprecated in favor of \"{replacement}\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'\n\t};\n\n\t/* utils/log.js */\n\tvar log = function( consolewarn, errors ) {\n\n\t\tvar log = {\n\t\t\twarn: function( options, passthru ) {\n\t\t\t\tif ( !options.debug && !passthru ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.warnAlways( options );\n\t\t\t},\n\t\t\twarnAlways: function( options ) {\n\t\t\t\tthis.logger( getMessage( options ), options.allowDuplicates );\n\t\t\t},\n\t\t\terror: function( options ) {\n\t\t\t\tthis.errorOnly( options );\n\t\t\t\tif ( !options.debug ) {\n\t\t\t\t\tthis.warn( options, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorOnly: function( options ) {\n\t\t\t\tif ( options.debug ) {\n\t\t\t\t\tthis.critical( options );\n\t\t\t\t}\n\t\t\t},\n\t\t\tcritical: function( options ) {\n\t\t\t\tvar err = options.err || new Error( getMessage( options ) );\n\t\t\t\tthis.thrower( err );\n\t\t\t},\n\t\t\tlogger: consolewarn,\n\t\t\tthrower: function( err ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t};\n\n\t\tfunction getMessage( options ) {\n\t\t\tvar message = errors[ options.message ] || options.message || '';\n\t\t\treturn interpolate( message, options.args );\n\t\t}\n\t\t// simple interpolation. probably quicker (and better) out there,\n\t\t// but log is not in golden path of execution, only exceptions\n\t\tfunction interpolate( message, args ) {\n\t\t\treturn message.replace( /{([^{}]*)}/g, function( a, b ) {\n\t\t\t\treturn args[ b ];\n\t\t\t} );\n\t\t}\n\t\treturn log;\n\t}( warn, errors );\n\n\t/* Ractive/prototype/shared/hooks/Hook.js */\n\tvar Ractive$shared_hooks_Hook = function( log ) {\n\n\t\tvar deprecations = {\n\t\t\tconstruct: {\n\t\t\t\tdeprecated: 'beforeInit',\n\t\t\t\treplacement: 'onconstruct'\n\t\t\t},\n\t\t\trender: {\n\t\t\t\tdeprecated: 'init',\n\t\t\t\tmessage: 'The \"init\" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the \"oninit\" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use \"onrender\" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t\t\t},\n\t\t\tcomplete: {\n\t\t\t\tdeprecated: 'complete',\n\t\t\t\treplacement: 'oncomplete'\n\t\t\t}\n\t\t};\n\n\t\tfunction Hook( event ) {\n\t\t\tthis.event = event;\n\t\t\tthis.method = 'on' + event;\n\t\t\tthis.deprecate = deprecations[ event ];\n\t\t}\n\t\tHook.prototype.fire = function( ractive, arg ) {\n\t\t\tfunction call( method ) {\n\t\t\t\tif ( ractive[ method ] ) {\n\t\t\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcall( this.method );\n\t\t\tif ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {\n\t\t\t\tlog.warnAlways( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: this.deprecate.message || 'methodDeprecated',\n\t\t\t\t\targs: this.deprecate\n\t\t\t\t} );\n\t\t\t}\n\t\t\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t\t};\n\t\treturn Hook;\n\t}( log );\n\n\t/* utils/removeFromArray.js */\n\tvar removeFromArray = function( array, member ) {\n\t\tvar index = array.indexOf( member );\n\t\tif ( index !== -1 ) {\n\t\t\tarray.splice( index, 1 );\n\t\t}\n\t};\n\n\t/* utils/Promise.js */\n\tvar Promise = function() {\n\n\t\tvar __export;\n\t\tvar _Promise, PENDING = {},\n\t\t\tFULFILLED = {},\n\t\t\tREJECTED = {};\n\t\tif ( typeof Promise === 'function' ) {\n\t\t\t// use native Promise\n\t\t\t_Promise = Promise;\n\t\t} else {\n\t\t\t_Promise = function( callback ) {\n\t\t\t\tvar fulfilledHandlers = [],\n\t\t\t\t\trejectedHandlers = [],\n\t\t\t\t\tstate = PENDING,\n\t\t\t\t\tresult, dispatchHandlers, makeResolver, fulfil, reject, promise;\n\t\t\t\tmakeResolver = function( newState ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t\tdispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );\n\t\t\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tfulfil = makeResolver( FULFILLED );\n\t\t\t\treject = makeResolver( REJECTED );\n\t\t\t\ttry {\n\t\t\t\t\tcallback( fulfil, reject );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t}\n\t\t\t\tpromise = {\n\t\t\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\t\t\tthen: function( onFulfilled, onRejected ) {\n\t\t\t\t\t\tvar promise2 = new _Promise( function( fulfil, reject ) {\n\t\t\t\t\t\t\tvar processResolutionHandler = function( handler, handlers, forward ) {\n\t\t\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\t\t\thandlers.push( function( p1result ) {\n\t\t\t\t\t\t\t\t\t\tvar x;\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// 2.2\n\t\t\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\t\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn promise2;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tpromise[ 'catch' ] = function( onRejected ) {\n\t\t\t\t\treturn this.then( null, onRejected );\n\t\t\t\t};\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t\t_Promise.all = function( promises ) {\n\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\tvar result = [],\n\t\t\t\t\t\tpending, i, processPromise;\n\t\t\t\t\tif ( !promises.length ) {\n\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tprocessPromise = function( i ) {\n\t\t\t\t\t\tpromises[ i ].then( function( value ) {\n\t\t\t\t\t\t\tresult[ i ] = value;\n\t\t\t\t\t\t\tif ( !--pending ) {\n\t\t\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, reject );\n\t\t\t\t\t};\n\t\t\t\t\tpending = i = promises.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprocessPromise( i );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t\t_Promise.resolve = function( value ) {\n\t\t\t\treturn new _Promise( function( fulfil ) {\n\t\t\t\t\tfulfil( value );\n\t\t\t\t} );\n\t\t\t};\n\t\t\t_Promise.reject = function( reason ) {\n\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\treject( reason );\n\t\t\t\t} );\n\t\t\t};\n\t\t}\n\t\t__export = _Promise;\n\t\t// TODO use MutationObservers or something to simulate setImmediate\n\t\tfunction wait( callback ) {\n\t\t\tsetTimeout( callback, 0 );\n\t\t}\n\n\t\tfunction makeDispatcher( handlers, result ) {\n\t\t\treturn function() {\n\t\t\t\tvar handler;\n\t\t\t\twhile ( handler = handlers.shift() ) {\n\t\t\t\t\thandler( result );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction resolve( promise, x, fulfil, reject ) {\n\t\t\t// Promise Resolution Procedure\n\t\t\tvar then;\n\t\t\t// 2.3.1\n\t\t\tif ( x === promise ) {\n\t\t\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t\t\t}\n\t\t\t// 2.3.2\n\t\t\tif ( x instanceof _Promise ) {\n\t\t\t\tx.then( fulfil, reject );\n\t\t\t} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\t\t\ttry {\n\t\t\t\t\tthen = x.then;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treject( e );\n\t\t\t\t\t// 2.3.3.2\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// 2.3.3.3\n\t\t\t\tif ( typeof then === 'function' ) {\n\t\t\t\t\tvar called, resolvePromise, rejectPromise;\n\t\t\t\t\tresolvePromise = function( y ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t\t\t};\n\t\t\t\t\trejectPromise = function( r ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\treject( r );\n\t\t\t\t\t};\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\tif ( !called ) {\n\t\t\t\t\t\t\t// 2.3.3.3.4.1\n\t\t\t\t\t\t\treject( e );\n\t\t\t\t\t\t\t// 2.3.3.3.4.2\n\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( x );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfulfil( x );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* utils/normaliseRef.js */\n\tvar normaliseRef = function() {\n\n\t\tvar regex = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\t\treturn function normaliseRef( ref ) {\n\t\t\treturn ( ref || '' ).replace( regex, '.$1' );\n\t\t};\n\t}();\n\n\t/* shared/getInnerContext.js */\n\tvar getInnerContext = function( fragment ) {\n\t\tdo {\n\t\t\tif ( fragment.context !== undefined ) {\n\t\t\t\treturn fragment.context;\n\t\t\t}\n\t\t} while ( fragment = fragment.parent );\n\t\treturn '';\n\t};\n\n\t/* utils/isEqual.js */\n\tvar isEqual = function( a, b ) {\n\t\tif ( a === null && b === null ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a === b;\n\t};\n\n\t/* shared/createComponentBinding.js */\n\tvar createComponentBinding = function( circular, isEqual ) {\n\n\t\tvar runloop;\n\t\tcircular.push( function() {\n\t\t\treturn runloop = circular.runloop;\n\t\t} );\n\t\tvar Binding = function( ractive, keypath, otherInstance, otherKeypath ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.root = ractive;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.otherInstance = otherInstance;\n\t\t\tthis.otherKeypath = otherKeypath;\n\t\t\tthis.lock = function() {\n\t\t\t\treturn this$0.updating = true;\n\t\t\t};\n\t\t\tthis.unlock = function() {\n\t\t\t\treturn this$0.updating = false;\n\t\t\t};\n\t\t\tthis.bind();\n\t\t\tthis.value = this.root.viewmodel.get( this.keypath );\n\t\t};\n\t\tBinding.prototype = {\n\t\t\tisLocked: function() {\n\t\t\t\treturn this.updating || this.counterpart && this.counterpart.updating;\n\t\t\t},\n\t\t\tshuffle: function( newIndices, value ) {\n\t\t\t\tthis.propagateChange( value, newIndices );\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tthis.propagateChange( value );\n\t\t\t},\n\t\t\tpropagateChange: function( value, newIndices ) {\n\t\t\t\tvar other;\n\t\t\t\t// Only *you* can prevent infinite loops\n\t\t\t\tif ( this.isLocked() ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.lock();\n\t\t\t\t\t// TODO maybe the case that `value === this.value` - should that result\n\t\t\t\t\t// in an update rather than a set?\n\t\t\t\t\t// if the other viewmodel is already locked up, need to do a deferred update\n\t\t\t\t\tif ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn runloop.addViewmodel( other );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tif ( newIndices ) {\n\t\t\t\t\t\tother.smartUpdate( this.otherKeypath, value, newIndices );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( isSettable( other, this.otherKeypath ) ) {\n\t\t\t\t\t\t\tother.set( this.otherKeypath, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\t// TODO will the counterpart update after this line, during\n\t\t\t\t\t// the runloop end cycle? may be a problem...\n\t\t\t\t\trunloop.scheduleTask( this.unlock );\n\t\t\t\t}\n\t\t\t},\n\t\t\trefineValue: function( keypaths ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar other;\n\t\t\t\tif ( this.isLocked() ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.lock();\n\t\t\t\trunloop.addViewmodel( other = this.otherInstance.viewmodel );\n\t\t\t\tkeypaths.map( function( keypath ) {\n\t\t\t\t\treturn this$0.otherKeypath + keypath.substr( this$0.keypath.length );\n\t\t\t\t} ).forEach( function( keypath ) {\n\t\t\t\t\treturn other.mark( keypath );\n\t\t\t\t} );\n\t\t\t\trunloop.scheduleTask( this.unlock );\n\t\t\t},\n\t\t\tbind: function() {\n\t\t\t\tthis.root.viewmodel.register( this.keypath, this );\n\t\t\t},\n\t\t\trebind: function( newKeypath ) {\n\t\t\t\tthis.unbind();\n\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\tthis.counterpart.otherKeypath = newKeypath;\n\t\t\t\tthis.bind();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t}\n\t\t};\n\n\t\tfunction isSettable( viewmodel, keypath ) {\n\t\t\tvar computed = viewmodel.computations[ keypath ];\n\t\t\treturn !computed || computed.setter;\n\t\t}\n\t\treturn function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {\n\t\t\tvar hash, childInstance, bindings, parentToChildBinding, childToParentBinding;\n\t\t\thash = parentKeypath + '=' + childKeypath;\n\t\t\tbindings = component.bindings;\n\t\t\tif ( bindings[ hash ] ) {\n\t\t\t\t// TODO does this ever happen?\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchildInstance = component.instance;\n\t\t\tparentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );\n\t\t\tbindings.push( parentToChildBinding );\n\t\t\tif ( childInstance.twoway ) {\n\t\t\t\tchildToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );\n\t\t\t\tbindings.push( childToParentBinding );\n\t\t\t\tparentToChildBinding.counterpart = childToParentBinding;\n\t\t\t\tchildToParentBinding.counterpart = parentToChildBinding;\n\t\t\t}\n\t\t\tbindings[ hash ] = parentToChildBinding;\n\t\t};\n\t}( circular, isEqual );\n\n\t/* shared/resolveRef.js */\n\tvar resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {\n\n\t\tvar __export;\n\t\tvar ancestorErrorMessage, getOptions;\n\t\tancestorErrorMessage = 'Could not resolve reference - too many \"../\" prefixes';\n\t\tgetOptions = {\n\t\t\tevaluateWrapped: true\n\t\t};\n\t\t__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {\n\t\t\tvar context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;\n\t\t\tref = normaliseRef( ref );\n\t\t\t// If a reference begins '~/', it's a top-level reference\n\t\t\tif ( ref.substr( 0, 2 ) === '~/' ) {\n\t\t\t\treturn ref.substring( 2 );\n\t\t\t}\n\t\t\t// If a reference begins with '.', it's either a restricted reference or\n\t\t\t// an ancestor reference...\n\t\t\tif ( ref.charAt( 0 ) === '.' ) {\n\t\t\t\treturn resolveAncestorReference( getInnerContext( fragment ), ref );\n\t\t\t}\n\t\t\t// ...otherwise we need to find the keypath\n\t\t\tkey = ref.split( '.' )[ 0 ];\n\t\t\t// get() in viewmodel creation means no fragment (yet)\n\t\t\tfragment = fragment || {};\n\t\t\tdo {\n\t\t\t\tcontext = fragment.context;\n\t\t\t\tif ( !context ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thasContextChain = true;\n\t\t\t\tparentValue = ractive.viewmodel.get( context, getOptions );\n\t\t\t\tif ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {\n\t\t\t\t\treturn context + '.' + ref;\n\t\t\t\t}\n\t\t\t} while ( fragment = fragment.parent );\n\t\t\t// Root/computed property?\n\t\t\tif ( key in ractive.data || key in ractive.viewmodel.computations ) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t\t// If this is an inline component, and it's not isolated, we\n\t\t\t// can try going up the scope chain\n\t\t\tif ( ractive._parent && !ractive.isolated ) {\n\t\t\t\thasContextChain = true;\n\t\t\t\tfragment = ractive.component.parentFragment;\n\t\t\t\t// Special case - index refs\n\t\t\t\tif ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\t// Create an index ref binding, so that it can be rebound letter if necessary.\n\t\t\t\t\t// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`\n\t\t\t\t\tractive.component.indexRefBindings[ ref ] = ref;\n\t\t\t\t\tractive.viewmodel.set( ref, index, true );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tkeypath = resolveRef( ractive._parent, ref, fragment, true );\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\t// We need to create an inter-component binding\n\t\t\t\t\t// If parent keypath is 'one.foo' and child is 'two.foo', we bind\n\t\t\t\t\t// 'one' to 'two' as it's more efficient and avoids edge cases\n\t\t\t\t\tparentKeys = keypath.split( '.' );\n\t\t\t\t\tchildKeys = ref.split( '.' );\n\t\t\t\t\twhile ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {\n\t\t\t\t\t\tparentKeys.pop();\n\t\t\t\t\t\tchildKeys.pop();\n\t\t\t\t\t}\n\t\t\t\t\tparentKeypath = parentKeys.join( '.' );\n\t\t\t\t\tchildKeypath = childKeys.join( '.' );\n\t\t\t\t\tractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );\n\t\t\t\t\tcreateComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If there's no context chain, and the instance is either a) isolated or\n\t\t\t// b) an orphan, then we know that the keypath is identical to the reference\n\t\t\tif ( !isParentLookup && !hasContextChain ) {\n\t\t\t\t// the data object needs to have a property by this name,\n\t\t\t\t// to prevent future failed lookups\n\t\t\t\tractive.viewmodel.set( ref, undefined );\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t\tif ( ractive.viewmodel.get( ref ) !== undefined ) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t};\n\n\t\tfunction resolveAncestorReference( baseContext, ref ) {\n\t\t\tvar contextKeys;\n\t\t\t// {{.}} means 'current context'\n\t\t\tif ( ref === '.' )\n\t\t\t\treturn baseContext;\n\t\t\tcontextKeys = baseContext ? baseContext.split( '.' ) : [];\n\t\t\t// ancestor references (starting \"../\") go up the tree\n\t\t\tif ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\t\tif ( !contextKeys.length ) {\n\t\t\t\t\t\tthrow new Error( ancestorErrorMessage );\n\t\t\t\t\t}\n\t\t\t\t\tcontextKeys.pop();\n\t\t\t\t\tref = ref.substring( 3 );\n\t\t\t\t}\n\t\t\t\tcontextKeys.push( ref );\n\t\t\t\treturn contextKeys.join( '.' );\n\t\t\t}\n\t\t\t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n\t\t\tif ( !baseContext ) {\n\t\t\t\treturn ref.replace( /^\\.\\/?/, '' );\n\t\t\t}\n\t\t\treturn baseContext + ref.replace( /^\\.\\//, '.' );\n\t\t}\n\t\treturn __export;\n\t}( normaliseRef, getInnerContext, createComponentBinding );\n\n\t/* global/TransitionManager.js */\n\tvar TransitionManager = function( removeFromArray ) {\n\n\t\tvar TransitionManager = function( callback, parent ) {\n\t\t\tthis.callback = callback;\n\t\t\tthis.parent = parent;\n\t\t\tthis.intros = [];\n\t\t\tthis.outros = [];\n\t\t\tthis.children = [];\n\t\t\tthis.totalChildren = this.outroChildren = 0;\n\t\t\tthis.detachQueue = [];\n\t\t\tthis.outrosComplete = false;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.addChild( this );\n\t\t\t}\n\t\t};\n\t\tTransitionManager.prototype = {\n\t\t\taddChild: function( child ) {\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.totalChildren += 1;\n\t\t\t\tthis.outroChildren += 1;\n\t\t\t},\n\t\t\tdecrementOutros: function() {\n\t\t\t\tthis.outroChildren -= 1;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tdecrementTotal: function() {\n\t\t\t\tthis.totalChildren -= 1;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tadd: function( transition ) {\n\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\tlist.push( transition );\n\t\t\t},\n\t\t\tremove: function( transition ) {\n\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\tremoveFromArray( list, transition );\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tinit: function() {\n\t\t\t\tthis.ready = true;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tdetachNodes: function() {\n\t\t\t\tthis.detachQueue.forEach( detach );\n\t\t\t\tthis.children.forEach( detachNodes );\n\t\t\t}\n\t\t};\n\n\t\tfunction detach( element ) {\n\t\t\telement.detach();\n\t\t}\n\n\t\tfunction detachNodes( tm ) {\n\t\t\ttm.detachNodes();\n\t\t}\n\n\t\tfunction check( tm ) {\n\t\t\tif ( !tm.ready || tm.outros.length || tm.outroChildren )\n\t\t\t\treturn;\n\t\t\t// If all outros are complete, and we haven't already done this,\n\t\t\t// we notify the parent if there is one, otherwise\n\t\t\t// start detaching nodes\n\t\t\tif ( !tm.outrosComplete ) {\n\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\ttm.parent.decrementOutros( tm );\n\t\t\t\t} else {\n\t\t\t\t\ttm.detachNodes();\n\t\t\t\t}\n\t\t\t\ttm.outrosComplete = true;\n\t\t\t}\n\t\t\t// Once everything is done, we can notify parent transition\n\t\t\t// manager and call the callback\n\t\t\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\t\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\t\t\ttm.callback();\n\t\t\t\t}\n\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\ttm.parent.decrementTotal();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TransitionManager;\n\t}( removeFromArray );\n\n\t/* global/runloop.js */\n\tvar runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {\n\n\t\tvar __export;\n\t\tvar batch, runloop, unresolved = [],\n\t\t\tchangeHook = new Hook( 'change' );\n\t\trunloop = {\n\t\t\tstart: function( instance, returnPromise ) {\n\t\t\t\tvar promise, fulfilPromise;\n\t\t\t\tif ( returnPromise ) {\n\t\t\t\t\tpromise = new Promise( function( f ) {\n\t\t\t\t\t\treturn fulfilPromise = f;\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tbatch = {\n\t\t\t\t\tpreviousBatch: batch,\n\t\t\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\t\t\tviews: [],\n\t\t\t\t\ttasks: [],\n\t\t\t\t\tviewmodels: [],\n\t\t\t\t\tinstance: instance\n\t\t\t\t};\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tbatch.viewmodels.push( instance.viewmodel );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t},\n\t\t\tend: function() {\n\t\t\t\tflushChanges();\n\t\t\t\tbatch.transitionManager.init();\n\t\t\t\tif ( !batch.previousBatch && !!batch.instance )\n\t\t\t\t\tbatch.instance.viewmodel.changes = [];\n\t\t\t\tbatch = batch.previousBatch;\n\t\t\t},\n\t\t\taddViewmodel: function( viewmodel ) {\n\t\t\t\tif ( batch ) {\n\t\t\t\t\tif ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {\n\t\t\t\t\t\tbatch.viewmodels.push( viewmodel );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tviewmodel.applyChanges();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tregisterTransition: function( transition ) {\n\t\t\t\ttransition._manager = batch.transitionManager;\n\t\t\t\tbatch.transitionManager.add( transition );\n\t\t\t},\n\t\t\taddView: function( view ) {\n\t\t\t\tbatch.views.push( view );\n\t\t\t},\n\t\t\taddUnresolved: function( thing ) {\n\t\t\t\tunresolved.push( thing );\n\t\t\t},\n\t\t\tremoveUnresolved: function( thing ) {\n\t\t\t\tremoveFromArray( unresolved, thing );\n\t\t\t},\n\t\t\t// synchronise node detachments with transition ends\n\t\t\tdetachWhenReady: function( thing ) {\n\t\t\t\tbatch.transitionManager.detachQueue.push( thing );\n\t\t\t},\n\t\t\tscheduleTask: function( task, postRender ) {\n\t\t\t\tvar _batch;\n\t\t\t\tif ( !batch ) {\n\t\t\t\t\ttask();\n\t\t\t\t} else {\n\t\t\t\t\t_batch = batch;\n\t\t\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t\t\t}\n\t\t\t\t\t_batch.tasks.push( task );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tcircular.runloop = runloop;\n\t\t__export = runloop;\n\n\t\tfunction flushChanges() {\n\t\t\tvar i, thing, changeHash;\n\t\t\tfor ( i = 0; i < batch.viewmodels.length; i += 1 ) {\n\t\t\t\tthing = batch.viewmodels[ i ];\n\t\t\t\tchangeHash = thing.applyChanges();\n\t\t\t\tif ( changeHash ) {\n\t\t\t\t\tchangeHook.fire( thing.ractive, changeHash );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbatch.viewmodels.length = 0;\n\t\t\tattemptKeypathResolution();\n\t\t\t// Now that changes have been fully propagated, we can update the DOM\n\t\t\t// and complete other tasks\n\t\t\tfor ( i = 0; i < batch.views.length; i += 1 ) {\n\t\t\t\tbatch.views[ i ].update();\n\t\t\t}\n\t\t\tbatch.views.length = 0;\n\t\t\tfor ( i = 0; i < batch.tasks.length; i += 1 ) {\n\t\t\t\tbatch.tasks[ i ]();\n\t\t\t}\n\t\t\tbatch.tasks.length = 0;\n\t\t\t// If updating the view caused some model blowback - e.g. a triple\n\t\t\t// containing <option> elements caused the binding on the <select>\n\t\t\t// to update - then we start over\n\t\t\tif ( batch.viewmodels.length )\n\t\t\t\treturn flushChanges();\n\t\t}\n\n\t\tfunction attemptKeypathResolution() {\n\t\t\tvar i, item, keypath, resolved;\n\t\t\ti = unresolved.length;\n\t\t\t// see if we can resolve any unresolved references\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = unresolved[ i ];\n\t\t\t\tif ( item.keypath ) {\n\t\t\t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n\t\t\t\t\t// weird that we'd still end up here\n\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t}\n\t\t\t\tif ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {\n\t\t\t\t\t( resolved || ( resolved = [] ) ).push( {\n\t\t\t\t\t\titem: item,\n\t\t\t\t\t\tkeypath: keypath\n\t\t\t\t\t} );\n\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( resolved ) {\n\t\t\t\tresolved.forEach( resolve );\n\t\t\t}\n\t\t}\n\n\t\tfunction resolve( resolved ) {\n\t\t\tresolved.item.resolve( resolved.keypath );\n\t\t}\n\t\treturn __export;\n\t}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );\n\n\t/* utils/createBranch.js */\n\tvar createBranch = function() {\n\n\t\tvar numeric = /^\\s*[0-9]+\\s*$/;\n\t\treturn function( key ) {\n\t\t\treturn numeric.test( key ) ? [] : {};\n\t\t};\n\t}();\n\n\t/* viewmodel/prototype/get/magicAdaptor.js */\n\tvar viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {\n\n\t\tvar __export;\n\t\tvar magicAdaptor, MagicWrapper;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t\tmagicAdaptor = {\n\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\tvar keys, key, parentKeypath, parentWrapper, parentValue;\n\t\t\t\t\tif ( !keypath ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\t\tkey = keys.pop();\n\t\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t\t\t// we shouldn't wrap this property\n\t\t\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentValue = ractive.get( parentKeypath );\n\t\t\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );\n\t\t\t\t},\n\t\t\t\twrap: function( ractive, property, keypath ) {\n\t\t\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t\tMagicWrapper = function( ractive, value, keypath ) {\n\t\t\t\tvar keys, objKeypath, template, siblings;\n\t\t\t\tthis.magic = true;\n\t\t\t\tthis.ractive = ractive;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.value = value;\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tthis.prop = keys.pop();\n\t\t\t\tobjKeypath = keys.join( '.' );\n\t\t\t\tthis.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;\n\t\t\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t// Has this property already been wrapped?\n\t\t\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\t\t\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\t\t\tsiblings.push( this );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// No, it hasn't been wrapped\n\t\t\t\tcreateAccessors( this, value, template );\n\t\t\t};\n\t\t\tMagicWrapper.prototype = {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\treset: function( value ) {\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t// trigger set() accessor\n\t\t\t\t\trunloop.addViewmodel( this.ractive.viewmodel );\n\t\t\t\t\tthis.ractive.viewmodel.mark( this.keypath );\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t},\n\t\t\t\tset: function( key, value ) {\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\t\t\tthis.updating = true;\n\t\t\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\t\t\tthis.updating = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar template, set, value, wrappers, index;\n\t\t\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t\t\t// so that it doesn't get torn down\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t\tset = template && template.set;\n\t\t\t\t\tif ( !set ) {\n\t\t\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twrappers = set._ractiveWrappers;\n\t\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t\t// Last one out, turn off the lights\n\t\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\t\tvalue = this.obj[ this.prop ];\n\t\t\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} catch ( err ) {\n\t\t\tmagicAdaptor = false;\n\t\t}\n\t\t__export = magicAdaptor;\n\n\t\tfunction createAccessors( originalWrapper, value, template ) {\n\t\t\tvar object, property, oldGet, oldSet, get, set;\n\t\t\tobject = originalWrapper.obj;\n\t\t\tproperty = originalWrapper.prop;\n\t\t\t// Is this template configurable?\n\t\t\tif ( template && !template.configurable ) {\n\t\t\t\t// Special case - array length\n\t\t\t\tif ( property === 'length' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t\t\t}\n\t\t\t// Time to wrap this property\n\t\t\tif ( template ) {\n\t\t\t\toldGet = template.get;\n\t\t\t\toldSet = template.set;\n\t\t\t}\n\t\t\tget = oldGet || function() {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t\tset = function( v ) {\n\t\t\t\tif ( oldSet ) {\n\t\t\t\t\toldSet( v );\n\t\t\t\t}\n\t\t\t\tvalue = oldGet ? oldGet() : v;\n\t\t\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t\t\t};\n\n\t\t\tfunction updateWrapper( wrapper ) {\n\t\t\t\tvar keypath, ractive;\n\t\t\t\twrapper.value = value;\n\t\t\t\tif ( wrapper.updating ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tractive = wrapper.ractive;\n\t\t\t\tkeypath = wrapper.keypath;\n\t\t\t\twrapper.updating = true;\n\t\t\t\trunloop.start( ractive );\n\t\t\t\tractive.viewmodel.mark( keypath );\n\t\t\t\trunloop.end();\n\t\t\t\twrapper.updating = false;\n\t\t\t}\n\t\t\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t\t\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\t\t\tset._ractiveWrappers = [ originalWrapper ];\n\t\t\tObject.defineProperty( object, property, {\n\t\t\t\tget: get,\n\t\t\t\tset: set,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( runloop, createBranch, isArray );\n\n\t/* config/magic.js */\n\tvar magic = function( magicAdaptor ) {\n\n\t\treturn !!magicAdaptor;\n\t}( viewmodel$get_magicAdaptor );\n\n\t/* config/namespaces.js */\n\tvar namespaces = {\n\t\thtml: 'http://www.w3.org/1999/xhtml',\n\t\tmathml: 'http://www.w3.org/1998/Math/MathML',\n\t\tsvg: 'http://www.w3.org/2000/svg',\n\t\txlink: 'http://www.w3.org/1999/xlink',\n\t\txml: 'http://www.w3.org/XML/1998/namespace',\n\t\txmlns: 'http://www.w3.org/2000/xmlns/'\n\t};\n\n\t/* utils/createElement.js */\n\tvar createElement = function( svg, namespaces ) {\n\n\t\tvar createElement;\n\t\t// Test for SVG support\n\t\tif ( !svg ) {\n\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\tif ( ns && ns !== namespaces.html ) {\n\t\t\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t\t\t}\n\t\t\t\treturn document.createElement( type );\n\t\t\t};\n\t\t} else {\n\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\tif ( !ns || ns === namespaces.html ) {\n\t\t\t\t\treturn document.createElement( type );\n\t\t\t\t}\n\t\t\t\treturn document.createElementNS( ns, type );\n\t\t\t};\n\t\t}\n\t\treturn createElement;\n\t}( svg, namespaces );\n\n\t/* config/isClient.js */\n\tvar isClient = function() {\n\n\t\tvar isClient = typeof document === 'object';\n\t\treturn isClient;\n\t}();\n\n\t/* utils/defineProperty.js */\n\tvar defineProperty = function( isClient ) {\n\n\t\tvar defineProperty;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t\tif ( isClient ) {\n\t\t\t\tObject.defineProperty( document.createElement( 'div' ), 'test', {\n\t\t\t\t\tvalue: 0\n\t\t\t\t} );\n\t\t\t}\n\t\t\tdefineProperty = Object.defineProperty;\n\t\t} catch ( err ) {\n\t\t\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t\t\t// only use it with DOM objects (what the fuck were you smoking, MSFT?)\n\t\t\tdefineProperty = function( obj, prop, desc ) {\n\t\t\t\tobj[ prop ] = desc.value;\n\t\t\t};\n\t\t}\n\t\treturn defineProperty;\n\t}( isClient );\n\n\t/* utils/defineProperties.js */\n\tvar defineProperties = function( createElement, defineProperty, isClient ) {\n\n\t\tvar defineProperties;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tObject.defineProperties( {}, {\n\t\t\t\t\ttest: {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} catch ( err ) {\n\t\t\t\t// TODO how do we account for this? noMagic = true;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tif ( isClient ) {\n\t\t\t\tObject.defineProperties( createElement( 'div' ), {\n\t\t\t\t\ttest: {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tdefineProperties = Object.defineProperties;\n\t\t} catch ( err ) {\n\t\t\tdefineProperties = function( obj, props ) {\n\t\t\t\tvar prop;\n\t\t\t\tfor ( prop in props ) {\n\t\t\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn defineProperties;\n\t}( createElement, defineProperty, isClient );\n\n\t/* Ractive/prototype/shared/add.js */\n\tvar Ractive$shared_add = function( isNumeric ) {\n\n\t\treturn function add( root, keypath, d ) {\n\t\t\tvar value;\n\t\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\t\t\tthrow new Error( 'Bad arguments' );\n\t\t\t}\n\t\t\tvalue = +root.get( keypath ) || 0;\n\t\t\tif ( !isNumeric( value ) ) {\n\t\t\t\tthrow new Error( 'Cannot add to a non-numeric value' );\n\t\t\t}\n\t\t\treturn root.set( keypath, value + d );\n\t\t};\n\t}( isNumeric );\n\n\t/* Ractive/prototype/add.js */\n\tvar Ractive$add = function( add ) {\n\n\t\treturn function Ractive$add( keypath, d ) {\n\t\t\treturn add( this, keypath, d === undefined ? 1 : +d );\n\t\t};\n\t}( Ractive$shared_add );\n\n\t/* utils/normaliseKeypath.js */\n\tvar normaliseKeypath = function( normaliseRef ) {\n\n\t\tvar leadingDot = /^\\.+/;\n\t\treturn function normaliseKeypath( keypath ) {\n\t\t\treturn normaliseRef( keypath ).replace( leadingDot, '' );\n\t\t};\n\t}( normaliseRef );\n\n\t/* config/vendors.js */\n\tvar vendors = [\n\t\t'o',\n\t\t'ms',\n\t\t'moz',\n\t\t'webkit'\n\t];\n\n\t/* utils/requestAnimationFrame.js */\n\tvar requestAnimationFrame = function( vendors ) {\n\n\t\tvar requestAnimationFrame;\n\t\t// If window doesn't exist, we don't need requestAnimationFrame\n\t\tif ( typeof window === 'undefined' ) {\n\t\t\trequestAnimationFrame = null;\n\t\t} else {\n\t\t\t// https://gist.github.com/paulirish/1579671\n\t\t\t( function( vendors, lastTime, window ) {\n\t\t\t\tvar x, setTimeout;\n\t\t\t\tif ( window.requestAnimationFrame ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {\n\t\t\t\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\t\t\t}\n\t\t\t\tif ( !window.requestAnimationFrame ) {\n\t\t\t\t\tsetTimeout = window.setTimeout;\n\t\t\t\t\twindow.requestAnimationFrame = function( callback ) {\n\t\t\t\t\t\tvar currTime, timeToCall, id;\n\t\t\t\t\t\tcurrTime = Date.now();\n\t\t\t\t\t\ttimeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\t\t\t\tid = setTimeout( function() {\n\t\t\t\t\t\t\tcallback( currTime + timeToCall );\n\t\t\t\t\t\t}, timeToCall );\n\t\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\t\treturn id;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}( vendors, 0, window ) );\n\t\t\trequestAnimationFrame = window.requestAnimationFrame;\n\t\t}\n\t\treturn requestAnimationFrame;\n\t}( vendors );\n\n\t/* utils/getTime.js */\n\tvar getTime = function() {\n\n\t\tvar getTime;\n\t\tif ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {\n\t\t\tgetTime = function() {\n\t\t\t\treturn window.performance.now();\n\t\t\t};\n\t\t} else {\n\t\t\tgetTime = function() {\n\t\t\t\treturn Date.now();\n\t\t\t};\n\t\t}\n\t\treturn getTime;\n\t}();\n\n\t/* shared/animations.js */\n\tvar animations = function( rAF, getTime, runloop ) {\n\n\t\tvar queue = [];\n\t\tvar animations = {\n\t\t\ttick: function() {\n\t\t\t\tvar i, animation, now;\n\t\t\t\tnow = getTime();\n\t\t\t\trunloop.start();\n\t\t\t\tfor ( i = 0; i < queue.length; i += 1 ) {\n\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\tif ( !animation.tick( now ) ) {\n\t\t\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\t\t\tqueue.splice( i--, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tif ( queue.length ) {\n\t\t\t\t\trAF( animations.tick );\n\t\t\t\t} else {\n\t\t\t\t\tanimations.running = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: function( animation ) {\n\t\t\t\tqueue.push( animation );\n\t\t\t\tif ( !animations.running ) {\n\t\t\t\t\tanimations.running = true;\n\t\t\t\t\trAF( animations.tick );\n\t\t\t\t}\n\t\t\t},\n\t\t\t// TODO optimise this\n\t\t\tabort: function( keypath, root ) {\n\t\t\t\tvar i = queue.length,\n\t\t\t\t\tanimation;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\n\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn animations;\n\t}( requestAnimationFrame, getTime, runloop );\n\n\t/* config/options/css/transform.js */\n\tvar transform = function() {\n\n\t\tvar __export;\n\t\tvar selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n\t\t\tcommentsPattern = /\\/\\*.*?\\*\\//g,\n\t\t\tselectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~]+)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n\t\t\tmediaQueryPattern = /^@media/,\n\t\t\tdataRvcGuidPattern = /\\[data-rvcguid=\"[a-z0-9-]+\"]/g;\n\t\t__export = function transformCss( css, guid ) {\n\t\t\tvar transformed, addGuid;\n\t\t\taddGuid = function( selector ) {\n\t\t\t\tvar selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];\n\t\t\t\tselectorUnits = [];\n\t\t\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\t\t\tselectorUnits.push( {\n\t\t\t\t\t\tstr: match[ 0 ],\n\t\t\t\t\t\tbase: match[ 1 ],\n\t\t\t\t\t\tmodifiers: match[ 2 ]\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// For each simple selector within the selector, we need to create a version\n\t\t\t\t// that a) combines with the guid, and b) is inside the guid\n\t\t\t\tdataAttr = '[data-rvcguid=\"' + guid + '\"]';\n\t\t\t\tbase = selectorUnits.map( extractString );\n\t\t\t\ti = selectorUnits.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tappended = base.slice();\n\t\t\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\t\t\tunit = selectorUnits[ i ];\n\t\t\t\t\tappended[ i ] = unit.base + dataAttr + unit.modifiers || '';\n\t\t\t\t\tprepended = base.slice();\n\t\t\t\t\tprepended[ i ] = dataAttr + ' ' + prepended[ i ];\n\t\t\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t\t\t}\n\t\t\t\treturn transformed.join( ', ' );\n\t\t\t};\n\t\t\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\t\t\ttransformed = css.replace( dataRvcGuidPattern, '[data-rvcguid=\"' + guid + '\"]' );\n\t\t\t} else {\n\t\t\t\ttransformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {\n\t\t\t\t\tvar selectors, transformed;\n\t\t\t\t\t// don't transform media queries!\n\t\t\t\t\tif ( mediaQueryPattern.test( $1 ) )\n\t\t\t\t\t\treturn match;\n\t\t\t\t\tselectors = $1.split( ',' ).map( trim );\n\t\t\t\t\ttransformed = selectors.map( addGuid ).join( ', ' ) + ' ';\n\t\t\t\t\treturn match.replace( $1, transformed );\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn transformed;\n\t\t};\n\n\t\tfunction trim( str ) {\n\t\t\tif ( str.trim ) {\n\t\t\t\treturn str.trim();\n\t\t\t}\n\t\t\treturn str.replace( /^\\s+/, '' ).replace( /\\s+$/, '' );\n\t\t}\n\n\t\tfunction extractString( unit ) {\n\t\t\treturn unit.str;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* config/options/css/css.js */\n\tvar css = function( transformCss ) {\n\n\t\tvar cssConfig = {\n\t\t\tname: 'css',\n\t\t\textend: extend,\n\t\t\tinit: function() {}\n\t\t};\n\n\t\tfunction extend( Parent, proto, options ) {\n\t\t\tvar guid = proto.constructor._guid,\n\t\t\t\tcss;\n\t\t\tif ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {\n\t\t\t\tproto.constructor.css = css;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCss( css, target, guid ) {\n\t\t\tif ( !css ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn target.noCssTransform ? css : transformCss( css, guid );\n\t\t}\n\t\treturn cssConfig;\n\t}( transform );\n\n\t/* utils/wrapMethod.js */\n\tvar wrapMethod = function() {\n\n\t\tvar __export;\n\t\t__export = function( method, superMethod, force ) {\n\t\t\tif ( force || needsSuper( method, superMethod ) ) {\n\t\t\t\treturn function() {\n\t\t\t\t\tvar hasSuper = '_super' in this,\n\t\t\t\t\t\t_super = this._super,\n\t\t\t\t\t\tresult;\n\t\t\t\t\tthis._super = superMethod;\n\t\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\t\tthis._super = _super;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t};\n\n\t\tfunction needsSuper( method, superMethod ) {\n\t\t\treturn typeof superMethod === 'function' && /_super/.test( method );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* config/options/data.js */\n\tvar data = function( wrap ) {\n\n\t\tvar __export;\n\t\tvar dataConfig = {\n\t\t\tname: 'data',\n\t\t\textend: extend,\n\t\t\tinit: init,\n\t\t\treset: reset\n\t\t};\n\t\t__export = dataConfig;\n\n\t\tfunction combine( Parent, target, options ) {\n\t\t\tvar value = options.data || {},\n\t\t\t\tparentValue = getAddedKeys( Parent.prototype.data );\n\t\t\tif ( typeof value !== 'object' && typeof value !== 'function' ) {\n\t\t\t\tthrow new TypeError( 'data option must be an object or a function, \"' + value + '\" is not valid' );\n\t\t\t}\n\t\t\treturn dispatch( parentValue, value );\n\t\t}\n\n\t\tfunction extend( Parent, proto, options ) {\n\t\t\tproto.data = combine( Parent, proto, options );\n\t\t}\n\n\t\tfunction init( Parent, ractive, options ) {\n\t\t\tvar value = options.data,\n\t\t\t\tresult = combine( Parent, ractive, options );\n\t\t\tif ( typeof result === 'function' ) {\n\t\t\t\tresult = result.call( ractive, value ) || value;\n\t\t\t}\n\t\t\treturn ractive.data = result || {};\n\t\t}\n\n\t\tfunction reset( ractive ) {\n\t\t\tvar result = this.init( ractive.constructor, ractive, ractive );\n\t\t\tif ( result ) {\n\t\t\t\tractive.data = result;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getAddedKeys( parent ) {\n\t\t\t// only for functions that had keys added\n\t\t\tif ( typeof parent !== 'function' || !Object.keys( parent ).length ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t\t// copy the added keys to temp 'object', otherwise\n\t\t\t// parent would be interpreted as 'function' by dispatch\n\t\t\tvar temp = {};\n\t\t\tcopy( parent, temp );\n\t\t\t// roll in added keys\n\t\t\treturn dispatch( parent, temp );\n\t\t}\n\n\t\tfunction dispatch( parent, child ) {\n\t\t\tif ( typeof child === 'function' ) {\n\t\t\t\treturn extendFn( child, parent );\n\t\t\t} else if ( typeof parent === 'function' ) {\n\t\t\t\treturn fromFn( child, parent );\n\t\t\t} else {\n\t\t\t\treturn fromProperties( child, parent );\n\t\t\t}\n\t\t}\n\n\t\tfunction copy( from, to, fillOnly ) {\n\t\t\tfor ( var key in from ) {\n\t\t\t\tif ( fillOnly && key in to ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tto[ key ] = from[ key ];\n\t\t\t}\n\t\t}\n\n\t\tfunction fromProperties( child, parent ) {\n\t\t\tchild = child || {};\n\t\t\tif ( !parent ) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tcopy( parent, child, true );\n\t\t\treturn child;\n\t\t}\n\n\t\tfunction fromFn( child, parentFn ) {\n\t\t\treturn function( data ) {\n\t\t\t\tvar keys;\n\t\t\t\tif ( child ) {\n\t\t\t\t\t// Track the keys that our on the child,\n\t\t\t\t\t// but not on the data. We'll need to apply these\n\t\t\t\t\t// after the parent function returns.\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( var key in child ) {\n\t\t\t\t\t\tif ( !data || !( key in data ) ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// call the parent fn, use data if no return value\n\t\t\t\tdata = parentFn.call( this, data ) || data;\n\t\t\t\t// Copy child keys back onto data. The child keys\n\t\t\t\t// should take precedence over whatever the\n\t\t\t\t// parent did with the data.\n\t\t\t\tif ( keys && keys.length ) {\n\t\t\t\t\tdata = data || {};\n\t\t\t\t\tkeys.forEach( function( key ) {\n\t\t\t\t\t\tdata[ key ] = child[ key ];\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t};\n\t\t}\n\n\t\tfunction extendFn( childFn, parent ) {\n\t\t\tvar parentFn;\n\t\t\tif ( typeof parent !== 'function' ) {\n\t\t\t\t// copy props to data\n\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\tfromProperties( data, parent );\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\t// give parent function it's own this._super context,\n\t\t\t\t\t// otherwise this._super is from child and\n\t\t\t\t\t// causes infinite loop\n\t\t\t\t\tparent = wrap( parent, function() {}, true );\n\t\t\t\t\treturn parent.call( this, data ) || data;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn wrap( childFn, parentFn );\n\t\t}\n\t\treturn __export;\n\t}( wrapMethod );\n\n\t/* config/types.js */\n\tvar types = {\n\t\tTEXT: 1,\n\t\tINTERPOLATOR: 2,\n\t\tTRIPLE: 3,\n\t\tSECTION: 4,\n\t\tINVERTED: 5,\n\t\tCLOSING: 6,\n\t\tELEMENT: 7,\n\t\tPARTIAL: 8,\n\t\tCOMMENT: 9,\n\t\tDELIMCHANGE: 10,\n\t\tMUSTACHE: 11,\n\t\tTAG: 12,\n\t\tATTRIBUTE: 13,\n\t\tCLOSING_TAG: 14,\n\t\tCOMPONENT: 15,\n\t\tNUMBER_LITERAL: 20,\n\t\tSTRING_LITERAL: 21,\n\t\tARRAY_LITERAL: 22,\n\t\tOBJECT_LITERAL: 23,\n\t\tBOOLEAN_LITERAL: 24,\n\t\tGLOBAL: 26,\n\t\tKEY_VALUE_PAIR: 27,\n\t\tREFERENCE: 30,\n\t\tREFINEMENT: 31,\n\t\tMEMBER: 32,\n\t\tPREFIX_OPERATOR: 33,\n\t\tBRACKETED: 34,\n\t\tCONDITIONAL: 35,\n\t\tINFIX_OPERATOR: 36,\n\t\tINVOCATION: 40,\n\t\tSECTION_IF: 50,\n\t\tSECTION_UNLESS: 51,\n\t\tSECTION_EACH: 52,\n\t\tSECTION_WITH: 53,\n\t\tSECTION_IF_WITH: 54\n\t};\n\n\t/* utils/create.js */\n\tvar create = function() {\n\n\t\tvar create;\n\t\ttry {\n\t\t\tObject.create( null );\n\t\t\tcreate = Object.create;\n\t\t} catch ( err ) {\n\t\t\t// sigh\n\t\t\tcreate = function() {\n\t\t\t\tvar F = function() {};\n\t\t\t\treturn function( proto, props ) {\n\t\t\t\t\tvar obj;\n\t\t\t\t\tif ( proto === null ) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\tF.prototype = proto;\n\t\t\t\t\tobj = new F();\n\t\t\t\t\tif ( props ) {\n\t\t\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t\t\t}\n\t\t\t\t\treturn obj;\n\t\t\t\t};\n\t\t\t}();\n\t\t}\n\t\treturn create;\n\t}();\n\n\t/* parse/Parser/expressions/shared/errors.js */\n\tvar parse_Parser_expressions_shared_errors = {\n\t\texpectedExpression: 'Expected a JavaScript expression',\n\t\texpectedParen: 'Expected closing paren'\n\t};\n\n\t/* parse/Parser/expressions/primary/literal/numberLiteral.js */\n\tvar numberLiteral = function( types ) {\n\n\t\tvar numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\treturn function( parser ) {\n\t\t\tvar result;\n\t\t\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.NUMBER_LITERAL,\n\t\t\t\t\tv: result\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types );\n\n\t/* parse/Parser/expressions/primary/literal/booleanLiteral.js */\n\tvar booleanLiteral = function( types ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar remaining = parser.remaining();\n\t\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\t\t\tparser.pos += 4;\n\t\t\t\treturn {\n\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'true'\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\t\t\tparser.pos += 5;\n\t\t\t\treturn {\n\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'false'\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */\n\tvar makeQuotedStringMatcher = function() {\n\n\t\tvar stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\t\t// Match one or more characters until: \", ', \\, or EOL/EOF.\n\t\t// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\t\tstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\t\t// Match one escape sequence, including the backslash.\n\t\tescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\t\t// Match one ES5 line continuation (backslash + line terminator).\n\t\tlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\t\t// Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\t\treturn function( okQuote ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, literal, done, next;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tliteral = '\"';\n\t\t\t\tdone = false;\n\t\t\t\twhile ( !done ) {\n\t\t\t\t\tnext = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );\n\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\tif ( next === '\"' ) {\n\t\t\t\t\t\t\tliteral += '\\\\\"';\n\t\t\t\t\t\t} else if ( next === '\\\\\\'' ) {\n\t\t\t\t\t\t\tliteral += '\\'';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral += next;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tliteral += '\"';\n\t\t\t\t// use JSON.parse to interpret escapes\n\t\t\t\treturn JSON.parse( literal );\n\t\t\t};\n\t\t};\n\t}();\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */\n\tvar singleQuotedString = function( makeQuotedStringMatcher ) {\n\n\t\treturn makeQuotedStringMatcher( '\"' );\n\t}( makeQuotedStringMatcher );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */\n\tvar doubleQuotedString = function( makeQuotedStringMatcher ) {\n\n\t\treturn makeQuotedStringMatcher( '\\'' );\n\t}( makeQuotedStringMatcher );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */\n\tvar stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, string;\n\t\t\tstart = parser.pos;\n\t\t\tif ( parser.matchString( '\"' ) ) {\n\t\t\t\tstring = getDoubleQuotedString( parser );\n\t\t\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( parser.matchString( '\\'' ) ) {\n\t\t\t\tstring = getSingleQuotedString( parser );\n\t\t\t\tif ( !parser.matchString( '\\'' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types, singleQuotedString, doubleQuotedString );\n\n\t/* parse/Parser/expressions/shared/patterns.js */\n\tvar patterns = {\n\t\tname: /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\t};\n\n\t/* parse/Parser/expressions/shared/key.js */\n\tvar key = function( getStringLiteral, getNumberLiteral, patterns ) {\n\n\t\tvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\t\t// http://mathiasbynens.be/notes/javascript-properties\n\t\t// can be any name, string literal, or number literal\n\t\treturn function( parser ) {\n\t\t\tvar token;\n\t\t\tif ( token = getStringLiteral( parser ) ) {\n\t\t\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t\t\t}\n\t\t\tif ( token = getNumberLiteral( parser ) ) {\n\t\t\t\treturn token.v;\n\t\t\t}\n\t\t\tif ( token = parser.matchPattern( patterns.name ) ) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\t};\n\t}( stringLiteral, numberLiteral, patterns );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */\n\tvar keyValuePair = function( types, getKey ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, key, value;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace between '{' and key\n\t\t\tparser.allowWhitespace();\n\t\t\tkey = getKey( parser );\n\t\t\tif ( key === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace between key and ':'\n\t\t\tparser.allowWhitespace();\n\t\t\t// next character must be ':'\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace between ':' and value\n\t\t\tparser.allowWhitespace();\n\t\t\t// next expression must be a, well... expression\n\t\t\tvalue = parser.readExpression();\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.KEY_VALUE_PAIR,\n\t\t\t\tk: key,\n\t\t\t\tv: value\n\t\t\t};\n\t\t};\n\t}( types, key );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */\n\tvar keyValuePairs = function( getKeyValuePair ) {\n\n\t\treturn function getKeyValuePairs( parser ) {\n\t\t\tvar start, pairs, pair, keyValuePairs;\n\t\t\tstart = parser.pos;\n\t\t\tpair = getKeyValuePair( parser );\n\t\t\tif ( pair === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpairs = [ pair ];\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t\tif ( !keyValuePairs ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn pairs.concat( keyValuePairs );\n\t\t\t}\n\t\t\treturn pairs;\n\t\t};\n\t}( keyValuePair );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */\n\tvar objectLiteral = function( types, getKeyValuePairs ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, keyValuePairs;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t// allow whitespace between final value and '}'\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '}' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.OBJECT_LITERAL,\n\t\t\t\tm: keyValuePairs\n\t\t\t};\n\t\t};\n\t}( types, keyValuePairs );\n\n\t/* parse/Parser/expressions/shared/expressionList.js */\n\tvar expressionList = function( errors ) {\n\n\t\treturn function getExpressionList( parser ) {\n\t\t\tvar start, expressions, expr, next;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\texpr = parser.readExpression();\n\t\t\tif ( expr === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\texpressions = [ expr ];\n\t\t\t// allow whitespace between expression and ','\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tnext = getExpressionList( parser );\n\t\t\t\tif ( next === null ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tnext.forEach( append );\n\t\t\t}\n\n\t\t\tfunction append( expression ) {\n\t\t\t\texpressions.push( expression );\n\t\t\t}\n\t\t\treturn expressions;\n\t\t};\n\t}( parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/primary/literal/arrayLiteral.js */\n\tvar arrayLiteral = function( types, getExpressionList ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expressionList;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace before '['\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\texpressionList = getExpressionList( parser );\n\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.ARRAY_LITERAL,\n\t\t\t\tm: expressionList\n\t\t\t};\n\t\t};\n\t}( types, expressionList );\n\n\t/* parse/Parser/expressions/primary/literal/_literal.js */\n\tvar literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );\n\t\t\treturn literal;\n\t\t};\n\t}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );\n\n\t/* parse/Parser/expressions/primary/reference.js */\n\tvar reference = function( types, patterns ) {\n\n\t\tvar dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;\n\t\tdotRefinementPattern = /^\\.[a-zA-Z_$0-9]+/;\n\t\tgetArrayRefinement = function( parser ) {\n\t\t\tvar num = parser.matchPattern( arrayMemberPattern );\n\t\t\tif ( num ) {\n\t\t\t\treturn '.' + num;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tarrayMemberPattern = /^\\[(0|[1-9][0-9]*)\\]/;\n\t\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\n\t\tglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;\n\t\t// keywords are not valid references, with the exception of `this`\n\t\tkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\t\treturn function( parser ) {\n\t\t\tvar startPos, ancestor, name, dot, combo, refinement, lastDotIndex;\n\t\t\tstartPos = parser.pos;\n\t\t\t// we might have a root-level reference\n\t\t\tif ( parser.matchString( '~/' ) ) {\n\t\t\t\tancestor = '~/';\n\t\t\t} else {\n\t\t\t\t// we might have ancestor refs...\n\t\t\t\tancestor = '';\n\t\t\t\twhile ( parser.matchString( '../' ) ) {\n\t\t\t\t\tancestor += '../';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !ancestor ) {\n\t\t\t\t// we might have an implicit iterator or a restricted reference\n\t\t\t\tdot = parser.matchString( './' ) || parser.matchString( '.' ) || '';\n\t\t\t}\n\t\t\tname = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';\n\t\t\t// bug out if it's a keyword\n\t\t\tif ( keywords.test( name ) ) {\n\t\t\t\tparser.pos = startPos;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// if this is a browser global, stop here\n\t\t\tif ( !ancestor && !dot && globals.test( name ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.GLOBAL,\n\t\t\t\t\tv: name\n\t\t\t\t};\n\t\t\t}\n\t\t\tcombo = ( ancestor || dot ) + name;\n\t\t\tif ( !combo ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\twhile ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {\n\t\t\t\tcombo += refinement;\n\t\t\t}\n\t\t\tif ( parser.matchString( '(' ) ) {\n\t\t\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t\t\t// to strip the method name from the reference combo, else the context\n\t\t\t\t// will be wrong\n\t\t\t\tlastDotIndex = combo.lastIndexOf( '.' );\n\t\t\t\tif ( lastDotIndex !== -1 ) {\n\t\t\t\t\tcombo = combo.substr( 0, lastDotIndex );\n\t\t\t\t\tparser.pos = startPos + combo.length;\n\t\t\t\t} else {\n\t\t\t\t\tparser.pos -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.REFERENCE,\n\t\t\t\tn: combo.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t\t\t};\n\t\t};\n\t}( types, patterns );\n\n\t/* parse/Parser/expressions/primary/bracketedExpression.js */\n\tvar bracketedExpression = function( types, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expr;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( '(' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\texpr = parser.readExpression();\n\t\t\tif ( !expr ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.BRACKETED,\n\t\t\t\tx: expr\n\t\t\t};\n\t\t};\n\t}( types, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/primary/_primary.js */\n\tvar primary = function( getLiteral, getReference, getBracketedExpression ) {\n\n\t\treturn function( parser ) {\n\t\t\treturn getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );\n\t\t};\n\t}( literal, reference, bracketedExpression );\n\n\t/* parse/Parser/expressions/shared/refinement.js */\n\tvar refinement = function( types, errors, patterns ) {\n\n\t\treturn function getRefinement( parser ) {\n\t\t\tvar start, name, expr;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\t// \".\" name\n\t\t\tif ( parser.matchString( '.' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( name = parser.matchPattern( patterns.name ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\t\tn: name\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tparser.error( 'Expected a property name' );\n\t\t\t}\n\t\t\t// \"[\" expression \"]\"\n\t\t\tif ( parser.matchString( '[' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpr = parser.readExpression();\n\t\t\t\tif ( !expr ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\t\tparser.error( 'Expected \\']\\'' );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\tx: expr\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types, parse_Parser_expressions_shared_errors, patterns );\n\n\t/* parse/Parser/expressions/memberOrInvocation.js */\n\tvar memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar current, expression, refinement, expressionList;\n\t\t\texpression = getPrimary( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\twhile ( expression ) {\n\t\t\t\tcurrent = parser.pos;\n\t\t\t\tif ( refinement = getRefinement( parser ) ) {\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: types.MEMBER,\n\t\t\t\t\t\tx: expression,\n\t\t\t\t\t\tr: refinement\n\t\t\t\t\t};\n\t\t\t\t} else if ( parser.matchString( '(' ) ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\texpressionList = getExpressionList( parser );\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t\t\t}\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: types.INVOCATION,\n\t\t\t\t\t\tx: expression\n\t\t\t\t\t};\n\t\t\t\t\tif ( expressionList ) {\n\t\t\t\t\t\texpression.o = expressionList;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expression;\n\t\t};\n\t}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/typeof.js */\n\tvar _typeof = function( types, errors, getMemberOrInvocation ) {\n\n\t\tvar getTypeof, makePrefixSequenceMatcher;\n\t\tmakePrefixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar expression;\n\t\t\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\t\t\treturn expression;\n\t\t\t\t}\n\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpression = parser.readExpression();\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ts: symbol,\n\t\t\t\t\to: expression,\n\t\t\t\t\tt: types.PREFIX_OPERATOR\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t// create all prefix sequence matchers, return getTypeof\n\t\t( function() {\n\t\t\tvar i, len, matcher, prefixOperators, fallthrough;\n\t\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\t\t\tfallthrough = getMemberOrInvocation;\n\t\t\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\t\t// typeof operator is higher precedence than multiplication, so provides the\n\t\t\t// fallthrough for the multiplication sequence matcher we're about to create\n\t\t\t// (we're skipping void and delete)\n\t\t\tgetTypeof = fallthrough;\n\t\t}() );\n\t\treturn getTypeof;\n\t}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );\n\n\t/* parse/Parser/expressions/logicalOr.js */\n\tvar logicalOr = function( types, getTypeof ) {\n\n\t\tvar getLogicalOr, makeInfixSequenceMatcher;\n\t\tmakeInfixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, left, right;\n\t\t\t\tleft = fallthrough( parser );\n\t\t\t\tif ( !left ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t\t\t// to parse `left` because that would be infinite regress.\n\t\t\t\twhile ( true ) {\n\t\t\t\t\tstart = parser.pos;\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\t\t\tright = fallthrough( parser );\n\t\t\t\t\tif ( !right ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\tleft = {\n\t\t\t\t\t\tt: types.INFIX_OPERATOR,\n\t\t\t\t\t\ts: symbol,\n\t\t\t\t\t\to: [\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\tright\n\t\t\t\t\t\t]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\t// create all infix sequence matchers, and return getLogicalOr\n\t\t( function() {\n\t\t\tvar i, len, matcher, infixOperators, fallthrough;\n\t\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t\t\t// Each sequence matcher will initially fall through to its higher precedence\n\t\t\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\t\t\t// A typeof operator is higher precedence than multiplication\n\t\t\tfallthrough = getTypeof;\n\t\t\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\t\t// Logical OR is the fallthrough for the conditional matcher\n\t\t\tgetLogicalOr = fallthrough;\n\t\t}() );\n\t\treturn getLogicalOr;\n\t}( types, _typeof );\n\n\t/* parse/Parser/expressions/conditional.js */\n\tvar conditional = function( types, getLogicalOr, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expression, ifTrue, ifFalse;\n\t\t\texpression = getLogicalOr( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '?' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tifTrue = parser.readExpression();\n\t\t\tif ( !ifTrue ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.error( 'Expected \":\"' );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tifFalse = parser.readExpression();\n\t\t\tif ( !ifFalse ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.CONDITIONAL,\n\t\t\t\to: [\n\t\t\t\t\texpression,\n\t\t\t\t\tifTrue,\n\t\t\t\t\tifFalse\n\t\t\t\t]\n\t\t\t};\n\t\t};\n\t}( types, logicalOr, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/utils/flattenExpression.js */\n\tvar flattenExpression = function( types, isObject ) {\n\n\t\tvar __export;\n\t\t__export = function( expression ) {\n\t\t\tvar refs = [],\n\t\t\t\tflattened;\n\t\t\textractRefs( expression, refs );\n\t\t\tflattened = {\n\t\t\t\tr: refs,\n\t\t\t\ts: stringify( this, expression, refs )\n\t\t\t};\n\t\t\treturn flattened;\n\t\t};\n\n\t\tfunction quoteStringLiteral( str ) {\n\t\t\treturn JSON.stringify( String( str ) );\n\t\t}\n\t\t// TODO maybe refactor this?\n\t\tfunction extractRefs( node, refs ) {\n\t\t\tvar i, list;\n\t\t\tif ( node.t === types.REFERENCE ) {\n\t\t\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\t\t\trefs.unshift( node.n );\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist = node.o || node.m;\n\t\t\tif ( list ) {\n\t\t\t\tif ( isObject( list ) ) {\n\t\t\t\t\textractRefs( list, refs );\n\t\t\t\t} else {\n\t\t\t\t\ti = list.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\textractRefs( list[ i ], refs );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( node.x ) {\n\t\t\t\textractRefs( node.x, refs );\n\t\t\t}\n\t\t\tif ( node.r ) {\n\t\t\t\textractRefs( node.r, refs );\n\t\t\t}\n\t\t\tif ( node.v ) {\n\t\t\t\textractRefs( node.v, refs );\n\t\t\t}\n\t\t}\n\n\t\tfunction stringify( parser, node, refs ) {\n\t\t\tvar stringifyAll = function( item ) {\n\t\t\t\treturn stringify( parser, item, refs );\n\t\t\t};\n\t\t\tswitch ( node.t ) {\n\t\t\t\tcase types.BOOLEAN_LITERAL:\n\t\t\t\tcase types.GLOBAL:\n\t\t\t\tcase types.NUMBER_LITERAL:\n\t\t\t\t\treturn node.v;\n\t\t\t\tcase types.STRING_LITERAL:\n\t\t\t\t\treturn quoteStringLiteral( node.v );\n\t\t\t\tcase types.ARRAY_LITERAL:\n\t\t\t\t\treturn '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';\n\t\t\t\tcase types.OBJECT_LITERAL:\n\t\t\t\t\treturn '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';\n\t\t\t\tcase types.KEY_VALUE_PAIR:\n\t\t\t\t\treturn node.k + ':' + stringify( parser, node.v, refs );\n\t\t\t\tcase types.PREFIX_OPERATOR:\n\t\t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );\n\t\t\t\tcase types.INFIX_OPERATOR:\n\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );\n\t\t\t\tcase types.INVOCATION:\n\t\t\t\t\treturn stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';\n\t\t\t\tcase types.BRACKETED:\n\t\t\t\t\treturn '(' + stringify( parser, node.x, refs ) + ')';\n\t\t\t\tcase types.MEMBER:\n\t\t\t\t\treturn stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );\n\t\t\t\tcase types.REFINEMENT:\n\t\t\t\t\treturn node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';\n\t\t\t\tcase types.CONDITIONAL:\n\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );\n\t\t\t\tcase types.REFERENCE:\n\t\t\t\t\treturn '_' + refs.indexOf( node.n );\n\t\t\t\tdefault:\n\t\t\t\t\tparser.error( 'Expected legal JavaScript' );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( types, isObject );\n\n\t/* parse/Parser/_Parser.js */\n\tvar Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {\n\n\t\tvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\t\tParseError = function( message ) {\n\t\t\tthis.name = 'ParseError';\n\t\t\tthis.message = message;\n\t\t\ttry {\n\t\t\t\tthrow new Error( message );\n\t\t\t} catch ( e ) {\n\t\t\t\tthis.stack = e.stack;\n\t\t\t}\n\t\t};\n\t\tParseError.prototype = Error.prototype;\n\t\tParser = function( str, options ) {\n\t\t\tvar items, item, lineStart = 0;\n\t\t\tthis.str = str;\n\t\t\tthis.options = options || {};\n\t\t\tthis.pos = 0;\n\t\t\tthis.lines = this.str.split( '\\n' );\n\t\t\tthis.lineEnds = this.lines.map( function( line ) {\n\t\t\t\tvar lineEnd = lineStart + line.length + 1;\n\t\t\t\t// +1 for the newline\n\t\t\t\tlineStart = lineEnd;\n\t\t\t\treturn lineEnd;\n\t\t\t}, 0 );\n\t\t\t// Custom init logic\n\t\t\tif ( this.init )\n\t\t\t\tthis.init( str, options );\n\t\t\titems = [];\n\t\t\twhile ( this.pos < this.str.length && ( item = this.read() ) ) {\n\t\t\t\titems.push( item );\n\t\t\t}\n\t\t\tthis.leftover = this.remaining();\n\t\t\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t\t};\n\t\tParser.prototype = {\n\t\t\tread: function( converters ) {\n\t\t\t\tvar pos, i, len, item;\n\t\t\t\tif ( !converters )\n\t\t\t\t\tconverters = this.converters;\n\t\t\t\tpos = this.pos;\n\t\t\t\tlen = converters.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t// reset for each attempt\n\t\t\t\t\tif ( item = converters[ i ]( this ) ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\treadExpression: function() {\n\t\t\t\t// The conditional operator is the lowest precedence operator (except yield,\n\t\t\t\t// assignment operators, and commas, none of which are supported), so we\n\t\t\t\t// start there. If it doesn't match, it 'falls through' to progressively\n\t\t\t\t// higher precedence operators, until it eventually matches (or fails to\n\t\t\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t\t\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t\t\t\treturn getConditional( this );\n\t\t\t},\n\t\t\tflattenExpression: flattenExpression,\n\t\t\tgetLinePos: function( char ) {\n\t\t\t\tvar lineNum = 0,\n\t\t\t\t\tlineStart = 0,\n\t\t\t\t\tcolumnNum;\n\t\t\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\t\t\tlineNum += 1;\n\t\t\t\t}\n\t\t\t\tcolumnNum = char - lineStart;\n\t\t\t\treturn [\n\t\t\t\t\tlineNum + 1,\n\t\t\t\t\tcolumnNum + 1,\n\t\t\t\t\tchar\n\t\t\t\t];\n\t\t\t},\n\t\t\terror: function( message ) {\n\t\t\t\tvar pos, lineNum, columnNum, line, annotation, error;\n\t\t\t\tpos = this.getLinePos( this.pos );\n\t\t\t\tlineNum = pos[ 0 ];\n\t\t\t\tcolumnNum = pos[ 1 ];\n\t\t\t\tline = this.lines[ pos[ 0 ] - 1 ];\n\t\t\t\tannotation = line + '\\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';\n\t\t\t\terror = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\\n' + annotation );\n\t\t\t\terror.line = pos[ 0 ];\n\t\t\t\terror.character = pos[ 1 ];\n\t\t\t\terror.shortMessage = message;\n\t\t\t\tthrow error;\n\t\t\t},\n\t\t\tmatchString: function( string ) {\n\t\t\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\t\t\tthis.pos += string.length;\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmatchPattern: function( pattern ) {\n\t\t\t\tvar match;\n\t\t\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\t\t\tthis.pos += match[ 0 ].length;\n\t\t\t\t\treturn match[ 1 ] || match[ 0 ];\n\t\t\t\t}\n\t\t\t},\n\t\t\tallowWhitespace: function() {\n\t\t\t\tthis.matchPattern( leadingWhitespace );\n\t\t\t},\n\t\t\tremaining: function() {\n\t\t\t\treturn this.str.substring( this.pos );\n\t\t\t},\n\t\t\tnextChar: function() {\n\t\t\t\treturn this.str.charAt( this.pos );\n\t\t\t}\n\t\t};\n\t\tParser.extend = function( proto ) {\n\t\t\tvar Parent = this,\n\t\t\t\tChild, key;\n\t\t\tChild = function( str, options ) {\n\t\t\t\tParser.call( this, str, options );\n\t\t\t};\n\t\t\tChild.prototype = create( Parent.prototype );\n\t\t\tfor ( key in proto ) {\n\t\t\t\tif ( hasOwnProperty.call( proto, key ) ) {\n\t\t\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tChild.extend = Parser.extend;\n\t\t\treturn Child;\n\t\t};\n\t\tcircular.Parser = Parser;\n\t\treturn Parser;\n\t}( circular, create, hasOwn, conditional, flattenExpression );\n\n\t/* parse/converters/mustache/delimiterChange.js */\n\tvar delimiterChange = function() {\n\n\t\tvar delimiterChangePattern = /^[^\\s=]+/,\n\t\t\twhitespacePattern = /^\\s+/;\n\t\treturn function( parser ) {\n\t\t\tvar start, opening, closing;\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace before new opening delimiter\n\t\t\tparser.allowWhitespace();\n\t\t\topening = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !opening ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace (in fact, it's necessary...)\n\t\t\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tclosing = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !closing ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace before closing '='\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn [\n\t\t\t\topening,\n\t\t\t\tclosing\n\t\t\t];\n\t\t};\n\t}();\n\n\t/* parse/converters/mustache/delimiterTypes.js */\n\tvar delimiterTypes = [ {\n\t\tdelimiters: 'delimiters',\n\t\tisTriple: false,\n\t\tisStatic: false\n\t}, {\n\t\tdelimiters: 'tripleDelimiters',\n\t\tisTriple: true,\n\t\tisStatic: false\n\t}, {\n\t\tdelimiters: 'staticDelimiters',\n\t\tisTriple: false,\n\t\tisStatic: true\n\t}, {\n\t\tdelimiters: 'staticTripleDelimiters',\n\t\tisTriple: true,\n\t\tisStatic: true\n\t} ];\n\n\t/* parse/converters/mustache/type.js */\n\tvar type = function( types ) {\n\n\t\tvar mustacheTypes = {\n\t\t\t'#': types.SECTION,\n\t\t\t'^': types.INVERTED,\n\t\t\t'/': types.CLOSING,\n\t\t\t'>': types.PARTIAL,\n\t\t\t'!': types.COMMENT,\n\t\t\t'&': types.TRIPLE\n\t\t};\n\t\treturn function( parser ) {\n\t\t\tvar type = mustacheTypes[ parser.str.charAt( parser.pos ) ];\n\t\t\tif ( !type ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.pos += 1;\n\t\t\treturn type;\n\t\t};\n\t}( types );\n\n\t/* parse/converters/mustache/handlebarsBlockCodes.js */\n\tvar handlebarsBlockCodes = function( types ) {\n\n\t\treturn {\n\t\t\t'each': types.SECTION_EACH,\n\t\t\t'if': types.SECTION_IF,\n\t\t\t'if-with': types.SECTION_IF_WITH,\n\t\t\t'with': types.SECTION_WITH,\n\t\t\t'unless': types.SECTION_UNLESS\n\t\t};\n\t}( types );\n\n\t/* empty/legacy.js */\n\tvar legacy = null;\n\n\t/* parse/converters/mustache/content.js */\n\tvar content = function( types, mustacheType, handlebarsBlockCodes ) {\n\n\t\tvar __export;\n\t\tvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\t\t\tarrayMemberPattern = /^[0-9][1-9]*$/,\n\t\t\thandlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' ),\n\t\t\tlegalReference;\n\t\tlegalReference = /^[a-zA-Z$_0-9]+(?:(\\.[a-zA-Z$_0-9]+)|(\\[[a-zA-Z$_0-9]+\\]))*$/;\n\t\t__export = function( parser, delimiterType ) {\n\t\t\tvar start, pos, mustache, type, block, expression, i, remaining, index, delimiters;\n\t\t\tstart = parser.pos;\n\t\t\tmustache = {};\n\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\tif ( delimiterType.isStatic ) {\n\t\t\t\tmustache.s = true;\n\t\t\t}\n\t\t\t// Determine mustache type\n\t\t\tif ( delimiterType.isTriple ) {\n\t\t\t\tmustache.t = types.TRIPLE;\n\t\t\t} else {\n\t\t\t\t// We need to test for expressions before we test for mustache type, because\n\t\t\t\t// an expression that begins '!' looks a lot like a comment\n\t\t\t\tif ( parser.remaining()[ 0 ] === '!' ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\texpression = parser.readExpression();\n\t\t\t\t\t\t// Was it actually an expression, or a comment block in disguise?\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {\n\t\t\t\t\t\t\texpression = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmustache.t = types.INTERPOLATOR;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\tif ( !expression ) {\n\t\t\t\t\t\tindex = parser.remaining().indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\tif ( ~index ) {\n\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.error( 'Expected closing delimiter (\\'' + delimiters[ 1 ] + '\\')' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tt: types.COMMENT\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\ttype = mustacheType( parser );\n\t\t\t\t\tmustache.t = type || types.INTERPOLATOR;\n\t\t\t\t\t// default\n\t\t\t\t\t// See if there's an explicit section type e.g. {{#with}}...{{/with}}\n\t\t\t\t\tif ( type === types.SECTION ) {\n\t\t\t\t\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\t\t\t\t\tmustache.n = block;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t} else if ( type === types.COMMENT || type === types.CLOSING ) {\n\t\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];\n\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !expression ) {\n\t\t\t\t// allow whitespace\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// get expression\n\t\t\t\texpression = parser.readExpression();\n\t\t\t\t// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These\n\t\t\t\t// cases involve a bit of a hack - we want to turn it into the equivalent of\n\t\t\t\t// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append\n\t\t\t\t// a 'contextPartialExpression' to the mustache, and process the context instead of\n\t\t\t\t// the reference\n\t\t\t\tvar temp;\n\t\t\t\tif ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {\n\t\t\t\t\tmustache = {\n\t\t\t\t\t\tcontextPartialExpression: expression\n\t\t\t\t\t};\n\t\t\t\t\texpression = temp;\n\t\t\t\t}\n\t\t\t\t// With certain valid references that aren't valid expressions,\n\t\t\t\t// e.g. {{1.foo}}, we have a problem: it looks like we've got an\n\t\t\t\t// expression, but the expression didn't consume the entire\n\t\t\t\t// reference. So we need to check that the mustache delimiters\n\t\t\t\t// appear next, unless there's an index reference (i.e. a colon)\n\t\t\t\tremaining = parser.remaining();\n\t\t\t\tif ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {\n\t\t\t\t\tpos = parser.pos;\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).trim();\n\t\t\t\t\t\t// Check it's a legal reference\n\t\t\t\t\t\tif ( !legalReference.test( mustache.r ) ) {\n\t\t\t\t\t\t\tparser.error( 'Expected a legal Mustache reference' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t}\n\t\t\t\t\tparser.pos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\trefineExpression( parser, expression, mustache );\n\t\t\t// if there was context, process the expression now and save it for later\n\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\tmustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {\n\t\t\t\t\tt: types.PARTIAL\n\t\t\t\t} ) ];\n\t\t\t}\n\t\t\t// optional index reference\n\t\t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\t\t\tmustache.i = i;\n\t\t\t}\n\t\t\treturn mustache;\n\t\t};\n\n\t\tfunction refineExpression( parser, expression, mustache ) {\n\t\t\tvar referenceExpression;\n\t\t\tif ( expression ) {\n\t\t\t\twhile ( expression.t === types.BRACKETED && expression.x ) {\n\t\t\t\t\texpression = expression.x;\n\t\t\t\t}\n\t\t\t\t// special case - integers should be treated as array members references,\n\t\t\t\t// rather than as expressions in their own right\n\t\t\t\tif ( expression.t === types.REFERENCE ) {\n\t\t\t\t\tmustache.r = expression.n;\n\t\t\t\t} else {\n\t\t\t\t\tif ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {\n\t\t\t\t\t\tmustache.r = expression.v;\n\t\t\t\t\t} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {\n\t\t\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmustache.x = parser.flattenExpression( expression );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\t\t// TODO refactor this! it's bewildering\n\t\tfunction getReferenceExpression( parser, expression ) {\n\t\t\tvar members = [],\n\t\t\t\trefinement;\n\t\t\twhile ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {\n\t\t\t\trefinement = expression.r;\n\t\t\t\tif ( refinement.x ) {\n\t\t\t\t\tif ( refinement.x.t === types.REFERENCE ) {\n\t\t\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmembers.unshift( parser.flattenExpression( refinement.x ) );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmembers.unshift( refinement.n );\n\t\t\t\t}\n\t\t\t\texpression = expression.x;\n\t\t\t}\n\t\t\tif ( expression.t !== types.REFERENCE ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tr: expression.n,\n\t\t\t\tm: members\n\t\t\t};\n\t\t}\n\t\treturn __export;\n\t}( types, type, handlebarsBlockCodes, legacy );\n\n\t/* parse/converters/mustache.js */\n\tvar mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {\n\n\t\tvar __export;\n\t\tvar delimiterChangeToken = {\n\t\t\tt: types.DELIMCHANGE,\n\t\t\texclude: true\n\t\t};\n\t\t__export = getMustache;\n\n\t\tfunction getMustache( parser ) {\n\t\t\tvar types;\n\t\t\t// If we're inside a <script> or <style> tag, and we're not\n\t\t\t// interpolating, bug out\n\t\t\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttypes = delimiterTypes.slice().sort( function compare( a, b ) {\n\t\t\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t\t\t// to protect against opening delimiters being substrings of each other\n\t\t\t\treturn parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;\n\t\t\t} );\n\t\t\treturn function r( type ) {\n\t\t\t\tif ( !type ) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn getMustacheOfType( parser, type ) || r( types.shift() );\n\t\t\t\t}\n\t\t\t}( types.shift() );\n\t\t}\n\n\t\tfunction getMustacheOfType( parser, delimiterType ) {\n\t\t\tvar start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;\n\t\t\tstart = parser.pos;\n\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\tif ( !parser.matchString( delimiters[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// delimiter change?\n\t\t\tif ( mustache = delimiterChange( parser ) ) {\n\t\t\t\t// find closing delimiter or abort...\n\t\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// ...then make the switch\n\t\t\t\tparser[ delimiterType.delimiters ] = mustache;\n\t\t\t\treturn delimiterChangeToken;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tmustache = mustacheContent( parser, delimiterType );\n\t\t\tif ( mustache === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace before closing delimiter\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\tparser.error( 'Expected closing delimiter \\'' + delimiters[ 1 ] + '\\' after reference' );\n\t\t\t}\n\t\t\tif ( mustache.t === types.COMMENT ) {\n\t\t\t\tmustache.exclude = true;\n\t\t\t}\n\t\t\tif ( mustache.t === types.CLOSING ) {\n\t\t\t\tparser.sectionDepth -= 1;\n\t\t\t\tif ( parser.sectionDepth < 0 ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// partials with context\n\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\tmustache.f = mustache.contextPartialExpression;\n\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\tmustache.n = 'with';\n\t\t\t\tdelete mustache.contextPartialExpression;\n\t\t\t} else if ( isSection( mustache ) ) {\n\t\t\t\tparser.sectionDepth += 1;\n\t\t\t\tchildren = [];\n\t\t\t\tcurrentChildren = children;\n\t\t\t\texpectedClose = mustache.n;\n\t\t\t\twhile ( child = parser.read() ) {\n\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\t\t\t\tparser.error( 'Expected {{/' + expectedClose + '}}' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// {{else}} tags require special treatment\n\t\t\t\t\tif ( child.t === types.INTERPOLATOR && child.r === 'else' ) {\n\t\t\t\t\t\t// no {{else}} allowed in {{#unless}}\n\t\t\t\t\t\tif ( mustache.n === 'unless' ) {\n\t\t\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentChildren = elseChildren = [];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurrentChildren.push( child );\n\t\t\t\t}\n\t\t\t\tif ( children.length ) {\n\t\t\t\t\tmustache.f = children;\n\t\t\t\t}\n\t\t\t\tif ( elseChildren && elseChildren.length ) {\n\t\t\t\t\tmustache.l = elseChildren;\n\t\t\t\t\tif ( mustache.n === 'with' ) {\n\t\t\t\t\t\tmustache.n = 'if-with';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\t// Replace block name with code\n\t\t\tif ( mustache.n ) {\n\t\t\t\tmustache.n = handlebarsBlockCodes[ mustache.n ];\n\t\t\t} else if ( mustache.t === types.INVERTED ) {\n\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\tmustache.n = types.SECTION_UNLESS;\n\t\t\t}\n\t\t\treturn mustache;\n\t\t}\n\n\t\tfunction isSection( mustache ) {\n\t\t\treturn mustache.t === types.SECTION || mustache.t === types.INVERTED;\n\t\t}\n\t\treturn __export;\n\t}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );\n\n\t/* parse/converters/comment.js */\n\tvar comment = function( types ) {\n\n\t\tvar OPEN_COMMENT = '<!--',\n\t\t\tCLOSE_COMMENT = '-->';\n\t\treturn function( parser ) {\n\t\t\tvar start, content, remaining, endIndex, comment;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( OPEN_COMMENT ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tremaining = parser.remaining();\n\t\t\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\t\t\tif ( endIndex === -1 ) {\n\t\t\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t\t\t}\n\t\t\tcontent = remaining.substr( 0, endIndex );\n\t\t\tparser.pos += endIndex + 3;\n\t\t\tcomment = {\n\t\t\t\tt: types.COMMENT,\n\t\t\t\tc: content\n\t\t\t};\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tcomment.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\treturn comment;\n\t\t};\n\t}( types );\n\n\t/* config/voidElementNames.js */\n\tvar voidElementNames = function() {\n\n\t\tvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\t\treturn voidElementNames;\n\t}();\n\n\t/* parse/converters/utils/getLowestIndex.js */\n\tvar getLowestIndex = function( haystack, needles ) {\n\t\tvar i, index, lowest;\n\t\ti = needles.length;\n\t\twhile ( i-- ) {\n\t\t\tindex = haystack.indexOf( needles[ i ] );\n\t\t\t// short circuit\n\t\t\tif ( !index ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ( index === -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !lowest || index < lowest ) {\n\t\t\t\tlowest = index;\n\t\t\t}\n\t\t}\n\t\treturn lowest || -1;\n\t};\n\n\t/* shared/decodeCharacterReferences.js */\n\tvar decodeCharacterReferences = function() {\n\n\t\tvar __export;\n\t\tvar htmlEntities, controlCharacters, entityPattern;\n\t\thtmlEntities = {\n\t\t\tquot: 34,\n\t\t\tamp: 38,\n\t\t\tapos: 39,\n\t\t\tlt: 60,\n\t\t\tgt: 62,\n\t\t\tnbsp: 160,\n\t\t\tiexcl: 161,\n\t\t\tcent: 162,\n\t\t\tpound: 163,\n\t\t\tcurren: 164,\n\t\t\tyen: 165,\n\t\t\tbrvbar: 166,\n\t\t\tsect: 167,\n\t\t\tuml: 168,\n\t\t\tcopy: 169,\n\t\t\tordf: 170,\n\t\t\tlaquo: 171,\n\t\t\tnot: 172,\n\t\t\tshy: 173,\n\t\t\treg: 174,\n\t\t\tmacr: 175,\n\t\t\tdeg: 176,\n\t\t\tplusmn: 177,\n\t\t\tsup2: 178,\n\t\t\tsup3: 179,\n\t\t\tacute: 180,\n\t\t\tmicro: 181,\n\t\t\tpara: 182,\n\t\t\tmiddot: 183,\n\t\t\tcedil: 184,\n\t\t\tsup1: 185,\n\t\t\tordm: 186,\n\t\t\traquo: 187,\n\t\t\tfrac14: 188,\n\t\t\tfrac12: 189,\n\t\t\tfrac34: 190,\n\t\t\tiquest: 191,\n\t\t\tAgrave: 192,\n\t\t\tAacute: 193,\n\t\t\tAcirc: 194,\n\t\t\tAtilde: 195,\n\t\t\tAuml: 196,\n\t\t\tAring: 197,\n\t\t\tAElig: 198,\n\t\t\tCcedil: 199,\n\t\t\tEgrave: 200,\n\t\t\tEacute: 201,\n\t\t\tEcirc: 202,\n\t\t\tEuml: 203,\n\t\t\tIgrave: 204,\n\t\t\tIacute: 205,\n\t\t\tIcirc: 206,\n\t\t\tIuml: 207,\n\t\t\tETH: 208,\n\t\t\tNtilde: 209,\n\t\t\tOgrave: 210,\n\t\t\tOacute: 211,\n\t\t\tOcirc: 212,\n\t\t\tOtilde: 213,\n\t\t\tOuml: 214,\n\t\t\ttimes: 215,\n\t\t\tOslash: 216,\n\t\t\tUgrave: 217,\n\t\t\tUacute: 218,\n\t\t\tUcirc: 219,\n\t\t\tUuml: 220,\n\t\t\tYacute: 221,\n\t\t\tTHORN: 222,\n\t\t\tszlig: 223,\n\t\t\tagrave: 224,\n\t\t\taacute: 225,\n\t\t\tacirc: 226,\n\t\t\tatilde: 227,\n\t\t\tauml: 228,\n\t\t\taring: 229,\n\t\t\taelig: 230,\n\t\t\tccedil: 231,\n\t\t\tegrave: 232,\n\t\t\teacute: 233,\n\t\t\tecirc: 234,\n\t\t\teuml: 235,\n\t\t\tigrave: 236,\n\t\t\tiacute: 237,\n\t\t\ticirc: 238,\n\t\t\tiuml: 239,\n\t\t\teth: 240,\n\t\t\tntilde: 241,\n\t\t\tograve: 242,\n\t\t\toacute: 243,\n\t\t\tocirc: 244,\n\t\t\totilde: 245,\n\t\t\touml: 246,\n\t\t\tdivide: 247,\n\t\t\toslash: 248,\n\t\t\tugrave: 249,\n\t\t\tuacute: 250,\n\t\t\tucirc: 251,\n\t\t\tuuml: 252,\n\t\t\tyacute: 253,\n\t\t\tthorn: 254,\n\t\t\tyuml: 255,\n\t\t\tOElig: 338,\n\t\t\toelig: 339,\n\t\t\tScaron: 352,\n\t\t\tscaron: 353,\n\t\t\tYuml: 376,\n\t\t\tfnof: 402,\n\t\t\tcirc: 710,\n\t\t\ttilde: 732,\n\t\t\tAlpha: 913,\n\t\t\tBeta: 914,\n\t\t\tGamma: 915,\n\t\t\tDelta: 916,\n\t\t\tEpsilon: 917,\n\t\t\tZeta: 918,\n\t\t\tEta: 919,\n\t\t\tTheta: 920,\n\t\t\tIota: 921,\n\t\t\tKappa: 922,\n\t\t\tLambda: 923,\n\t\t\tMu: 924,\n\t\t\tNu: 925,\n\t\t\tXi: 926,\n\t\t\tOmicron: 927,\n\t\t\tPi: 928,\n\t\t\tRho: 929,\n\t\t\tSigma: 931,\n\t\t\tTau: 932,\n\t\t\tUpsilon: 933,\n\t\t\tPhi: 934,\n\t\t\tChi: 935,\n\t\t\tPsi: 936,\n\t\t\tOmega: 937,\n\t\t\talpha: 945,\n\t\t\tbeta: 946,\n\t\t\tgamma: 947,\n\t\t\tdelta: 948,\n\t\t\tepsilon: 949,\n\t\t\tzeta: 950,\n\t\t\teta: 951,\n\t\t\ttheta: 952,\n\t\t\tiota: 953,\n\t\t\tkappa: 954,\n\t\t\tlambda: 955,\n\t\t\tmu: 956,\n\t\t\tnu: 957,\n\t\t\txi: 958,\n\t\t\tomicron: 959,\n\t\t\tpi: 960,\n\t\t\trho: 961,\n\t\t\tsigmaf: 962,\n\t\t\tsigma: 963,\n\t\t\ttau: 964,\n\t\t\tupsilon: 965,\n\t\t\tphi: 966,\n\t\t\tchi: 967,\n\t\t\tpsi: 968,\n\t\t\tomega: 969,\n\t\t\tthetasym: 977,\n\t\t\tupsih: 978,\n\t\t\tpiv: 982,\n\t\t\tensp: 8194,\n\t\t\temsp: 8195,\n\t\t\tthinsp: 8201,\n\t\t\tzwnj: 8204,\n\t\t\tzwj: 8205,\n\t\t\tlrm: 8206,\n\t\t\trlm: 8207,\n\t\t\tndash: 8211,\n\t\t\tmdash: 8212,\n\t\t\tlsquo: 8216,\n\t\t\trsquo: 8217,\n\t\t\tsbquo: 8218,\n\t\t\tldquo: 8220,\n\t\t\trdquo: 8221,\n\t\t\tbdquo: 8222,\n\t\t\tdagger: 8224,\n\t\t\tDagger: 8225,\n\t\t\tbull: 8226,\n\t\t\thellip: 8230,\n\t\t\tpermil: 8240,\n\t\t\tprime: 8242,\n\t\t\tPrime: 8243,\n\t\t\tlsaquo: 8249,\n\t\t\trsaquo: 8250,\n\t\t\toline: 8254,\n\t\t\tfrasl: 8260,\n\t\t\teuro: 8364,\n\t\t\timage: 8465,\n\t\t\tweierp: 8472,\n\t\t\treal: 8476,\n\t\t\ttrade: 8482,\n\t\t\talefsym: 8501,\n\t\t\tlarr: 8592,\n\t\t\tuarr: 8593,\n\t\t\trarr: 8594,\n\t\t\tdarr: 8595,\n\t\t\tharr: 8596,\n\t\t\tcrarr: 8629,\n\t\t\tlArr: 8656,\n\t\t\tuArr: 8657,\n\t\t\trArr: 8658,\n\t\t\tdArr: 8659,\n\t\t\thArr: 8660,\n\t\t\tforall: 8704,\n\t\t\tpart: 8706,\n\t\t\texist: 8707,\n\t\t\tempty: 8709,\n\t\t\tnabla: 8711,\n\t\t\tisin: 8712,\n\t\t\tnotin: 8713,\n\t\t\tni: 8715,\n\t\t\tprod: 8719,\n\t\t\tsum: 8721,\n\t\t\tminus: 8722,\n\t\t\tlowast: 8727,\n\t\t\tradic: 8730,\n\t\t\tprop: 8733,\n\t\t\tinfin: 8734,\n\t\t\tang: 8736,\n\t\t\tand: 8743,\n\t\t\tor: 8744,\n\t\t\tcap: 8745,\n\t\t\tcup: 8746,\n\t\t\t'int': 8747,\n\t\t\tthere4: 8756,\n\t\t\tsim: 8764,\n\t\t\tcong: 8773,\n\t\t\tasymp: 8776,\n\t\t\tne: 8800,\n\t\t\tequiv: 8801,\n\t\t\tle: 8804,\n\t\t\tge: 8805,\n\t\t\tsub: 8834,\n\t\t\tsup: 8835,\n\t\t\tnsub: 8836,\n\t\t\tsube: 8838,\n\t\t\tsupe: 8839,\n\t\t\toplus: 8853,\n\t\t\totimes: 8855,\n\t\t\tperp: 8869,\n\t\t\tsdot: 8901,\n\t\t\tlceil: 8968,\n\t\t\trceil: 8969,\n\t\t\tlfloor: 8970,\n\t\t\trfloor: 8971,\n\t\t\tlang: 9001,\n\t\t\trang: 9002,\n\t\t\tloz: 9674,\n\t\t\tspades: 9824,\n\t\t\tclubs: 9827,\n\t\t\thearts: 9829,\n\t\t\tdiams: 9830\n\t\t};\n\t\tcontrolCharacters = [\n\t\t\t8364,\n\t\t\t129,\n\t\t\t8218,\n\t\t\t402,\n\t\t\t8222,\n\t\t\t8230,\n\t\t\t8224,\n\t\t\t8225,\n\t\t\t710,\n\t\t\t8240,\n\t\t\t352,\n\t\t\t8249,\n\t\t\t338,\n\t\t\t141,\n\t\t\t381,\n\t\t\t143,\n\t\t\t144,\n\t\t\t8216,\n\t\t\t8217,\n\t\t\t8220,\n\t\t\t8221,\n\t\t\t8226,\n\t\t\t8211,\n\t\t\t8212,\n\t\t\t732,\n\t\t\t8482,\n\t\t\t353,\n\t\t\t8250,\n\t\t\t339,\n\t\t\t157,\n\t\t\t382,\n\t\t\t376\n\t\t];\n\t\tentityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\t\t__export = function decodeCharacterReferences( html ) {\n\t\t\treturn html.replace( entityPattern, function( match, entity ) {\n\t\t\t\tvar code;\n\t\t\t\t// Handle named entities\n\t\t\t\tif ( entity[ 0 ] !== '#' ) {\n\t\t\t\t\tcode = htmlEntities[ entity ];\n\t\t\t\t} else if ( entity[ 1 ] === 'x' ) {\n\t\t\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t\t\t} else {\n\t\t\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t\t\t}\n\t\t\t\tif ( !code ) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\treturn String.fromCharCode( validateCode( code ) );\n\t\t\t} );\n\t\t};\n\t\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t\t// to replace them ourselves\n\t\t//\n\t\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\t\tfunction validateCode( code ) {\n\t\t\tif ( !code ) {\n\t\t\t\treturn 65533;\n\t\t\t}\n\t\t\t// line feed becomes generic whitespace\n\t\t\tif ( code === 10 ) {\n\t\t\t\treturn 32;\n\t\t\t}\n\t\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t\t\tif ( code < 128 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t\t\t// to correct the mistake or we'll end up with missing € signs and so on\n\t\t\tif ( code <= 159 ) {\n\t\t\t\treturn controlCharacters[ code - 128 ];\n\t\t\t}\n\t\t\t// basic multilingual plane\n\t\t\tif ( code < 55296 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\t// UTF-16 surrogate halves\n\t\t\tif ( code <= 57343 ) {\n\t\t\t\treturn 65533;\n\t\t\t}\n\t\t\t// rest of the basic multilingual plane\n\t\t\tif ( code <= 65535 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\treturn 65533;\n\t\t}\n\t\treturn __export;\n\t}( legacy );\n\n\t/* parse/converters/text.js */\n\tvar text = function( getLowestIndex, decodeCharacterReferences ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar index, remaining, disallowed, barrier;\n\t\t\tremaining = parser.remaining();\n\t\t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\t\t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\t\t\tindex = remaining.indexOf( barrier );\n\t\t\t} else {\n\t\t\t\tdisallowed = [\n\t\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t\t];\n\t\t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\t\t\tif ( parser.inAttribute === true ) {\n\t\t\t\t\t// we're inside an unquoted attribute value\n\t\t\t\t\tdisallowed.push( '\"', '\\'', '=', '<', '>', '`' );\n\t\t\t\t} else if ( parser.inAttribute ) {\n\t\t\t\t\t// quoted attribute value\n\t\t\t\t\tdisallowed.push( parser.inAttribute );\n\t\t\t\t} else {\n\t\t\t\t\tdisallowed.push( barrier );\n\t\t\t\t}\n\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t}\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( index === -1 ) {\n\t\t\t\tindex = remaining.length;\n\t\t\t}\n\t\t\tparser.pos += index;\n\t\t\treturn parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );\n\t\t};\n\t}( getLowestIndex, decodeCharacterReferences );\n\n\t/* parse/converters/element/closingTag.js */\n\tvar closingTag = function( types ) {\n\n\t\tvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\t\treturn function( parser ) {\n\t\t\tvar tag;\n\t\t\t// are we looking at a closing tag?\n\t\t\tif ( !parser.matchString( '</' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.CLOSING_TAG,\n\t\t\t\t\te: tag\n\t\t\t\t};\n\t\t\t}\n\t\t\t// We have an illegal closing tag, report it\n\t\t\tparser.pos -= 2;\n\t\t\tparser.error( 'Illegal closing tag' );\n\t\t};\n\t}( types );\n\n\t/* parse/converters/element/attribute.js */\n\tvar attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {\n\n\t\tvar __export;\n\t\tvar attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n\t\t\tunquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\t\t__export = getAttribute;\n\n\t\tfunction getAttribute( parser ) {\n\t\t\tvar attr, name, value;\n\t\t\tparser.allowWhitespace();\n\t\t\tname = parser.matchPattern( attributeNamePattern );\n\t\t\tif ( !name ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tattr = {\n\t\t\t\tname: name\n\t\t\t};\n\t\t\tvalue = getAttributeValue( parser );\n\t\t\tif ( value ) {\n\t\t\t\tattr.value = value;\n\t\t\t}\n\t\t\treturn attr;\n\t\t}\n\n\t\tfunction getAttributeValue( parser ) {\n\t\t\tvar start, valueStart, startDepth, value;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tvalueStart = parser.pos;\n\t\t\tstartDepth = parser.sectionDepth;\n\t\t\tvalue = getQuotedAttributeValue( parser, '\\'' ) || getQuotedAttributeValue( parser, '\"' ) || getUnquotedAttributeValue( parser );\n\t\t\tif ( parser.sectionDepth !== startDepth ) {\n\t\t\t\tparser.pos = valueStart;\n\t\t\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t\t\t}\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( !value.length ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( value.length === 1 && typeof value[ 0 ] === 'string' ) {\n\t\t\t\treturn decodeCharacterReferences( value[ 0 ] );\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction getUnquotedAttributeValueToken( parser ) {\n\t\t\tvar start, text, haystack, needles, index;\n\t\t\tstart = parser.pos;\n\t\t\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\t\t\tif ( !text ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\thaystack = text;\n\t\t\tneedles = [\n\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t];\n\t\t\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\t\t\ttext = text.substr( 0, index );\n\t\t\t\tparser.pos = start + text.length;\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\n\t\tfunction getUnquotedAttributeValue( parser ) {\n\t\t\tvar tokens, token;\n\t\t\tparser.inAttribute = true;\n\t\t\ttokens = [];\n\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\twhile ( token !== null ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\t}\n\t\t\tif ( !tokens.length ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = false;\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfunction getQuotedAttributeValue( parser, quoteMark ) {\n\t\t\tvar start, tokens, token;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = quoteMark;\n\t\t\ttokens = [];\n\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\twhile ( token !== null ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\t}\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = false;\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfunction getQuotedStringToken( parser, quoteMark ) {\n\t\t\tvar start, index, haystack, needles;\n\t\t\tstart = parser.pos;\n\t\t\thaystack = parser.remaining();\n\t\t\tneedles = [\n\t\t\t\tquoteMark,\n\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t];\n\t\t\tindex = getLowestIndex( haystack, needles );\n\t\t\tif ( index === -1 ) {\n\t\t\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t\t\t}\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.pos += index;\n\t\t\treturn haystack.substr( 0, index );\n\t\t}\n\t\treturn __export;\n\t}( getLowestIndex, mustache, decodeCharacterReferences );\n\n\t/* utils/parseJSON.js */\n\tvar parseJSON = function( Parser, getStringLiteral, getKey ) {\n\n\t\tvar JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\t\tspecials = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'undefined': undefined,\n\t\t\t'null': null\n\t\t};\n\t\tspecialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );\n\t\tnumberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\tplaceholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\t\tplaceholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\t\tonlyWhitespace = /^\\s*$/;\n\t\tJsonParser = Parser.extend( {\n\t\t\tinit: function( str, options ) {\n\t\t\t\tthis.values = options.values;\n\t\t\t\tthis.allowWhitespace();\n\t\t\t},\n\t\t\tpostProcess: function( result ) {\n\t\t\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tvalue: result[ 0 ].v\n\t\t\t\t};\n\t\t\t},\n\t\t\tconverters: [\n\n\t\t\t\tfunction getPlaceholder( parser ) {\n\t\t\t\t\tvar placeholder;\n\t\t\t\t\tif ( !parser.values ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tplaceholder = parser.matchPattern( placeholderAtStartPattern );\n\t\t\t\t\tif ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: parser.values[ placeholder ]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getSpecial( parser ) {\n\t\t\t\t\tvar special;\n\t\t\t\t\tif ( special = parser.matchPattern( specialsPattern ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: specials[ special ]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getNumber( parser ) {\n\t\t\t\t\tvar number;\n\t\t\t\t\tif ( number = parser.matchPattern( numberPattern ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: +number\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getString( parser ) {\n\t\t\t\t\tvar stringLiteral = getStringLiteral( parser ),\n\t\t\t\t\t\tvalues;\n\t\t\t\t\tif ( stringLiteral && ( values = parser.values ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {\n\t\t\t\t\t\t\t\treturn $1 in values ? values[ $1 ] : $1;\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn stringLiteral;\n\t\t\t\t},\n\t\t\t\tfunction getObject( parser ) {\n\t\t\t\t\tvar result, pair;\n\t\t\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tresult = {};\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\t\t\tresult[ pair.key ] = pair.value;\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\tfunction getArray( parser ) {\n\t\t\t\t\tvar result, valueToken;\n\t\t\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tresult = [];\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\t\t\tresult.push( valueToken.v );\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\n\t\tfunction getKeyValuePair( parser ) {\n\t\t\tvar key, valueToken, pair;\n\t\t\tparser.allowWhitespace();\n\t\t\tkey = getKey( parser );\n\t\t\tif ( !key ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpair = {\n\t\t\t\tkey: key\n\t\t\t};\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tvalueToken = parser.read();\n\t\t\tif ( !valueToken ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpair.value = valueToken.v;\n\t\t\treturn pair;\n\t\t}\n\t\treturn function( str, values ) {\n\t\t\tvar parser = new JsonParser( str, {\n\t\t\t\tvalues: values\n\t\t\t} );\n\t\t\treturn parser.result;\n\t\t};\n\t}( Parser, stringLiteral, key );\n\n\t/* parse/converters/element/processDirective.js */\n\tvar processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {\n\n\t\tvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n\t\t\tExpressionParser;\n\t\tExpressionParser = Parser.extend( {\n\t\t\tconverters: [ conditional ]\n\t\t} );\n\t\t// TODO clean this up, it's shocking\n\t\treturn function( tokens ) {\n\t\t\tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\t\t\tif ( typeof tokens === 'string' ) {\n\t\t\t\tif ( match = methodCallPattern.exec( tokens ) ) {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tm: match[ 1 ]\n\t\t\t\t\t};\n\t\t\t\t\targs = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';\n\t\t\t\t\tparser = new ExpressionParser( args );\n\t\t\t\t\tresult.a = flattenExpression( parser.result[ 0 ] );\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\t\t\treturn tokens.trim();\n\t\t\t\t}\n\t\t\t\ttokens = [ tokens ];\n\t\t\t}\n\t\t\tresult = {};\n\t\t\tdirectiveName = [];\n\t\t\tdirectiveArgs = [];\n\t\t\tif ( tokens ) {\n\t\t\t\twhile ( tokens.length ) {\n\t\t\t\t\ttoken = tokens.shift();\n\t\t\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\t\t\tcolonIndex = token.indexOf( ':' );\n\t\t\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t\t\t// no\n\t\t\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\t\t\tdirectiveArgs[ 0 ] = token.substring( colonIndex + 1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t\t\t}\n\t\t\tif ( !directiveName.length ) {\n\t\t\t\tresult = '';\n\t\t\t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\t\t\tresult = {\n\t\t\t\t\t// TODO is this really necessary? just use the array\n\t\t\t\t\tn: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName\n\t\t\t\t};\n\t\t\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {\n\t\t\t\t\tparsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );\n\t\t\t\t\tresult.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();\n\t\t\t\t} else {\n\t\t\t\t\tresult.d = directiveArgs;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = directiveName;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( Parser, conditional, flattenExpression, parseJSON );\n\n\t/* parse/converters/element.js */\n\tvar element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {\n\n\t\tvar __export;\n\t\tvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n\t\t\tvalidTagNameFollower = /^[\\s\\n\\/>]/,\n\t\t\tonPattern = /^on/,\n\t\t\tproxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n\t\t\treservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n\t\t\tdirectives = {\n\t\t\t\t'intro-outro': 't0',\n\t\t\t\tintro: 't1',\n\t\t\t\toutro: 't2',\n\t\t\t\tdecorator: 'o'\n\t\t\t},\n\t\t\texclude = {\n\t\t\t\texclude: true\n\t\t\t},\n\t\t\tconverters, disallowedContents;\n\t\t// Different set of converters, because this time we're looking for closing tags\n\t\tconverters = [\n\t\t\tgetMustache,\n\t\t\tgetComment,\n\t\t\tgetElement,\n\t\t\tgetText,\n\t\t\tgetClosingTag\n\t\t];\n\t\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\t\tdisallowedContents = {\n\t\t\tli: [ 'li' ],\n\t\t\tdt: [\n\t\t\t\t'dt',\n\t\t\t\t'dd'\n\t\t\t],\n\t\t\tdd: [\n\t\t\t\t'dt',\n\t\t\t\t'dd'\n\t\t\t],\n\t\t\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t\t\trt: [\n\t\t\t\t'rt',\n\t\t\t\t'rp'\n\t\t\t],\n\t\t\trp: [\n\t\t\t\t'rt',\n\t\t\t\t'rp'\n\t\t\t],\n\t\t\toptgroup: [ 'optgroup' ],\n\t\t\toption: [\n\t\t\t\t'option',\n\t\t\t\t'optgroup'\n\t\t\t],\n\t\t\tthead: [\n\t\t\t\t'tbody',\n\t\t\t\t'tfoot'\n\t\t\t],\n\t\t\ttbody: [\n\t\t\t\t'tbody',\n\t\t\t\t'tfoot'\n\t\t\t],\n\t\t\ttfoot: [ 'tbody' ],\n\t\t\ttr: [\n\t\t\t\t'tr',\n\t\t\t\t'tbody'\n\t\t\t],\n\t\t\ttd: [\n\t\t\t\t'td',\n\t\t\t\t'th',\n\t\t\t\t'tr'\n\t\t\t],\n\t\t\tth: [\n\t\t\t\t'td',\n\t\t\t\t'th',\n\t\t\t\t'tr'\n\t\t\t]\n\t\t};\n\t\t__export = getElement;\n\n\t\tfunction getElement( parser ) {\n\t\t\tvar start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;\n\t\t\tstart = parser.pos;\n\t\t\tif ( parser.inside || parser.inAttribute ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( !parser.matchString( '<' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// if this is a closing tag, abort straight away\n\t\t\tif ( parser.nextChar() === '/' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telement = {\n\t\t\t\tt: types.ELEMENT\n\t\t\t};\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\telement.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\tif ( parser.matchString( '!' ) ) {\n\t\t\t\telement.y = 1;\n\t\t\t}\n\t\t\t// element name\n\t\t\telement.e = parser.matchPattern( tagNamePattern );\n\t\t\tif ( !element.e ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// next character must be whitespace, closing solidus or '>'\n\t\t\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\t\t\tparser.error( 'Illegal tag name' );\n\t\t\t}\n\t\t\taddProxyEvent = function( name, directive ) {\n\t\t\t\tvar directiveName = directive.n || directive;\n\t\t\t\tif ( reservedEventNames.test( directiveName ) ) {\n\t\t\t\t\tparser.pos -= directiveName.length;\n\t\t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t\t\t}\n\t\t\t\telement.v[ name ] = directive;\n\t\t\t};\n\t\t\tparser.allowWhitespace();\n\t\t\t// directives and attributes\n\t\t\twhile ( attribute = getMustache( parser ) || getAttribute( parser ) ) {\n\t\t\t\t// regular attributes\n\t\t\t\tif ( attribute.name ) {\n\t\t\t\t\t// intro, outro, decorator\n\t\t\t\t\tif ( directiveName = directives[ attribute.name ] ) {\n\t\t\t\t\t\telement[ directiveName ] = processDirective( attribute.value );\n\t\t\t\t\t} else if ( match = proxyEventPattern.exec( attribute.name ) ) {\n\t\t\t\t\t\tif ( !element.v )\n\t\t\t\t\t\t\telement.v = {};\n\t\t\t\t\t\tdirective = processDirective( attribute.value );\n\t\t\t\t\t\taddProxyEvent( match[ 1 ], directive );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {\n\t\t\t\t\t\t\tif ( !element.a )\n\t\t\t\t\t\t\t\telement.a = {};\n\t\t\t\t\t\t\telement.a[ attribute.name ] = attribute.value || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( !element.m )\n\t\t\t\t\t\telement.m = [];\n\t\t\t\t\telement.m.push( attribute );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\t\t\t// allow whitespace before closing solidus\n\t\t\tparser.allowWhitespace();\n\t\t\t// self-closing solidus?\n\t\t\tif ( parser.matchString( '/' ) ) {\n\t\t\t\tselfClosing = true;\n\t\t\t}\n\t\t\t// closing angle bracket\n\t\t\tif ( !parser.matchString( '>' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlowerCaseName = element.e.toLowerCase();\n\t\t\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t\t\t// Special case - if we open a script element, further tags should\n\t\t\t\t// be ignored unless they're a closing script element\n\t\t\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {\n\t\t\t\t\tparser.inside = lowerCaseName;\n\t\t\t\t}\n\t\t\t\tchildren = [];\n\t\t\t\twhile ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {\n\t\t\t\t\t// Special case - closing section tag\n\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ( child.t === types.CLOSING_TAG ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchildren.push( child );\n\t\t\t\t}\n\t\t\t\tif ( children.length ) {\n\t\t\t\t\telement.f = children;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser.inside = null;\n\t\t\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\t\t\treturn exclude;\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction canContain( name, remaining ) {\n\t\t\tvar match, disallowed;\n\t\t\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t\t\tdisallowed = disallowedContents[ name ];\n\t\t\tif ( !match || !disallowed ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !~disallowed.indexOf( match[ 1 ].toLowerCase() );\n\t\t}\n\t\treturn __export;\n\t}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );\n\n\t/* parse/utils/trimWhitespace.js */\n\tvar trimWhitespace = function() {\n\n\t\tvar leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n\t\t\ttrailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\t\treturn function( items, leading, trailing ) {\n\t\t\tvar item;\n\t\t\tif ( leading ) {\n\t\t\t\titem = items[ 0 ];\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( leadingWhitespace, '' );\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[ 0 ] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( trailing ) {\n\t\t\t\titem = items[ items.length - 1 ];\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( trailingWhitespace, '' );\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\t/* parse/utils/stripStandalones.js */\n\tvar stripStandalones = function( types ) {\n\n\t\tvar __export;\n\t\tvar leadingLinebreak = /^\\s*\\r?\\n/,\n\t\t\ttrailingLinebreak = /\\r?\\n\\s*$/;\n\t\t__export = function( items ) {\n\t\t\tvar i, current, backOne, backTwo, lastSectionItem;\n\t\t\tfor ( i = 1; i < items.length; i += 1 ) {\n\t\t\t\tcurrent = items[ i ];\n\t\t\t\tbackOne = items[ i - 1 ];\n\t\t\t\tbackTwo = items[ i - 2 ];\n\t\t\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\t\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\t\t\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\t\t\titems[ i - 2 ] = backTwo.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\t// and the leading line break of the second text token\n\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t\t\t// its first item is a linebreak...\n\t\t\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {\n\t\t\t\t\t\titems[ i - 1 ] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\tcurrent.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t\t\t// its last item is a linebreak...\n\t\t\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\t\t\tlastSectionItem = backOne.f[ backOne.f.length - 1 ];\n\t\t\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn items;\n\t\t};\n\n\t\tfunction isString( item ) {\n\t\t\treturn typeof item === 'string';\n\t\t}\n\n\t\tfunction isComment( item ) {\n\t\t\treturn item.t === types.COMMENT || item.t === types.DELIMCHANGE;\n\t\t}\n\n\t\tfunction isSection( item ) {\n\t\t\treturn ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;\n\t\t}\n\t\treturn __export;\n\t}( types );\n\n\t/* utils/escapeRegExp.js */\n\tvar escapeRegExp = function() {\n\n\t\tvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\t\treturn function escapeRegExp( str ) {\n\t\t\treturn str.replace( pattern, '\\\\$&' );\n\t\t};\n\t}();\n\n\t/* parse/_parse.js */\n\tvar parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {\n\n\t\tvar __export;\n\t\tvar StandardParser, parse, contiguousWhitespace = /[ \\t\\f\\r\\n]+/g,\n\t\t\tpreserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,\n\t\t\tleadingWhitespace = /^\\s+/,\n\t\t\ttrailingWhitespace = /\\s+$/;\n\t\tStandardParser = Parser.extend( {\n\t\t\tinit: function( str, options ) {\n\t\t\t\t// config\n\t\t\t\tsetDelimiters( options, this );\n\t\t\t\tthis.sectionDepth = 0;\n\t\t\t\tthis.interpolate = {\n\t\t\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n\t\t\t\t};\n\t\t\t\tif ( options.sanitize === true ) {\n\t\t\t\t\toptions.sanitize = {\n\t\t\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\t\t\teventAttributes: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\t\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\t\t\tthis.includeLinePositions = options.includeLinePositions;\n\t\t\t},\n\t\t\tpostProcess: function( items, options ) {\n\t\t\t\tif ( this.sectionDepth > 0 ) {\n\t\t\t\t\tthis.error( 'A section was left open' );\n\t\t\t\t}\n\t\t\t\tcleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );\n\t\t\t\treturn items;\n\t\t\t},\n\t\t\tconverters: [\n\t\t\t\tmustache,\n\t\t\t\tcomment,\n\t\t\t\telement,\n\t\t\t\ttext\n\t\t\t]\n\t\t} );\n\t\tparse = function( template ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;\n\t\t\tsetDelimiters( options );\n\t\t\tinlinePartialStart = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*>\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\tinlinePartialEnd = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*\\\\/\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\tresult = {\n\t\t\t\tv: 1\n\t\t\t};\n\t\t\tif ( inlinePartialStart.test( template ) ) {\n\t\t\t\tremaining = template;\n\t\t\t\ttemplate = '';\n\t\t\t\twhile ( startMatch = inlinePartialStart.exec( remaining ) ) {\n\t\t\t\t\tname = startMatch[ 1 ];\n\t\t\t\t\ttemplate += remaining.substr( 0, startMatch.index );\n\t\t\t\t\tremaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );\n\t\t\t\t\tendMatch = inlinePartialEnd.exec( remaining );\n\t\t\t\t\tif ( !endMatch || endMatch[ 1 ] !== name ) {\n\t\t\t\t\t\tthrow new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for \"' + name + '\", but ' + ( endMatch ? 'instead found \"' + endMatch[ 1 ] + '\"' : ' no closing found' ) );\n\t\t\t\t\t}\n\t\t\t\t\t( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;\n\t\t\t\t\tremaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );\n\t\t\t\t}\n\t\t\t\ttemplate += remaining;\n\t\t\t\tresult.p = partials;\n\t\t\t}\n\t\t\tresult.t = new StandardParser( template, options ).result;\n\t\t\treturn result;\n\t\t};\n\t\t__export = parse;\n\n\t\tfunction cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {\n\t\t\tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;\n\t\t\t// First pass - remove standalones and comments etc\n\t\t\tstripStandalones( items );\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[ i ];\n\t\t\t\t// Remove delimiter changes, unsafe elements etc\n\t\t\t\tif ( item.exclude ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t} else if ( stripComments && item.t === types.COMMENT ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If necessary, remove leading and trailing whitespace\n\t\t\ttrimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[ i ];\n\t\t\t\t// Recurse\n\t\t\t\tif ( item.f ) {\n\t\t\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\t\t\tnextItem = items[ i + 1 ];\n\t\t\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\t\t\tif ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {\n\t\t\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// and vice versa\n\t\t\t\t\t\tif ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {\n\t\t\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t}\n\t\t\t\t// Split if-else blocks into two (an if, and an unless)\n\t\t\t\tif ( item.l ) {\n\t\t\t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\tif ( rewriteElse ) {\n\t\t\t\t\t\tunlessBlock = {\n\t\t\t\t\t\t\tt: 4,\n\t\t\t\t\t\t\tn: types.SECTION_UNLESS,\n\t\t\t\t\t\t\tf: item.l\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// copy the conditional based on its type\n\t\t\t\t\t\tif ( item.r ) {\n\t\t\t\t\t\t\tunlessBlock.r = item.r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( item.x ) {\n\t\t\t\t\t\t\tunlessBlock.x = item.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( item.rx ) {\n\t\t\t\t\t\t\tunlessBlock.rx = item.rx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.splice( i + 1, 0, unlessBlock );\n\t\t\t\t\t\tdelete item.l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Clean up element attributes\n\t\t\t\tif ( item.a ) {\n\t\t\t\t\tfor ( key in item.a ) {\n\t\t\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// final pass - fuse text nodes together\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( typeof items[ i ] === 'string' ) {\n\t\t\t\t\tif ( typeof items[ i + 1 ] === 'string' ) {\n\t\t\t\t\t\titems[ i ] = items[ i ] + items[ i + 1 ];\n\t\t\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\t\t\titems[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );\n\t\t\t\t\t}\n\t\t\t\t\tif ( items[ i ] === '' ) {\n\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction setDelimiters( source ) {\n\t\t\tvar target = arguments[ 1 ];\n\t\t\tif ( target === void 0 )\n\t\t\t\ttarget = source;\n\t\t\ttarget.delimiters = source.delimiters || [\n\t\t\t\t'{{',\n\t\t\t\t'}}'\n\t\t\t];\n\t\t\ttarget.tripleDelimiters = source.tripleDelimiters || [\n\t\t\t\t'{{{',\n\t\t\t\t'}}}'\n\t\t\t];\n\t\t\ttarget.staticDelimiters = source.staticDelimiters || [\n\t\t\t\t'[[',\n\t\t\t\t']]'\n\t\t\t];\n\t\t\ttarget.staticTripleDelimiters = source.staticTripleDelimiters || [\n\t\t\t\t'[[[',\n\t\t\t\t']]]'\n\t\t\t];\n\t\t}\n\t\treturn __export;\n\t}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );\n\n\t/* config/options/groups/optionGroup.js */\n\tvar optionGroup = function() {\n\n\t\treturn function createOptionGroup( keys, config ) {\n\t\t\tvar group = keys.map( config );\n\t\t\tkeys.forEach( function( key, i ) {\n\t\t\t\tgroup[ key ] = group[ i ];\n\t\t\t} );\n\t\t\treturn group;\n\t\t};\n\t}( legacy );\n\n\t/* config/options/groups/parseOptions.js */\n\tvar parseOptions = function( optionGroup ) {\n\n\t\tvar keys, parseOptions;\n\t\tkeys = [\n\t\t\t'preserveWhitespace',\n\t\t\t'sanitize',\n\t\t\t'stripComments',\n\t\t\t'delimiters',\n\t\t\t'tripleDelimiters',\n\t\t\t'interpolate'\n\t\t];\n\t\tparseOptions = optionGroup( keys, function( key ) {\n\t\t\treturn key;\n\t\t} );\n\t\treturn parseOptions;\n\t}( optionGroup );\n\n\t/* config/options/template/parser.js */\n\tvar parser = function( errors, isClient, parse, create, parseOptions ) {\n\n\t\tvar parser = {\n\t\t\tparse: doParse,\n\t\t\tfromId: fromId,\n\t\t\tisHashedId: isHashedId,\n\t\t\tisParsed: isParsed,\n\t\t\tgetParseOptions: getParseOptions,\n\t\t\tcreateHelper: createHelper\n\t\t};\n\n\t\tfunction createHelper( parseOptions ) {\n\t\t\tvar helper = create( parser );\n\t\t\thelper.parse = function( template, options ) {\n\t\t\t\treturn doParse( template, options || parseOptions );\n\t\t\t};\n\t\t\treturn helper;\n\t\t}\n\n\t\tfunction doParse( template, parseOptions ) {\n\t\t\tif ( !parse ) {\n\t\t\t\tthrow new Error( errors.missingParser );\n\t\t\t}\n\t\t\treturn parse( template, parseOptions || this.options );\n\t\t}\n\n\t\tfunction fromId( id, options ) {\n\t\t\tvar template;\n\t\t\tif ( !isClient ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );\n\t\t\t}\n\t\t\tif ( isHashedId( id ) ) {\n\t\t\t\tid = id.substring( 1 );\n\t\t\t}\n\t\t\tif ( !( template = document.getElementById( id ) ) ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Could not find template element with id #' + id );\n\t\t\t}\n\t\t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Template element with id #' + id + ', must be a <script> element' );\n\t\t\t}\n\t\t\treturn template.innerHTML;\n\t\t}\n\n\t\tfunction isHashedId( id ) {\n\t\t\treturn id && id.charAt( 0 ) === '#';\n\t\t}\n\n\t\tfunction isParsed( template ) {\n\t\t\treturn !( typeof template === 'string' );\n\t\t}\n\n\t\tfunction getParseOptions( ractive ) {\n\t\t\t// Could be Ractive or a Component\n\t\t\tif ( ractive.defaults ) {\n\t\t\t\tractive = ractive.defaults;\n\t\t\t}\n\t\t\treturn parseOptions.reduce( function( val, key ) {\n\t\t\t\tval[ key ] = ractive[ key ];\n\t\t\t\treturn val;\n\t\t\t}, {} );\n\t\t}\n\t\treturn parser;\n\t}( errors, isClient, parse, create, parseOptions );\n\n\t/* config/options/template/template.js */\n\tvar template = function( parser, parse ) {\n\n\t\tvar templateConfig = {\n\t\t\tname: 'template',\n\t\t\textend: function extend( Parent, proto, options ) {\n\t\t\t\tvar template;\n\t\t\t\t// only assign if exists\n\t\t\t\tif ( 'template' in options ) {\n\t\t\t\t\ttemplate = options.template;\n\t\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\t\tproto.template = template;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto.template = parseIfString( template, proto );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinit: function init( Parent, ractive, options ) {\n\t\t\t\tvar template, fn;\n\t\t\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t\t\t// At present that breaks the test mocks' expectations\n\t\t\t\ttemplate = 'template' in options ? options.template : Parent.prototype.template;\n\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\tfn = template;\n\t\t\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\t\t\t\t\tractive._config.template = {\n\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\tresult: template\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\ttemplate = parseIfString( template, ractive );\n\t\t\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t\t\t// it's unnecessary, because the developer never needs to access\n\t\t\t\t// ractive.template\n\t\t\t\tractive.template = template.t;\n\t\t\t\tif ( template.p ) {\n\t\t\t\t\textendPartials( ractive.partials, template.p );\n\t\t\t\t}\n\t\t\t},\n\t\t\treset: function( ractive ) {\n\t\t\t\tvar result = resetValue( ractive ),\n\t\t\t\t\tparsed;\n\t\t\t\tif ( result ) {\n\t\t\t\t\tparsed = parseIfString( result, ractive );\n\t\t\t\t\tractive.template = parsed.t;\n\t\t\t\t\textendPartials( ractive.partials, parsed.p, true );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction resetValue( ractive ) {\n\t\t\tvar initial = ractive._config.template,\n\t\t\t\tresult;\n\t\t\t// If this isn't a dynamic template, there's nothing to do\n\t\t\tif ( !initial || !initial.fn ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = getDynamicTemplate( ractive, initial.fn );\n\t\t\t// TODO deep equality check to prevent unnecessary re-rendering\n\t\t\t// in the case of already-parsed templates\n\t\t\tif ( result !== initial.result ) {\n\t\t\t\tinitial.result = result;\n\t\t\t\tresult = parseIfString( result, ractive );\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfunction getDynamicTemplate( ractive, fn ) {\n\t\t\tvar helper = parser.createHelper( parser.getParseOptions( ractive ) );\n\t\t\treturn fn.call( ractive, ractive.data, helper );\n\t\t}\n\n\t\tfunction parseIfString( template, ractive ) {\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t// ID of an element containing the template?\n\t\t\t\tif ( template[ 0 ] === '#' ) {\n\t\t\t\t\ttemplate = parser.fromId( template );\n\t\t\t\t}\n\t\t\t\ttemplate = parse( template, parser.getParseOptions( ractive ) );\n\t\t\t} else if ( template.v !== 1 ) {\n\t\t\t\tthrow new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );\n\t\t\t}\n\t\t\treturn template;\n\t\t}\n\n\t\tfunction extendPartials( existingPartials, newPartials, overwrite ) {\n\t\t\tif ( !newPartials )\n\t\t\t\treturn;\n\t\t\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t\t\t// case, but not initially...\n\t\t\tfor ( var key in newPartials ) {\n\t\t\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn templateConfig;\n\t}( parser, parse );\n\n\t/* config/options/Registry.js */\n\tvar Registry = function( create ) {\n\n\t\tfunction Registry( name, useDefaults ) {\n\t\t\tthis.name = name;\n\t\t\tthis.useDefaults = useDefaults;\n\t\t}\n\t\tRegistry.prototype = {\n\t\t\tconstructor: Registry,\n\t\t\textend: function( Parent, proto, options ) {\n\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );\n\t\t\t},\n\t\t\tinit: function( Parent, ractive, options ) {\n\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );\n\t\t\t},\n\t\t\tconfigure: function( Parent, target, options ) {\n\t\t\t\tvar name = this.name,\n\t\t\t\t\toption = options[ name ],\n\t\t\t\t\tregistry;\n\t\t\t\tregistry = create( Parent[ name ] );\n\t\t\t\tfor ( var key in option ) {\n\t\t\t\t\tregistry[ key ] = option[ key ];\n\t\t\t\t}\n\t\t\t\ttarget[ name ] = registry;\n\t\t\t},\n\t\t\treset: function( ractive ) {\n\t\t\t\tvar registry = ractive[ this.name ];\n\t\t\t\tvar changed = false;\n\t\t\t\tObject.keys( registry ).forEach( function( key ) {\n\t\t\t\t\tvar item = registry[ key ];\n\t\t\t\t\tif ( item._fn ) {\n\t\t\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\t\t\tregistry[ key ] = item._fn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete registry[ key ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn changed;\n\t\t\t},\n\t\t\tfindOwner: function( ractive, key ) {\n\t\t\t\treturn ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );\n\t\t\t},\n\t\t\tfindConstructor: function( constructor, key ) {\n\t\t\t\tif ( !constructor ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );\n\t\t\t},\n\t\t\tfind: function( ractive, key ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\treturn r[ this$0.name ][ key ];\n\t\t\t\t} );\n\t\t\t},\n\t\t\tfindInstance: function( ractive, key ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\treturn r[ this$0.name ][ key ] ? r : void 0;\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\n\t\tfunction recurseFind( ractive, fn ) {\n\t\t\tvar find, parent;\n\t\t\tif ( find = fn( ractive ) ) {\n\t\t\t\treturn find;\n\t\t\t}\n\t\t\tif ( !ractive.isolated && ( parent = ractive._parent ) ) {\n\t\t\t\treturn recurseFind( parent, fn );\n\t\t\t}\n\t\t}\n\t\treturn Registry;\n\t}( create, legacy );\n\n\t/* config/options/groups/registries.js */\n\tvar registries = function( optionGroup, Registry ) {\n\n\t\tvar keys = [\n\t\t\t\t'adaptors',\n\t\t\t\t'components',\n\t\t\t\t'computed',\n\t\t\t\t'decorators',\n\t\t\t\t'easing',\n\t\t\t\t'events',\n\t\t\t\t'interpolators',\n\t\t\t\t'partials',\n\t\t\t\t'transitions'\n\t\t\t],\n\t\t\tregistries = optionGroup( keys, function( key ) {\n\t\t\t\treturn new Registry( key, key === 'computed' );\n\t\t\t} );\n\t\treturn registries;\n\t}( optionGroup, Registry );\n\n\t/* utils/noop.js */\n\tvar noop = function() {};\n\n\t/* utils/wrapPrototypeMethod.js */\n\tvar wrapPrototypeMethod = function( noop ) {\n\n\t\tvar __export;\n\t\t__export = function wrap( parent, name, method ) {\n\t\t\tif ( !/_super/.test( method ) ) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t\tvar wrapper = function wrapSuper() {\n\t\t\t\tvar superMethod = getSuperMethod( wrapper._parent, name ),\n\t\t\t\t\thasSuper = '_super' in this,\n\t\t\t\t\toldSuper = this._super,\n\t\t\t\t\tresult;\n\t\t\t\tthis._super = superMethod;\n\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\tthis._super = oldSuper;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._super;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\twrapper._parent = parent;\n\t\t\twrapper._method = method;\n\t\t\treturn wrapper;\n\t\t};\n\n\t\tfunction getSuperMethod( parent, name ) {\n\t\t\tvar method;\n\t\t\tif ( name in parent ) {\n\t\t\t\tvar value = parent[ name ];\n\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\tmethod = value;\n\t\t\t\t} else {\n\t\t\t\t\tmethod = function returnValue() {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmethod = noop;\n\t\t\t}\n\t\t\treturn method;\n\t\t}\n\t\treturn __export;\n\t}( noop );\n\n\t/* config/deprecate.js */\n\tvar deprecate = function( warn, isArray ) {\n\n\t\tfunction deprecate( options, deprecated, correct ) {\n\t\t\tif ( deprecated in options ) {\n\t\t\t\tif ( !( correct in options ) ) {\n\t\t\t\t\twarn( getMessage( deprecated, correct ) );\n\t\t\t\t\toptions[ correct ] = options[ deprecated ];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( getMessage( deprecated, correct, true ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getMessage( deprecated, correct, isError ) {\n\t\t\treturn 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );\n\t\t}\n\n\t\tfunction deprecateEventDefinitions( options ) {\n\t\t\tdeprecate( options, 'eventDefinitions', 'events' );\n\t\t}\n\n\t\tfunction deprecateAdaptors( options ) {\n\t\t\t// Using extend with Component instead of options,\n\t\t\t// like Human.extend( Spider ) means adaptors as a registry\n\t\t\t// gets copied to options. So we have to check if actually an array\n\t\t\tif ( isArray( options.adaptors ) ) {\n\t\t\t\tdeprecate( options, 'adaptors', 'adapt' );\n\t\t\t}\n\t\t}\n\t\treturn function deprecateOptions( options ) {\n\t\t\tdeprecate( options, 'beforeInit', 'onconstruct' );\n\t\t\tdeprecate( options, 'init', 'onrender' );\n\t\t\tdeprecate( options, 'complete', 'oncomplete' );\n\t\t\tdeprecateEventDefinitions( options );\n\t\t\tdeprecateAdaptors( options );\n\t\t};\n\t}( warn, isArray );\n\n\t/* config/config.js */\n\tvar config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {\n\n\t\tvar custom, options, config, blacklisted;\n\t\t// would be nice to not have these here,\n\t\t// they get added during initialise, so for now we have\n\t\t// to make sure not to try and extend them.\n\t\t// Possibly, we could re-order and not add till later\n\t\t// in process.\n\t\tblacklisted = {\n\t\t\t'_parent': true,\n\t\t\t'_component': true\n\t\t};\n\t\tcustom = {\n\t\t\tdata: data,\n\t\t\ttemplate: template,\n\t\t\tcss: css\n\t\t};\n\t\toptions = Object.keys( defaults ).filter( function( key ) {\n\t\t\treturn !registries[ key ] && !custom[ key ] && !parseOptions[ key ];\n\t\t} );\n\t\t// this defines the order:\n\t\tconfig = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );\n\t\tfor ( var key in custom ) {\n\t\t\tconfig[ key ] = custom[ key ];\n\t\t}\n\t\t// for iteration\n\t\tconfig.keys = Object.keys( defaults ).concat( registries.map( function( r ) {\n\t\t\treturn r.name;\n\t\t} ) ).concat( [ 'css' ] );\n\t\t// add these to blacklisted key's that we don't double extend\n\t\tconfig.keys.forEach( function( key ) {\n\t\t\treturn blacklisted[ key ] = true;\n\t\t} );\n\t\tconfig.parseOptions = parseOptions;\n\t\tconfig.registries = registries;\n\n\t\tfunction customConfig( method, key, Parent, instance, options ) {\n\t\t\tcustom[ key ][ method ]( Parent, instance, options );\n\t\t}\n\t\tconfig.extend = function( Parent, proto, options ) {\n\t\t\tconfigure( 'extend', Parent, proto, options );\n\t\t};\n\t\tconfig.init = function( Parent, ractive, options ) {\n\t\t\tconfigure( 'init', Parent, ractive, options );\n\t\t};\n\n\t\tfunction isStandardDefaultKey( key ) {\n\t\t\treturn key in defaults && !( key in config.parseOptions ) && !( key in custom );\n\t\t}\n\n\t\tfunction configure( method, Parent, instance, options ) {\n\t\t\tdeprecate( options );\n\t\t\tcustomConfig( method, 'data', Parent, instance, options );\n\t\t\tconfig.parseOptions.forEach( function( key ) {\n\t\t\t\tif ( key in options ) {\n\t\t\t\t\tinstance[ key ] = options[ key ];\n\t\t\t\t}\n\t\t\t} );\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( isStandardDefaultKey( key ) ) {\n\t\t\t\t\tvar value = options[ key ];\n\t\t\t\t\tinstance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfig.registries.forEach( function( registry ) {\n\t\t\t\tregistry[ method ]( Parent, instance, options );\n\t\t\t} );\n\t\t\tcustomConfig( method, 'template', Parent, instance, options );\n\t\t\tcustomConfig( method, 'css', Parent, instance, options );\n\t\t\textendOtherMethods( Parent.prototype, instance, options );\n\t\t}\n\n\t\tfunction extendOtherMethods( parent, instance, options ) {\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar member = options[ key ];\n\t\t\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\t\t\tmember = wrapPrototype( parent, key, member );\n\t\t\t\t\t}\n\t\t\t\t\tinstance[ key ] = member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfig.reset = function( ractive ) {\n\t\t\treturn config.filter( function( c ) {\n\t\t\t\treturn c.reset && c.reset( ractive );\n\t\t\t} ).map( function( c ) {\n\t\t\t\treturn c.name;\n\t\t\t} );\n\t\t};\n\t\tconfig.getConstructTarget = function( ractive, options ) {\n\t\t\tif ( options.onconstruct ) {\n\t\t\t\t// pretend this object literal is the ractive instance\n\t\t\t\treturn {\n\t\t\t\t\tonconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),\n\t\t\t\t\tfire: ractive.fire.bind( ractive )\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn ractive;\n\t\t\t}\n\t\t};\n\t\treturn config;\n\t}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );\n\n\t/* shared/interpolate.js */\n\tvar interpolate = function( circular, warn, interpolators, config ) {\n\n\t\tvar __export;\n\t\tvar interpolate = function( from, to, ractive, type ) {\n\t\t\tif ( from === to ) {\n\t\t\t\treturn snap( to );\n\t\t\t}\n\t\t\tif ( type ) {\n\t\t\t\tvar interpol = config.registries.interpolators.find( ractive, type );\n\t\t\t\tif ( interpol ) {\n\t\t\t\t\treturn interpol( from, to ) || snap( to );\n\t\t\t\t}\n\t\t\t\twarn( 'Missing \"' + type + '\" interpolator. You may need to download a plugin from [TODO]' );\n\t\t\t}\n\t\t\treturn interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );\n\t\t};\n\t\tcircular.interpolate = interpolate;\n\t\t__export = interpolate;\n\n\t\tfunction snap( to ) {\n\t\t\treturn function() {\n\t\t\t\treturn to;\n\t\t\t};\n\t\t}\n\t\treturn __export;\n\t}( circular, warn, interpolators, config );\n\n\t/* Ractive/prototype/animate/Animation.js */\n\tvar Ractive$animate_Animation = function( warn, runloop, interpolate ) {\n\n\t\tvar Animation = function( options ) {\n\t\t\tvar key;\n\t\t\tthis.startTime = Date.now();\n\t\t\t// from and to\n\t\t\tfor ( key in options ) {\n\t\t\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\t\t\tthis[ key ] = options[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\t\t\tthis.running = true;\n\t\t\tthis.tick();\n\t\t};\n\t\tAnimation.prototype = {\n\t\t\ttick: function() {\n\t\t\t\tvar elapsed, t, value, timeNow, index, keypath;\n\t\t\t\tkeypath = this.keypath;\n\t\t\t\tif ( this.running ) {\n\t\t\t\t\ttimeNow = Date.now();\n\t\t\t\t\telapsed = timeNow - this.startTime;\n\t\t\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.complete( this.to );\n\t\t\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t\t\t// TODO investigate why this happens\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t\t\t\tthis.running = false;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tt = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;\n\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\tthis.step( t, value );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tstop: function() {\n\t\t\t\tvar index;\n\t\t\t\tthis.running = false;\n\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t// TODO investigate why this happens\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t}\n\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t}\n\t\t};\n\t\treturn Animation;\n\t}( warn, runloop, interpolate );\n\n\t/* Ractive/prototype/animate.js */\n\tvar Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {\n\n\t\tvar __export;\n\t\tvar noop = function() {},\n\t\t\tnoAnimation = {\n\t\t\t\tstop: noop\n\t\t\t};\n\t\t__export = function Ractive$animate( keypath, to, options ) {\n\t\t\tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\t\t\tpromise = new Promise( function( fulfil ) {\n\t\t\t\tfulfilPromise = fulfil;\n\t\t\t} );\n\t\t\t// animate multiple keypaths\n\t\t\tif ( typeof keypath === 'object' ) {\n\t\t\t\toptions = to || {};\n\t\t\t\teasing = options.easing;\n\t\t\t\tduration = options.duration;\n\t\t\t\tanimations = [];\n\t\t\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t\t\t// our own...\n\t\t\t\tstep = options.step;\n\t\t\t\tcomplete = options.complete;\n\t\t\t\tif ( step || complete ) {\n\t\t\t\t\tcurrentValues = {};\n\t\t\t\t\toptions.step = null;\n\t\t\t\t\toptions.complete = null;\n\t\t\t\t\tmakeValueCollector = function( keypath ) {\n\t\t\t\t\t\treturn function( t, value ) {\n\t\t\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tfor ( k in keypath ) {\n\t\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\t\tif ( step || complete ) {\n\t\t\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\t\t\toptions = {\n\t\t\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\t\t\tduration: duration\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\t\t\tanimations.push( animate( this, k, keypath[ k ], options ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create a dummy animation, to facilitate step/complete\n\t\t\t\t// callbacks, and Promise fulfilment\n\t\t\t\tdummyOptions = {\n\t\t\t\t\teasing: easing,\n\t\t\t\t\tduration: duration\n\t\t\t\t};\n\t\t\t\tif ( step ) {\n\t\t\t\t\tdummyOptions.step = function( t ) {\n\t\t\t\t\t\tstep( t, currentValues );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( complete ) {\n\t\t\t\t\tpromise.then( function( t ) {\n\t\t\t\t\t\tcomplete( t, currentValues );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tdummyOptions.complete = fulfilPromise;\n\t\t\t\tdummy = animate( this, null, null, dummyOptions );\n\t\t\t\tanimations.push( dummy );\n\t\t\t\tpromise.stop = function() {\n\t\t\t\t\tvar animation;\n\t\t\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t}\n\t\t\t\t\tif ( dummy ) {\n\t\t\t\t\t\tdummy.stop();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t\t// animate a single keypath\n\t\t\toptions = options || {};\n\t\t\tif ( options.complete ) {\n\t\t\t\tpromise.then( options.complete );\n\t\t\t}\n\t\t\toptions.complete = fulfilPromise;\n\t\t\tanimation = animate( this, keypath, to, options );\n\t\t\tpromise.stop = function() {\n\t\t\t\tanimation.stop();\n\t\t\t};\n\t\t\treturn promise;\n\t\t};\n\n\t\tfunction animate( root, keypath, to, options ) {\n\t\t\tvar easing, duration, animation, from;\n\t\t\tif ( keypath ) {\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t}\n\t\t\tif ( keypath !== null ) {\n\t\t\t\tfrom = root.viewmodel.get( keypath );\n\t\t\t}\n\t\t\t// cancel any existing animation\n\t\t\t// TODO what about upstream/downstream keypaths?\n\t\t\tanimations.abort( keypath, root );\n\t\t\t// don't bother animating values that stay the same\n\t\t\tif ( isEqual( from, to ) ) {\n\t\t\t\tif ( options.complete ) {\n\t\t\t\t\toptions.complete( options.to );\n\t\t\t\t}\n\t\t\t\treturn noAnimation;\n\t\t\t}\n\t\t\t// easing function\n\t\t\tif ( options.easing ) {\n\t\t\t\tif ( typeof options.easing === 'function' ) {\n\t\t\t\t\teasing = options.easing;\n\t\t\t\t} else {\n\t\t\t\t\teasing = root.easing[ options.easing ];\n\t\t\t\t}\n\t\t\t\tif ( typeof easing !== 'function' ) {\n\t\t\t\t\teasing = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// duration\n\t\t\tduration = options.duration === undefined ? 400 : options.duration;\n\t\t\t// TODO store keys, use an internal set method\n\t\t\tanimation = new Animation( {\n\t\t\t\tkeypath: keypath,\n\t\t\t\tfrom: from,\n\t\t\t\tto: to,\n\t\t\t\troot: root,\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tinterpolator: options.interpolator,\n\t\t\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\t\t\tstep: options.step,\n\t\t\t\tcomplete: options.complete\n\t\t\t} );\n\t\t\tanimations.add( animation );\n\t\t\troot._animations.push( animation );\n\t\t\treturn animation;\n\t\t}\n\t\treturn __export;\n\t}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );\n\n\t/* Ractive/prototype/detach.js */\n\tvar Ractive$detach = function( Hook, removeFromArray ) {\n\n\t\tvar detachHook = new Hook( 'detach' );\n\t\treturn function Ractive$detach() {\n\t\t\tif ( this.detached ) {\n\t\t\t\treturn this.detached;\n\t\t\t}\n\t\t\tif ( this.el ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\t\tthis.detached = this.fragment.detach();\n\t\t\tdetachHook.fire( this );\n\t\t\treturn this.detached;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, removeFromArray );\n\n\t/* Ractive/prototype/find.js */\n\tvar Ractive$find = function Ractive$find( selector ) {\n\t\tif ( !this.el ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.fragment.find( selector );\n\t};\n\n\t/* utils/matches.js */\n\tvar matches = function( isClient, vendors, createElement ) {\n\n\t\tvar matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;\n\t\tif ( !isClient ) {\n\t\t\tmatches = null;\n\t\t} else {\n\t\t\tdiv = createElement( 'div' );\n\t\t\tmethodNames = [\n\t\t\t\t'matches',\n\t\t\t\t'matchesSelector'\n\t\t\t];\n\t\t\tmakeFunction = function( methodName ) {\n\t\t\t\treturn function( node, selector ) {\n\t\t\t\t\treturn node[ methodName ]( selector );\n\t\t\t\t};\n\t\t\t};\n\t\t\ti = methodNames.length;\n\t\t\twhile ( i-- && !matches ) {\n\t\t\t\tunprefixed = methodNames[ i ];\n\t\t\t\tif ( div[ unprefixed ] ) {\n\t\t\t\t\tmatches = makeFunction( unprefixed );\n\t\t\t\t} else {\n\t\t\t\t\tj = vendors.length;\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\tprefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\t\t\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// IE8...\n\t\t\tif ( !matches ) {\n\t\t\t\tmatches = function( node, selector ) {\n\t\t\t\t\tvar nodes, parentNode, i;\n\t\t\t\t\tparentNode = node.parentNode;\n\t\t\t\t\tif ( !parentNode ) {\n\t\t\t\t\t\t// empty dummy <div>\n\t\t\t\t\t\tdiv.innerHTML = '';\n\t\t\t\t\t\tparentNode = div;\n\t\t\t\t\t\tnode = node.cloneNode();\n\t\t\t\t\t\tdiv.appendChild( node );\n\t\t\t\t\t}\n\t\t\t\t\tnodes = parentNode.querySelectorAll( selector );\n\t\t\t\t\ti = nodes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( nodes[ i ] === node ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}( isClient, vendors, createElement );\n\n\t/* Ractive/prototype/shared/makeQuery/test.js */\n\tvar Ractive$shared_makeQuery_test = function( matches ) {\n\n\t\treturn function( item, noDirty ) {\n\t\t\tvar itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );\n\t\t\tif ( itemMatches ) {\n\t\t\t\tthis.push( item.node || item.instance );\n\t\t\t\tif ( !noDirty ) {\n\t\t\t\t\tthis._makeDirty();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* Ractive/prototype/shared/makeQuery/cancel.js */\n\tvar Ractive$shared_makeQuery_cancel = function() {\n\t\tvar liveQueries, selector, index;\n\t\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t\tselector = this.selector;\n\t\tindex = liveQueries.indexOf( selector );\n\t\tif ( index !== -1 ) {\n\t\t\tliveQueries.splice( index, 1 );\n\t\t\tliveQueries[ selector ] = null;\n\t\t}\n\t};\n\n\t/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */\n\tvar Ractive$shared_makeQuery_sortByItemPosition = function() {\n\n\t\tvar __export;\n\t\t__export = function( a, b ) {\n\t\t\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\t\t\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\t\t\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t// remove items from the end of both ancestries as long as they are identical\n\t\t\t// - the final one removed is the closest mutual ancestor\n\t\t\twhile ( oldestA && oldestA === oldestB ) {\n\t\t\t\tancestryA.pop();\n\t\t\t\tancestryB.pop();\n\t\t\t\tmutualAncestor = oldestA;\n\t\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t}\n\t\t\t// now that we have the mutual ancestor, we can find which is earliest\n\t\t\toldestA = oldestA.component || oldestA;\n\t\t\toldestB = oldestB.component || oldestB;\n\t\t\tfragmentA = oldestA.parentFragment;\n\t\t\tfragmentB = oldestB.parentFragment;\n\t\t\t// if both items share a parent fragment, our job is easy\n\t\t\tif ( fragmentA === fragmentB ) {\n\t\t\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\t\t\tindexB = fragmentB.items.indexOf( oldestB );\n\t\t\t\t// if it's the same index, it means one contains the other,\n\t\t\t\t// so we see which has the longest ancestry\n\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\t\t// if mutual ancestor is a section, we first test to see which section\n\t\t\t// fragment comes first\n\t\t\tif ( fragments = mutualAncestor.fragments ) {\n\t\t\t\tindexA = fragments.indexOf( fragmentA );\n\t\t\t\tindexB = fragments.indexOf( fragmentB );\n\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\t\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n\t\t};\n\n\t\tfunction getParent( item ) {\n\t\t\tvar parentFragment;\n\t\t\tif ( parentFragment = item.parentFragment ) {\n\t\t\t\treturn parentFragment.owner;\n\t\t\t}\n\t\t\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\t\t\treturn parentFragment.owner;\n\t\t\t}\n\t\t}\n\n\t\tfunction getAncestry( item ) {\n\t\t\tvar ancestry, ancestor;\n\t\t\tancestry = [ item ];\n\t\t\tancestor = getParent( item );\n\t\t\twhile ( ancestor ) {\n\t\t\t\tancestry.push( ancestor );\n\t\t\t\tancestor = getParent( ancestor );\n\t\t\t}\n\t\t\treturn ancestry;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */\n\tvar Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {\n\n\t\treturn function( node, otherNode ) {\n\t\t\tvar bitmask;\n\t\t\tif ( node.compareDocumentPosition ) {\n\t\t\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\t\t\treturn bitmask & 2 ? 1 : -1;\n\t\t\t}\n\t\t\t// In old IE, we can piggy back on the mechanism for\n\t\t\t// comparing component positions\n\t\t\treturn sortByItemPosition( node, otherNode );\n\t\t};\n\t}( Ractive$shared_makeQuery_sortByItemPosition );\n\n\t/* Ractive/prototype/shared/makeQuery/sort.js */\n\tvar Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {\n\n\t\treturn function() {\n\t\t\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t\t\tthis._dirty = false;\n\t\t};\n\t}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );\n\n\t/* Ractive/prototype/shared/makeQuery/dirty.js */\n\tvar Ractive$shared_makeQuery_dirty = function( runloop ) {\n\n\t\treturn function() {\n\t\t\tvar this$0 = this;\n\t\t\tif ( !this._dirty ) {\n\t\t\t\tthis._dirty = true;\n\t\t\t\t// Once the DOM has been updated, ensure the query\n\t\t\t\t// is correctly ordered\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tthis$0._sort();\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* Ractive/prototype/shared/makeQuery/remove.js */\n\tvar Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {\n\t\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t\tif ( index !== -1 ) {\n\t\t\tthis.splice( index, 1 );\n\t\t}\n\t};\n\n\t/* Ractive/prototype/shared/makeQuery/_makeQuery.js */\n\tvar Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {\n\n\t\treturn function makeQuery( ractive, selector, live, isComponentQuery ) {\n\t\t\tvar query = [];\n\t\t\tdefineProperties( query, {\n\t\t\t\tselector: {\n\t\t\t\t\tvalue: selector\n\t\t\t\t},\n\t\t\t\tlive: {\n\t\t\t\t\tvalue: live\n\t\t\t\t},\n\t\t\t\t_isComponentQuery: {\n\t\t\t\t\tvalue: isComponentQuery\n\t\t\t\t},\n\t\t\t\t_test: {\n\t\t\t\t\tvalue: test\n\t\t\t\t}\n\t\t\t} );\n\t\t\tif ( !live ) {\n\t\t\t\treturn query;\n\t\t\t}\n\t\t\tdefineProperties( query, {\n\t\t\t\tcancel: {\n\t\t\t\t\tvalue: cancel\n\t\t\t\t},\n\t\t\t\t_root: {\n\t\t\t\t\tvalue: ractive\n\t\t\t\t},\n\t\t\t\t_sort: {\n\t\t\t\t\tvalue: sort\n\t\t\t\t},\n\t\t\t\t_makeDirty: {\n\t\t\t\t\tvalue: dirty\n\t\t\t\t},\n\t\t\t\t_remove: {\n\t\t\t\t\tvalue: remove\n\t\t\t\t},\n\t\t\t\t_dirty: {\n\t\t\t\t\tvalue: false,\n\t\t\t\t\twritable: true\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn query;\n\t\t};\n\t}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );\n\n\t/* Ractive/prototype/findAll.js */\n\tvar Ractive$findAll = function( makeQuery ) {\n\n\t\treturn function Ractive$findAll( selector, options ) {\n\t\t\tvar liveQueries, query;\n\t\t\tif ( !this.el ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\toptions = options || {};\n\t\t\tliveQueries = this._liveQueries;\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t}\n\t\t\tquery = makeQuery( this, selector, !!options.live, false );\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\t\tthis.fragment.findAll( selector, query );\n\t\t\treturn query;\n\t\t};\n\t}( Ractive$shared_makeQuery__makeQuery );\n\n\t/* Ractive/prototype/findAllComponents.js */\n\tvar Ractive$findAllComponents = function( makeQuery ) {\n\n\t\treturn function Ractive$findAllComponents( selector, options ) {\n\t\t\tvar liveQueries, query;\n\t\t\toptions = options || {};\n\t\t\tliveQueries = this._liveComponentQueries;\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t}\n\t\t\tquery = makeQuery( this, selector, !!options.live, true );\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t\treturn query;\n\t\t};\n\t}( Ractive$shared_makeQuery__makeQuery );\n\n\t/* Ractive/prototype/findComponent.js */\n\tvar Ractive$findComponent = function Ractive$findComponent( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t};\n\n\t/* utils/getPotentialWildcardMatches.js */\n\tvar getPotentialWildcardMatches = function() {\n\n\t\tvar __export;\n\t\tvar starMaps = {};\n\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t// all the variants of that keypath that include a wildcard in place\n\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t// to see if any pattern observers are downstream of one or more of\n\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tif ( !( starMap = starMaps[ keys.length ] ) ) {\n\t\t\t\tstarMap = getStarMap( keys.length );\n\t\t\t}\n\t\t\tresult = [];\n\t\t\tmapper = function( star, i ) {\n\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t};\n\t\t\ti = starMap.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\twildcardKeypath = starMap[ i ].map( mapper ).join( '.' );\n\t\t\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\t\t\tresult.push( wildcardKeypath );\n\t\t\t\t\tresult[ wildcardKeypath ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\t// This function returns all the possible true/false combinations for\n\t\t// a given number - e.g. for two, the possible combinations are\n\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\tfunction getStarMap( num ) {\n\t\t\tvar ones = '',\n\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\tif ( !starMaps[ num ] ) {\n\t\t\t\tstarMap = [];\n\t\t\t\twhile ( ones.length < num ) {\n\t\t\t\t\tones += 1;\n\t\t\t\t}\n\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\treturn digit === '1';\n\t\t\t\t};\n\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\twhile ( binary.length < num ) {\n\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t}\n\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t}\n\t\t\t\tstarMaps[ num ] = starMap;\n\t\t\t}\n\t\t\treturn starMaps[ num ];\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/fireEvent.js */\n\tvar Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {\n\n\t\tvar __export;\n\t\t__export = function fireEvent( ractive, eventName ) {\n\t\t\tvar options = arguments[ 2 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tif ( !eventName ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !options.event ) {\n\t\t\t\toptions.event = {\n\t\t\t\t\tname: eventName,\n\t\t\t\t\tcontext: ractive.data,\n\t\t\t\t\tkeypath: '',\n\t\t\t\t\t// until event not included as argument default\n\t\t\t\t\t_noArg: true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\toptions.event.name = eventName;\n\t\t\t}\n\t\t\tvar eventNames = getPotentialWildcardMatches( eventName );\n\t\t\tfireEventAs( ractive, eventNames, options.event, options.args, true );\n\t\t};\n\n\t\tfunction fireEventAs( ractive, eventNames, event, args ) {\n\t\t\tvar initialFire = arguments[ 4 ];\n\t\t\tif ( initialFire === void 0 )\n\t\t\t\tinitialFire = false;\n\t\t\tvar subscribers, i, bubble = true;\n\t\t\tif ( event ) {\n\t\t\t\tractive.event = event;\n\t\t\t}\n\t\t\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\t\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\t\t\t\tif ( subscribers ) {\n\t\t\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( event ) {\n\t\t\t\tdelete ractive.event;\n\t\t\t}\n\t\t\tif ( ractive._parent && bubble ) {\n\t\t\t\tif ( initialFire && ractive.component ) {\n\t\t\t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];\n\t\t\t\t\teventNames = getPotentialWildcardMatches( fullName );\n\t\t\t\t\tif ( event ) {\n\t\t\t\t\t\tevent.component = ractive;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfireEventAs( ractive._parent, eventNames, event, args );\n\t\t\t}\n\t\t}\n\n\t\tfunction notifySubscribers( ractive, subscribers, event, args ) {\n\t\t\tvar originalEvent = null,\n\t\t\t\tstopEvent = false;\n\t\t\tif ( event && !event._noArg ) {\n\t\t\t\targs = [ event ].concat( args );\n\t\t\t}\n\t\t\tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\t\t\tif ( subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\t\t\tstopEvent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\t\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\t\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t\t\t}\n\t\t\treturn !stopEvent;\n\t\t}\n\t\treturn __export;\n\t}( getPotentialWildcardMatches );\n\n\t/* Ractive/prototype/fire.js */\n\tvar Ractive$fire = function( fireEvent ) {\n\n\t\treturn function Ractive$fire( eventName ) {\n\t\t\tvar options = {\n\t\t\t\targs: Array.prototype.slice.call( arguments, 1 )\n\t\t\t};\n\t\t\tfireEvent( this, eventName, options );\n\t\t};\n\t}( Ractive$shared_fireEvent );\n\n\t/* Ractive/prototype/get.js */\n\tvar Ractive$get = function( normaliseKeypath, resolveRef ) {\n\n\t\tvar options = {\n\t\t\tcapture: true\n\t\t};\n\t\t// top-level calls should be intercepted\n\t\treturn function Ractive$get( keypath ) {\n\t\t\tvar value;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\tvalue = this.viewmodel.get( keypath, options );\n\t\t\t// Create inter-component binding, if necessary\n\t\t\tif ( value === undefined && this._parent && !this.isolated ) {\n\t\t\t\tif ( resolveRef( this, keypath, this.fragment ) ) {\n\t\t\t\t\t// creates binding as side-effect, if appropriate\n\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t}( normaliseKeypath, resolveRef );\n\n\t/* utils/getElement.js */\n\tvar getElement = function getElement( input ) {\n\t\tvar output;\n\t\tif ( !input || typeof input === 'boolean' ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( typeof window === 'undefined' || !document || !input ) {\n\t\t\treturn null;\n\t\t}\n\t\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t\tif ( input.nodeType ) {\n\t\t\treturn input;\n\t\t}\n\t\t// Get node from string\n\t\tif ( typeof input === 'string' ) {\n\t\t\t// try ID first\n\t\t\toutput = document.getElementById( input );\n\t\t\t// then as selector, if possible\n\t\t\tif ( !output && document.querySelector ) {\n\t\t\t\toutput = document.querySelector( input );\n\t\t\t}\n\t\t\t// did it work?\n\t\t\tif ( output && output.nodeType ) {\n\t\t\t\treturn output;\n\t\t\t}\n\t\t}\n\t\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t\tif ( input[ 0 ] && input[ 0 ].nodeType ) {\n\t\t\treturn input[ 0 ];\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* Ractive/prototype/insert.js */\n\tvar Ractive$insert = function( Hook, getElement ) {\n\n\t\tvar __export;\n\t\tvar insertHook = new Hook( 'insert' );\n\t\t__export = function Ractive$insert( target, anchor ) {\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\t// TODO create, and link to, documentation explaining this\n\t\t\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t\t\t}\n\t\t\ttarget = getElement( target );\n\t\t\tanchor = getElement( anchor ) || null;\n\t\t\tif ( !target ) {\n\t\t\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t\t\t}\n\t\t\ttarget.insertBefore( this.detach(), anchor );\n\t\t\tthis.el = target;\n\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t\t\tthis.detached = null;\n\t\t\tfireInsertHook( this );\n\t\t};\n\n\t\tfunction fireInsertHook( ractive ) {\n\t\t\tinsertHook.fire( ractive );\n\t\t\tractive.findAllComponents( '*' ).forEach( function( child ) {\n\t\t\t\tfireInsertHook( child.instance );\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( Ractive$shared_hooks_Hook, getElement );\n\n\t/* Ractive/prototype/merge.js */\n\tvar Ractive$merge = function( runloop, isArray, normaliseKeypath ) {\n\n\t\treturn function Ractive$merge( keypath, array, options ) {\n\t\t\tvar currentArray, promise;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\tcurrentArray = this.viewmodel.get( keypath );\n\t\t\t// If either the existing value or the new value isn't an\n\t\t\t// array, just do a regular set\n\t\t\tif ( !isArray( currentArray ) || !isArray( array ) ) {\n\t\t\t\treturn this.set( keypath, array, options && options.complete );\n\t\t\t}\n\t\t\t// Manage transitions\n\t\t\tpromise = runloop.start( this, true );\n\t\t\tthis.viewmodel.merge( keypath, currentArray, array, options );\n\t\t\trunloop.end();\n\t\t\t// attach callback as fulfilment handler, if specified\n\t\t\tif ( options && options.complete ) {\n\t\t\t\tpromise.then( options.complete );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( runloop, isArray, normaliseKeypath );\n\n\t/* Ractive/prototype/observe/Observer.js */\n\tvar Ractive$observe_Observer = function( runloop, isEqual ) {\n\n\t\tvar Observer = function( ractive, keypath, callback, options ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.callback = callback;\n\t\t\tthis.defer = options.defer;\n\t\t\t// default to root as context, but allow it to be overridden\n\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t};\n\t\tObserver.prototype = {\n\t\t\tinit: function( immediate ) {\n\t\t\t\tthis.value = this.root.get( this.keypath );\n\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t} else {\n\t\t\t\t\tthis.oldValue = this.value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn this$0.update();\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\t// Prevent infinite loops\n\t\t\t\tif ( this.updating ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath );\n\t\t\t\tthis.oldValue = this.value;\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\t\t};\n\t\treturn Observer;\n\t}( runloop, isEqual );\n\n\t/* shared/getMatchingKeypaths.js */\n\tvar getMatchingKeypaths = function( isArray ) {\n\n\t\treturn function getMatchingKeypaths( ractive, pattern ) {\n\t\t\tvar keys, key, matchingKeypaths;\n\t\t\tkeys = pattern.split( '.' );\n\t\t\tmatchingKeypaths = [ '' ];\n\t\t\twhile ( key = keys.shift() ) {\n\t\t\t\tif ( key === '*' ) {\n\t\t\t\t\t// expand to find all valid child keypaths\n\t\t\t\t\tmatchingKeypaths = matchingKeypaths.reduce( expand, [] );\n\t\t\t\t} else {\n\t\t\t\t\tif ( matchingKeypaths[ 0 ] === '' ) {\n\t\t\t\t\t\t// first key\n\t\t\t\t\t\tmatchingKeypaths[ 0 ] = key;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatchingKeypaths = matchingKeypaths.map( concatenate( key ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matchingKeypaths;\n\n\t\t\tfunction expand( matchingKeypaths, keypath ) {\n\t\t\t\tvar value, key, childKeypath;\n\t\t\t\tvalue = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );\n\t\t\t\tfor ( key in value ) {\n\t\t\t\t\tif ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {\n\t\t\t\t\t\t// for benefit of IE8\n\t\t\t\t\t\tchildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t\tmatchingKeypaths.push( childKeypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn matchingKeypaths;\n\t\t\t}\n\n\t\t\tfunction concatenate( key ) {\n\t\t\t\treturn function( keypath ) {\n\t\t\t\t\treturn keypath ? keypath + '.' + key : key;\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}( isArray );\n\n\t/* Ractive/prototype/observe/getPattern.js */\n\tvar Ractive$observe_getPattern = function( getMatchingKeypaths ) {\n\n\t\treturn function getPattern( ractive, pattern ) {\n\t\t\tvar matchingKeypaths, values;\n\t\t\tmatchingKeypaths = getMatchingKeypaths( ractive, pattern );\n\t\t\tvalues = {};\n\t\t\tmatchingKeypaths.forEach( function( keypath ) {\n\t\t\t\tvalues[ keypath ] = ractive.get( keypath );\n\t\t\t} );\n\t\t\treturn values;\n\t\t};\n\t}( getMatchingKeypaths );\n\n\t/* Ractive/prototype/observe/PatternObserver.js */\n\tvar Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {\n\n\t\tvar PatternObserver, wildcard = /\\*/,\n\t\t\tslice = Array.prototype.slice;\n\t\tPatternObserver = function( ractive, keypath, callback, options ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.callback = callback;\n\t\t\tthis.defer = options.defer;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.regex = new RegExp( '^' + keypath.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\t\t\tthis.values = {};\n\t\t\tif ( this.defer ) {\n\t\t\t\tthis.proxies = [];\n\t\t\t}\n\t\t\t// default to root as context, but allow it to be overridden\n\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t};\n\t\tPatternObserver.prototype = {\n\t\t\tinit: function( immediate ) {\n\t\t\t\tvar values, keypath;\n\t\t\t\tvalues = getPattern( this.root, this.keypath );\n\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.values = values;\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function( keypath ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar values;\n\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\tvalues = getPattern( this.root, keypath );\n\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// special case - array mutation should not trigger `array.*`\n\t\t\t\t// pattern observer with `array.length`\n\t\t\t\tif ( this.root.viewmodel.implicitChanges[ keypath ] ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.getProxy( keypath ).update();\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.reallyUpdate( keypath );\n\t\t\t},\n\t\t\treallyUpdate: function( keypath ) {\n\t\t\t\tvar value, keys, args;\n\t\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\t\t// Prevent infinite loops\n\t\t\t\tif ( this.updating ) {\n\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.updating = true;\n\t\t\t\tif ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {\n\t\t\t\t\tkeys = slice.call( this.regex.exec( keypath ), 1 );\n\t\t\t\t\targs = [\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tthis.values[ keypath ],\n\t\t\t\t\t\tkeypath\n\t\t\t\t\t].concat( keys );\n\t\t\t\t\tthis.callback.apply( this.context, args );\n\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t}\n\t\t\t\tthis.updating = false;\n\t\t\t},\n\t\t\tgetProxy: function( keypath ) {\n\t\t\t\tvar self = this;\n\t\t\t\tif ( !this.proxies[ keypath ] ) {\n\t\t\t\t\tthis.proxies[ keypath ] = {\n\t\t\t\t\t\tupdate: function() {\n\t\t\t\t\t\t\tself.reallyUpdate( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn this.proxies[ keypath ];\n\t\t\t}\n\t\t};\n\t\treturn PatternObserver;\n\t}( runloop, isEqual, Ractive$observe_getPattern );\n\n\t/* Ractive/prototype/observe/getObserverFacade.js */\n\tvar Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {\n\n\t\tvar wildcard = /\\*/,\n\t\t\temptyObject = {};\n\t\treturn function getObserverFacade( ractive, keypath, callback, options ) {\n\t\t\tvar observer, isPatternObserver, cancelled;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\toptions = options || emptyObject;\n\t\t\t// pattern observers are treated differently\n\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\t\t\tractive.viewmodel.patternObservers.push( observer );\n\t\t\t\tisPatternObserver = true;\n\t\t\t} else {\n\t\t\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t\t\t}\n\t\t\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\t\t\tobserver.init( options.init );\n\t\t\t// This flag allows observers to initialise even with undefined values\n\t\t\tobserver.ready = true;\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\tvar index;\n\t\t\t\t\tif ( cancelled ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( isPatternObserver ) {\n\t\t\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\t\t\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t\t\t}\n\t\t\t\t\tcancelled = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );\n\n\t/* Ractive/prototype/observe.js */\n\tvar Ractive$observe = function( isObject, getObserverFacade ) {\n\n\t\treturn function Ractive$observe( keypath, callback, options ) {\n\t\t\tvar observers, map, keypaths, i;\n\t\t\t// Allow a map of keypaths to handlers\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\toptions = callback;\n\t\t\t\tmap = keypath;\n\t\t\t\tobservers = [];\n\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\tcallback = map[ keypath ];\n\t\t\t\t\t\tobservers.push( this.observe( keypath, callback, options ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Allow `ractive.observe( callback )` - i.e. observe entire model\n\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\toptions = callback;\n\t\t\t\tcallback = keypath;\n\t\t\t\tkeypath = '';\n\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t}\n\t\t\tkeypaths = keypath.split( ' ' );\n\t\t\t// Single keypath\n\t\t\tif ( keypaths.length === 1 ) {\n\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t}\n\t\t\t// Multiple space-separated keypaths\n\t\t\tobservers = [];\n\t\t\ti = keypaths.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tkeypath = keypaths[ i ];\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\tobservers.push( getObserverFacade( this, keypath, callback, options ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( isObject, Ractive$observe_getObserverFacade );\n\n\t/* Ractive/prototype/shared/trim.js */\n\tvar Ractive$shared_trim = function( str ) {\n\t\treturn str.trim();\n\t};\n\n\t/* Ractive/prototype/shared/notEmptyString.js */\n\tvar Ractive$shared_notEmptyString = function( str ) {\n\t\treturn str !== '';\n\t};\n\n\t/* Ractive/prototype/off.js */\n\tvar Ractive$off = function( trim, notEmptyString ) {\n\n\t\treturn function Ractive$off( eventName, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar eventNames;\n\t\t\t// if no arguments specified, remove all callbacks\n\t\t\tif ( !eventName ) {\n\t\t\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\t\t\tfor ( eventName in this._subs ) {\n\t\t\t\t\tdelete this._subs[ eventName ];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle multiple space-separated event names\n\t\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t\tvar subscribers, index;\n\t\t\t\t\t// If we have subscribers for this event...\n\t\t\t\t\tif ( subscribers = this$0._subs[ eventName ] ) {\n\t\t\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tindex = subscribers.indexOf( callback );\n\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis$0._subs[ eventName ] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\n\t/* Ractive/prototype/on.js */\n\tvar Ractive$on = function( trim, notEmptyString ) {\n\n\t\treturn function Ractive$on( eventName, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar self = this,\n\t\t\t\tlisteners, n, eventNames;\n\t\t\t// allow mutliple listeners to be bound in one go\n\t\t\tif ( typeof eventName === 'object' ) {\n\t\t\t\tlisteners = [];\n\t\t\t\tfor ( n in eventName ) {\n\t\t\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\tvar listener;\n\t\t\t\t\t\twhile ( listener = listeners.pop() ) {\n\t\t\t\t\t\t\tlistener.cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Handle multiple space-separated event names\n\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );\n\t\t\t} );\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\n\t/* shared/getNewIndices.js */\n\tvar getNewIndices = function() {\n\n\t\tvar __export;\n\t\t// This function takes an array, the name of a mutator method, and the\n\t\t// arguments to call that mutator method with, and returns an array that\n\t\t// maps the old indices to their new indices.\n\t\t// So if you had something like this...\n\t\t//\n\t\t//     array = [ 'a', 'b', 'c', 'd' ];\n\t\t//     array.push( 'e' );\n\t\t//\n\t\t// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t\t// have changed. If you then did this...\n\t\t//\n\t\t//     array.unshift( 'z' );\n\t\t//\n\t\t// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t\t// one higher to make room for the 'z'. If you removed an item, the new index\n\t\t// would be -1...\n\t\t//\n\t\t//     array.splice( 2, 2 );\n\t\t//\n\t\t// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t\t//\n\t\t// This information is used to enable fast, non-destructive shuffling of list\n\t\t// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\t\t__export = function getNewIndices( array, methodName, args ) {\n\t\t\tvar spliceArguments, len, newIndices = [],\n\t\t\t\tremoveStart, removeEnd, balance, i;\n\t\t\tspliceArguments = getSpliceEquivalent( array, methodName, args );\n\t\t\tif ( !spliceArguments ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlen = array.length;\n\t\t\tbalance = spliceArguments.length - 2 - spliceArguments[ 1 ];\n\t\t\tremoveStart = Math.min( len, spliceArguments[ 0 ] );\n\t\t\tremoveEnd = removeStart + spliceArguments[ 1 ];\n\t\t\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\t\t\tnewIndices.push( i );\n\t\t\t}\n\t\t\tfor ( ; i < removeEnd; i += 1 ) {\n\t\t\t\tnewIndices.push( -1 );\n\t\t\t}\n\t\t\tfor ( ; i < len; i += 1 ) {\n\t\t\t\tnewIndices.push( i + balance );\n\t\t\t}\n\t\t\treturn newIndices;\n\t\t};\n\t\t// The pop, push, shift an unshift methods can all be represented\n\t\t// as an equivalent splice\n\t\tfunction getSpliceEquivalent( array, methodName, args ) {\n\t\t\tswitch ( methodName ) {\n\t\t\t\tcase 'splice':\n\t\t\t\t\tif ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {\n\t\t\t\t\t\targs[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );\n\t\t\t\t\t}\n\t\t\t\t\twhile ( args.length < 2 ) {\n\t\t\t\t\t\targs.push( 0 );\n\t\t\t\t\t}\n\t\t\t\t\t// ensure we only remove elements that exist\n\t\t\t\t\targs[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );\n\t\t\t\t\treturn args;\n\t\t\t\tcase 'sort':\n\t\t\t\tcase 'reverse':\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'pop':\n\t\t\t\t\tif ( array.length ) {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tarray.length - 1,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'push':\n\t\t\t\t\treturn [\n\t\t\t\t\t\tarray.length,\n\t\t\t\t\t\t0\n\t\t\t\t\t].concat( args );\n\t\t\t\tcase 'shift':\n\t\t\t\t\treturn [\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t1\n\t\t\t\t\t];\n\t\t\t\tcase 'unshift':\n\t\t\t\t\treturn [\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t].concat( args );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/makeArrayMethod.js */\n\tvar Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {\n\n\t\tvar arrayProto = Array.prototype;\n\t\treturn function( methodName ) {\n\t\t\treturn function( keypath ) {\n\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\tvar args = SLICE$0.call( arguments, 1 );\n\t\t\t\tvar array, newIndices = [],\n\t\t\t\t\tlen, promise, result;\n\t\t\t\tarray = this.get( keypath );\n\t\t\t\tlen = array.length;\n\t\t\t\tif ( !isArray( array ) ) {\n\t\t\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath + '\\'), but \\'' + keypath + '\\' does not refer to an array' );\n\t\t\t\t}\n\t\t\t\tnewIndices = getNewIndices( array, methodName, args );\n\t\t\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\t\t\tpromise = runloop.start( this, true ).then( function() {\n\t\t\t\t\treturn result;\n\t\t\t\t} );\n\t\t\t\tif ( !!newIndices ) {\n\t\t\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.mark( keypath );\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t};\n\t}( isArray, runloop, getNewIndices );\n\n\t/* Ractive/prototype/pop.js */\n\tvar Ractive$pop = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'pop' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/push.js */\n\tvar Ractive$push = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'push' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* global/css.js */\n\tvar global_css = function( circular, isClient, removeFromArray ) {\n\n\t\tvar css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\\n',\n\t\t\tcomponentsInPage = {},\n\t\t\tstyles = [];\n\t\tif ( !isClient ) {\n\t\t\tcss = null;\n\t\t} else {\n\t\t\tcircular.push( function() {\n\t\t\t\trunloop = circular.runloop;\n\t\t\t} );\n\t\t\tstyleElement = document.createElement( 'style' );\n\t\t\tstyleElement.type = 'text/css';\n\t\t\thead = document.getElementsByTagName( 'head' )[ 0 ];\n\t\t\tinDom = false;\n\t\t\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t\t\t// use styleSheet.cssText instead\n\t\t\tstyleSheet = styleElement.styleSheet;\n\t\t\tupdate = function() {\n\t\t\t\tvar css;\n\t\t\t\tif ( styles.length ) {\n\t\t\t\t\tcss = prefix + styles.join( ' ' );\n\t\t\t\t\tif ( styleSheet ) {\n\t\t\t\t\t\tstyleSheet.cssText = css;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyleElement.innerHTML = css;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !inDom ) {\n\t\t\t\t\t\thead.appendChild( styleElement );\n\t\t\t\t\t\tinDom = true;\n\t\t\t\t\t}\n\t\t\t\t} else if ( inDom ) {\n\t\t\t\t\thead.removeChild( styleElement );\n\t\t\t\t\tinDom = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\tcss = {\n\t\t\t\tadd: function( Component ) {\n\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\t// we create this counter so that we can in/decrement it as\n\t\t\t\t\t\t// instances are added and removed. When all components are\n\t\t\t\t\t\t// removed, the style is too\n\t\t\t\t\t\tcomponentsInPage[ Component._guid ] = 0;\n\t\t\t\t\t\tstyles.push( Component.css );\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t\tcomponentsInPage[ Component._guid ] += 1;\n\t\t\t\t},\n\t\t\t\tremove: function( Component ) {\n\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcomponentsInPage[ Component._guid ] -= 1;\n\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\tremoveFromArray( styles, Component.css );\n\t\t\t\t\t\trunloop.scheduleTask( update );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn css;\n\t}( circular, isClient, removeFromArray );\n\n\t/* Ractive/prototype/render.js */\n\tvar Ractive$render = function( css, Hook, getElement, runloop ) {\n\n\t\tvar renderHook = new Hook( 'render' ),\n\t\t\tcompleteHook = new Hook( 'complete' );\n\t\treturn function Ractive$render( target, anchor ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar promise, instances, transitionsEnabled;\n\t\t\t// if `noIntro` is `true`, temporarily disable transitions\n\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\tif ( this.noIntro ) {\n\t\t\t\tthis.transitionsEnabled = false;\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\trunloop.scheduleTask( function() {\n\t\t\t\treturn renderHook.fire( this$0 );\n\t\t\t}, true );\n\t\t\tif ( this.fragment.rendered ) {\n\t\t\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t\t\t}\n\t\t\ttarget = getElement( target ) || this.el;\n\t\t\tanchor = getElement( anchor ) || this.anchor;\n\t\t\tthis.el = target;\n\t\t\tthis.anchor = anchor;\n\t\t\t// Add CSS, if applicable\n\t\t\tif ( this.constructor.css ) {\n\t\t\t\tcss.add( this.constructor );\n\t\t\t}\n\t\t\tif ( target ) {\n\t\t\t\tif ( !( instances = target.__ractive_instances__ ) ) {\n\t\t\t\t\ttarget.__ractive_instances__ = [ this ];\n\t\t\t\t} else {\n\t\t\t\t\tinstances.push( this );\n\t\t\t\t}\n\t\t\t\tif ( anchor ) {\n\t\t\t\t\ttarget.insertBefore( this.fragment.render(), anchor );\n\t\t\t\t} else {\n\t\t\t\t\ttarget.appendChild( this.fragment.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t\trunloop.end();\n\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t\t// It is now more problematic to know if the complete hook\n\t\t\t// would fire. Method checking is straight-forward, but would\n\t\t\t// also require preflighting event subscriptions. Which seems\n\t\t\t// like more work then just letting the promise happen.\n\t\t\t// But perhaps I'm wrong about that...\n\t\t\tpromise.then( function() {\n\t\t\t\treturn completeHook.fire( this$0 );\n\t\t\t} );\n\t\t\treturn promise;\n\t\t};\n\t}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );\n\n\t/* virtualdom/Fragment/prototype/bubble.js */\n\tvar virtualdom_Fragment$bubble = function Fragment$bubble() {\n\t\tthis.dirtyValue = this.dirtyArgs = true;\n\t\tif ( this.bound && typeof this.owner.bubble === 'function' ) {\n\t\t\tthis.owner.bubble();\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/detach.js */\n\tvar virtualdom_Fragment$detach = function Fragment$detach() {\n\t\tvar docFrag;\n\t\tif ( this.items.length === 1 ) {\n\t\t\treturn this.items[ 0 ].detach();\n\t\t}\n\t\tdocFrag = document.createDocumentFragment();\n\t\tthis.items.forEach( function( item ) {\n\t\t\tvar node = item.detach();\n\t\t\t// TODO The if {...} wasn't previously required - it is now, because we're\n\t\t\t// forcibly detaching everything to reorder sections after an update. That's\n\t\t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n\t\t\t// - as soon as it's replaced with something more elegant, this should\n\t\t\t// revert to `docFrag.appendChild( item.detach() )`\n\t\t\tif ( node ) {\n\t\t\t\tdocFrag.appendChild( node );\n\t\t\t}\n\t\t} );\n\t\treturn docFrag;\n\t};\n\n\t/* virtualdom/Fragment/prototype/find.js */\n\tvar virtualdom_Fragment$find = function Fragment$find( selector ) {\n\t\tvar i, len, item, queryResult;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.find && ( queryResult = item.find( selector ) ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/findAll.js */\n\tvar virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {\n\t\tvar i, len, item;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findAll ) {\n\t\t\t\t\titem.findAll( selector, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn query;\n\t};\n\n\t/* virtualdom/Fragment/prototype/findAllComponents.js */\n\tvar virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {\n\t\tvar i, len, item;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findAllComponents ) {\n\t\t\t\t\titem.findAllComponents( selector, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn query;\n\t};\n\n\t/* virtualdom/Fragment/prototype/findComponent.js */\n\tvar virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {\n\t\tvar len, i, item, queryResult;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/findNextNode.js */\n\tvar virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {\n\t\tvar index = item.index,\n\t\t\tnode;\n\t\tif ( this.items[ index + 1 ] ) {\n\t\t\tnode = this.items[ index + 1 ].firstNode();\n\t\t} else if ( this.owner === this.root ) {\n\t\t\tif ( !this.owner.component ) {\n\t\t\t\t// TODO but something else could have been appended to\n\t\t\t\t// this.root.el, no?\n\t\t\t\tnode = null;\n\t\t\t} else {\n\t\t\t\tnode = this.owner.component.findNextNode();\n\t\t\t}\n\t\t} else {\n\t\t\tnode = this.owner.findNextNode( this );\n\t\t}\n\t\treturn node;\n\t};\n\n\t/* virtualdom/Fragment/prototype/firstNode.js */\n\tvar virtualdom_Fragment$firstNode = function Fragment$firstNode() {\n\t\tif ( this.items && this.items[ 0 ] ) {\n\t\t\treturn this.items[ 0 ].firstNode();\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/Fragment/prototype/getNode.js */\n\tvar virtualdom_Fragment$getNode = function Fragment$getNode() {\n\t\tvar fragment = this;\n\t\tdo {\n\t\t\tif ( fragment.pElement ) {\n\t\t\t\treturn fragment.pElement.node;\n\t\t\t}\n\t\t} while ( fragment = fragment.parent );\n\t\treturn this.root.detached || this.root.el;\n\t};\n\n\t/* virtualdom/Fragment/prototype/getValue.js */\n\tvar virtualdom_Fragment$getValue = function( parseJSON ) {\n\n\t\tvar __export;\n\t\tvar empty = {};\n\t\t__export = function Fragment$getValue() {\n\t\t\tvar options = arguments[ 0 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = empty;\n\t\t\tvar asArgs, values, source, parsed, cachedResult, dirtyFlag, result;\n\t\t\tasArgs = options.args;\n\t\t\tcachedResult = asArgs ? 'argsList' : 'value';\n\t\t\tdirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';\n\t\t\tif ( this[ dirtyFlag ] ) {\n\t\t\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\t\t\tparsed = parseJSON( asArgs ? '[' + source + ']' : source, values );\n\t\t\t\tif ( !parsed ) {\n\t\t\t\t\tresult = asArgs ? [ this.toString() ] : this.toString();\n\t\t\t\t} else {\n\t\t\t\t\tresult = parsed.value;\n\t\t\t\t}\n\t\t\t\tthis[ cachedResult ] = result;\n\t\t\t\tthis[ dirtyFlag ] = false;\n\t\t\t}\n\t\t\treturn this[ cachedResult ];\n\t\t};\n\n\t\tfunction processItems( items, values, guid, counter ) {\n\t\t\tcounter = counter || 0;\n\t\t\treturn items.map( function( item ) {\n\t\t\t\tvar placeholderId, wrapped, value;\n\t\t\t\tif ( item.text ) {\n\t\t\t\t\treturn item.text;\n\t\t\t\t}\n\t\t\t\tif ( item.fragments ) {\n\t\t\t\t\treturn item.fragments.map( function( fragment ) {\n\t\t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t\t\t} ).join( '' );\n\t\t\t\t}\n\t\t\t\tplaceholderId = guid + '-' + counter++;\n\t\t\t\tif ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {\n\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = item.getValue();\n\t\t\t\t}\n\t\t\t\tvalues[ placeholderId ] = value;\n\t\t\t\treturn '${' + placeholderId + '}';\n\t\t\t} ).join( '' );\n\t\t}\n\t\treturn __export;\n\t}( parseJSON );\n\n\t/* utils/escapeHtml.js */\n\tvar escapeHtml = function() {\n\n\t\tvar lessThan = /</g;\n\t\tvar greaterThan = />/g;\n\t\tvar amp = /&/g;\n\t\treturn function escapeHtml( str ) {\n\t\t\treturn str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );\n\t\t};\n\t}();\n\n\t/* utils/detachNode.js */\n\tvar detachNode = function detachNode( node ) {\n\t\tif ( node && node.parentNode ) {\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t\treturn node;\n\t};\n\n\t/* virtualdom/items/shared/detach.js */\n\tvar detach = function( detachNode ) {\n\n\t\treturn function() {\n\t\t\treturn detachNode( this.node );\n\t\t};\n\t}( detachNode );\n\n\t/* virtualdom/items/Text.js */\n\tvar Text = function( types, escapeHtml, detach ) {\n\n\t\tvar Text = function( options ) {\n\t\t\tthis.type = types.TEXT;\n\t\t\tthis.text = options.template;\n\t\t};\n\t\tText.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createTextNode( this.text );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function( escape ) {\n\t\t\t\treturn escape ? escapeHtml( this.text ) : this.text;\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\treturn this.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Text;\n\t}( types, escapeHtml, detach );\n\n\t/* virtualdom/items/shared/unbind.js */\n\tvar unbind = function unbind() {\n\t\tif ( this.registered ) {\n\t\t\t// this was registered as a dependant\n\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t}\n\t\tif ( this.resolver ) {\n\t\t\tthis.resolver.unbind();\n\t\t}\n\t};\n\n\t/* virtualdom/items/shared/Mustache/getValue.js */\n\tvar getValue = function Mustache$getValue() {\n\t\treturn this.value;\n\t};\n\n\t/* virtualdom/items/shared/utils/startsWithKeypath.js */\n\tvar startsWithKeypath = function startsWithKeypath( target, keypath ) {\n\t\treturn target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';\n\t};\n\n\t/* virtualdom/items/shared/utils/getNewKeypath.js */\n\tvar getNewKeypath = function( startsWithKeypath ) {\n\n\t\treturn function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {\n\t\t\t// exact match\n\t\t\tif ( targetKeypath === oldKeypath ) {\n\t\t\t\treturn newKeypath !== undefined ? newKeypath : null;\n\t\t\t}\n\t\t\t// partial match based on leading keypath segments\n\t\t\tif ( startsWithKeypath( targetKeypath, oldKeypath ) ) {\n\t\t\t\treturn newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );\n\t\t\t}\n\t\t};\n\t}( startsWithKeypath );\n\n\t/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */\n\tvar ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {\n\n\t\tvar ReferenceResolver = function( owner, ref, callback ) {\n\t\t\tvar keypath;\n\t\t\tthis.ref = ref;\n\t\t\tthis.resolved = false;\n\t\t\tthis.root = owner.root;\n\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\tthis.callback = callback;\n\t\t\tkeypath = resolveRef( owner.root, ref, owner.parentFragment );\n\t\t\tif ( keypath !== undefined ) {\n\t\t\t\tthis.resolve( keypath );\n\t\t\t} else {\n\t\t\t\trunloop.addUnresolved( this );\n\t\t\t}\n\t\t};\n\t\tReferenceResolver.prototype = {\n\t\t\tresolve: function( keypath ) {\n\t\t\t\tthis.resolved = true;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.callback( keypath );\n\t\t\t},\n\t\t\tforceResolution: function() {\n\t\t\t\tthis.resolve( this.ref );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar keypath;\n\t\t\t\tif ( this.keypath !== undefined ) {\n\t\t\t\t\tkeypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );\n\t\t\t\t\t// was a new keypath created?\n\t\t\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t\t\t// resolve it\n\t\t\t\t\t\tthis.resolve( keypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tif ( !this.resolved ) {\n\t\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn ReferenceResolver;\n\t}( runloop, resolveRef, getNewKeypath );\n\n\t/* virtualdom/items/shared/Resolvers/SpecialResolver.js */\n\tvar SpecialResolver = function() {\n\n\t\tvar SpecialResolver = function( owner, ref, callback ) {\n\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\tthis.ref = ref;\n\t\t\tthis.callback = callback;\n\t\t\tthis.rebind();\n\t\t};\n\t\tSpecialResolver.prototype = {\n\t\t\trebind: function() {\n\t\t\t\tvar ref = this.ref,\n\t\t\t\t\tfragment = this.parentFragment;\n\t\t\t\tif ( ref === '@keypath' ) {\n\t\t\t\t\twhile ( fragment ) {\n\t\t\t\t\t\tif ( !!fragment.context ) {\n\t\t\t\t\t\t\treturn this.callback( '@' + fragment.context );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( ref === '@index' || ref === '@key' ) {\n\t\t\t\t\twhile ( fragment ) {\n\t\t\t\t\t\tif ( fragment.index !== undefined ) {\n\t\t\t\t\t\t\treturn this.callback( '@' + fragment.index );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Unknown special reference \"' + ref + '\" - valid references are @index, @key and @keypath' );\n\t\t\t},\n\t\t\tunbind: function() {}\n\t\t};\n\t\treturn SpecialResolver;\n\t}();\n\n\t/* virtualdom/items/shared/Resolvers/IndexResolver.js */\n\tvar IndexResolver = function() {\n\n\t\tvar IndexResolver = function( owner, ref, callback ) {\n\t\t\tthis.parentFragment = owner.parentFragment;\n\t\t\tthis.ref = ref;\n\t\t\tthis.callback = callback;\n\t\t\tthis.rebind();\n\t\t};\n\t\tIndexResolver.prototype = {\n\t\t\trebind: function() {\n\t\t\t\tvar ref = this.ref,\n\t\t\t\t\tindexRefs = this.parentFragment.indexRefs,\n\t\t\t\t\tindex = indexRefs[ ref ];\n\t\t\t\tif ( index !== undefined ) {\n\t\t\t\t\tthis.callback( '@' + index );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {}\n\t\t};\n\t\treturn IndexResolver;\n\t}();\n\n\t/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */\n\tvar createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {\n\n\t\treturn function createReferenceResolver( owner, ref, callback ) {\n\t\t\tvar indexRefs, index;\n\t\t\tif ( ref.charAt( 0 ) === '@' ) {\n\t\t\t\treturn new SpecialResolver( owner, ref, callback );\n\t\t\t}\n\t\t\tindexRefs = owner.parentFragment.indexRefs;\n\t\t\tif ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\treturn new IndexResolver( owner, ref, callback );\n\t\t\t}\n\t\t\treturn new ReferenceResolver( owner, ref, callback );\n\t\t};\n\t}( ReferenceResolver, SpecialResolver, IndexResolver );\n\n\t/* shared/getFunctionFromString.js */\n\tvar getFunctionFromString = function() {\n\n\t\tvar cache = {};\n\t\treturn function getFunctionFromString( str, i ) {\n\t\t\tvar fn, args;\n\t\t\tif ( cache[ str ] ) {\n\t\t\t\treturn cache[ str ];\n\t\t\t}\n\t\t\targs = [];\n\t\t\twhile ( i-- ) {\n\t\t\t\targs[ i ] = '_' + i;\n\t\t\t}\n\t\t\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\t\t\tcache[ str ] = fn;\n\t\t\treturn fn;\n\t\t};\n\t}();\n\n\t/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */\n\tvar ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {\n\n\t\tvar __export;\n\t\tvar ExpressionResolver, bind = Function.prototype.bind;\n\t\tExpressionResolver = function( owner, parentFragment, expression, callback ) {\n\t\t\tvar resolver = this,\n\t\t\t\tractive, indexRefs;\n\t\t\tractive = owner.root;\n\t\t\tresolver.root = ractive;\n\t\t\tresolver.parentFragment = parentFragment;\n\t\t\tresolver.callback = callback;\n\t\t\tresolver.owner = owner;\n\t\t\tresolver.str = expression.s;\n\t\t\tresolver.keypaths = [];\n\t\t\tindexRefs = parentFragment.indexRefs;\n\t\t\t// Create resolvers for each reference\n\t\t\tresolver.pending = expression.r.length;\n\t\t\tresolver.refResolvers = expression.r.map( function( ref, i ) {\n\t\t\t\treturn createReferenceResolver( resolver, ref, function( keypath ) {\n\t\t\t\t\tresolver.resolve( i, keypath );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tresolver.ready = true;\n\t\t\tresolver.bubble();\n\t\t};\n\t\tExpressionResolver.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.ready ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.uniqueString = getUniqueString( this.str, this.keypaths );\n\t\t\t\tthis.keypath = getKeypath( this.uniqueString );\n\t\t\t\tthis.createEvaluator();\n\t\t\t\tthis.callback( this.keypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tvar resolver;\n\t\t\t\twhile ( resolver = this.refResolvers.pop() ) {\n\t\t\t\t\tresolver.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tresolve: function( index, keypath ) {\n\t\t\t\tthis.keypaths[ index ] = keypath;\n\t\t\t\tthis.bubble();\n\t\t\t},\n\t\t\tcreateEvaluator: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar self = this,\n\t\t\t\t\tcomputation, valueGetters, signature, keypath, fn;\n\t\t\t\tcomputation = this.root.viewmodel.computations[ this.keypath ];\n\t\t\t\t// only if it doesn't exist yet!\n\t\t\t\tif ( !computation ) {\n\t\t\t\t\tfn = getFunctionFromString( this.str, this.refResolvers.length );\n\t\t\t\t\tvalueGetters = this.keypaths.map( function( keypath ) {\n\t\t\t\t\t\tvar value;\n\t\t\t\t\t\tif ( keypath === 'undefined' ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 'special' keypaths encode a value\n\t\t\t\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\t\t\treturn isNumeric( value ) ? function() {\n\t\t\t\t\t\t\t\treturn +value;\n\t\t\t\t\t\t\t} : function() {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar value = this$0.root.viewmodel.get( keypath );\n\t\t\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\t\t\tvalue = wrapFunction( value, self.root );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t};\n\t\t\t\t\t} );\n\t\t\t\t\tsignature = {\n\t\t\t\t\t\tdeps: this.keypaths.filter( isValidDependency ),\n\t\t\t\t\t\tget: function() {\n\t\t\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tcomputation = this.root.viewmodel.compute( this.keypath, signature );\n\t\t\t\t} else {\n\t\t\t\t\tthis.root.viewmodel.mark( this.keypath );\n\t\t\t\t}\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\t// TODO only bubble once, no matter how many references are affected by the rebind\n\t\t\t\tthis.refResolvers.forEach( function( r ) {\n\t\t\t\t\treturn r.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\t__export = ExpressionResolver;\n\n\t\tfunction call( value ) {\n\t\t\treturn value.call();\n\t\t}\n\n\t\tfunction getUniqueString( str, keypaths ) {\n\t\t\t// get string that is unique to this expression\n\t\t\treturn str.replace( /_([0-9]+)/g, function( match, $1 ) {\n\t\t\t\tvar keypath, value;\n\t\t\t\tkeypath = keypaths[ $1 ];\n\t\t\t\tif ( keypath === undefined ) {\n\t\t\t\t\treturn 'undefined';\n\t\t\t\t}\n\t\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\t\treturn isNumeric( value ) ? value : '\"' + value + '\"';\n\t\t\t\t}\n\t\t\t\treturn keypath;\n\t\t\t} );\n\t\t}\n\n\t\tfunction getKeypath( uniqueString ) {\n\t\t\t// Sanitize by removing any periods or square brackets. Otherwise\n\t\t\t// we can't split the keypath into keys!\n\t\t\treturn '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ) + '}';\n\t\t}\n\n\t\tfunction isValidDependency( keypath ) {\n\t\t\treturn keypath !== undefined && keypath[ 0 ] !== '@';\n\t\t}\n\n\t\tfunction wrapFunction( fn, ractive ) {\n\t\t\tvar wrapped, prop, key;\n\t\t\tif ( fn._noWrap ) {\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t\tprop = '__ractive_' + ractive._guid;\n\t\t\twrapped = fn[ prop ];\n\t\t\tif ( wrapped ) {\n\t\t\t\treturn wrapped;\n\t\t\t} else if ( /this/.test( fn.toString() ) ) {\n\t\t\t\tdefineProperty( fn, prop, {\n\t\t\t\t\tvalue: bind.call( fn, ractive )\n\t\t\t\t} );\n\t\t\t\t// Add properties/methods to wrapped function\n\t\t\t\tfor ( key in fn ) {\n\t\t\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fn[ prop ];\n\t\t\t}\n\t\t\tdefineProperty( fn, '__ractive_nowrap', {\n\t\t\t\tvalue: fn\n\t\t\t} );\n\t\t\treturn fn.__ractive_nowrap;\n\t\t}\n\t\treturn __export;\n\t}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );\n\n\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */\n\tvar MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {\n\n\t\tvar MemberResolver = function( template, resolver, parentFragment ) {\n\t\t\tvar member = this,\n\t\t\t\tkeypath;\n\t\t\tmember.resolver = resolver;\n\t\t\tmember.root = resolver.root;\n\t\t\tmember.parentFragment = parentFragment;\n\t\t\tmember.viewmodel = resolver.root.viewmodel;\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\tmember.value = template;\n\t\t\t} else if ( template.t === types.REFERENCE ) {\n\t\t\t\tmember.refResolver = createReferenceResolver( this, template.n, function( keypath ) {\n\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tnew ExpressionResolver( resolver, parentFragment, template, function( keypath ) {\n\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\tMemberResolver.prototype = {\n\t\t\tresolve: function( keypath ) {\n\t\t\t\tif ( this.keypath ) {\n\t\t\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t\t\t}\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.value = this.viewmodel.get( keypath );\n\t\t\t\tthis.bind();\n\t\t\t\tthis.resolver.bubble();\n\t\t\t},\n\t\t\tbind: function() {\n\t\t\t\tthis.viewmodel.register( this.keypath, this );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tif ( this.refResolver ) {\n\t\t\t\t\tthis.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.resolver.bubble();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tif ( this.keypath ) {\n\t\t\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t\t\t}\n\t\t\t\tif ( this.unresolved ) {\n\t\t\t\t\tthis.unresolved.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceResolution: function() {\n\t\t\t\tif ( this.refResolver ) {\n\t\t\t\t\tthis.refResolver.forceResolution();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn MemberResolver;\n\t}( types, createReferenceResolver, ExpressionResolver );\n\n\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */\n\tvar ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {\n\n\t\tvar ReferenceExpressionResolver = function( mustache, template, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar resolver = this,\n\t\t\t\tractive, ref, keypath, parentFragment;\n\t\t\tresolver.parentFragment = parentFragment = mustache.parentFragment;\n\t\t\tresolver.root = ractive = mustache.root;\n\t\t\tresolver.mustache = mustache;\n\t\t\tresolver.ref = ref = template.r;\n\t\t\tresolver.callback = callback;\n\t\t\tresolver.unresolved = [];\n\t\t\t// Find base keypath\n\t\t\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\t\t\tresolver.base = keypath;\n\t\t\t} else {\n\t\t\t\tresolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {\n\t\t\t\t\tresolver.base = keypath;\n\t\t\t\t\tresolver.baseResolver = null;\n\t\t\t\t\tresolver.bubble();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Find values for members, or mark them as unresolved\n\t\t\tresolver.members = template.m.map( function( template ) {\n\t\t\t\treturn new MemberResolver( template, this$0, parentFragment );\n\t\t\t} );\n\t\t\tresolver.ready = true;\n\t\t\tresolver.bubble();\n\t\t};\n\t\tReferenceExpressionResolver.prototype = {\n\t\t\tgetKeypath: function() {\n\t\t\t\tvar values = this.members.map( getValue );\n\t\t\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn this.base + '.' + values.join( '.' );\n\t\t\t},\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.callback( this.getKeypath() );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.members.forEach( unbind );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar changed;\n\t\t\t\tthis.members.forEach( function( members ) {\n\t\t\t\t\tif ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( changed ) {\n\t\t\t\t\tthis.bubble();\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceResolution: function() {\n\t\t\t\tif ( this.baseResolver ) {\n\t\t\t\t\tthis.base = this.ref;\n\t\t\t\t\tthis.baseResolver.unbind();\n\t\t\t\t\tthis.baseResolver = null;\n\t\t\t\t}\n\t\t\t\tthis.members.forEach( function( m ) {\n\t\t\t\t\treturn m.forceResolution();\n\t\t\t\t} );\n\t\t\t\tthis.bubble();\n\t\t\t}\n\t\t};\n\n\t\tfunction getValue( member ) {\n\t\t\treturn member.value;\n\t\t}\n\n\t\tfunction isDefined( value ) {\n\t\t\treturn value != undefined;\n\t\t}\n\n\t\tfunction unbind( member ) {\n\t\t\tmember.unbind();\n\t\t}\n\t\treturn ReferenceExpressionResolver;\n\t}( resolveRef, ReferenceResolver, MemberResolver );\n\n\t/* virtualdom/items/shared/Mustache/initialise.js */\n\tvar initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {\n\n\t\treturn function Mustache$init( mustache, options ) {\n\t\t\tvar ref, parentFragment, template;\n\t\t\tparentFragment = options.parentFragment;\n\t\t\ttemplate = options.template;\n\t\t\tmustache.root = parentFragment.root;\n\t\t\tmustache.parentFragment = parentFragment;\n\t\t\tmustache.pElement = parentFragment.pElement;\n\t\t\tmustache.template = options.template;\n\t\t\tmustache.index = options.index || 0;\n\t\t\tmustache.isStatic = options.template.s;\n\t\t\tmustache.type = options.template.t;\n\t\t\tmustache.registered = false;\n\t\t\t// if this is a simple mustache, with a reference, we just need to resolve\n\t\t\t// the reference to a keypath\n\t\t\tif ( ref = template.r ) {\n\t\t\t\tmustache.resolver = new createReferenceResolver( mustache, ref, resolve );\n\t\t\t}\n\t\t\t// if it's an expression, we have a bit more work to do\n\t\t\tif ( options.template.x ) {\n\t\t\t\tmustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );\n\t\t\t}\n\t\t\tif ( options.template.rx ) {\n\t\t\t\tmustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );\n\t\t\t}\n\t\t\t// Special case - inverted sections\n\t\t\tif ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {\n\t\t\t\tmustache.setValue( undefined );\n\t\t\t}\n\n\t\t\tfunction resolve( keypath ) {\n\t\t\t\tmustache.resolve( keypath );\n\t\t\t}\n\n\t\t\tfunction resolveAndRebindChildren( newKeypath ) {\n\t\t\t\tvar oldKeypath = mustache.keypath;\n\t\t\t\tif ( newKeypath !== oldKeypath ) {\n\t\t\t\t\tmustache.resolve( newKeypath );\n\t\t\t\t\tif ( oldKeypath !== undefined ) {\n\t\t\t\t\t\tmustache.fragments && mustache.fragments.forEach( function( f ) {\n\t\t\t\t\t\t\tf.rebind( null, null, oldKeypath, newKeypath );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );\n\n\t/* virtualdom/items/shared/Mustache/resolve.js */\n\tvar resolve = function( isNumeric ) {\n\n\t\treturn function Mustache$resolve( keypath ) {\n\t\t\tvar wasResolved, value, twowayBinding;\n\t\t\t// 'Special' keypaths, e.g. @foo or @7, encode a value\n\t\t\tif ( keypath && keypath[ 0 ] === '@' ) {\n\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\tif ( isNumeric( value ) ) {\n\t\t\t\t\tvalue = +value;\n\t\t\t\t}\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.setValue( value );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If we resolved previously, we need to unregister\n\t\t\tif ( this.registered ) {\n\t\t\t\t// undefined or null\n\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t\tthis.registered = false;\n\t\t\t\twasResolved = true;\n\t\t\t}\n\t\t\tthis.keypath = keypath;\n\t\t\t// If the new keypath exists, we need to register\n\t\t\t// with the viewmodel\n\t\t\tif ( keypath != undefined ) {\n\t\t\t\t// undefined or null\n\t\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\t\tthis.root.viewmodel.register( keypath, this );\n\t\t\t\tthis.registered = true;\n\t\t\t}\n\t\t\t// Either way we need to queue up a render (`value`\n\t\t\t// will be `undefined` if there's no keypath)\n\t\t\tthis.setValue( value );\n\t\t\t// Two-way bindings need to point to their new target keypath\n\t\t\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\t\t\ttwowayBinding.rebound();\n\t\t\t}\n\t\t};\n\t}( isNumeric );\n\n\t/* virtualdom/items/shared/Mustache/rebind.js */\n\tvar rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t// Children first\n\t\tif ( this.fragments ) {\n\t\t\tthis.fragments.forEach( function( f ) {\n\t\t\t\treturn f.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t} );\n\t\t}\n\t\t// Expression mustache?\n\t\tif ( this.resolver ) {\n\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t}\n\t};\n\n\t/* virtualdom/items/shared/Mustache/_Mustache.js */\n\tvar Mustache = function( getValue, init, resolve, rebind ) {\n\n\t\treturn {\n\t\t\tgetValue: getValue,\n\t\t\tinit: init,\n\t\t\tresolve: resolve,\n\t\t\trebind: rebind\n\t\t};\n\t}( getValue, initialise, resolve, rebind );\n\n\t/* virtualdom/items/Interpolator.js */\n\tvar Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {\n\n\t\tvar Interpolator = function( options ) {\n\t\t\tthis.type = types.INTERPOLATOR;\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tInterpolator.prototype = {\n\t\t\tupdate: function() {\n\t\t\t\tthis.node.data = this.value == undefined ? '' : this.value;\n\t\t\t},\n\t\t\tresolve: Mustache.resolve,\n\t\t\trebind: Mustache.rebind,\n\t\t\tdetach: detach,\n\t\t\tunbind: unbind,\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createTextNode( this.value != undefined ? this.value : '' );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\tdetachNode( this.node );\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetValue: Mustache.getValue,\n\t\t\t// TEMP\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar wrapper;\n\t\t\t\t// TODO is there a better way to approach this?\n\t\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t\tif ( this.node ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function( escape ) {\n\t\t\t\tvar string = this.value != undefined ? '' + this.value : '';\n\t\t\t\treturn escape ? escapeHtml( string ) : string;\n\t\t\t}\n\t\t};\n\t\treturn Interpolator;\n\t}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );\n\n\t/* virtualdom/items/Section/prototype/bubble.js */\n\tvar virtualdom_items_Section$bubble = function Section$bubble() {\n\t\tthis.parentFragment.bubble();\n\t};\n\n\t/* virtualdom/items/Section/prototype/detach.js */\n\tvar virtualdom_items_Section$detach = function Section$detach() {\n\t\tvar docFrag;\n\t\tif ( this.fragments.length === 1 ) {\n\t\t\treturn this.fragments[ 0 ].detach();\n\t\t}\n\t\tdocFrag = document.createDocumentFragment();\n\t\tthis.fragments.forEach( function( item ) {\n\t\t\tdocFrag.appendChild( item.detach() );\n\t\t} );\n\t\treturn docFrag;\n\t};\n\n\t/* virtualdom/items/Section/prototype/find.js */\n\tvar virtualdom_items_Section$find = function Section$find( selector ) {\n\t\tvar i, len, queryResult;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( queryResult = this.fragments[ i ].find( selector ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Section/prototype/findAll.js */\n\tvar virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {\n\t\tvar i, len;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.fragments[ i ].findAll( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Section/prototype/findAllComponents.js */\n\tvar virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {\n\t\tvar i, len;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.fragments[ i ].findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Section/prototype/findComponent.js */\n\tvar virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {\n\t\tvar i, len, queryResult;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( queryResult = this.fragments[ i ].findComponent( selector ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Section/prototype/findNextNode.js */\n\tvar virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {\n\t\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Section/prototype/firstNode.js */\n\tvar virtualdom_items_Section$firstNode = function Section$firstNode() {\n\t\tvar len, i, node;\n\t\tif ( len = this.fragments.length ) {\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( node = this.fragments[ i ].firstNode() ) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Section/prototype/shuffle.js */\n\tvar virtualdom_items_Section$shuffle = function( types, runloop, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Section$shuffle( newIndices ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar section = this,\n\t\t\t\tparentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\t\t\t// short circuit any double-updates, and ensure that this isn't applied to\n\t\t\t// non-list sections\n\t\t\tif ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.shuffling = true;\n\t\t\trunloop.scheduleTask( function() {\n\t\t\t\treturn this$0.shuffling = false;\n\t\t\t} );\n\t\t\tparentFragment = this.parentFragment;\n\t\t\treboundFragments = [];\n\t\t\t// first, rebind existing fragments\n\t\t\tnewIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {\n\t\t\t\tvar fragment, by, oldKeypath, newKeypath;\n\t\t\t\tif ( newIndex === oldIndex ) {\n\t\t\t\t\treboundFragments[ newIndex ] = section.fragments[ oldIndex ];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfragment = section.fragments[ oldIndex ];\n\t\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t\tfirstChange = oldIndex;\n\t\t\t\t}\n\t\t\t\t// does this fragment need to be torn down?\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Otherwise, it needs to be rebound to a new index\n\t\t\t\tby = newIndex - oldIndex;\n\t\t\t\toldKeypath = section.keypath + '.' + oldIndex;\n\t\t\t\tnewKeypath = section.keypath + '.' + newIndex;\n\t\t\t\tfragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );\n\t\t\t\tfragment.index = newIndex;\n\t\t\t\treboundFragments[ newIndex ] = fragment;\n\t\t\t} );\n\t\t\tnewLength = this.root.get( this.keypath ).length;\n\t\t\t// If nothing changed with the existing fragments, then we start adding\n\t\t\t// new fragments at the end...\n\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t// ...unless there are no new fragments to add\n\t\t\t\tif ( this.length === newLength ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfirstChange = this.length;\n\t\t\t}\n\t\t\tthis.length = this.fragments.length = newLength;\n\t\t\tif ( this.rendered ) {\n\t\t\t\trunloop.addView( this );\n\t\t\t}\n\t\t\t// Prepare new fragment options\n\t\t\tfragmentOptions = {\n\t\t\t\ttemplate: this.template.f,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t};\n\t\t\tif ( this.template.i ) {\n\t\t\t\tfragmentOptions.indexRef = this.template.i;\n\t\t\t}\n\t\t\t// Add as many new fragments as we need to, or add back existing\n\t\t\t// (detached) fragments\n\t\t\tfor ( i = firstChange; i < newLength; i += 1 ) {\n\t\t\t\tfragment = reboundFragments[ i ];\n\t\t\t\tif ( !fragment ) {\n\t\t\t\t\tthis.fragmentsToCreate.push( i );\n\t\t\t\t}\n\t\t\t\tthis.fragments[ i ] = fragment;\n\t\t\t}\n\t\t};\n\t}( types, runloop, circular );\n\n\t/* virtualdom/items/Section/prototype/render.js */\n\tvar virtualdom_items_Section$render = function Section$render() {\n\t\tvar docFrag;\n\t\tdocFrag = this.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\t\tthis.rendered = true;\n\t\treturn docFrag;\n\t};\n\n\t/* utils/isArrayLike.js */\n\tvar isArrayLike = function() {\n\n\t\tvar pattern = /^\\[object (?:Array|FileList)\\]$/,\n\t\t\ttoString = Object.prototype.toString;\n\t\treturn function isArrayLike( obj ) {\n\t\t\treturn pattern.test( toString.call( obj ) );\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Section/prototype/setValue.js */\n\tvar virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {\n\n\t\tvar __export;\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function Section$setValue( value ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar wrapper, fragmentOptions;\n\t\t\tif ( this.updating ) {\n\t\t\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t\t\t// expression refers to a function that mutates the array that this\n\t\t\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.updating = true;\n\t\t\t// with sections, we need to get the fake value if we have a wrapped object\n\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\tvalue = wrapper.get();\n\t\t\t}\n\t\t\t// If any fragments are awaiting creation after a splice,\n\t\t\t// this is the place to do it\n\t\t\tif ( this.fragmentsToCreate.length ) {\n\t\t\t\tfragmentOptions = {\n\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\tpElement: this.pElement,\n\t\t\t\t\towner: this,\n\t\t\t\t\tindexRef: this.template.i\n\t\t\t\t};\n\t\t\t\tthis.fragmentsToCreate.forEach( function( index ) {\n\t\t\t\t\tvar fragment;\n\t\t\t\t\tfragmentOptions.context = this$0.keypath + '.' + index;\n\t\t\t\t\tfragmentOptions.index = index;\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tthis$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );\n\t\t\t\t} );\n\t\t\t\tthis.fragmentsToCreate.length = 0;\n\t\t\t} else if ( reevaluateSection( this, value ) ) {\n\t\t\t\tthis.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.value = value;\n\t\t\tthis.updating = false;\n\t\t};\n\n\t\tfunction reevaluateSection( section, value ) {\n\t\t\tvar fragmentOptions = {\n\t\t\t\ttemplate: section.template.f,\n\t\t\t\troot: section.root,\n\t\t\t\tpElement: section.parentFragment.pElement,\n\t\t\t\towner: section\n\t\t\t};\n\t\t\t// If we already know the section type, great\n\t\t\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t\t\t// and avoid doing this each time?\n\t\t\tif ( section.subtype ) {\n\t\t\t\tswitch ( section.subtype ) {\n\t\t\t\t\tcase types.SECTION_IF:\n\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_UNLESS:\n\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_WITH:\n\t\t\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_IF_WITH:\n\t\t\t\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_EACH:\n\t\t\t\t\t\tif ( isObject( value ) ) {\n\t\t\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise we need to work out what sort of section we're dealing with\n\t\t\tsection.ordered = !!isArrayLike( value );\n\t\t\t// Ordered list section\n\t\t\tif ( section.ordered ) {\n\t\t\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t\t\t}\n\t\t\t// Unordered list, or context\n\t\t\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t\t\t// Index reference indicates section should be treated as a list\n\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t}\n\t\t\t\t// Otherwise, object provides context for contents\n\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t}\n\t\t\t// Conditional section\n\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t}\n\n\t\tfunction reevaluateListSection( section, value, fragmentOptions ) {\n\t\t\tvar i, length, fragment;\n\t\t\tlength = value.length;\n\t\t\tif ( length === section.length ) {\n\t\t\t\t// Nothing to do\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// if the array is shorter than it was previously, remove items\n\t\t\tif ( length < section.length ) {\n\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t} else {\n\t\t\t\tif ( length > section.length ) {\n\t\t\t\t\t// add any new ones\n\t\t\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t\t\t// append list item to context stack\n\t\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + i;\n\t\t\t\t\t\tfragmentOptions.index = i;\n\t\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ i ] = fragment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsection.length = length;\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction reevaluateListObjectSection( section, value, fragmentOptions ) {\n\t\t\tvar id, i, hasKey, fragment, changed;\n\t\t\thasKey = section.hasKey || ( section.hasKey = {} );\n\t\t\t// remove any fragments that should no longer exist\n\t\t\ti = section.fragments.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tfragment = section.fragments[ i ];\n\t\t\t\tif ( !( fragment.index in value ) ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\tsection.fragments.splice( i, 1 );\n\t\t\t\t\thasKey[ fragment.index ] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add any that haven't been created yet\n\t\t\tfor ( id in value ) {\n\t\t\t\tif ( !hasKey[ id ] ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + id;\n\t\t\t\t\tfragmentOptions.index = id;\n\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t}\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\t\t\tsection.fragments.push( fragment );\n\t\t\t\t\thasKey[ id ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsection.length = section.fragments.length;\n\t\t\treturn changed;\n\t\t}\n\n\t\tfunction reevaluateConditionalContextSection( section, value, fragmentOptions ) {\n\t\t\tif ( value ) {\n\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t} else {\n\t\t\t\treturn removeSectionFragments( section );\n\t\t\t}\n\t\t}\n\n\t\tfunction reevaluateContextSection( section, fragmentOptions ) {\n\t\t\tvar fragment;\n\t\t\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t\t\t// (if it is already rendered, then any children dependent on the context stack\n\t\t\t// will update themselves without any prompting)\n\t\t\tif ( !section.length ) {\n\t\t\t\t// append this section to the context stack\n\t\t\t\tfragmentOptions.context = section.keypath;\n\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\tsection.length = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {\n\t\t\tvar doRender, emptyArray, emptyObject, fragment, name;\n\t\t\temptyArray = isArrayLike( value ) && value.length === 0;\n\t\t\temptyObject = false;\n\t\t\tif ( !isArrayLike( value ) && isObject( value ) ) {\n\t\t\t\temptyObject = true;\n\t\t\t\tfor ( name in value ) {\n\t\t\t\t\temptyObject = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( inverted ) {\n\t\t\t\tdoRender = emptyArray || emptyObject || !value;\n\t\t\t} else {\n\t\t\t\tdoRender = value && !emptyArray && !emptyObject;\n\t\t\t}\n\t\t\tif ( doRender ) {\n\t\t\t\tif ( !section.length ) {\n\t\t\t\t\t// no change to context stack\n\t\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\t\tsection.length = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif ( section.length > 1 ) {\n\t\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn removeSectionFragments( section );\n\t\t\t}\n\t\t}\n\n\t\tfunction removeSectionFragments( section ) {\n\t\t\tif ( section.length ) {\n\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction unbind( fragment ) {\n\t\t\tfragment.unbind();\n\t\t}\n\n\t\tfunction isRendered( fragment ) {\n\t\t\treturn fragment.rendered;\n\t\t}\n\t\treturn __export;\n\t}( types, isArrayLike, isObject, runloop, circular );\n\n\t/* virtualdom/items/Section/prototype/toString.js */\n\tvar virtualdom_items_Section$toString = function Section$toString( escape ) {\n\t\tvar str, i, len;\n\t\tstr = '';\n\t\ti = 0;\n\t\tlen = this.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tstr += this.fragments[ i ].toString( escape );\n\t\t}\n\t\treturn str;\n\t};\n\n\t/* virtualdom/items/Section/prototype/unbind.js */\n\tvar virtualdom_items_Section$unbind = function( unbind ) {\n\n\t\tvar __export;\n\t\t__export = function Section$unbind() {\n\t\t\tthis.fragments.forEach( unbindFragment );\n\t\t\tunbind.call( this );\n\t\t\tthis.length = 0;\n\t\t\tthis.unbound = true;\n\t\t};\n\n\t\tfunction unbindFragment( fragment ) {\n\t\t\tfragment.unbind();\n\t\t}\n\t\treturn __export;\n\t}( unbind );\n\n\t/* virtualdom/items/Section/prototype/unrender.js */\n\tvar virtualdom_items_Section$unrender = function() {\n\n\t\tvar __export;\n\t\t__export = function Section$unrender( shouldDestroy ) {\n\t\t\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t\t};\n\n\t\tfunction unrenderAndDestroy( fragment ) {\n\t\t\tfragment.unrender( true );\n\t\t}\n\n\t\tfunction unrender( fragment ) {\n\t\t\tfragment.unrender( false );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Section/prototype/update.js */\n\tvar virtualdom_items_Section$update = function Section$update() {\n\t\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\t\t// `this.renderedFragments` is in the order of the previous render.\n\t\t// If fragments have shuffled about, this allows us to quickly\n\t\t// reinsert them in the correct place\n\t\trenderedFragments = this.renderedFragments;\n\t\t// Remove fragments that have been marked for destruction\n\t\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\t\tfragment.unrender( true );\n\t\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t\t}\n\t\t// Render new fragments (but don't insert them yet)\n\t\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\t\tfragment.render();\n\t\t}\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t}\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tfragment = this.fragments[ i ];\n\t\t\trenderIndex = renderedFragments.indexOf( fragment, i );\n\t\t\t// search from current index - it's guaranteed to be the same or higher\n\t\t\tif ( renderIndex === i ) {\n\t\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.docFrag.appendChild( fragment.detach() );\n\t\t\t// update renderedFragments\n\t\t\tif ( renderIndex !== -1 ) {\n\t\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t\t}\n\t\t\trenderedFragments.splice( i, 0, fragment );\n\t\t}\n\t\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t\t// Save the rendering order for next time\n\t\tthis.renderedFragments = this.fragments.slice();\n\t};\n\n\t/* virtualdom/items/Section/_Section.js */\n\tvar Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {\n\n\t\tvar Section = function( options ) {\n\t\t\tthis.type = types.SECTION;\n\t\t\tthis.subtype = options.template.n;\n\t\t\tthis.inverted = this.subtype === types.SECTION_UNLESS;\n\t\t\tthis.pElement = options.pElement;\n\t\t\tthis.fragments = [];\n\t\t\tthis.fragmentsToCreate = [];\n\t\t\tthis.fragmentsToRender = [];\n\t\t\tthis.fragmentsToUnrender = [];\n\t\t\tthis.renderedFragments = [];\n\t\t\tthis.length = 0;\n\t\t\t// number of times this section is rendered\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tSection.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetValue: Mustache.getValue,\n\t\t\tshuffle: shuffle,\n\t\t\trebind: Mustache.rebind,\n\t\t\trender: render,\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: setValue,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Section;\n\t}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );\n\n\t/* virtualdom/items/Triple/prototype/detach.js */\n\tvar virtualdom_items_Triple$detach = function Triple$detach() {\n\t\tvar len, i;\n\t\tif ( this.docFrag ) {\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis.docFrag.appendChild( this.nodes[ i ] );\n\t\t\t}\n\t\t\treturn this.docFrag;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Triple/prototype/find.js */\n\tvar virtualdom_items_Triple$find = function( matches ) {\n\n\t\treturn function Triple$find( selector ) {\n\t\t\tvar i, len, node, queryResult;\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Triple/prototype/findAll.js */\n\tvar virtualdom_items_Triple$findAll = function( matches ) {\n\n\t\treturn function Triple$findAll( selector, queryResult ) {\n\t\t\tvar i, len, node, queryAllResult, numNodes, j;\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\tqueryResult.push( node );\n\t\t\t\t}\n\t\t\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\t\t\tnumNodes = queryAllResult.length;\n\t\t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\t\t\tqueryResult.push( queryAllResult[ j ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Triple/prototype/firstNode.js */\n\tvar virtualdom_items_Triple$firstNode = function Triple$firstNode() {\n\t\tif ( this.rendered && this.nodes[ 0 ] ) {\n\t\t\treturn this.nodes[ 0 ];\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Triple/helpers/insertHtml.js */\n\tvar insertHtml = function( namespaces, createElement ) {\n\n\t\tvar __export;\n\t\tvar elementCache = {},\n\t\t\tieBug, ieBlacklist;\n\t\ttry {\n\t\t\tcreateElement( 'table' ).innerHTML = 'foo';\n\t\t} catch ( err ) {\n\t\t\tieBug = true;\n\t\t\tieBlacklist = {\n\t\t\t\tTABLE: [\n\t\t\t\t\t'<table class=\"x\">',\n\t\t\t\t\t'</table>'\n\t\t\t\t],\n\t\t\t\tTHEAD: [\n\t\t\t\t\t'<table><thead class=\"x\">',\n\t\t\t\t\t'</thead></table>'\n\t\t\t\t],\n\t\t\t\tTBODY: [\n\t\t\t\t\t'<table><tbody class=\"x\">',\n\t\t\t\t\t'</tbody></table>'\n\t\t\t\t],\n\t\t\t\tTR: [\n\t\t\t\t\t'<table><tr class=\"x\">',\n\t\t\t\t\t'</tr></table>'\n\t\t\t\t],\n\t\t\t\tSELECT: [\n\t\t\t\t\t'<select class=\"x\">',\n\t\t\t\t\t'</select>'\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t\t__export = function( html, node, docFrag ) {\n\t\t\tvar container, nodes = [],\n\t\t\t\twrapper, selectedOption, child, i;\n\t\t\t// render 0 and false\n\t\t\tif ( html != null && html !== '' ) {\n\t\t\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\tcontainer.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];\n\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t\t}\n\t\t\t\t} else if ( node.namespaceURI === namespaces.svg ) {\n\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t} else {\n\t\t\t\t\tcontainer = element( node.tagName );\n\t\t\t\t\tcontainer.innerHTML = html;\n\t\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( child = container.firstChild ) {\n\t\t\t\t\tnodes.push( child );\n\t\t\t\t\tdocFrag.appendChild( child );\n\t\t\t\t}\n\t\t\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t\t\t// temporary container <select> causes the remaining ones to\n\t\t\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t\t\t// amaze me. You really do\n\t\t\t\t// ...and now Chrome too\n\t\t\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\t\t\ti = nodes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( nodes[ i ] !== selectedOption ) {\n\t\t\t\t\t\t\tnodes[ i ].selected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nodes;\n\t\t};\n\n\t\tfunction element( tagName ) {\n\t\t\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t\t}\n\t\treturn __export;\n\t}( namespaces, createElement );\n\n\t/* utils/toArray.js */\n\tvar toArray = function toArray( arrayLike ) {\n\t\tvar array = [],\n\t\t\ti = arrayLike.length;\n\t\twhile ( i-- ) {\n\t\t\tarray[ i ] = arrayLike[ i ];\n\t\t}\n\t\treturn array;\n\t};\n\n\t/* virtualdom/items/Triple/helpers/updateSelect.js */\n\tvar updateSelect = function( toArray ) {\n\n\t\tvar __export;\n\t\t__export = function updateSelect( parentElement ) {\n\t\t\tvar selectedOptions, option, value;\n\t\t\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\t\t\t// If one of them had a `selected` attribute, we need to sync\n\t\t\t// the model to the view\n\t\t\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\t\t\tvalue = selectedOptions.map( function( o ) {\n\t\t\t\t\treturn o.value;\n\t\t\t\t} );\n\t\t\t} else if ( option = selectedOptions[ 0 ] ) {\n\t\t\t\tvalue = option.value;\n\t\t\t}\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tparentElement.binding.setValue( value );\n\t\t\t}\n\t\t\tparentElement.bubble();\n\t\t};\n\n\t\tfunction isSelected( option ) {\n\t\t\treturn option.selected;\n\t\t}\n\t\treturn __export;\n\t}( toArray );\n\n\t/* virtualdom/items/Triple/prototype/render.js */\n\tvar virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {\n\n\t\treturn function Triple$render() {\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t\t\t}\n\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\tupdateSelect( this.pElement );\n\t\t\tthis.rendered = true;\n\t\t\treturn this.docFrag;\n\t\t};\n\t}( insertHtml, updateSelect );\n\n\t/* virtualdom/items/Triple/prototype/setValue.js */\n\tvar virtualdom_items_Triple$setValue = function( runloop ) {\n\n\t\treturn function Triple$setValue( value ) {\n\t\t\tvar wrapper;\n\t\t\t// TODO is there a better way to approach this?\n\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\tvalue = wrapper.get();\n\t\t\t}\n\t\t\tif ( value !== this.value ) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* virtualdom/items/Triple/prototype/toString.js */\n\tvar virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {\n\n\t\treturn function Triple$toString() {\n\t\t\treturn this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';\n\t\t};\n\t}( decodeCharacterReferences );\n\n\t/* virtualdom/items/Triple/prototype/unrender.js */\n\tvar virtualdom_items_Triple$unrender = function( detachNode ) {\n\n\t\treturn function Triple$unrender( shouldDestroy ) {\n\t\t\tif ( this.rendered && shouldDestroy ) {\n\t\t\t\tthis.nodes.forEach( detachNode );\n\t\t\t\tthis.rendered = false;\n\t\t\t}\n\t\t};\n\t}( detachNode );\n\n\t/* virtualdom/items/Triple/prototype/update.js */\n\tvar virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {\n\n\t\treturn function Triple$update() {\n\t\t\tvar node, parentNode;\n\t\t\tif ( !this.rendered ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Remove existing nodes\n\t\t\twhile ( this.nodes && this.nodes.length ) {\n\t\t\t\tnode = this.nodes.pop();\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t\t// Insert new nodes\n\t\t\tparentNode = this.parentFragment.getNode();\n\t\t\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\t\t\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\tupdateSelect( this.pElement );\n\t\t};\n\t}( insertHtml, updateSelect );\n\n\t/* virtualdom/items/Triple/_Triple.js */\n\tvar Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {\n\n\t\tvar Triple = function( options ) {\n\t\t\tthis.type = types.TRIPLE;\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tTriple.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetValue: Mustache.getValue,\n\t\t\trebind: Mustache.rebind,\n\t\t\trender: render,\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: setValue,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Triple;\n\t}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );\n\n\t/* virtualdom/items/Element/prototype/bubble.js */\n\tvar virtualdom_items_Element$bubble = function() {\n\t\tthis.parentFragment.bubble();\n\t};\n\n\t/* virtualdom/items/Element/prototype/detach.js */\n\tvar virtualdom_items_Element$detach = function Element$detach() {\n\t\tvar node = this.node,\n\t\t\tparentNode;\n\t\tif ( node ) {\n\t\t\t// need to check for parent node - DOM may have been altered\n\t\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\t\tif ( parentNode = node.parentNode ) {\n\t\t\t\tparentNode.removeChild( node );\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/find.js */\n\tvar virtualdom_items_Element$find = function( matches ) {\n\n\t\treturn function( selector ) {\n\t\t\tif ( matches( this.node, selector ) ) {\n\t\t\t\treturn this.node;\n\t\t\t}\n\t\t\tif ( this.fragment && this.fragment.find ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Element/prototype/findAll.js */\n\tvar virtualdom_items_Element$findAll = function( selector, query ) {\n\t\t// Add this node to the query, if applicable, and register the\n\t\t// query on this element\n\t\tif ( query._test( this, true ) && query.live ) {\n\t\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t\t}\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.findAll( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findAllComponents.js */\n\tvar virtualdom_items_Element$findAllComponents = function( selector, query ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findComponent.js */\n\tvar virtualdom_items_Element$findComponent = function( selector ) {\n\t\tif ( this.fragment ) {\n\t\t\treturn this.fragment.findComponent( selector );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findNextNode.js */\n\tvar virtualdom_items_Element$findNextNode = function Element$findNextNode() {\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Element/prototype/firstNode.js */\n\tvar virtualdom_items_Element$firstNode = function Element$firstNode() {\n\t\treturn this.node;\n\t};\n\n\t/* virtualdom/items/Element/prototype/getAttribute.js */\n\tvar virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {\n\t\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.attributes[ name ].value;\n\t};\n\n\t/* virtualdom/items/Element/shared/enforceCase.js */\n\tvar enforceCase = function() {\n\n\t\tvar svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n\t\tsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\n\t\tsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\t\tcreateMap = function( items ) {\n\t\t\tvar map = {},\n\t\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tmap[ items[ i ].toLowerCase() ] = items[ i ];\n\t\t\t}\n\t\t\treturn map;\n\t\t};\n\t\tmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\t\treturn function( elementName ) {\n\t\t\tvar lowerCaseElementName = elementName.toLowerCase();\n\t\t\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Element/Attribute/prototype/bubble.js */\n\tvar virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {\n\n\t\treturn function Attribute$bubble() {\n\t\t\tvar value = this.fragment.getValue();\n\t\t\t// TODO this can register the attribute multiple times (see render test\n\t\t\t// 'Attribute with nested mustaches')\n\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t// Need to clear old id from ractive.nodes\n\t\t\t\tif ( this.name === 'id' && this.value ) {\n\t\t\t\t\tdelete this.root.nodes[ this.value ];\n\t\t\t\t}\n\t\t\t\tthis.value = value;\n\t\t\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\t\t\tthis.node._ractive.value = value;\n\t\t\t\t}\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop, isEqual );\n\n\t/* config/booleanAttributes.js */\n\tvar booleanAttributes = function() {\n\n\t\t// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\t\tvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\t\treturn booleanAttributes;\n\t}();\n\n\t/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */\n\tvar determineNameAndNamespace = function( namespaces, enforceCase ) {\n\n\t\treturn function( attribute, name ) {\n\t\t\tvar colonIndex, namespacePrefix;\n\t\t\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\t\t\tcolonIndex = name.indexOf( ':' );\n\t\t\tif ( colonIndex !== -1 ) {\n\t\t\t\t// looks like we are, yes...\n\t\t\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\t\t\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t\t\t// that only valid namespaces will be used)\n\t\t\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\t\t\tname = name.substring( colonIndex + 1 );\n\t\t\t\t\tattribute.name = enforceCase( name );\n\t\t\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\t\t\tattribute.namespacePrefix = namespacePrefix;\n\t\t\t\t\tif ( !attribute.namespace ) {\n\t\t\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SVG attribute names are case sensitive\n\t\t\tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;\n\t\t};\n\t}( namespaces, enforceCase );\n\n\t/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */\n\tvar getInterpolator = function( types ) {\n\n\t\treturn function getInterpolator( attribute ) {\n\t\t\tvar items = attribute.fragment.items;\n\t\t\tif ( items.length !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( items[ 0 ].type === types.INTERPOLATOR ) {\n\t\t\t\treturn items[ 0 ];\n\t\t\t}\n\t\t};\n\t}( types );\n\n\t/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */\n\tvar determinePropertyName = function( namespaces, booleanAttributes ) {\n\n\t\tvar propertyNames = {\n\t\t\t'accept-charset': 'acceptCharset',\n\t\t\taccesskey: 'accessKey',\n\t\t\tbgcolor: 'bgColor',\n\t\t\t'class': 'className',\n\t\t\tcodebase: 'codeBase',\n\t\t\tcolspan: 'colSpan',\n\t\t\tcontenteditable: 'contentEditable',\n\t\t\tdatetime: 'dateTime',\n\t\t\tdirname: 'dirName',\n\t\t\t'for': 'htmlFor',\n\t\t\t'http-equiv': 'httpEquiv',\n\t\t\tismap: 'isMap',\n\t\t\tmaxlength: 'maxLength',\n\t\t\tnovalidate: 'noValidate',\n\t\t\tpubdate: 'pubDate',\n\t\t\treadonly: 'readOnly',\n\t\t\trowspan: 'rowSpan',\n\t\t\ttabindex: 'tabIndex',\n\t\t\tusemap: 'useMap'\n\t\t};\n\t\treturn function( attribute, options ) {\n\t\t\tvar propertyName;\n\t\t\tif ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {\n\t\t\t\tpropertyName = propertyNames[ attribute.name ] || attribute.name;\n\t\t\t\tif ( options.pNode[ propertyName ] !== undefined ) {\n\t\t\t\t\tattribute.propertyName = propertyName;\n\t\t\t\t}\n\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\tattribute.useProperty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( namespaces, booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/init.js */\n\tvar virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Attribute$init( options ) {\n\t\t\tthis.type = types.ATTRIBUTE;\n\t\t\tthis.element = options.element;\n\t\t\tthis.root = options.root;\n\t\t\tdetermineNameAndNamespace( this, options.name );\n\t\t\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t\t\t// mustache shenanigans, set the attribute accordingly and go home\n\t\t\tif ( !options.value || typeof options.value === 'string' ) {\n\t\t\t\tthis.value = booleanAttributes.test( this.name ) ? true : options.value || '';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// otherwise we need to do some work\n\t\t\t// share parentFragment with parent element\n\t\t\tthis.parentFragment = this.element.parentFragment;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: options.value,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.value = this.fragment.getValue();\n\t\t\t// Store a reference to this attribute's interpolator, if its fragment\n\t\t\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t\t\t// for correctly rendering HTML later\n\t\t\tthis.interpolator = getInterpolator( this );\n\t\t\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\t\t\t// can we establish this attribute's property name equivalent?\n\t\t\tdeterminePropertyName( this, options );\n\t\t\t// mark as ready\n\t\t\tthis.ready = true;\n\t\t};\n\t}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );\n\n\t/* virtualdom/items/Element/Attribute/prototype/rebind.js */\n\tvar virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/render.js */\n\tvar virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {\n\n\t\tvar propertyNames = {\n\t\t\t'accept-charset': 'acceptCharset',\n\t\t\t'accesskey': 'accessKey',\n\t\t\t'bgcolor': 'bgColor',\n\t\t\t'class': 'className',\n\t\t\t'codebase': 'codeBase',\n\t\t\t'colspan': 'colSpan',\n\t\t\t'contenteditable': 'contentEditable',\n\t\t\t'datetime': 'dateTime',\n\t\t\t'dirname': 'dirName',\n\t\t\t'for': 'htmlFor',\n\t\t\t'http-equiv': 'httpEquiv',\n\t\t\t'ismap': 'isMap',\n\t\t\t'maxlength': 'maxLength',\n\t\t\t'novalidate': 'noValidate',\n\t\t\t'pubdate': 'pubDate',\n\t\t\t'readonly': 'readOnly',\n\t\t\t'rowspan': 'rowSpan',\n\t\t\t'tabindex': 'tabIndex',\n\t\t\t'usemap': 'useMap'\n\t\t};\n\t\treturn function Attribute$render( node ) {\n\t\t\tvar propertyName;\n\t\t\tthis.node = node;\n\t\t\t// should we use direct property access, or setAttribute?\n\t\t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\t\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\t\t\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\t\t\t}\n\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t}\n\t\t\t\tif ( propertyName === 'value' ) {\n\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t\tnode._ractive.value = this.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.rendered = true;\n\t\t\tthis.update();\n\t\t};\n\t}( namespaces, booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/toString.js */\n\tvar virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {\n\n\t\tvar __export;\n\t\t__export = function Attribute$toString() {\n\t\t\tvar name = ( fragment = this ).name,\n\t\t\t\tnamespacePrefix = fragment.namespacePrefix,\n\t\t\t\tvalue = fragment.value,\n\t\t\t\tinterpolator = fragment.interpolator,\n\t\t\t\tfragment = fragment.fragment;\n\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Special case - content editable\n\t\t\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Special case - radio names\n\t\t\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\t\t\treturn 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';\n\t\t\t}\n\t\t\t// Boolean attributes\n\t\t\tif ( booleanAttributes.test( name ) ) {\n\t\t\t\treturn value ? name : '';\n\t\t\t}\n\t\t\tif ( fragment ) {\n\t\t\t\tvalue = fragment.toString();\n\t\t\t}\n\t\t\tif ( namespacePrefix ) {\n\t\t\t\tname = namespacePrefix + ':' + name;\n\t\t\t}\n\t\t\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n\t\t};\n\n\t\tfunction escape( value ) {\n\t\t\treturn value.replace( /&/g, '&amp;' ).replace( /\"/g, '&quot;' ).replace( /'/g, '&#39;' );\n\t\t}\n\t\treturn __export;\n\t}( booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/unbind.js */\n\tvar virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {\n\t\t// ignore non-dynamic attributes\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t\tif ( this.name === 'id' ) {\n\t\t\tdelete this.root.nodes[ this.value ];\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {\n\t\tvar value = this.value,\n\t\t\toptions, option, optionValue, i;\n\t\tif ( !this.locked ) {\n\t\t\tthis.node._ractive.value = value;\n\t\t\toptions = this.node.options;\n\t\t\ti = options.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\toption = options[ i ];\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\tif ( optionValue == value ) {\n\t\t\t\t\t// double equals as we may be comparing numbers with strings\n\t\t\t\t\toption.selected = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/* utils/arrayContains.js */\n\tvar arrayContains = function arrayContains( array, value ) {\n\t\tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t\t\tif ( array[ i ] == value ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {\n\n\t\treturn function Attribute$updateMultipleSelect() {\n\t\t\tvar value = this.value,\n\t\t\t\toptions, i, option, optionValue;\n\t\t\tif ( !isArray( value ) ) {\n\t\t\t\tvalue = [ value ];\n\t\t\t}\n\t\t\toptions = this.node.options;\n\t\t\ti = options.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\toption = options[ i ];\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\toption.selected = arrayContains( value, optionValue );\n\t\t\t}\n\t\t};\n\t}( arrayContains, isArray );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\tnode.checked = value == node._ractive.value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {\n\n\t\treturn function Attribute$updateRadioValue() {\n\t\t\tvar wasChecked, node = this.node,\n\t\t\t\tbinding, bindings, i;\n\t\t\twasChecked = node.checked;\n\t\t\tnode.value = this.element.getAttribute( 'value' );\n\t\t\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\t\t\t// This is a special case - if the input was checked, and the value\n\t\t\t// changed so that it's no longer checked, the twoway binding is\n\t\t\t// most likely out of date. To fix it we have to jump through some\n\t\t\t// hoops... this is a little kludgy but it works\n\t\t\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\t\t\tbindings = this.element.binding.siblings;\n\t\t\t\tif ( i = bindings.length ) {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t\t\t// we'll come back later...\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {\n\n\t\treturn function Attribute$updateCheckboxName() {\n\t\t\tvar element = ( value = this ).element,\n\t\t\t\tnode = value.node,\n\t\t\t\tvalue = value.value,\n\t\t\t\tvalueAttribute, i;\n\t\t\tvalueAttribute = element.getAttribute( 'value' );\n\t\t\tif ( !isArray( value ) ) {\n\t\t\t\tnode.checked = value == valueAttribute;\n\t\t\t} else {\n\t\t\t\ti = value.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( valueAttribute == value[ i ] ) {\n\t\t\t\t\t\tnode.checked = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.checked = false;\n\t\t\t}\n\t\t};\n\t}( isArray );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {\n\t\tvar node, value;\n\t\tnode = this.node;\n\t\tvalue = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tnode.className = value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */\n\tvar virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\tthis.root.nodes[ value ] = node;\n\t\tnode.id = value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */\n\tvar virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {\n\t\tvar node, value;\n\t\tnode = this.node;\n\t\tvalue = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tnode.style.setAttribute( 'cssText', value );\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {\n\t\tvar value = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tif ( !this.locked ) {\n\t\t\tthis.node.innerHTML = value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\t// store actual value, so it doesn't get coerced to a string\n\t\tnode._ractive.value = value;\n\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t// otherwise the cursor will often be sent to the wrong place\n\t\tif ( !this.locked ) {\n\t\t\tnode.value = value == undefined ? '' : value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */\n\tvar virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {\n\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t// otherwise the cursor will often be sent to the wrong place\n\t\tif ( !this.locked ) {\n\t\t\tthis.node[ this.propertyName ] = this.value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */\n\tvar virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {\n\n\t\treturn function Attribute$updateEverythingElse() {\n\t\t\tvar node = ( fragment = this ).node,\n\t\t\t\tnamespace = fragment.namespace,\n\t\t\t\tname = fragment.name,\n\t\t\t\tvalue = fragment.value,\n\t\t\t\tfragment = fragment.fragment;\n\t\t\tif ( namespace ) {\n\t\t\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t\t\t} else if ( !booleanAttributes.test( name ) ) {\n\t\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t\t} else {\n\t\t\t\tif ( value ) {\n\t\t\t\t\tnode.setAttribute( name, '' );\n\t\t\t\t} else {\n\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update.js */\n\tvar virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {\n\n\t\treturn function Attribute$update() {\n\t\t\tvar name = ( node = this ).name,\n\t\t\t\telement = node.element,\n\t\t\t\tnode = node.node,\n\t\t\t\ttype, updateMethod;\n\t\t\tif ( name === 'id' ) {\n\t\t\t\tupdateMethod = updateIdAttribute;\n\t\t\t} else if ( name === 'value' ) {\n\t\t\t\t// special case - selects\n\t\t\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t\t\t} else if ( element.name === 'textarea' ) {\n\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t} else if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\t\t\tupdateMethod = updateContentEditableValue;\n\t\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\t\t// type='file' value='{{fileList}}'>\n\t\t\t\t\tif ( type === 'file' ) {\n\t\t\t\t\t\tupdateMethod = noop;\n\t\t\t\t\t} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( this.twoway && name === 'name' ) {\n\t\t\t\tif ( node.type === 'radio' ) {\n\t\t\t\t\tupdateMethod = updateRadioName;\n\t\t\t\t} else if ( node.type === 'checkbox' ) {\n\t\t\t\t\tupdateMethod = updateCheckboxName;\n\t\t\t\t}\n\t\t\t} else if ( name === 'style' && node.style.setAttribute ) {\n\t\t\t\tupdateMethod = updateIEStyleAttribute;\n\t\t\t} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\t\t\tupdateMethod = updateClassName;\n\t\t\t} else if ( this.useProperty ) {\n\t\t\t\tupdateMethod = updateBoolean;\n\t\t\t}\n\t\t\tif ( !updateMethod ) {\n\t\t\t\tupdateMethod = updateEverythingElse;\n\t\t\t}\n\t\t\tthis.update = updateMethod;\n\t\t\tthis.update();\n\t\t};\n\t}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );\n\n\t/* virtualdom/items/Element/Attribute/_Attribute.js */\n\tvar Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {\n\n\t\tvar Attribute = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tAttribute.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Attribute;\n\t}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );\n\n\t/* virtualdom/items/Element/prototype/init/createAttributes.js */\n\tvar virtualdom_items_Element$init_createAttributes = function( Attribute ) {\n\n\t\treturn function( element, attributes ) {\n\t\t\tvar name, attribute, result = [];\n\t\t\tfor ( name in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\t\t\tattribute = new Attribute( {\n\t\t\t\t\t\telement: element,\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: attributes[ name ],\n\t\t\t\t\t\troot: element.root\n\t\t\t\t\t} );\n\t\t\t\t\tresult.push( result[ name ] = attribute );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( Attribute );\n\n\t/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */\n\tvar ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {\n\n\t\tvar __export;\n\t\tvar Fragment, div;\n\t\tif ( typeof document !== 'undefined' ) {\n\t\t\tdiv = createElement( 'div' );\n\t\t}\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tvar ConditionalAttribute = function( element, template ) {\n\t\t\tthis.element = element;\n\t\t\tthis.root = element.root;\n\t\t\tthis.parentFragment = element.parentFragment;\n\t\t\tthis.attributes = [];\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\troot: element.root,\n\t\t\t\towner: this,\n\t\t\t\ttemplate: [ template ]\n\t\t\t} );\n\t\t};\n\t\tConditionalAttribute.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( this.node ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t\tthis.element.bubble();\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\trender: function( node ) {\n\t\t\t\tthis.node = node;\n\t\t\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\t\t\t\tthis.update();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar str, attrs;\n\t\t\t\tstr = this.fragment.toString();\n\t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\t\t\t\t// any attributes that previously existed but no longer do\n\t\t\t\t// must be removed\n\t\t\t\tthis.attributes.filter( function( a ) {\n\t\t\t\t\treturn notIn( attrs, a );\n\t\t\t\t} ).forEach( function( a ) {\n\t\t\t\t\tthis$0.node.removeAttribute( a.name );\n\t\t\t\t} );\n\t\t\t\tattrs.forEach( function( a ) {\n\t\t\t\t\tthis$0.node.setAttribute( a.name, a.value );\n\t\t\t\t} );\n\t\t\t\tthis.attributes = attrs;\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t}\n\t\t};\n\t\t__export = ConditionalAttribute;\n\n\t\tfunction parseAttributes( str, isSvg ) {\n\t\t\tvar tag = isSvg ? 'svg' : 'div';\n\t\t\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\t\t\treturn toArray( div.childNodes[ 0 ].attributes );\n\t\t}\n\n\t\tfunction notIn( haystack, needle ) {\n\t\t\tvar i = haystack.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( haystack[ i ].name === needle.name ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn __export;\n\t}( circular, namespaces, createElement, toArray );\n\n\t/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */\n\tvar virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {\n\n\t\treturn function( element, attributes ) {\n\t\t\tif ( !attributes ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn attributes.map( function( a ) {\n\t\t\t\treturn new ConditionalAttribute( element, a );\n\t\t\t} );\n\t\t};\n\t}( ConditionalAttribute );\n\n\t/* utils/extend.js */\n\tvar extend = function( target ) {\n\t\tvar SLICE$0 = Array.prototype.slice;\n\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\tvar prop, source;\n\t\twhile ( source = sources.shift() ) {\n\t\t\tfor ( prop in source ) {\n\t\t\t\tif ( source.hasOwnProperty( prop ) ) {\n\t\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t};\n\n\t/* virtualdom/items/Element/Binding/Binding.js */\n\tvar Binding = function( runloop, warn, create, extend, removeFromArray ) {\n\n\t\tvar Binding = function( element ) {\n\t\t\tvar interpolator, keypath, value;\n\t\t\tthis.element = element;\n\t\t\tthis.root = element.root;\n\t\t\tthis.attribute = element.attributes[ this.name || 'value' ];\n\t\t\tinterpolator = this.attribute.interpolator;\n\t\t\tinterpolator.twowayBinding = this;\n\t\t\tif ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {\n\t\t\t\twarn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t\t//\n\t\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t\t// assumption. That assumption is that the input in question should\n\t\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t\t// and not `foo.bar`.\n\t\t\t//\n\t\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\t\tif ( !interpolator.keypath ) {\n\t\t\t\tinterpolator.resolver.forceResolution();\n\t\t\t}\n\t\t\tthis.keypath = keypath = interpolator.keypath;\n\t\t\t// initialise value, if it's undefined\n\t\t\tif ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {\n\t\t\t\tvalue = this.getInitialValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tBinding.prototype = {\n\t\t\thandleChange: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.attribute.locked = true;\n\t\t\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t} );\n\t\t\t\trunloop.end();\n\t\t\t},\n\t\t\trebound: function() {\n\t\t\t\tvar bindings, oldKeypath, newKeypath;\n\t\t\t\toldKeypath = this.keypath;\n\t\t\t\tnewKeypath = this.attribute.interpolator.keypath;\n\t\t\t\t// The attribute this binding is linked to has already done the work\n\t\t\t\tif ( oldKeypath === newKeypath ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath ], this );\n\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\tbindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );\n\t\t\t\tbindings.push( this );\n\t\t\t},\n\t\t\tunbind: function() {}\n\t\t};\n\t\tBinding.extend = function( properties ) {\n\t\t\tvar Parent = this,\n\t\t\t\tSpecialisedBinding;\n\t\t\tSpecialisedBinding = function( element ) {\n\t\t\t\tBinding.call( this, element );\n\t\t\t\tif ( this.init ) {\n\t\t\t\t\tthis.init();\n\t\t\t\t}\n\t\t\t};\n\t\t\tSpecialisedBinding.prototype = create( Parent.prototype );\n\t\t\textend( SpecialisedBinding.prototype, properties );\n\t\t\tSpecialisedBinding.extend = Binding.extend;\n\t\t\treturn SpecialisedBinding;\n\t\t};\n\t\treturn Binding;\n\t}( runloop, warn, create, extend, removeFromArray );\n\n\t/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */\n\tvar handleDomEvent = function handleChange() {\n\t\tthis._ractive.binding.handleChange();\n\t};\n\n\t/* virtualdom/items/Element/Binding/ContentEditableBinding.js */\n\tvar ContentEditableBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar ContentEditableBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.innerHTML;\n\t\t\t}\n\t\t} );\n\t\treturn ContentEditableBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/shared/getSiblings.js */\n\tvar getSiblings = function() {\n\n\t\tvar sets = {};\n\t\treturn function getSiblings( id, group, keypath ) {\n\t\t\tvar hash = id + group + keypath;\n\t\t\treturn sets[ hash ] || ( sets[ hash ] = [] );\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Element/Binding/RadioBinding.js */\n\tvar RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\n\t\tvar RadioBinding = Binding.extend( {\n\t\t\tname: 'checked',\n\t\t\tinit: function() {\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.siblings.forEach( function( binding ) {\n\t\t\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t\t\t} );\n\t\t\t\trunloop.end();\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.checked;\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t}\n\t\t} );\n\t\treturn RadioBinding;\n\t}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/RadioNameBinding.js */\n\tvar RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {\n\n\t\tvar RadioNameBinding = Binding.extend( {\n\t\t\tname: 'name',\n\t\t\tinit: function() {\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t\tthis.radioName = true;\n\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\tthis.attribute.twoway = true;\n\t\t\t},\n\t\t\tgetInitialValue: function() {\n\t\t\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t\t}\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\treturn node._ractive ? node._ractive.value : node.value;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\t// If this <input> is the one that's checked, then the value of its\n\t\t\t\t// `name` keypath gets set to its value\n\t\t\t\tif ( this.element.node.checked ) {\n\t\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\trebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar node;\n\t\t\t\tBinding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\tif ( node = this.element.node ) {\n\t\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t}\n\t\t} );\n\t\treturn RadioNameBinding;\n\t}( removeFromArray, Binding, handleDomEvent, getSiblings );\n\n\t/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */\n\tvar CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\n\t\tvar CheckboxNameBinding = Binding.extend( {\n\t\t\tname: 'name',\n\t\t\tgetInitialValue: function() {\n\t\t\t\t// This only gets called once per group (of inputs that\n\t\t\t\t// share a name), because it only gets called if there\n\t\t\t\t// isn't an initial value. By the same token, we can make\n\t\t\t\t// a note of that fact that there was no initial value,\n\t\t\t\t// and populate it using any `checked` attributes that\n\t\t\t\t// exist (which users should avoid, but which we should\n\t\t\t\t// support anyway to avoid breaking expectations)\n\t\t\t\tthis.noInitialValue = true;\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tinit: function() {\n\t\t\t\tvar existingValue, bindingValue;\n\t\t\t\tthis.checkboxName = true;\n\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\tthis.attribute.twoway = true;\n\t\t\t\t// we set this property so that the attribute gets the correct update method\n\t\t\t\t// Each input has a reference to an array containing it and its\n\t\t\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t\t\t// the status of all inputs within the group\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t\tif ( this.noInitialValue ) {\n\t\t\t\t\tthis.siblings.noInitialValue = true;\n\t\t\t\t}\n\t\t\t\t// If no initial value was set, and this input is checked, we\n\t\t\t\t// update the model\n\t\t\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\t\texistingValue.push( bindingValue );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node,\n\t\t\t\t\texistingValue, bindingValue;\n\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\tif ( isArray( existingValue ) ) {\n\t\t\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t\t\t} else {\n\t\t\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t\t\t}\n\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\tnode.checked = this.isChecked;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t// in case of IE emergency, bind to click event as well\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tchanged: function() {\n\t\t\t\tvar wasChecked = !!this.isChecked;\n\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\treturn this.isChecked === wasChecked;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t\t\t}\n\t\t} );\n\n\t\tfunction isChecked( binding ) {\n\t\t\treturn binding.isChecked;\n\t\t}\n\n\t\tfunction getValue( binding ) {\n\t\t\treturn binding.element.getAttribute( 'value' );\n\t\t}\n\t\treturn CheckboxNameBinding;\n\t}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/CheckboxBinding.js */\n\tvar CheckboxBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar CheckboxBinding = Binding.extend( {\n\t\t\tname: 'checked',\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.checked;\n\t\t\t}\n\t\t} );\n\t\treturn CheckboxBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/SelectBinding.js */\n\tvar SelectBinding = function( runloop, Binding, handleDomEvent ) {\n\n\t\tvar SelectBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\tvar options = this.element.options,\n\t\t\t\t\tlen, i, value, optionWasSelected;\n\t\t\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ti = len = options.length;\n\t\t\t\tif ( !len ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// take the final selected option...\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( options[ i ].getAttribute( 'selected' ) ) {\n\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// or the first non-disabled option, if none are selected\n\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\twhile ( ++i < len ) {\n\t\t\t\t\t\tif ( !options[ i ].getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t\t\t// other more expensive work\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.element.attributes.value.value = value;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\t// TODO this method is an anomaly... is it necessary?\n\t\t\tsetValue: function( value ) {\n\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar options, i, len, option, optionValue;\n\t\t\t\toptions = this.element.node.options;\n\t\t\t\tlen = options.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( options[ i ].selected ) {\n\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\treturn optionValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceUpdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar value = this.getValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t} );\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn SelectBinding;\n\t}( runloop, Binding, handleDomEvent );\n\n\t/* utils/arrayContentsMatch.js */\n\tvar arrayContentsMatch = function( isArray ) {\n\n\t\treturn function( a, b ) {\n\t\t\tvar i;\n\t\t\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( a.length !== b.length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti = a.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}( isArray );\n\n\t/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */\n\tvar MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {\n\n\t\tvar MultipleSelectBinding = SelectBinding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn this.element.options.filter( function( option ) {\n\t\t\t\t\treturn option.getAttribute( 'selected' );\n\t\t\t\t} ).map( function( option ) {\n\t\t\t\t\treturn option.getAttribute( 'value' );\n\t\t\t\t} );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar valueFromModel;\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\t\t\t\tif ( valueFromModel === undefined ) {\n\t\t\t\t\t// get value from DOM, if possible\n\t\t\t\t\tthis.handleChange();\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tsetValue: function() {\n\t\t\t\tthrow new Error( 'TODO not implemented yet' );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar selectedValues, options, i, len, option, optionValue;\n\t\t\t\tselectedValues = [];\n\t\t\t\toptions = this.element.node.options;\n\t\t\t\tlen = options.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\tselectedValues.push( optionValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn selectedValues;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\tvar attribute, previousValue, value;\n\t\t\t\tattribute = this.attribute;\n\t\t\t\tpreviousValue = attribute.value;\n\t\t\t\tvalue = this.getValue();\n\t\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tforceUpdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar value = this.getValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t} );\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdateModel: function() {\n\t\t\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn MultipleSelectBinding;\n\t}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/FileListBinding.js */\n\tvar FileListBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar FileListBinding = Binding.extend( {\n\t\t\trender: function() {\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.files;\n\t\t\t}\n\t\t} );\n\t\treturn FileListBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/GenericBinding.js */\n\tvar GenericBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar __export;\n\t\tvar GenericBinding, getOptions;\n\t\tgetOptions = {\n\t\t\tevaluateWrapped: true\n\t\t};\n\t\tGenericBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.value;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t\t\t}\n\t\t} );\n\t\t__export = GenericBinding;\n\n\t\tfunction handleBlur() {\n\t\t\tvar value;\n\t\t\thandleDomEvent.call( this );\n\t\t\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );\n\t\t\tthis.value = value == undefined ? '' : value;\n\t\t}\n\t\treturn __export;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/NumericBinding.js */\n\tvar NumericBinding = function( GenericBinding ) {\n\n\t\treturn GenericBinding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar value = parseFloat( this.element.node.value );\n\t\t\t\treturn isNaN( value ) ? undefined : value;\n\t\t\t}\n\t\t} );\n\t}( GenericBinding );\n\n\t/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */\n\tvar virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {\n\n\t\tvar __export;\n\t\t__export = function createTwowayBinding( element ) {\n\t\t\tvar attributes = element.attributes,\n\t\t\t\ttype, Binding, bindName, bindChecked;\n\t\t\t// if this is a late binding, and there's already one, it\n\t\t\t// needs to be torn down\n\t\t\tif ( element.binding ) {\n\t\t\t\telement.binding.teardown();\n\t\t\t\telement.binding = null;\n\t\t\t}\n\t\t\t// contenteditable\n\t\t\tif ( // if the contenteditable attribute is true or is bindable and may thus become true\n\t\t\t\t( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = ContentEditableBinding;\n\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\t\t\tbindName = isBindable( attributes.name );\n\t\t\t\t\tbindChecked = isBindable( attributes.checked );\n\t\t\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\tmessage: 'badRadioInputBinding'\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tif ( bindName ) {\n\t\t\t\t\t\tBinding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t\t\t\t\t} else if ( bindChecked ) {\n\t\t\t\t\t\tBinding = type === 'radio' ? RadioBinding : CheckboxBinding;\n\t\t\t\t\t}\n\t\t\t\t} else if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = FileListBinding;\n\t\t\t\t} else if ( isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;\n\t\t\t\t}\n\t\t\t} else if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;\n\t\t\t} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = GenericBinding;\n\t\t\t}\n\t\t\tif ( Binding ) {\n\t\t\t\treturn new Binding( element );\n\t\t\t}\n\t\t};\n\n\t\tfunction isBindable( attribute ) {\n\t\t\treturn attribute && attribute.isBindable;\n\t\t}\n\t\treturn __export;\n\t}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/bubble.js */\n\tvar virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {\n\t\tvar hasAction = this.getAction();\n\t\tif ( hasAction && !this.hasListener ) {\n\t\t\tthis.listen();\n\t\t} else if ( !hasAction && this.hasListener ) {\n\t\t\tthis.unrender();\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/fire.js */\n\tvar virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {\n\n\t\treturn function EventHandler$fire( event ) {\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event\n\t\t\t} );\n\t\t};\n\t}( Ractive$shared_fireEvent );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/getAction.js */\n\tvar virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {\n\t\treturn this.action.toString().trim();\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/init.js */\n\tvar virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {\n\n\t\tvar __export;\n\t\tvar Fragment, getValueOptions = {\n\t\t\t\targs: true\n\t\t\t},\n\t\t\teventPattern = /^event(?:\\.(.+))?/;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function EventHandler$init( element, name, template ) {\n\t\t\tvar handler = this,\n\t\t\t\taction, refs, ractive;\n\t\t\thandler.element = element;\n\t\t\thandler.root = element.root;\n\t\t\thandler.name = name;\n\t\t\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\tmessage: 'noElementProxyEventWildcards',\n\t\t\t\t\targs: {\n\t\t\t\t\t\telement: element.tagName,\n\t\t\t\t\t\tevent: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthis.invalid = true;\n\t\t\t}\n\t\t\tif ( template.m ) {\n\t\t\t\trefs = template.a.r;\n\t\t\t\t// This is a method call\n\t\t\t\thandler.method = template.m;\n\t\t\t\thandler.keypaths = [];\n\t\t\t\thandler.fn = getFunctionFromString( template.a.s, refs.length );\n\t\t\t\thandler.parentFragment = element.parentFragment;\n\t\t\t\tractive = handler.root;\n\t\t\t\t// Create resolvers for each reference\n\t\t\t\thandler.refResolvers = refs.map( function( ref, i ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\t// special case - the `event` object\n\t\t\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\t\t\thandler.keypaths[ i ] = {\n\t\t\t\t\t\t\teventObject: true,\n\t\t\t\t\t\t\trefinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn createReferenceResolver( handler, ref, function( keypath ) {\n\t\t\t\t\t\thandler.resolve( i, keypath );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tthis.fire = fireMethodCall;\n\t\t\t} else {\n\t\t\t\t// Get action ('foo' in 'on-click='foo')\n\t\t\t\taction = template.n || template;\n\t\t\t\tif ( typeof action !== 'string' ) {\n\t\t\t\t\taction = new Fragment( {\n\t\t\t\t\t\ttemplate: action,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\towner: this\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis.action = action;\n\t\t\t\t// Get parameters\n\t\t\t\tif ( template.d ) {\n\t\t\t\t\tthis.dynamicParams = new Fragment( {\n\t\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\towner: this.element\n\t\t\t\t\t} );\n\t\t\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t\t\t} else if ( template.a ) {\n\t\t\t\t\tthis.params = template.a;\n\t\t\t\t\tthis.fire = fireEventWithParams;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction fireMethodCall( event ) {\n\t\t\tvar ractive, values, args;\n\t\t\tractive = this.root;\n\t\t\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\t\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t\t\t}\n\t\t\tvalues = this.keypaths.map( function( keypath ) {\n\t\t\t\tvar value, len, i;\n\t\t\t\tif ( keypath === undefined ) {\n\t\t\t\t\t// not yet resolved\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// TODO the refinements stuff would be better handled at parse time\n\t\t\t\tif ( keypath.eventObject ) {\n\t\t\t\t\tvalue = event;\n\t\t\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\t\tvalue = value[ keypath.refinements[ i ] ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} );\n\t\t\tractive.event = event;\n\t\t\targs = this.fn.apply( null, values );\n\t\t\tractive[ this.method ].apply( ractive, args );\n\t\t\tdelete ractive.event;\n\t\t}\n\n\t\tfunction fireEventWithParams( event ) {\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event,\n\t\t\t\targs: this.params\n\t\t\t} );\n\t\t}\n\n\t\tfunction fireEventWithDynamicParams( event ) {\n\t\t\tvar args = this.dynamicParams.getValue( getValueOptions );\n\t\t\t// need to strip [] from ends if a string!\n\t\t\tif ( typeof args === 'string' ) {\n\t\t\t\targs = args.substr( 1, args.length - 2 );\n\t\t\t}\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event,\n\t\t\t\targs: args\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );\n\n\t/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */\n\tvar genericHandler = function genericHandler( event ) {\n\t\tvar storage, handler;\n\t\tstorage = this._ractive;\n\t\thandler = storage.events[ event.type ];\n\t\thandler.fire( {\n\t\t\tnode: this,\n\t\t\toriginal: event,\n\t\t\tindex: storage.index,\n\t\t\tkeypath: storage.keypath,\n\t\t\tcontext: storage.root.get( storage.keypath )\n\t\t} );\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/listen.js */\n\tvar virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {\n\n\t\tvar __export;\n\t\tvar customHandlers = {},\n\t\t\ttouchEvents = {\n\t\t\t\ttouchstart: true,\n\t\t\t\ttouchmove: true,\n\t\t\t\ttouchend: true,\n\t\t\t\ttouchcancel: true,\n\t\t\t\t//not w3c, but supported in some browsers\n\t\t\t\ttouchleave: true\n\t\t\t};\n\t\t__export = function EventHandler$listen() {\n\t\t\tvar definition, name = this.name;\n\t\t\tif ( this.invalid ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( definition = config.registries.events.find( this.root, name ) ) {\n\t\t\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t\t\t} else {\n\t\t\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\t\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {\n\t\t\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tplugin: 'event',\n\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.node.addEventListener( name, genericHandler, false );\n\t\t\t}\n\t\t\tthis.hasListener = true;\n\t\t};\n\n\t\tfunction getCustomHandler( name ) {\n\t\t\tif ( !customHandlers[ name ] ) {\n\t\t\t\tcustomHandlers[ name ] = function( event ) {\n\t\t\t\t\tvar storage = event.node._ractive;\n\t\t\t\t\tevent.index = storage.index;\n\t\t\t\t\tevent.keypath = storage.keypath;\n\t\t\t\t\tevent.context = storage.root.get( storage.keypath );\n\t\t\t\t\tstorage.events[ name ].fire( event );\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn customHandlers[ name ];\n\t\t}\n\t\treturn __export;\n\t}( config, genericHandler, log );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/rebind.js */\n\tvar virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\tvar fragment;\n\t\tif ( this.method ) {\n\t\t\tfragment = this.element.parentFragment;\n\t\t\tthis.refResolvers.forEach( rebind );\n\t\t\treturn;\n\t\t}\n\t\tif ( typeof this.action !== 'string' ) {\n\t\t\trebind( this.action );\n\t\t}\n\t\tif ( this.dynamicParams ) {\n\t\t\trebind( this.dynamicParams );\n\t\t}\n\n\t\tfunction rebind( thing ) {\n\t\t\tthing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/render.js */\n\tvar virtualdom_items_Element_EventHandler$render = function EventHandler$render() {\n\t\tthis.node = this.element.node;\n\t\t// store this on the node itself, so it can be retrieved by a\n\t\t// universal handler\n\t\tthis.node._ractive.events[ this.name ] = this;\n\t\tif ( this.method || this.getAction() ) {\n\t\t\tthis.listen();\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/resolve.js */\n\tvar virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {\n\t\tthis.keypaths[ index ] = keypath;\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/unbind.js */\n\tvar virtualdom_items_Element_EventHandler$unbind = function() {\n\n\t\tvar __export;\n\t\t__export = function EventHandler$unbind() {\n\t\t\tif ( this.method ) {\n\t\t\t\tthis.refResolvers.forEach( unbind );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Tear down dynamic name\n\t\t\tif ( typeof this.action !== 'string' ) {\n\t\t\t\tthis.action.unbind();\n\t\t\t}\n\t\t\t// Tear down dynamic parameters\n\t\t\tif ( this.dynamicParams ) {\n\t\t\t\tthis.dynamicParams.unbind();\n\t\t\t}\n\t\t};\n\n\t\tfunction unbind( x ) {\n\t\t\tx.unbind();\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Element/EventHandler/prototype/unrender.js */\n\tvar virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {\n\n\t\treturn function EventHandler$unrender() {\n\t\t\tif ( this.custom ) {\n\t\t\t\tthis.custom.teardown();\n\t\t\t} else {\n\t\t\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t\t\t}\n\t\t\tthis.hasListener = false;\n\t\t};\n\t}( genericHandler );\n\n\t/* virtualdom/items/Element/EventHandler/_EventHandler.js */\n\tvar EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {\n\n\t\tvar EventHandler = function( element, name, template ) {\n\t\t\tthis.init( element, name, template );\n\t\t};\n\t\tEventHandler.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tfire: fire,\n\t\t\tgetAction: getAction,\n\t\t\tinit: init,\n\t\t\tlisten: listen,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\tresolve: resolve,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn EventHandler;\n\t}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );\n\n\t/* virtualdom/items/Element/prototype/init/createEventHandlers.js */\n\tvar virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {\n\n\t\treturn function( element, template ) {\n\t\t\tvar i, name, names, handler, result = [];\n\t\t\tfor ( name in template ) {\n\t\t\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\t\t\tnames = name.split( '-' );\n\t\t\t\t\ti = names.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\thandler = new EventHandler( element, names[ i ], template[ name ] );\n\t\t\t\t\t\tresult.push( handler );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( EventHandler );\n\n\t/* virtualdom/items/Element/Decorator/_Decorator.js */\n\tvar Decorator = function( log, circular, config ) {\n\n\t\tvar Fragment, getValueOptions, Decorator;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tgetValueOptions = {\n\t\t\targs: true\n\t\t};\n\t\tDecorator = function( element, template ) {\n\t\t\tvar decorator = this,\n\t\t\t\tractive, name, fragment;\n\t\t\tdecorator.element = element;\n\t\t\tdecorator.root = ractive = element.root;\n\t\t\tname = template.n || template;\n\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: name,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tname = fragment.toString();\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tif ( template.a ) {\n\t\t\t\tdecorator.params = template.a;\n\t\t\t} else if ( template.d ) {\n\t\t\t\tdecorator.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tdecorator.params = decorator.fragment.getValue( getValueOptions );\n\t\t\t\tdecorator.fragment.bubble = function() {\n\t\t\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\t\t\tdecorator.params = this.getValue( getValueOptions );\n\t\t\t\t\tif ( decorator.ready ) {\n\t\t\t\t\t\tdecorator.update();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tdecorator.fn = config.registries.decorators.find( ractive, name );\n\t\t\tif ( !decorator.fn ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tplugin: 'decorator',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\tDecorator.prototype = {\n\t\t\tinit: function() {\n\t\t\t\tvar decorator = this,\n\t\t\t\t\tnode, result, args;\n\t\t\t\tnode = decorator.element.node;\n\t\t\t\tif ( decorator.params ) {\n\t\t\t\t\targs = [ node ].concat( decorator.params );\n\t\t\t\t\tresult = decorator.fn.apply( decorator.root, args );\n\t\t\t\t} else {\n\t\t\t\t\tresult = decorator.fn.call( decorator.root, node );\n\t\t\t\t}\n\t\t\t\tif ( !result || !result.teardown ) {\n\t\t\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t\t\t}\n\t\t\t\t// TODO does this make sense?\n\t\t\t\tdecorator.actual = result;\n\t\t\t\tdecorator.ready = true;\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tif ( this.actual.update ) {\n\t\t\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t\t\t} else {\n\t\t\t\t\tthis.actual.teardown( true );\n\t\t\t\t\tthis.init();\n\t\t\t\t}\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function( updating ) {\n\t\t\t\tthis.actual.teardown();\n\t\t\t\tif ( !updating && this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Decorator;\n\t}( log, circular, config );\n\n\t/* virtualdom/items/Element/special/select/sync.js */\n\tvar sync = function( toArray ) {\n\n\t\tvar __export;\n\t\t__export = function syncSelect( selectElement ) {\n\t\t\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\t\t\tselectNode = selectElement.node;\n\t\t\tif ( !selectNode ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toptions = toArray( selectNode.options );\n\t\t\tselectValue = selectElement.getAttribute( 'value' );\n\t\t\tisMultiple = selectElement.getAttribute( 'multiple' );\n\t\t\t// If the <select> has a specified value, that should override\n\t\t\t// these options\n\t\t\tif ( selectValue !== undefined ) {\n\t\t\t\toptions.forEach( function( o ) {\n\t\t\t\t\tvar optionValue, shouldSelect;\n\t\t\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\t\t\t\t\tif ( shouldSelect ) {\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t}\n\t\t\t\t\to.selected = shouldSelect;\n\t\t\t\t} );\n\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\tif ( options[ 0 ] ) {\n\t\t\t\t\t\toptions[ 0 ].selected = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( selectElement.binding ) {\n\t\t\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( selectElement.binding ) {\n\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t}\n\t\t};\n\n\t\tfunction valueContains( selectValue, optionValue ) {\n\t\t\tvar i = selectValue.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( toArray );\n\n\t/* virtualdom/items/Element/special/select/bubble.js */\n\tvar bubble = function( runloop, syncSelect ) {\n\n\t\treturn function bubbleSelect() {\n\t\t\tvar this$0 = this;\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tsyncSelect( this$0 );\n\t\t\t\t\tthis$0.dirty = false;\n\t\t\t\t} );\n\t\t\t}\n\t\t\tthis.parentFragment.bubble();\n\t\t};\n\t}( runloop, sync );\n\n\t/* virtualdom/items/Element/special/option/findParentSelect.js */\n\tvar findParentSelect = function findParentSelect( element ) {\n\t\tdo {\n\t\t\tif ( element.name === 'select' ) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t} while ( element = element.parent );\n\t};\n\n\t/* virtualdom/items/Element/special/option/init.js */\n\tvar init = function( findParentSelect ) {\n\n\t\treturn function initOption( option, template ) {\n\t\t\toption.select = findParentSelect( option.parent );\n\t\t\t// we might be inside a <datalist> element\n\t\t\tif ( !option.select ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toption.select.options.push( option );\n\t\t\t// If the value attribute is missing, use the element's content\n\t\t\tif ( !template.a ) {\n\t\t\t\ttemplate.a = {};\n\t\t\t}\n\t\t\t// ...as long as it isn't disabled\n\t\t\tif ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\t\t\ttemplate.a.value = template.f;\n\t\t\t}\n\t\t\t// If there is a `selected` attribute, but the <select>\n\t\t\t// already has a value, delete it\n\t\t\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tdelete template.a.selected;\n\t\t\t}\n\t\t};\n\t}( findParentSelect );\n\n\t/* virtualdom/items/Element/prototype/init.js */\n\tvar virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Element$init( options ) {\n\t\t\tvar parentFragment, template, ractive, binding, bindings;\n\t\t\tthis.type = types.ELEMENT;\n\t\t\t// stuff we'll need later\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\ttemplate = this.template = options.template;\n\t\t\tthis.parent = options.pElement || parentFragment.pElement;\n\t\t\tthis.root = ractive = parentFragment.root;\n\t\t\tthis.index = options.index;\n\t\t\tthis.name = enforceCase( template.e );\n\t\t\t// Special case - <option> elements\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tinitOption( this, template );\n\t\t\t}\n\t\t\t// Special case - <select> elements\n\t\t\tif ( this.name === 'select' ) {\n\t\t\t\tthis.options = [];\n\t\t\t\tthis.bubble = bubbleSelect;\n\t\t\t}\n\t\t\t// create attributes\n\t\t\tthis.attributes = createAttributes( this, template.a );\n\t\t\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\t\t\t// append children, if there are any\n\t\t\tif ( template.f ) {\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template.f,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: this,\n\t\t\t\t\tpElement: this\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// create twoway binding\n\t\t\tif ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\t\t\tthis.binding = binding;\n\t\t\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );\n\t\t\t\tbindings.push( binding );\n\t\t\t}\n\t\t\t// create event proxies\n\t\t\tif ( template.v ) {\n\t\t\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t\t\t}\n\t\t\t// create decorator\n\t\t\tif ( template.o ) {\n\t\t\t\tthis.decorator = new Decorator( this, template.o );\n\t\t\t}\n\t\t\t// create transitions\n\t\t\tthis.intro = template.t0 || template.t1;\n\t\t\tthis.outro = template.t0 || template.t2;\n\t\t};\n\t}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );\n\n\t/* virtualdom/items/shared/utils/startsWith.js */\n\tvar startsWith = function( startsWithKeypath ) {\n\n\t\treturn function startsWith( target, keypath ) {\n\t\t\treturn target === keypath || startsWithKeypath( target, keypath );\n\t\t};\n\t}( startsWithKeypath );\n\n\t/* virtualdom/items/shared/utils/assignNewKeypath.js */\n\tvar assignNewKeypath = function( startsWith, getNewKeypath ) {\n\n\t\treturn function assignNewKeypath( target, property, oldKeypath, newKeypath ) {\n\t\t\tvar existingKeypath = target[ property ];\n\t\t\tif ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );\n\t\t};\n\t}( startsWith, getNewKeypath );\n\n\t/* virtualdom/items/Element/prototype/rebind.js */\n\tvar virtualdom_items_Element$rebind = function( assignNewKeypath ) {\n\n\t\treturn function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar i, storage, liveQueries, ractive;\n\t\t\tif ( this.attributes ) {\n\t\t\t\tthis.attributes.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.conditionalAttributes ) {\n\t\t\t\tthis.conditionalAttributes.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.decorator ) {\n\t\t\t\trebind( this.decorator );\n\t\t\t}\n\t\t\t// rebind children\n\t\t\tif ( this.fragment ) {\n\t\t\t\trebind( this.fragment );\n\t\t\t}\n\t\t\t// Update live queries, if necessary\n\t\t\tif ( liveQueries = this.liveQueries ) {\n\t\t\t\tractive = this.root;\n\t\t\t\ti = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tliveQueries[ i ]._makeDirty();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this.node && ( storage = this.node._ractive ) ) {\n\t\t\t\t// adjust keypath if needed\n\t\t\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t\t\t\tif ( indexRef != undefined ) {\n\t\t\t\t\tstorage.index[ indexRef ] = newIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction rebind( thing ) {\n\t\t\t\tthing.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t}( assignNewKeypath );\n\n\t/* virtualdom/items/Element/special/img/render.js */\n\tvar render = function renderImage( img ) {\n\t\tvar loadHandler;\n\t\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t\t// from overriding width and height when it loads the src\n\t\tif ( img.attributes.width || img.attributes.height ) {\n\t\t\timg.node.addEventListener( 'load', loadHandler = function() {\n\t\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\t\theight = img.getAttribute( 'height' );\n\t\t\t\tif ( width !== undefined ) {\n\t\t\t\t\timg.node.setAttribute( 'width', width );\n\t\t\t\t}\n\t\t\t\tif ( height !== undefined ) {\n\t\t\t\t\timg.node.setAttribute( 'height', height );\n\t\t\t\t}\n\t\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t\t}, false );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Transition/prototype/init.js */\n\tvar virtualdom_items_Element_Transition$init = function( log, config, circular ) {\n\n\t\tvar Fragment, getValueOptions = {};\n\t\t// TODO what are the options?\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Transition$init( element, template, isIntro ) {\n\t\t\tvar t = this,\n\t\t\t\tractive, name, fragment;\n\t\t\tt.element = element;\n\t\t\tt.root = ractive = element.root;\n\t\t\tt.isIntro = isIntro;\n\t\t\tname = template.n || template;\n\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: name,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tname = fragment.toString();\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tt.name = name;\n\t\t\tif ( template.a ) {\n\t\t\t\tt.params = template.a;\n\t\t\t} else if ( template.d ) {\n\t\t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t\t\t// 'dependency thrashing'?\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tt.params = fragment.getValue( getValueOptions );\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tt._fn = config.registries.transitions.find( ractive, name );\n\t\t\tif ( !t._fn ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tplugin: 'transition',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\t}( log, config, circular );\n\n\t/* utils/camelCase.js */\n\tvar camelCase = function( hyphenatedStr ) {\n\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {\n\t\t\treturn $1.toUpperCase();\n\t\t} );\n\t};\n\n\t/* virtualdom/items/Element/Transition/helpers/prefix.js */\n\tvar prefix = function( isClient, vendors, createElement, camelCase ) {\n\n\t\tvar prefix, prefixCache, testStyle;\n\t\tif ( !isClient ) {\n\t\t\tprefix = null;\n\t\t} else {\n\t\t\tprefixCache = {};\n\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\tprefix = function( prop ) {\n\t\t\t\tvar i, vendor, capped;\n\t\t\t\tprop = camelCase( prop );\n\t\t\t\tif ( !prefixCache[ prop ] ) {\n\t\t\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// test vendors...\n\t\t\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\t\t\t\t\t\ti = vendors.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn prefixCache[ prop ];\n\t\t\t};\n\t\t}\n\t\treturn prefix;\n\t}( isClient, vendors, createElement, camelCase );\n\n\t/* virtualdom/items/Element/Transition/prototype/getStyle.js */\n\tvar virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {\n\n\t\tvar getStyle, getComputedStyle;\n\t\tif ( !isClient ) {\n\t\t\tgetStyle = null;\n\t\t} else {\n\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\tgetStyle = function( props ) {\n\t\t\t\tvar computedStyle, styles, i, prop, value;\n\t\t\t\tcomputedStyle = getComputedStyle( this.node );\n\t\t\t\tif ( typeof props === 'string' ) {\n\t\t\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif ( !isArray( props ) ) {\n\t\t\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t\t\t}\n\t\t\t\tstyles = {};\n\t\t\t\ti = props.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = props[ i ];\n\t\t\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t\tstyles[ prop ] = value;\n\t\t\t\t}\n\t\t\t\treturn styles;\n\t\t\t};\n\t\t}\n\t\treturn getStyle;\n\t}( legacy, isClient, isArray, prefix );\n\n\t/* virtualdom/items/Element/Transition/prototype/setStyle.js */\n\tvar virtualdom_items_Element_Transition$setStyle = function( prefix ) {\n\n\t\treturn function( style, value ) {\n\t\t\tvar prop;\n\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\tthis.node.style[ prefix( style ) ] = value;\n\t\t\t} else {\n\t\t\t\tfor ( prop in style ) {\n\t\t\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t}( prefix );\n\n\t/* shared/Ticker.js */\n\tvar Ticker = function( warn, getTime, animations ) {\n\n\t\tvar __export;\n\t\tvar Ticker = function( options ) {\n\t\t\tvar easing;\n\t\t\tthis.duration = options.duration;\n\t\t\tthis.step = options.step;\n\t\t\tthis.complete = options.complete;\n\t\t\t// easing\n\t\t\tif ( typeof options.easing === 'string' ) {\n\t\t\t\teasing = options.root.easing[ options.easing ];\n\t\t\t\tif ( !easing ) {\n\t\t\t\t\twarn( 'Missing easing function (\"' + options.easing + '\"). You may need to download a plugin from [TODO]' );\n\t\t\t\t\teasing = linear;\n\t\t\t\t}\n\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t\t\t\teasing = options.easing;\n\t\t\t} else {\n\t\t\t\teasing = linear;\n\t\t\t}\n\t\t\tthis.easing = easing;\n\t\t\tthis.start = getTime();\n\t\t\tthis.end = this.start + this.duration;\n\t\t\tthis.running = true;\n\t\t\tanimations.add( this );\n\t\t};\n\t\tTicker.prototype = {\n\t\t\ttick: function( now ) {\n\t\t\t\tvar elapsed, eased;\n\t\t\t\tif ( !this.running ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( now > this.end ) {\n\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\tthis.step( 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.complete ) {\n\t\t\t\t\t\tthis.complete( 1 );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telapsed = now - this.start;\n\t\t\t\teased = this.easing( elapsed / this.duration );\n\t\t\t\tif ( this.step ) {\n\t\t\t\t\tthis.step( eased );\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tstop: function() {\n\t\t\t\tif ( this.abort ) {\n\t\t\t\t\tthis.abort();\n\t\t\t\t}\n\t\t\t\tthis.running = false;\n\t\t\t}\n\t\t};\n\t\t__export = Ticker;\n\n\t\tfunction linear( t ) {\n\t\t\treturn t;\n\t\t}\n\t\treturn __export;\n\t}( warn, getTime, animations );\n\n\t/* virtualdom/items/Element/Transition/helpers/unprefix.js */\n\tvar unprefix = function( vendors ) {\n\n\t\tvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\t\treturn function( prop ) {\n\t\t\treturn prop.replace( unprefixPattern, '' );\n\t\t};\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/helpers/hyphenate.js */\n\tvar hyphenate = function( vendors ) {\n\n\t\tvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\t\treturn function( str ) {\n\t\t\tvar hyphenated;\n\t\t\tif ( !str ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tif ( vendorPattern.test( str ) ) {\n\t\t\t\tstr = '-' + str;\n\t\t\t}\n\t\t\thyphenated = str.replace( /[A-Z]/g, function( match ) {\n\t\t\t\treturn '-' + match.toLowerCase();\n\t\t\t} );\n\t\t\treturn hyphenated;\n\t\t};\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */\n\tvar virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {\n\n\t\tvar createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},\n\t\t\tcannotUseCssTransitions = {};\n\t\tif ( !isClient ) {\n\t\t\tcreateTransitions = null;\n\t\t} else {\n\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\t// determine some facts about our environment\n\t\t\t( function() {\n\t\t\t\tif ( testStyle.transition !== undefined ) {\n\t\t\t\t\tTRANSITION = 'transition';\n\t\t\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\t\t\tTRANSITION = 'webkitTransition';\n\t\t\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t} else {\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t\t\t}\n\t\t\t}() );\n\t\t\tif ( TRANSITION ) {\n\t\t\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\t\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\t\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t\t\t}\n\t\t\tcreateTransitions = function( t, to, options, changedProperties, resolve ) {\n\t\t\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t\t\t// TODO use a fastdom-style mechanism?\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\t\t\t\t\tcheckComplete = function() {\n\t\t\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t\t\t// which properties\n\t\t\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\t\t\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\t\t\tt.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';\n\t\t\t\t\ttransitionEndHandler = function( event ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t\t\t// still transitioning...\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\t\t\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tvar i = changedProperties.length,\n\t\t\t\t\t\t\thash, originalValue, index, propertiesToTransitionInJs = [],\n\t\t\t\t\t\t\tprop, suffix;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprop = changedProperties[ i ];\n\t\t\t\t\t\t\thash = hashPrefix + prop;\n\t\t\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\t\t\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];\n\t\t\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\t\t\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\t\twarn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\t\t\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[ 0 ];\n\t\t\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\t\t\tpropertiesToTransitionInJs.push( {\n\t\t\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// javascript transitions\n\t\t\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\t\t\tnew Ticker( {\n\t\t\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\t\t\tstep: function( pos ) {\n\t\t\t\t\t\t\t\t\tvar prop, i;\n\t\t\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[ i ];\n\t\t\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0 );\n\t\t\t\t}, options.delay || 0 );\n\t\t\t};\n\t\t}\n\t\treturn createTransitions;\n\t}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */\n\tvar virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {\n\n\t\tvar hidden, vendor, prefix, i, visibility;\n\t\tif ( typeof document !== 'undefined' ) {\n\t\t\thidden = 'hidden';\n\t\t\tvisibility = {};\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = '';\n\t\t\t} else {\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\thidden = vendor + 'Hidden';\n\t\t\t\t\tif ( hidden in document ) {\n\t\t\t\t\t\tprefix = vendor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( prefix !== undefined ) {\n\t\t\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\t\t\t\t// initialise\n\t\t\t\tonChange();\n\t\t\t} else {\n\t\t\t\t// gah, we're in an old browser\n\t\t\t\tif ( 'onfocusout' in document ) {\n\t\t\t\t\tdocument.addEventListener( 'focusout', onHide );\n\t\t\t\t\tdocument.addEventListener( 'focusin', onShow );\n\t\t\t\t} else {\n\t\t\t\t\twindow.addEventListener( 'pagehide', onHide );\n\t\t\t\t\twindow.addEventListener( 'blur', onHide );\n\t\t\t\t\twindow.addEventListener( 'pageshow', onShow );\n\t\t\t\t\twindow.addEventListener( 'focus', onShow );\n\t\t\t\t}\n\t\t\t\tvisibility.hidden = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction onChange() {\n\t\t\tvisibility.hidden = document[ hidden ];\n\t\t}\n\n\t\tfunction onHide() {\n\t\t\tvisibility.hidden = true;\n\t\t}\n\n\t\tfunction onShow() {\n\t\t\tvisibility.hidden = false;\n\t\t}\n\t\treturn visibility;\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */\n\tvar virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {\n\n\t\tvar animateStyle, getComputedStyle, resolved;\n\t\tif ( !isClient ) {\n\t\t\tanimateStyle = null;\n\t\t} else {\n\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\tanimateStyle = function( style, value, options, complete ) {\n\t\t\t\tvar t = this,\n\t\t\t\t\tto;\n\t\t\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t\t\t// that way you'll never get CSS transitionend events\n\t\t\t\tif ( visibility.hidden ) {\n\t\t\t\t\tthis.setStyle( style, value );\n\t\t\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t\t\t}\n\t\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\t\tto = {};\n\t\t\t\t\tto[ style ] = value;\n\t\t\t\t} else {\n\t\t\t\t\tto = style;\n\t\t\t\t\t// shuffle arguments\n\t\t\t\t\tcomplete = options;\n\t\t\t\t\toptions = value;\n\t\t\t\t}\n\t\t\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t\t\t// callback function that gets called after the animation completes\n\t\t\t\t// TODO remove this check in a future version\n\t\t\t\tif ( !options ) {\n\t\t\t\t\twarn( 'The \"' + t.name + '\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );\n\t\t\t\t\toptions = t;\n\t\t\t\t\tcomplete = t.complete;\n\t\t\t\t}\n\t\t\t\tvar promise = new Promise( function( resolve ) {\n\t\t\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\t\t\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\t\t\tif ( !options.duration ) {\n\t\t\t\t\t\tt.setStyle( to );\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Get a list of the properties we're animating\n\t\t\t\t\tpropertyNames = Object.keys( to );\n\t\t\t\t\tchangedProperties = [];\n\t\t\t\t\t// Store the current styles\n\t\t\t\t\tcomputedStyle = getComputedStyle( t.node );\n\t\t\t\t\tfrom = {};\n\t\t\t\t\ti = propertyNames.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = propertyNames[ i ];\n\t\t\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\t\t\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\t\t\tif ( current != to[ prop ] ) {\n\t\t\t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\t\t\tchangedProperties.push( prop );\n\t\t\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = current;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t\t\t// will never fire! So we complete early\n\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcreateTransitions( t, to, options, changedProperties, resolve );\n\t\t\t\t} );\n\t\t\t\t// If a callback was supplied, do the honours\n\t\t\t\t// TODO remove this check in future\n\t\t\t\tif ( complete ) {\n\t\t\t\t\twarn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );\n\t\t\t\t\tpromise.then( complete );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}\n\t\treturn animateStyle;\n\t}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );\n\n\t/* utils/fillGaps.js */\n\tvar fillGaps = function( target ) {\n\t\tvar SLICE$0 = Array.prototype.slice;\n\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\tsources.forEach( function( s ) {\n\t\t\tfor ( var key in s ) {\n\t\t\t\tif ( s.hasOwnProperty( key ) && !( key in target ) ) {\n\t\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn target;\n\t};\n\n\t/* virtualdom/items/Element/Transition/prototype/processParams.js */\n\tvar virtualdom_items_Element_Transition$processParams = function( fillGaps ) {\n\n\t\treturn function( params, defaults ) {\n\t\t\tif ( typeof params === 'number' ) {\n\t\t\t\tparams = {\n\t\t\t\t\tduration: params\n\t\t\t\t};\n\t\t\t} else if ( typeof params === 'string' ) {\n\t\t\t\tif ( params === 'slow' ) {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 600\n\t\t\t\t\t};\n\t\t\t\t} else if ( params === 'fast' ) {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 200\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 400\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else if ( !params ) {\n\t\t\t\tparams = {};\n\t\t\t}\n\t\t\treturn fillGaps( {}, params, defaults );\n\t\t};\n\t}( fillGaps );\n\n\t/* virtualdom/items/Element/Transition/prototype/start.js */\n\tvar virtualdom_items_Element_Transition$start = function() {\n\n\t\tvar __export;\n\t\t__export = function Transition$start() {\n\t\t\tvar t = this,\n\t\t\t\tnode, originalStyle, completed;\n\t\t\tnode = t.node = t.element.node;\n\t\t\toriginalStyle = node.getAttribute( 'style' );\n\t\t\t// create t.complete() - we don't want this on the prototype,\n\t\t\t// because we don't want `this` silliness when passing it as\n\t\t\t// an argument\n\t\t\tt.complete = function( noReset ) {\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !noReset && t.isIntro ) {\n\t\t\t\t\tresetStyle( node, originalStyle );\n\t\t\t\t}\n\t\t\t\tnode._ractive.transition = null;\n\t\t\t\tt._manager.remove( t );\n\t\t\t\tcompleted = true;\n\t\t\t};\n\t\t\t// If the transition function doesn't exist, abort\n\t\t\tif ( !t._fn ) {\n\t\t\t\tt.complete();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt._fn.apply( t.root, [ t ].concat( t.params ) );\n\t\t};\n\n\t\tfunction resetStyle( node, style ) {\n\t\t\tif ( style ) {\n\t\t\t\tnode.setAttribute( 'style', style );\n\t\t\t} else {\n\t\t\t\t// Next line is necessary, to remove empty style attribute!\n\t\t\t\t// See http://stackoverflow.com/a/7167553\n\t\t\t\tnode.getAttribute( 'style' );\n\t\t\t\tnode.removeAttribute( 'style' );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Element/Transition/_Transition.js */\n\tvar Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {\n\n\t\tvar Fragment, Transition;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tTransition = function( owner, template, isIntro ) {\n\t\t\tthis.init( owner, template, isIntro );\n\t\t};\n\t\tTransition.prototype = {\n\t\t\tinit: init,\n\t\t\tstart: start,\n\t\t\tgetStyle: getStyle,\n\t\t\tsetStyle: setStyle,\n\t\t\tanimateStyle: animateStyle,\n\t\t\tprocessParams: processParams\n\t\t};\n\t\treturn Transition;\n\t}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );\n\n\t/* virtualdom/items/Element/prototype/render.js */\n\tvar virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {\n\n\t\tvar __export;\n\t\tvar updateCss, updateScript;\n\t\tupdateCss = function() {\n\t\t\tvar node = this.node,\n\t\t\t\tcontent = this.fragment.toString( false );\n\t\t\t// IE8 has no styleSheet unless there's a type text/css\n\t\t\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\t\t\tnode.type = 'text/css';\n\t\t\t}\n\t\t\tif ( node.styleSheet ) {\n\t\t\t\tnode.styleSheet.cssText = content;\n\t\t\t} else {\n\t\t\t\twhile ( node.hasChildNodes() ) {\n\t\t\t\t\tnode.removeChild( node.firstChild );\n\t\t\t\t}\n\t\t\t\tnode.appendChild( document.createTextNode( content ) );\n\t\t\t}\n\t\t};\n\t\tupdateScript = function() {\n\t\t\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\t\t\twarn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );\n\t\t\t}\n\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t};\n\t\t__export = function Element$render() {\n\t\t\tvar this$0 = this;\n\t\t\tvar root = this.root,\n\t\t\t\tnamespace, node;\n\t\t\tnamespace = getNamespace( this );\n\t\t\tnode = this.node = createElement( this.name, namespace );\n\t\t\t// Is this a top-level node of a component? If so, we may need to add\n\t\t\t// a data-rvcguid attribute, for CSS encapsulation\n\t\t\t// NOTE: css no longer copied to instance, so we check constructor.css -\n\t\t\t// we can enhance to handle instance, but this is more \"correct\" with current\n\t\t\t// functionality\n\t\t\tif ( root.constructor.css && this.parentFragment.getNode() === root.el ) {\n\t\t\t\tthis.node.setAttribute( 'data-rvcguid', root.constructor._guid );\n\t\t\t}\n\t\t\t// Add _ractive property to the node - we use this object to store stuff\n\t\t\t// related to proxy events, two-way bindings etc\n\t\t\tdefineProperty( this.node, '_ractive', {\n\t\t\t\tvalue: {\n\t\t\t\t\tproxy: this,\n\t\t\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\t\t\tindex: this.parentFragment.indexRefs,\n\t\t\t\t\tevents: create( null ),\n\t\t\t\t\troot: root\n\t\t\t\t}\n\t\t\t} );\n\t\t\t// Render attributes\n\t\t\tthis.attributes.forEach( function( a ) {\n\t\t\t\treturn a.render( node );\n\t\t\t} );\n\t\t\tthis.conditionalAttributes.forEach( function( a ) {\n\t\t\t\treturn a.render( node );\n\t\t\t} );\n\t\t\t// Render children\n\t\t\tif ( this.fragment ) {\n\t\t\t\t// Special case - <script> element\n\t\t\t\tif ( this.name === 'script' ) {\n\t\t\t\t\tthis.bubble = updateScript;\n\t\t\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t\t\t\t// bypass warning initially\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else if ( this.name === 'style' ) {\n\t\t\t\t\tthis.bubble = updateCss;\n\t\t\t\t\tthis.bubble();\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add proxy event handlers\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\treturn h.render();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// deal with two-way bindings\n\t\t\tif ( this.binding ) {\n\t\t\t\tthis.binding.render();\n\t\t\t\tthis.node._ractive.binding = this.binding;\n\t\t\t}\n\t\t\t// Special case: if this is an <img>, and we're in a crap browser, we may\n\t\t\t// need to prevent it from overriding width and height when it loads the src\n\t\t\tif ( this.name === 'img' ) {\n\t\t\t\trenderImage( this );\n\t\t\t}\n\t\t\t// apply decorator(s)\n\t\t\tif ( this.decorator && this.decorator.fn ) {\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.decorator.init();\n\t\t\t\t}, true );\n\t\t\t}\n\t\t\t// trigger intro transition\n\t\t\tif ( root.transitionsEnabled && this.intro ) {\n\t\t\t\tvar transition = new Transition( this, this.intro, true );\n\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn transition.start();\n\t\t\t\t}, true );\n\t\t\t\tthis.transition = transition;\n\t\t\t}\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tprocessOption( this );\n\t\t\t}\n\t\t\tif ( this.node.autofocus ) {\n\t\t\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.node.focus();\n\t\t\t\t}, true );\n\t\t\t}\n\t\t\tupdateLiveQueries( this );\n\t\t\treturn this.node;\n\t\t};\n\n\t\tfunction getNamespace( element ) {\n\t\t\tvar namespace, xmlns, parent;\n\t\t\t// Use specified namespace...\n\t\t\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\t\t\tnamespace = xmlns;\n\t\t\t} else if ( element.name === 'svg' ) {\n\t\t\t\tnamespace = namespaces.svg;\n\t\t\t} else if ( parent = element.parent ) {\n\t\t\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\t\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\t\t\tnamespace = namespaces.html;\n\t\t\t\t} else {\n\t\t\t\t\tnamespace = parent.node.namespaceURI;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnamespace = element.root.el.namespaceURI;\n\t\t\t}\n\t\t\treturn namespace;\n\t\t}\n\n\t\tfunction processOption( option ) {\n\t\t\tvar optionValue, selectValue, i;\n\t\t\tif ( !option.select ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tselectValue = option.select.getAttribute( 'value' );\n\t\t\tif ( selectValue === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toptionValue = option.getAttribute( 'value' );\n\t\t\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\t\t\ti = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( optionValue == selectValue[ i ] ) {\n\t\t\t\t\t\toption.node.selected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toption.node.selected = optionValue == selectValue;\n\t\t\t}\n\t\t}\n\n\t\tfunction updateLiveQueries( element ) {\n\t\t\tvar instance, liveQueries, i, selector, query;\n\t\t\t// Does this need to be added to any live queries?\n\t\t\tinstance = element.root;\n\t\t\tdo {\n\t\t\t\tliveQueries = instance._liveQueries;\n\t\t\t\ti = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tselector = liveQueries[ i ];\n\t\t\t\t\tquery = liveQueries[ '_' + selector ];\n\t\t\t\t\tif ( query._test( element ) ) {\n\t\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while ( instance = instance._parent );\n\t\t}\n\t\treturn __export;\n\t}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );\n\n\t/* virtualdom/items/Element/prototype/toString.js */\n\tvar virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {\n\n\t\tvar __export;\n\t\t__export = function() {\n\t\t\tvar str, escape;\n\t\t\tstr = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );\n\t\t\tstr += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\t\t\t// Special case - selected options\n\t\t\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\t\t\tstr += ' selected';\n\t\t\t}\n\t\t\t// Special case - two-way radio name bindings\n\t\t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\t\t\tstr += ' checked';\n\t\t\t}\n\t\t\tstr += '>';\n\t\t\t// Special case - textarea\n\t\t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t\t\t} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\tstr += this.getAttribute( 'value' );\n\t\t\t}\n\t\t\tif ( this.fragment ) {\n\t\t\t\tescape = this.name !== 'script' && this.name !== 'style';\n\t\t\t\tstr += this.fragment.toString( escape );\n\t\t\t}\n\t\t\t// add a closing tag if this isn't a void element\n\t\t\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\t\t\tstr += '</' + this.template.e + '>';\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\n\t\tfunction optionIsSelected( element ) {\n\t\t\tvar optionValue, selectValue, i;\n\t\t\toptionValue = element.getAttribute( 'value' );\n\t\t\tif ( optionValue === undefined || !element.select ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tselectValue = element.select.getAttribute( 'value' );\n\t\t\tif ( selectValue == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\t\t\ti = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction inputIsCheckedRadio( element ) {\n\t\t\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\t\t\tattributes = element.attributes;\n\t\t\ttypeAttribute = attributes.type;\n\t\t\tvalueAttribute = attributes.value;\n\t\t\tnameAttribute = attributes.name;\n\t\t\tif ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction stringifyAttribute( attribute ) {\n\t\t\tvar str = attribute.toString();\n\t\t\treturn str ? ' ' + str : '';\n\t\t}\n\t\treturn __export;\n\t}( voidElementNames, isArray, escapeHtml );\n\n\t/* virtualdom/items/Element/special/option/unbind.js */\n\tvar virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {\n\n\t\treturn function unbindOption( option ) {\n\t\t\tif ( option.select ) {\n\t\t\t\tremoveFromArray( option.select.options, option );\n\t\t\t}\n\t\t};\n\t}( removeFromArray );\n\n\t/* virtualdom/items/Element/prototype/unbind.js */\n\tvar virtualdom_items_Element$unbind = function( unbindOption ) {\n\n\t\tvar __export;\n\t\t__export = function Element$unbind() {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t}\n\t\t\tif ( this.binding ) {\n\t\t\t\tthis.binding.unbind();\n\t\t\t}\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( unbind );\n\t\t\t}\n\t\t\t// Special case - <option>\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tunbindOption( this );\n\t\t\t}\n\t\t\tthis.attributes.forEach( unbind );\n\t\t\tthis.conditionalAttributes.forEach( unbind );\n\t\t};\n\n\t\tfunction unbind( x ) {\n\t\t\tx.unbind();\n\t\t}\n\t\treturn __export;\n\t}( virtualdom_items_Element_special_option_unbind );\n\n\t/* virtualdom/items/Element/prototype/unrender.js */\n\tvar virtualdom_items_Element$unrender = function( runloop, Transition ) {\n\n\t\tvar __export;\n\t\t__export = function Element$unrender( shouldDestroy ) {\n\t\t\tvar binding, bindings;\n\t\t\tif ( this.transition ) {\n\t\t\t\tthis.transition.complete();\n\t\t\t}\n\t\t\t// Detach as soon as we can\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t// <option> elements detach immediately, so that\n\t\t\t\t// their parent <select> element syncs correctly, and\n\t\t\t\t// since option elements can't have transitions anyway\n\t\t\t\tthis.detach();\n\t\t\t} else if ( shouldDestroy ) {\n\t\t\t\trunloop.detachWhenReady( this );\n\t\t\t}\n\t\t\t// Children first. that way, any transitions on child elements will be\n\t\t\t// handled by the current transitionManager\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( false );\n\t\t\t}\n\t\t\tif ( binding = this.binding ) {\n\t\t\t\tthis.binding.unrender();\n\t\t\t\tthis.node._ractive.binding = null;\n\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ];\n\t\t\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t\t\t}\n\t\t\t// Remove event handlers\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\treturn h.unrender();\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.decorator ) {\n\t\t\t\tthis.decorator.teardown();\n\t\t\t}\n\t\t\t// trigger outro transition if necessary\n\t\t\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\t\t\tvar transition = new Transition( this, this.outro, false );\n\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn transition.start();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Remove this node from any live queries\n\t\t\tif ( this.liveQueries ) {\n\t\t\t\tremoveFromLiveQueries( this );\n\t\t\t}\n\t\t};\n\n\t\tfunction removeFromLiveQueries( element ) {\n\t\t\tvar query, selector, i;\n\t\t\ti = element.liveQueries.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tquery = element.liveQueries[ i ];\n\t\t\t\tselector = query.selector;\n\t\t\t\tquery._remove( element.node );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( runloop, Transition );\n\n\t/* virtualdom/items/Element/_Element.js */\n\tvar Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {\n\n\t\tvar Element = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tElement.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetAttribute: getAttribute,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn Element;\n\t}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );\n\n\t/* virtualdom/items/Partial/deIndent.js */\n\tvar deIndent = function() {\n\n\t\tvar __export;\n\t\tvar empty = /^\\s*$/,\n\t\t\tleadingWhitespace = /^\\s*/;\n\t\t__export = function( str ) {\n\t\t\tvar lines, firstLine, lastLine, minIndent;\n\t\t\tlines = str.split( '\\n' );\n\t\t\t// remove first and last line, if they only contain whitespace\n\t\t\tfirstLine = lines[ 0 ];\n\t\t\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t\tlastLine = lines[ lines.length - 1 ];\n\t\t\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t\tminIndent = lines.reduce( reducer, null );\n\t\t\tif ( minIndent ) {\n\t\t\t\tstr = lines.map( function( line ) {\n\t\t\t\t\treturn line.replace( minIndent, '' );\n\t\t\t\t} ).join( '\\n' );\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\n\t\tfunction reducer( previous, line ) {\n\t\t\tvar lineIndent = leadingWhitespace.exec( line )[ 0 ];\n\t\t\tif ( previous === null || lineIndent.length < previous.length ) {\n\t\t\t\treturn lineIndent;\n\t\t\t}\n\t\t\treturn previous;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Partial/getPartialTemplate.js */\n\tvar getPartialTemplate = function( log, config, parser, deIndent ) {\n\n\t\tvar __export;\n\t\t__export = function getPartialTemplate( ractive, name ) {\n\t\t\tvar partial;\n\t\t\t// If the partial in instance or view heirarchy instances, great\n\t\t\tif ( partial = getPartialFromRegistry( ractive, name ) ) {\n\t\t\t\treturn partial;\n\t\t\t}\n\t\t\t// Does it exist on the page as a script tag?\n\t\t\tpartial = parser.fromId( name, {\n\t\t\t\tnoThrow: true\n\t\t\t} );\n\t\t\tif ( partial ) {\n\t\t\t\t// is this necessary?\n\t\t\t\tpartial = deIndent( partial );\n\t\t\t\t// parse and register to this ractive instance\n\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t\t\t\t// register (and return main partial if there are others in the template)\n\t\t\t\treturn ractive.partials[ name ] = parsed.t;\n\t\t\t}\n\t\t};\n\n\t\tfunction getPartialFromRegistry( ractive, name ) {\n\t\t\tvar partials = config.registries.partials;\n\t\t\t// find first instance in the ractive or view hierarchy that has this partial\n\t\t\tvar instance = partials.findInstance( ractive, name );\n\t\t\tif ( !instance ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar partial = instance.partials[ name ],\n\t\t\t\tfn;\n\t\t\t// partial is a function?\n\t\t\tif ( typeof partial === 'function' ) {\n\t\t\t\tfn = partial.bind( instance );\n\t\t\t\tfn.isOwner = instance.partials.hasOwnProperty( name );\n\t\t\t\tpartial = fn( instance.data, parser );\n\t\t\t}\n\t\t\tif ( !partial ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tregistry: 'partial',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If this was added manually to the registry,\n\t\t\t// but hasn't been parsed, parse it now\n\t\t\tif ( !parser.isParsed( partial ) ) {\n\t\t\t\t// use the parseOptions of the ractive instance on which it was found\n\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\t\t\t\t// Partials cannot contain nested partials!\n\t\t\t\t// TODO add a test for this\n\t\t\t\tif ( parsed.p ) {\n\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'noNestedPartials',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\trname: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t\t\t// in the correct point in prototype chain on instance or constructor\n\t\t\t\tvar target = fn ? instance : partials.findOwner( instance, name );\n\t\t\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\t\t\ttarget.partials[ name ] = partial = parsed.t;\n\t\t\t}\n\t\t\t// store for reset\n\t\t\tif ( fn ) {\n\t\t\t\tpartial._fn = fn;\n\t\t\t}\n\t\t\treturn partial.v ? partial.t : partial;\n\t\t}\n\t\treturn __export;\n\t}( log, config, parser, deIndent );\n\n\t/* virtualdom/items/Partial/applyIndent.js */\n\tvar applyIndent = function( string, indent ) {\n\t\tvar indented;\n\t\tif ( !indent ) {\n\t\t\treturn string;\n\t\t}\n\t\tindented = string.split( '\\n' ).map( function( line, notFirstLine ) {\n\t\t\treturn notFirstLine ? indent + line : line;\n\t\t} ).join( '\\n' );\n\t\treturn indented;\n\t};\n\n\t/* virtualdom/items/Partial/_Partial.js */\n\tvar Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {\n\n\t\tvar Partial, Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tPartial = function( options ) {\n\t\t\tvar parentFragment, template;\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\tthis.root = parentFragment.root;\n\t\t\tthis.type = types.PARTIAL;\n\t\t\tthis.index = options.index;\n\t\t\tthis.name = options.template.r;\n\t\t\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\t\t\tMustache.init( this, options );\n\t\t\t// If this didn't resolve, it most likely means we have a named partial\n\t\t\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t\t\t// whose name is the value of `foo`')\n\t\t\tif ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\tunbind.call( this );\n\t\t\t\t// prevent any further changes\n\t\t\t\tthis.isNamed = true;\n\t\t\t\tthis.setTemplate( template );\n\t\t\t}\n\t\t};\n\t\tPartial.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t},\n\t\t\tdetach: function() {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t},\n\t\t\tfind: function( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t},\n\t\t\tfindAll: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t},\n\t\t\tfindComponent: function( selector ) {\n\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t},\n\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.fragment.firstNode();\n\t\t\t},\n\t\t\tfindNextNode: function() {\n\t\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.fragment.getValue();\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\trebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\t\tthis.update();\n\t\t\t\tthis.rendered = true;\n\t\t\t\treturn this.docFrag;\n\t\t\t},\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar template;\n\t\t\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t\t\t// nothing has changed, so no work to be done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttemplate = getPartialTemplate( this.root, '' + value );\n\t\t\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t\t\t// and a partial. In those cases, this becomes a named partial\n\t\t\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\t\tunbind.call( this );\n\t\t\t\t\tthis.isNamed = true;\n\t\t\t\t}\n\t\t\t\tif ( !template ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\tmessage: 'noTemplateForPartial',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tname: this.name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis.setTemplate( template || [] );\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetTemplate: function( template ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t\t}\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\towner: this,\n\t\t\t\t\tpElement: this.parentFragment.pElement\n\t\t\t\t} );\n\t\t\t\tthis.fragmentToRender = this.fragment;\n\t\t\t},\n\t\t\ttoString: function( toString ) {\n\t\t\t\tvar string, previousItem, lastLine, match;\n\t\t\t\tstring = this.fragment.toString( toString );\n\t\t\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\t\t\t\tif ( !previousItem || previousItem.type !== types.TEXT ) {\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\t\t\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\t\t\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\t\t\treturn applyIndent( string, match[ 0 ] );\n\t\t\t\t}\n\t\t\t\treturn string;\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tif ( !this.isNamed ) {\n\t\t\t\t\t// dynamic partial - need to unbind self\n\t\t\t\t\tunbind.call( this );\n\t\t\t\t}\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\t\t}\n\t\t\t\t\tthis.rendered = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar target, anchor;\n\t\t\t\tif ( this.fragmentToUnrender ) {\n\t\t\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\t\t\tthis.fragmentToUnrender = null;\n\t\t\t\t}\n\t\t\t\tif ( this.fragmentToRender ) {\n\t\t\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\t\t\tthis.fragmentToRender = null;\n\t\t\t\t}\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\ttarget = this.parentFragment.getNode();\n\t\t\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Partial;\n\t}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );\n\n\t/* virtualdom/items/Component/getComponent.js */\n\tvar getComponent = function( config, log, circular ) {\n\n\t\tvar Ractive;\n\t\tcircular.push( function() {\n\t\t\tRactive = circular.Ractive;\n\t\t} );\n\t\t// finds the component constructor in the registry or view hierarchy registries\n\t\treturn function getComponent( ractive, name ) {\n\t\t\tvar component, instance = config.registries.components.findInstance( ractive, name );\n\t\t\tif ( instance ) {\n\t\t\t\tcomponent = instance.components[ name ];\n\t\t\t\t// best test we have for not Ractive.extend\n\t\t\t\tif ( !component._parent ) {\n\t\t\t\t\t// function option, execute and store for reset\n\t\t\t\t\tvar fn = component.bind( instance );\n\t\t\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\t\t\tcomponent = fn( instance.data );\n\t\t\t\t\tif ( !component ) {\n\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tregistry: 'component',\n\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof component === 'string' ) {\n\t\t\t\t\t\t//allow string lookup\n\t\t\t\t\t\tcomponent = getComponent( ractive, component );\n\t\t\t\t\t}\n\t\t\t\t\tcomponent._fn = fn;\n\t\t\t\t\tinstance.components[ name ] = component;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn component;\n\t\t};\n\t}( config, log, circular );\n\n\t/* virtualdom/items/Component/prototype/detach.js */\n\tvar virtualdom_items_Component$detach = function( Hook ) {\n\n\t\tvar detachHook = new Hook( 'detach' );\n\t\treturn function Component$detach() {\n\t\t\tvar detached = this.instance.fragment.detach();\n\t\t\tdetachHook.fire( this.instance );\n\t\t\treturn detached;\n\t\t};\n\t}( Ractive$shared_hooks_Hook );\n\n\t/* virtualdom/items/Component/prototype/find.js */\n\tvar virtualdom_items_Component$find = function Component$find( selector ) {\n\t\treturn this.instance.fragment.find( selector );\n\t};\n\n\t/* virtualdom/items/Component/prototype/findAll.js */\n\tvar virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {\n\t\treturn this.instance.fragment.findAll( selector, query );\n\t};\n\n\t/* virtualdom/items/Component/prototype/findAllComponents.js */\n\tvar virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {\n\t\tquery._test( this, true );\n\t\tif ( this.instance.fragment ) {\n\t\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Component/prototype/findComponent.js */\n\tvar virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {\n\t\tif ( !selector || selector === this.name ) {\n\t\t\treturn this.instance;\n\t\t}\n\t\tif ( this.instance.fragment ) {\n\t\t\treturn this.instance.fragment.findComponent( selector );\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Component/prototype/findNextNode.js */\n\tvar virtualdom_items_Component$findNextNode = function Component$findNextNode() {\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Component/prototype/firstNode.js */\n\tvar virtualdom_items_Component$firstNode = function Component$firstNode() {\n\t\tif ( this.rendered ) {\n\t\t\treturn this.instance.fragment.firstNode();\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */\n\tvar ComponentParameter = function( runloop, circular ) {\n\n\t\tvar Fragment, ComponentParameter;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tComponentParameter = function( component, key, value ) {\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.component = component;\n\t\t\tthis.key = key;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: value,\n\t\t\t\troot: component.root,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.value = this.fragment.getValue();\n\t\t};\n\t\tComponentParameter.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar value = this.fragment.getValue();\n\t\t\t\tthis.component.instance.viewmodel.set( this.key, value );\n\t\t\t\trunloop.addViewmodel( this.component.instance.viewmodel );\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.dirty = false;\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t}\n\t\t};\n\t\treturn ComponentParameter;\n\t}( runloop, circular );\n\n\t/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */\n\tvar ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {\n\n\t\tvar ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.root = component.root;\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.ready = false;\n\t\t\tthis.hash = null;\n\t\t\tthis.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {\n\t\t\t\t// Are we updating an existing binding?\n\t\t\t\tif ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {\n\t\t\t\t\tcomponent.bindings[ this$0.hash ] = null;\n\t\t\t\t\tthis$0.binding.rebind( keypath );\n\t\t\t\t\tthis$0.hash = keypath + '=' + childKeypath;\n\t\t\t\t\tcomponent.bindings[ this$0.hash ];\n\t\t\t\t} else {\n\t\t\t\t\tif ( !this$0.ready ) {\n\t\t\t\t\t\t// The child instance isn't created yet, we need to create the binding later\n\t\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\t\tchildKeypath: childKeypath,\n\t\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcreateComponentBinding( component, component.root, keypath, childKeypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis$0.value = component.root.viewmodel.get( keypath );\n\t\t\t} );\n\t\t};\n\t\tReferenceExpressionParameter.prototype = {\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.resolver.unbind();\n\t\t\t}\n\t\t};\n\t\treturn ReferenceExpressionParameter;\n\t}( ReferenceExpressionResolver, createComponentBinding );\n\n\t/* virtualdom/items/Component/initialise/createModel/_createModel.js */\n\tvar createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {\n\n\t\tvar __export;\n\t\t__export = function( component, defaultData, attributes, toBind ) {\n\t\t\tvar data = {},\n\t\t\t\tkey, value;\n\t\t\t// some parameters, e.g. foo=\"The value is {{bar}}\", are 'complex' - in\n\t\t\t// other words, we need to construct a string fragment to watch\n\t\t\t// when they change. We store these so they can be torn down later\n\t\t\tcomponent.complexParameters = [];\n\t\t\tfor ( key in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( key ) ) {\n\t\t\t\t\tvalue = getValue( component, key, attributes[ key ], toBind );\n\t\t\t\t\tif ( value !== undefined || defaultData[ key ] === undefined ) {\n\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data;\n\t\t};\n\n\t\tfunction getValue( component, key, template, toBind ) {\n\t\t\tvar parameter, parsed, parentInstance, parentFragment, keypath, indexRef;\n\t\t\tparentInstance = component.root;\n\t\t\tparentFragment = component.parentFragment;\n\t\t\t// If this is a static value, great\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\tparsed = parseJSON( template );\n\t\t\t\tif ( !parsed ) {\n\t\t\t\t\treturn template;\n\t\t\t\t}\n\t\t\t\treturn parsed.value;\n\t\t\t}\n\t\t\t// If null, we treat it as a boolean attribute (i.e. true)\n\t\t\tif ( template === null ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Single interpolator?\n\t\t\tif ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {\n\t\t\t\t// If it's a regular interpolator, we bind to it\n\t\t\t\tif ( template[ 0 ].r ) {\n\t\t\t\t\t// Is it an index reference?\n\t\t\t\t\tif ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {\n\t\t\t\t\t\tcomponent.indexRefBindings[ indexRef ] = key;\n\t\t\t\t\t\treturn parentFragment.indexRefs[ indexRef ];\n\t\t\t\t\t}\n\t\t\t\t\t// TODO what about references that resolve late? Should these be considered?\n\t\t\t\t\tkeypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;\n\t\t\t\t\t// We need to set up bindings between parent and child, but\n\t\t\t\t\t// we can't do it yet because the child instance doesn't exist\n\t\t\t\t\t// yet - so we make a note instead\n\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\tchildKeypath: key,\n\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t} );\n\t\t\t\t\treturn parentInstance.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t\t// If it's a reference expression (e.g. `{{foo[bar]}}`), we need\n\t\t\t\t// to watch the keypath and create/destroy bindings\n\t\t\t\tif ( template[ 0 ].rx ) {\n\t\t\t\t\tparameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );\n\t\t\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\t\t\tparameter.ready = true;\n\t\t\t\t\treturn parameter.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We have a 'complex parameter' - we need to create a full-blown string\n\t\t\t// fragment in order to evaluate and observe its value\n\t\t\tparameter = new ComponentParameter( component, key, template );\n\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\treturn parameter.value;\n\t\t}\n\t\treturn __export;\n\t}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );\n\n\t/* virtualdom/items/Component/initialise/createInstance.js */\n\tvar createInstance = function( log ) {\n\n\t\treturn function( component, Component, data, contentDescriptor ) {\n\t\t\tvar instance, parentFragment, partials, ractive;\n\t\t\tparentFragment = component.parentFragment;\n\t\t\tractive = component.root;\n\t\t\t// Make contents available as a {{>content}} partial\n\t\t\tpartials = {\n\t\t\t\tcontent: contentDescriptor || []\n\t\t\t};\n\t\t\tif ( Component.defaults.el ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'defaultElSpecified',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tname: component.name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tinstance = new Component( {\n\t\t\t\tel: null,\n\t\t\t\tappend: true,\n\t\t\t\tdata: data,\n\t\t\t\tpartials: partials,\n\t\t\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\t\t\tmodifyArrays: ractive.modifyArrays,\n\t\t\t\t_parent: ractive,\n\t\t\t\t_component: component,\n\t\t\t\t// need to inherit runtime parent adaptors\n\t\t\t\tadapt: ractive.adapt,\n\t\t\t\tyield: {\n\t\t\t\t\ttemplate: contentDescriptor,\n\t\t\t\t\tinstance: ractive\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn instance;\n\t\t};\n\t}( log );\n\n\t/* virtualdom/items/Component/initialise/createBindings.js */\n\tvar createBindings = function( createComponentBinding ) {\n\n\t\treturn function createInitialComponentBindings( component, toBind ) {\n\t\t\ttoBind.forEach( function createInitialComponentBinding( pair ) {\n\t\t\t\tvar childValue, parentValue;\n\t\t\t\tcreateComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );\n\t\t\t\tchildValue = component.instance.viewmodel.get( pair.childKeypath );\n\t\t\t\tparentValue = component.root.viewmodel.get( pair.parentKeypath );\n\t\t\t\tif ( childValue !== undefined && parentValue === undefined ) {\n\t\t\t\t\tcomponent.root.viewmodel.set( pair.parentKeypath, childValue );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t}( createComponentBinding );\n\n\t/* virtualdom/items/Component/initialise/propagateEvents.js */\n\tvar propagateEvents = function( circular, fireEvent, log ) {\n\n\t\tvar __export;\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function propagateEvents( component, eventsDescriptor ) {\n\t\t\tvar eventName;\n\t\t\tfor ( eventName in eventsDescriptor ) {\n\t\t\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {\n\t\t\tif ( typeof proxyEventName !== 'string' ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: parentInstance.debug,\n\t\t\t\t\tmessage: 'noComponentEventArguments'\n\t\t\t\t} );\n\t\t\t}\n\t\t\tchildInstance.on( eventName, function() {\n\t\t\t\tvar event, args;\n\t\t\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\t\t\tif ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {\n\t\t\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t\t\t}\n\t\t\t\targs = Array.prototype.slice.call( arguments );\n\t\t\t\tfireEvent( parentInstance, proxyEventName, {\n\t\t\t\t\tevent: event,\n\t\t\t\t\targs: args\n\t\t\t\t} );\n\t\t\t\t// cancel bubbling\n\t\t\t\treturn false;\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( circular, Ractive$shared_fireEvent, log );\n\n\t/* virtualdom/items/Component/initialise/updateLiveQueries.js */\n\tvar updateLiveQueries = function( component ) {\n\t\tvar ancestor, query;\n\t\t// If there's a live query for this component type, add it\n\t\tancestor = component.root;\n\t\twhile ( ancestor ) {\n\t\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\tquery.push( component.instance );\n\t\t\t}\n\t\t\tancestor = ancestor._parent;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Component/prototype/init.js */\n\tvar virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {\n\n\t\treturn function Component$init( options, Component ) {\n\t\t\tvar parentFragment, root, data, toBind;\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\troot = parentFragment.root;\n\t\t\tthis.root = root;\n\t\t\tthis.type = types.COMPONENT;\n\t\t\tthis.name = options.template.e;\n\t\t\tthis.index = options.index;\n\t\t\tthis.indexRefBindings = {};\n\t\t\tthis.bindings = [];\n\t\t\t// even though only one yielder is allowed, we need to have an array of them\n\t\t\t// as it's possible to cause a yielder to be created before the last one\n\t\t\t// was destroyed in the same turn of the runloop\n\t\t\tthis.yielders = [];\n\t\t\tif ( !Component ) {\n\t\t\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t\t\t}\n\t\t\t// First, we need to create a model for the component - e.g. if we\n\t\t\t// encounter <widget foo='bar'/> then we need to create a widget\n\t\t\t// with `data: { foo: 'bar' }`.\n\t\t\t//\n\t\t\t// This may involve setting up some bindings, but we can't do it\n\t\t\t// yet so we take some notes instead\n\t\t\ttoBind = [];\n\t\t\tdata = createModel( this, Component.defaults.data || {}, options.template.a, toBind );\n\t\t\tcreateInstance( this, Component, data, options.template.f );\n\t\t\tcreateBindings( this, toBind );\n\t\t\tpropagateEvents( this, options.template.v );\n\t\t\t// intro, outro and decorator directives have no effect\n\t\t\tif ( options.template.t1 || options.template.t2 || options.template.o ) {\n\t\t\t\twarn( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components' );\n\t\t\t}\n\t\t\tupdateLiveQueries( this );\n\t\t};\n\t}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );\n\n\t/* virtualdom/items/Component/prototype/rebind.js */\n\tvar virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {\n\n\t\treturn function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar childInstance = this.instance,\n\t\t\t\tparentInstance = childInstance._parent,\n\t\t\t\tindexRefAlias, query;\n\t\t\tthis.bindings.forEach( function( binding ) {\n\t\t\t\tvar updated;\n\t\t\t\tif ( binding.root !== parentInstance ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {\n\t\t\t\t\tbinding.rebind( updated );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tthis.complexParameters.forEach( rebind );\n\t\t\tif ( this.yielders[ 0 ] ) {\n\t\t\t\trebind( this.yielders[ 0 ] );\n\t\t\t}\n\t\t\tif ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {\n\t\t\t\trunloop.addViewmodel( childInstance.viewmodel );\n\t\t\t\tchildInstance.viewmodel.set( indexRefAlias, newIndex );\n\t\t\t}\n\t\t\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\t\t\tquery._makeDirty();\n\t\t\t}\n\n\t\t\tfunction rebind( x ) {\n\t\t\t\tx.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t}( runloop, getNewKeypath );\n\n\t/* virtualdom/items/Component/prototype/render.js */\n\tvar virtualdom_items_Component$render = function Component$render() {\n\t\tvar instance = this.instance;\n\t\tinstance.render( this.parentFragment.getNode() );\n\t\tthis.rendered = true;\n\t\treturn instance.fragment.detach();\n\t};\n\n\t/* virtualdom/items/Component/prototype/toString.js */\n\tvar virtualdom_items_Component$toString = function Component$toString() {\n\t\treturn this.instance.fragment.toString();\n\t};\n\n\t/* virtualdom/items/Component/prototype/unbind.js */\n\tvar virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {\n\n\t\tvar __export;\n\t\tvar teardownHook = new Hook( 'teardown' );\n\t\t__export = function Component$unbind() {\n\t\t\tvar instance = this.instance;\n\t\t\tthis.complexParameters.forEach( unbind );\n\t\t\tthis.bindings.forEach( unbind );\n\t\t\tremoveFromLiveComponentQueries( this );\n\t\t\t// teardown the instance\n\t\t\tinstance.fragment.unbind();\n\t\t\tinstance.viewmodel.teardown();\n\t\t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t\t\t}\n\t\t\tteardownHook.fire( instance );\n\t\t};\n\n\t\tfunction unbind( thing ) {\n\t\t\tthing.unbind();\n\t\t}\n\n\t\tfunction removeFromLiveComponentQueries( component ) {\n\t\t\tvar instance, query;\n\t\t\tinstance = component.root;\n\t\t\tdo {\n\t\t\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\t\tquery._remove( component );\n\t\t\t\t}\n\t\t\t} while ( instance = instance._parent );\n\t\t}\n\t\treturn __export;\n\t}( Ractive$shared_hooks_Hook, removeFromArray );\n\n\t/* virtualdom/items/Component/prototype/unrender.js */\n\tvar virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {\n\t\tthis.shouldDestroy = shouldDestroy;\n\t\tthis.instance.unrender();\n\t};\n\n\t/* virtualdom/items/Component/_Component.js */\n\tvar Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {\n\n\t\tvar Component = function( options, Constructor ) {\n\t\t\tthis.init( options, Constructor );\n\t\t};\n\t\tComponent.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn Component;\n\t}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );\n\n\t/* virtualdom/items/Comment.js */\n\tvar Comment = function( types, detach ) {\n\n\t\tvar Comment = function( options ) {\n\t\t\tthis.type = types.COMMENT;\n\t\t\tthis.value = options.template.c;\n\t\t};\n\t\tComment.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createComment( this.value );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn '<!--' + this.value + '-->';\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Comment;\n\t}( types, detach );\n\n\t/* virtualdom/items/Yielder.js */\n\tvar Yielder = function( runloop, removeFromArray, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tvar Yielder = function( options ) {\n\t\t\tvar componentInstance, component;\n\t\t\tcomponentInstance = options.parentFragment.root;\n\t\t\tthis.component = component = componentInstance.component;\n\t\t\tthis.surrogateParent = options.parentFragment;\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\towner: this,\n\t\t\t\troot: componentInstance.yield.instance,\n\t\t\t\ttemplate: componentInstance.yield.template,\n\t\t\t\tpElement: this.surrogateParent.pElement\n\t\t\t} );\n\t\t\tcomponent.yielders.push( this );\n\t\t\trunloop.scheduleTask( function() {\n\t\t\t\tif ( component.yielders.length > 1 ) {\n\t\t\t\t\tthrow new Error( 'A component template can only have one {{yield}} declaration at a time' );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t\tYielder.prototype = {\n\t\t\tdetach: function() {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t},\n\t\t\tfind: function( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t},\n\t\t\tfindAll: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t},\n\t\t\tfindComponent: function( selector ) {\n\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t},\n\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t},\n\t\t\tfindNextNode: function() {\n\t\t\t\treturn this.surrogateParent.findNextNode( this );\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.fragment.firstNode();\n\t\t\t},\n\t\t\tgetValue: function( options ) {\n\t\t\t\treturn this.fragment.getValue( options );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\treturn this.fragment.render();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\tremoveFromArray( this.component.yielders, this );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t}\n\t\t};\n\t\treturn Yielder;\n\t}( runloop, removeFromArray, circular );\n\n\t/* virtualdom/Fragment/prototype/init/createItem.js */\n\tvar virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {\n\n\t\treturn function createItem( options ) {\n\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\treturn new Text( options );\n\t\t\t}\n\t\t\tswitch ( options.template.t ) {\n\t\t\t\tcase types.INTERPOLATOR:\n\t\t\t\t\tif ( options.template.r === 'yield' ) {\n\t\t\t\t\t\treturn new Yielder( options );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Interpolator( options );\n\t\t\t\tcase types.SECTION:\n\t\t\t\t\treturn new Section( options );\n\t\t\t\tcase types.TRIPLE:\n\t\t\t\t\treturn new Triple( options );\n\t\t\t\tcase types.ELEMENT:\n\t\t\t\t\tvar constructor;\n\t\t\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\t\t\treturn new Component( options, constructor );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Element( options );\n\t\t\t\tcase types.PARTIAL:\n\t\t\t\t\treturn new Partial( options );\n\t\t\t\tcase types.COMMENT:\n\t\t\t\t\treturn new Comment( options );\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t\t\t}\n\t\t};\n\t}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );\n\n\t/* virtualdom/Fragment/prototype/init.js */\n\tvar virtualdom_Fragment$init = function( types, create, createItem ) {\n\n\t\treturn function Fragment$init( options ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar parentFragment, parentRefs, ref;\n\t\t\t// The item that owns this fragment - an element, section, partial, or attribute\n\t\t\tthis.owner = options.owner;\n\t\t\tparentFragment = this.parent = this.owner.parentFragment;\n\t\t\t// inherited properties\n\t\t\tthis.root = options.root;\n\t\t\tthis.pElement = options.pElement;\n\t\t\tthis.context = options.context;\n\t\t\t// If parent item is a section, this may not be the only fragment\n\t\t\t// that belongs to it - we need to make a note of the index\n\t\t\tif ( this.owner.type === types.SECTION ) {\n\t\t\t\tthis.index = options.index;\n\t\t\t}\n\t\t\t// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade\n\t\t\t// down the tree\n\t\t\tif ( parentFragment ) {\n\t\t\t\tparentRefs = parentFragment.indexRefs;\n\t\t\t\tif ( parentRefs ) {\n\t\t\t\t\tthis.indexRefs = create( null );\n\t\t\t\t\t// avoids need for hasOwnProperty\n\t\t\t\t\tfor ( ref in parentRefs ) {\n\t\t\t\t\t\tthis.indexRefs[ ref ] = parentRefs[ ref ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( options.indexRef ) {\n\t\t\t\tif ( !this.indexRefs ) {\n\t\t\t\t\tthis.indexRefs = {};\n\t\t\t\t}\n\t\t\t\tthis.indexRefs[ options.indexRef ] = options.index;\n\t\t\t}\n\t\t\t// Time to create this fragment's child items\n\t\t\t// TEMP should this be happening?\n\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\toptions.template = [ options.template ];\n\t\t\t} else if ( !options.template ) {\n\t\t\t\toptions.template = [];\n\t\t\t}\n\t\t\tthis.items = options.template.map( function( template, i ) {\n\t\t\t\treturn createItem( {\n\t\t\t\t\tparentFragment: this$0,\n\t\t\t\t\tpElement: options.pElement,\n\t\t\t\t\ttemplate: template,\n\t\t\t\t\tindex: i\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tthis.value = this.argsList = null;\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tthis.bound = true;\n\t\t};\n\t}( types, create, virtualdom_Fragment$init_createItem );\n\n\t/* virtualdom/Fragment/prototype/rebind.js */\n\tvar virtualdom_Fragment$rebind = function( assignNewKeypath ) {\n\n\t\treturn function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tthis.index = newIndex;\n\t\t\t// assign new context keypath if needed\n\t\t\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\t\t\tif ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {\n\t\t\t\tthis.indexRefs[ indexRef ] = newIndex;\n\t\t\t}\n\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\tif ( item.rebind ) {\n\t\t\t\t\titem.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t}( assignNewKeypath );\n\n\t/* virtualdom/Fragment/prototype/render.js */\n\tvar virtualdom_Fragment$render = function Fragment$render() {\n\t\tvar result;\n\t\tif ( this.items.length === 1 ) {\n\t\t\tresult = this.items[ 0 ].render();\n\t\t} else {\n\t\t\tresult = document.createDocumentFragment();\n\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\tresult.appendChild( item.render() );\n\t\t\t} );\n\t\t}\n\t\tthis.rendered = true;\n\t\treturn result;\n\t};\n\n\t/* virtualdom/Fragment/prototype/toString.js */\n\tvar virtualdom_Fragment$toString = function Fragment$toString( escape ) {\n\t\tif ( !this.items ) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.items.map( function( item ) {\n\t\t\treturn item.toString( escape );\n\t\t} ).join( '' );\n\t};\n\n\t/* virtualdom/Fragment/prototype/unbind.js */\n\tvar virtualdom_Fragment$unbind = function() {\n\n\t\tvar __export;\n\t\t__export = function Fragment$unbind() {\n\t\t\tif ( !this.bound ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.items.forEach( unbindItem );\n\t\t\tthis.bound = false;\n\t\t};\n\n\t\tfunction unbindItem( item ) {\n\t\t\tif ( item.unbind ) {\n\t\t\t\titem.unbind();\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/Fragment/prototype/unrender.js */\n\tvar virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {\n\t\tif ( !this.rendered ) {\n\t\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t\t}\n\t\tthis.items.forEach( function( i ) {\n\t\t\treturn i.unrender( shouldDestroy );\n\t\t} );\n\t\tthis.rendered = false;\n\t};\n\n\t/* virtualdom/Fragment.js */\n\tvar Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {\n\n\t\tvar Fragment = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tFragment.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetNode: getNode,\n\t\t\tgetValue: getValue,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\tcircular.Fragment = Fragment;\n\t\treturn Fragment;\n\t}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );\n\n\t/* Ractive/prototype/reset.js */\n\tvar Ractive$reset = function( Hook, runloop, Fragment, config ) {\n\n\t\tvar shouldRerender = [\n\t\t\t\t'template',\n\t\t\t\t'partials',\n\t\t\t\t'components',\n\t\t\t\t'decorators',\n\t\t\t\t'events'\n\t\t\t],\n\t\t\tresetHook = new Hook( 'reset' );\n\t\treturn function Ractive$reset( data, callback ) {\n\t\t\tvar promise, wrapper, changes, i, rerender;\n\t\t\tif ( typeof data === 'function' && !callback ) {\n\t\t\t\tcallback = data;\n\t\t\t\tdata = {};\n\t\t\t} else {\n\t\t\t\tdata = data || {};\n\t\t\t}\n\t\t\tif ( typeof data !== 'object' ) {\n\t\t\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t\t\t}\n\t\t\t// If the root object is wrapped, try and use the wrapper's reset value\n\t\t\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\t\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t\t\t// reset was rejected, we need to replace the object\n\t\t\t\t\tthis.data = data;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.data = data;\n\t\t\t}\n\t\t\t// reset config items and track if need to rerender\n\t\t\tchanges = config.reset( this );\n\t\t\ti = changes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( rerender ) {\n\t\t\t\tvar component;\n\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t\t// detaching its own nodes\n\t\t\t\tif ( component = this.component ) {\n\t\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t\t}\n\t\t\t\tthis.unrender();\n\t\t\t\tif ( component ) {\n\t\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t\t}\n\t\t\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t\t\t// TODO if we're here, presumably it did?\n\t\t\t\tif ( this.fragment.template !== this.template ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: this.template,\n\t\t\t\t\t\troot: this,\n\t\t\t\t\t\towner: this\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tpromise = this.render( this.el, this.anchor );\n\t\t\t} else {\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\trunloop.end();\n\t\t\t}\n\t\t\tresetHook.fire( this, data );\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, runloop, Fragment, config );\n\n\t/* Ractive/prototype/resetTemplate.js */\n\tvar Ractive$resetTemplate = function( config, Fragment ) {\n\n\t\treturn function Ractive$resetTemplate( template ) {\n\t\t\tvar transitionsEnabled, component;\n\t\t\tconfig.template.init( null, this, {\n\t\t\t\ttemplate: template\n\t\t\t} );\n\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\tthis.transitionsEnabled = false;\n\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t// detaching its own nodes\n\t\t\tif ( component = this.component ) {\n\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t}\n\t\t\tthis.unrender();\n\t\t\tif ( component ) {\n\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t}\n\t\t\t// remove existing fragment and create new one\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.render( this.el, this.anchor );\n\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t};\n\t}( config, Fragment );\n\n\t/* Ractive/prototype/reverse.js */\n\tvar Ractive$reverse = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'reverse' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/set.js */\n\tvar Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {\n\n\t\tvar wildcard = /\\*/;\n\t\treturn function Ractive$set( keypath, value, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar map, promise;\n\t\t\tpromise = runloop.start( this, true );\n\t\t\t// Set multiple keypaths in one go\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\tmap = keypath;\n\t\t\t\tcallback = value;\n\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\tvalue = map[ keypath ];\n\t\t\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\tgetMatchingKeypaths( this, keypath ).forEach( function( keypath ) {\n\t\t\t\t\t\tthis$0.viewmodel.set( keypath, value );\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t\trunloop.end();\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );\n\n\t/* Ractive/prototype/shift.js */\n\tvar Ractive$shift = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'shift' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/sort.js */\n\tvar Ractive$sort = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'sort' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/splice.js */\n\tvar Ractive$splice = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'splice' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/subtract.js */\n\tvar Ractive$subtract = function( add ) {\n\n\t\treturn function Ractive$subtract( keypath, d ) {\n\t\t\treturn add( this, keypath, d === undefined ? -1 : -d );\n\t\t};\n\t}( Ractive$shared_add );\n\n\t/* Ractive/prototype/teardown.js */\n\tvar Ractive$teardown = function( Hook, Promise, removeFromArray ) {\n\n\t\tvar teardownHook = new Hook( 'teardown' );\n\t\t// Teardown. This goes through the root fragment and all its children, removing observers\n\t\t// and generally cleaning up after itself\n\t\treturn function Ractive$teardown( callback ) {\n\t\t\tvar promise;\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.viewmodel.teardown();\n\t\t\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\t\tthis.shouldDestroy = true;\n\t\t\tpromise = this.fragment.rendered ? this.unrender() : Promise.resolve();\n\t\t\tteardownHook.fire( this );\n\t\t\tif ( callback ) {\n\t\t\t\t// TODO deprecate this?\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, Promise, removeFromArray );\n\n\t/* Ractive/prototype/toggle.js */\n\tvar Ractive$toggle = function( log ) {\n\n\t\treturn function Ractive$toggle( keypath, callback ) {\n\t\t\tvar value;\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tlog.errorOnly( {\n\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\tmesssage: 'badArguments',\n\t\t\t\t\targ: {\n\t\t\t\t\t\targuments: keypath\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tvalue = this.get( keypath );\n\t\t\treturn this.set( keypath, !value, callback );\n\t\t};\n\t}( log );\n\n\t/* Ractive/prototype/toHTML.js */\n\tvar Ractive$toHTML = function Ractive$toHTML() {\n\t\treturn this.fragment.toString( true );\n\t};\n\n\t/* Ractive/prototype/unrender.js */\n\tvar Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {\n\n\t\tvar unrenderHook = new Hook( 'unrender' );\n\t\treturn function Ractive$unrender() {\n\t\t\tvar this$0 = this;\n\t\t\tvar promise, shouldDestroy;\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\tmessage: 'ractive.unrender() was called on a Ractive instance that was not rendered'\n\t\t\t\t} );\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\t// If this is a component, and the component isn't marked for destruction,\n\t\t\t// don't detach nodes from the DOM unnecessarily\n\t\t\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t\t\tif ( this.constructor.css ) {\n\t\t\t\tpromise.then( function() {\n\t\t\t\t\tcss.remove( this$0.constructor );\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Cancel any animations in progress\n\t\t\twhile ( this._animations[ 0 ] ) {\n\t\t\t\tthis._animations[ 0 ].stop();\n\t\t\t}\n\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\tunrenderHook.fire( this );\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t};\n\t}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );\n\n\t/* Ractive/prototype/unshift.js */\n\tvar Ractive$unshift = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'unshift' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/update.js */\n\tvar Ractive$update = function( Hook, runloop ) {\n\n\t\tvar updateHook = new Hook( 'update' );\n\t\treturn function Ractive$update( keypath, callback ) {\n\t\t\tvar promise;\n\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\tcallback = keypath;\n\t\t\t\tkeypath = '';\n\t\t\t} else {\n\t\t\t\tkeypath = keypath || '';\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\tthis.viewmodel.mark( keypath );\n\t\t\trunloop.end();\n\t\t\tupdateHook.fire( this, keypath );\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, runloop );\n\n\t/* Ractive/prototype/updateModel.js */\n\tvar Ractive$updateModel = function( arrayContentsMatch, isEqual ) {\n\n\t\tvar __export;\n\t\t__export = function Ractive$updateModel( keypath, cascade ) {\n\t\t\tvar values;\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tkeypath = '';\n\t\t\t\tcascade = true;\n\t\t\t}\n\t\t\tconsolidateChangedValues( this, keypath, values = {}, cascade );\n\t\t\treturn this.set( values );\n\t\t};\n\n\t\tfunction consolidateChangedValues( ractive, keypath, values, cascade ) {\n\t\t\tvar bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];\n\t\t\tbindings = ractive._twowayBindings[ keypath ];\n\t\t\tif ( bindings && ( i = bindings.length ) ) {\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t// special case - radio name bindings\n\t\t\t\t\tif ( binding.radioName && !binding.element.node.checked ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - checkbox name bindings come in groups, so\n\t\t\t\t\t// we want to get the value once at most\n\t\t\t\t\tif ( binding.checkboxName ) {\n\t\t\t\t\t\tif ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {\n\t\t\t\t\t\t\tcheckboxGroups.push( binding.keypath );\n\t\t\t\t\t\t\tcheckboxGroups[ binding.keypath ] = binding;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\t\t\tif ( checkboxGroups.length ) {\n\t\t\t\tcheckboxGroups.forEach( function( keypath ) {\n\t\t\t\t\tvar binding, oldValue, newValue;\n\t\t\t\t\tbinding = checkboxGroups[ keypath ];\n\t\t\t\t\t// one to represent the entire group\n\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( !cascade ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// cascade\n\t\t\tchildDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];\n\t\t\tif ( childDeps ) {\n\t\t\t\ti = childDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tconsolidateChangedValues( ractive, childDeps[ i ], values, cascade );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( arrayContentsMatch, isEqual );\n\n\t/* Ractive/prototype.js */\n\tvar prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {\n\n\t\treturn {\n\t\t\tadd: add,\n\t\t\tanimate: animate,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfire: fire,\n\t\t\tget: get,\n\t\t\tinsert: insert,\n\t\t\tmerge: merge,\n\t\t\tobserve: observe,\n\t\t\toff: off,\n\t\t\ton: on,\n\t\t\tpop: pop,\n\t\t\tpush: push,\n\t\t\trender: render,\n\t\t\treset: reset,\n\t\t\tresetTemplate: resetTemplate,\n\t\t\treverse: reverse,\n\t\t\tset: set,\n\t\t\tshift: shift,\n\t\t\tsort: sort,\n\t\t\tsplice: splice,\n\t\t\tsubtract: subtract,\n\t\t\tteardown: teardown,\n\t\t\ttoggle: toggle,\n\t\t\ttoHTML: toHTML,\n\t\t\tunrender: unrender,\n\t\t\tunshift: unshift,\n\t\t\tupdate: update,\n\t\t\tupdateModel: updateModel\n\t\t};\n\t}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );\n\n\t/* utils/getGuid.js */\n\tvar getGuid = function() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {\n\t\t\tvar r, v;\n\t\t\tr = Math.random() * 16 | 0;\n\t\t\tv = c == 'x' ? r : r & 3 | 8;\n\t\t\treturn v.toString( 16 );\n\t\t} );\n\t};\n\n\t/* utils/getNextNumber.js */\n\tvar getNextNumber = function() {\n\n\t\tvar i = 0;\n\t\treturn function() {\n\t\t\treturn 'r-' + i++;\n\t\t};\n\t}();\n\n\t/* Ractive/prototype/shared/hooks/HookQueue.js */\n\tvar Ractive$shared_hooks_HookQueue = function( Hook ) {\n\n\t\tfunction HookQueue( event ) {\n\t\t\tthis.hook = new Hook( event );\n\t\t\tthis.inProcess = {};\n\t\t\tthis.queue = {};\n\t\t}\n\t\tHookQueue.prototype = {\n\t\t\tconstructor: HookQueue,\n\t\t\tbegin: function( ractive ) {\n\t\t\t\tthis.inProcess[ ractive._guid ] = true;\n\t\t\t},\n\t\t\tend: function( ractive ) {\n\t\t\t\tvar parent = ractive._parent;\n\t\t\t\t// If this is *isn't* a child of a component that's in process,\n\t\t\t\t// it should call methods or fire at this point\n\t\t\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\t\t\tfire( this, ractive );\n\t\t\t\t} else {\n\t\t\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t\t\t}\n\t\t\t\tdelete this.inProcess[ ractive._guid ];\n\t\t\t}\n\t\t};\n\n\t\tfunction getChildQueue( queue, ractive ) {\n\t\t\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t\t}\n\n\t\tfunction fire( hookQueue, ractive ) {\n\t\t\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\t\t\thookQueue.hook.fire( ractive );\n\t\t\t// queue is \"live\" because components can end up being\n\t\t\t// added while hooks fire on parents that modify data values.\n\t\t\twhile ( childQueue.length ) {\n\t\t\t\tfire( hookQueue, childQueue.shift() );\n\t\t\t}\n\t\t\tdelete hookQueue.queue[ ractive._guid ];\n\t\t}\n\t\treturn HookQueue;\n\t}( Ractive$shared_hooks_Hook );\n\n\t/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */\n\tvar viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {\n\t\tvar root = wrapper.root,\n\t\t\tkeypath = wrapper.keypath;\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\tif ( methodName === 'sort' || methodName === 'reverse' ) {\n\t\t\troot.viewmodel.set( keypath, array );\n\t\t\treturn;\n\t\t}\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t};\n\n\t/* viewmodel/prototype/get/arrayAdaptor/patch.js */\n\tvar viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {\n\n\t\tvar patchedArrayProto = [],\n\t\t\tmutatorMethods = [\n\t\t\t\t'pop',\n\t\t\t\t'push',\n\t\t\t\t'reverse',\n\t\t\t\t'shift',\n\t\t\t\t'sort',\n\t\t\t\t'splice',\n\t\t\t\t'unshift'\n\t\t\t],\n\t\t\ttestObj, patchArrayMethods, unpatchArrayMethods;\n\t\tmutatorMethods.forEach( function( methodName ) {\n\t\t\tvar method = function() {\n\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\tvar args = SLICE$0.call( arguments, 0 );\n\t\t\t\tvar newIndices, result, wrapper, i;\n\t\t\t\tnewIndices = getNewIndices( this, methodName, args );\n\t\t\t\t// apply the underlying method\n\t\t\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\t\t\t\t// trigger changes\n\t\t\t\trunloop.start();\n\t\t\t\tthis._ractive.setting = true;\n\t\t\t\ti = this._ractive.wrappers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\twrapper = this._ractive.wrappers[ i ];\n\t\t\t\t\trunloop.addViewmodel( wrapper.root.viewmodel );\n\t\t\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tthis._ractive.setting = false;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\tdefineProperty( patchedArrayProto, methodName, {\n\t\t\t\tvalue: method\n\t\t\t} );\n\t\t} );\n\t\t// can we use prototype chain injection?\n\t\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\t\ttestObj = {};\n\t\tif ( testObj.__proto__ ) {\n\t\t\t// yes, we can\n\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\tarray.__proto__ = patchedArrayProto;\n\t\t\t};\n\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\tarray.__proto__ = Array.prototype;\n\t\t\t};\n\t\t} else {\n\t\t\t// no, we can't\n\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\tvar i, methodName;\n\t\t\t\ti = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tmethodName = mutatorMethods[ i ];\n\t\t\t\t\tdefineProperty( array, methodName, {\n\t\t\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\tvar i;\n\t\t\t\ti = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete array[ mutatorMethods[ i ] ];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tpatchArrayMethods.unpatch = unpatchArrayMethods;\n\t\treturn patchArrayMethods;\n\t}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );\n\n\t/* viewmodel/prototype/get/arrayAdaptor.js */\n\tvar viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {\n\n\t\tvar arrayAdaptor,\n\t\t\t// helpers\n\t\t\tArrayWrapper, errorMessage;\n\t\tarrayAdaptor = {\n\t\t\tfilter: function( object ) {\n\t\t\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t\t\t// or the array didn't trigger the get() itself\n\t\t\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t\t\t},\n\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t\t\t}\n\t\t};\n\t\tArrayWrapper = function( ractive, array, keypath ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.value = array;\n\t\t\tthis.keypath = keypath;\n\t\t\t// if this array hasn't already been ractified, ractify it\n\t\t\tif ( !array._ractive ) {\n\t\t\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\t\t\tdefineProperty( array, '_ractive', {\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\twrappers: [],\n\t\t\t\t\t\tinstances: [],\n\t\t\t\t\t\tsetting: false\n\t\t\t\t\t},\n\t\t\t\t\tconfigurable: true\n\t\t\t\t} );\n\t\t\t\tpatch( array );\n\t\t\t}\n\t\t\t// store the ractive instance, so we can handle transitions later\n\t\t\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\t\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\t\t\tarray._ractive.instances.push( ractive );\n\t\t\t}\n\t\t\tarray._ractive.instances[ ractive._guid ] += 1;\n\t\t\tarray._ractive.wrappers.push( this );\n\t\t};\n\t\tArrayWrapper.prototype = {\n\t\t\tget: function() {\n\t\t\t\treturn this.value;\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar array, storage, wrappers, instances, index;\n\t\t\t\tarray = this.value;\n\t\t\t\tstorage = array._ractive;\n\t\t\t\twrappers = storage.wrappers;\n\t\t\t\tinstances = storage.instances;\n\t\t\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t\t\t// and immediate setup\n\t\t\t\tif ( storage.setting ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t// if nothing else depends on this array, we can revert it to its\n\t\t\t\t// natural state\n\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\tdelete array._ractive;\n\t\t\t\t\tpatch.unpatch( this.value );\n\t\t\t\t} else {\n\t\t\t\t\t// remove ractive instance if possible\n\t\t\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\t\t\tindex = instances.indexOf( this.root );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinstances.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\terrorMessage = 'Something went wrong in a rather interesting way';\n\t\treturn arrayAdaptor;\n\t}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );\n\n\t/* viewmodel/prototype/get/magicArrayAdaptor.js */\n\tvar viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {\n\n\t\tvar magicArrayAdaptor, MagicArrayWrapper;\n\t\tif ( magicAdaptor ) {\n\t\t\tmagicArrayAdaptor = {\n\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t\t\t},\n\t\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t\tMagicArrayWrapper = function( ractive, array, keypath ) {\n\t\t\t\tthis.value = array;\n\t\t\t\tthis.magic = true;\n\t\t\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\t\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t\t\t};\n\t\t\tMagicArrayWrapper.prototype = {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tthis.arrayWrapper.teardown();\n\t\t\t\t\tthis.magicWrapper.teardown();\n\t\t\t\t},\n\t\t\t\treset: function( value ) {\n\t\t\t\t\treturn this.magicWrapper.reset( value );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn magicArrayAdaptor;\n\t}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );\n\n\t/* viewmodel/prototype/adapt.js */\n\tvar viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {\n\n\t\tvar __export;\n\t\tvar prefixers = {};\n\t\t__export = function Viewmodel$adapt( keypath, value ) {\n\t\t\tvar ractive = this.ractive,\n\t\t\t\tlen, i, adaptor, wrapped;\n\t\t\t// Do we have an adaptor for this value?\n\t\t\tlen = ractive.adapt.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tadaptor = ractive.adapt[ i ];\n\t\t\t\t// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -\n\t\t\t\t// we need to get the actual adaptor if that's the case\n\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\tvar found = config.registries.adaptors.find( ractive, adaptor );\n\t\t\t\t\tif ( !found ) {\n\t\t\t\t\t\t// will throw. \"return\" for safety, if we downgrade :)\n\t\t\t\t\t\treturn log.critical( {\n\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tplugin: 'adaptor',\n\t\t\t\t\t\t\t\tname: adaptor\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tadaptor = ractive.adapt[ i ] = found;\n\t\t\t\t}\n\t\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\t\t\twrapped.value = value;\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ractive.magic ) {\n\t\t\t\tif ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t}\n\t\t\t} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\tthis.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\tfunction prefixKeypath( obj, prefix ) {\n\t\t\tvar prefixed = {},\n\t\t\t\tkey;\n\t\t\tif ( !prefix ) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tprefix += '.';\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prefixed;\n\t\t}\n\n\t\tfunction getPrefixer( rootKeypath ) {\n\t\t\tvar rootDot;\n\t\t\tif ( !prefixers[ rootKeypath ] ) {\n\t\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\t\t\t\tprefixers[ rootKeypath ] = function( relativeKeypath, value ) {\n\t\t\t\t\tvar obj;\n\t\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn prefixers[ rootKeypath ];\n\t\t}\n\t\treturn __export;\n\t}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );\n\n\t/* viewmodel/helpers/getUpstreamChanges.js */\n\tvar getUpstreamChanges = function getUpstreamChanges( changes ) {\n\t\tvar upstreamChanges = [ '' ],\n\t\t\ti, keypath, keys, upstreamKeypath;\n\t\ti = changes.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = changes[ i ];\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length > 1 ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tupstreamKeypath = keys.join( '.' );\n\t\t\t\tif ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {\n\t\t\t\t\tupstreamChanges.push( upstreamKeypath );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn upstreamChanges;\n\t};\n\n\t/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */\n\tvar viewmodel$applyChanges_getPotentialWildcardMatches = function() {\n\n\t\tvar __export;\n\t\tvar starMaps = {};\n\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t// all the variants of that keypath that include a wildcard in place\n\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t// to see if any pattern observers are downstream of one or more of\n\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\tvar keys, starMap, mapper, result;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tstarMap = getStarMap( keys.length );\n\t\t\tmapper = function( star, i ) {\n\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t};\n\t\t\tresult = starMap.map( function( mask ) {\n\t\t\t\treturn mask.map( mapper ).join( '.' );\n\t\t\t} );\n\t\t\treturn result;\n\t\t};\n\t\t// This function returns all the possible true/false combinations for\n\t\t// a given number - e.g. for two, the possible combinations are\n\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\tfunction getStarMap( length ) {\n\t\t\tvar ones = '',\n\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\tif ( !starMaps[ length ] ) {\n\t\t\t\tstarMap = [];\n\t\t\t\twhile ( ones.length < length ) {\n\t\t\t\t\tones += 1;\n\t\t\t\t}\n\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\treturn digit === '1';\n\t\t\t\t};\n\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\twhile ( binary.length < length ) {\n\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t}\n\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t}\n\t\t\t\tstarMaps[ length ] = starMap;\n\t\t\t}\n\t\t\treturn starMaps[ length ];\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */\n\tvar viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {\n\n\t\tvar __export;\n\t\tvar lastKey = /[^\\.]+$/;\n\t\t__export = notifyPatternObservers;\n\n\t\tfunction notifyPatternObservers( viewmodel, keypath, onlyDirect ) {\n\t\t\tvar potentialWildcardMatches;\n\t\t\tupdateMatchingPatternObservers( viewmodel, keypath );\n\t\t\tif ( onlyDirect ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpotentialWildcardMatches = getPotentialWildcardMatches( keypath );\n\t\t\tpotentialWildcardMatches.forEach( function( upstreamPattern ) {\n\t\t\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t\t\t} );\n\t\t}\n\n\t\tfunction cascade( viewmodel, upstreamPattern, keypath ) {\n\t\t\tvar group, map, actualChildKeypath;\n\t\t\tgroup = viewmodel.depsMap.patternObservers;\n\t\t\tmap = group[ upstreamPattern ];\n\t\t\tif ( map ) {\n\t\t\t\tmap.forEach( function( childKeypath ) {\n\t\t\t\t\tvar key = lastKey.exec( childKeypath )[ 0 ];\n\t\t\t\t\t// 'baz'\n\t\t\t\t\tactualChildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t// 'foo.bar.baz'\n\t\t\t\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\t\t\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction updateMatchingPatternObservers( viewmodel, keypath ) {\n\t\t\tviewmodel.patternObservers.forEach( function( observer ) {\n\t\t\t\tif ( observer.regex.test( keypath ) ) {\n\t\t\t\t\tobserver.update( keypath );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( viewmodel$applyChanges_getPotentialWildcardMatches );\n\n\t/* viewmodel/prototype/applyChanges.js */\n\tvar viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$applyChanges() {\n\t\t\tvar this$0 = this;\n\t\t\tvar self = this,\n\t\t\t\tchanges, upstreamChanges, hash = {};\n\t\t\tchanges = this.changes;\n\t\t\tif ( !changes.length ) {\n\t\t\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunction cascade( keypath ) {\n\t\t\t\tvar map, dependants, keys;\n\t\t\t\tif ( self.noCascade.hasOwnProperty( keypath ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t\tkeys.forEach( cascade );\n\t\t\t\t}\n\t\t\t\tif ( map = self.depsMap.computed[ keypath ] ) {\n\t\t\t\t\tmap.forEach( cascade );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction mark( keypath ) {\n\t\t\t\tself.mark( keypath );\n\t\t\t}\n\t\t\tchanges.forEach( cascade );\n\t\t\tupstreamChanges = getUpstreamChanges( changes );\n\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\tvar dependants, keys;\n\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t\tkeys.forEach( cascade );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tthis.changes = [];\n\t\t\t// Pattern observers are a weird special case\n\t\t\tif ( this.patternObservers.length ) {\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyPatternObservers( this$0, keypath, true );\n\t\t\t\t} );\n\t\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyPatternObservers( this$0, keypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.deps.observers ) {\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyUpstreamDependants( this$0, null, keypath, 'observers' );\n\t\t\t\t} );\n\t\t\t\tnotifyAllDependants( this, changes, 'observers' );\n\t\t\t}\n\t\t\tif ( this.deps[ 'default' ] ) {\n\t\t\t\tvar bindings = [];\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyUpstreamDependants( this$0, bindings, keypath, 'default' );\n\t\t\t\t} );\n\t\t\t\tif ( bindings.length ) {\n\t\t\t\t\tnotifyBindings( this, bindings, changes );\n\t\t\t\t}\n\t\t\t\tnotifyAllDependants( this, changes, 'default' );\n\t\t\t}\n\t\t\t// Return a hash of keypaths to updated values\n\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\thash[ keypath ] = this$0.get( keypath );\n\t\t\t} );\n\t\t\tthis.implicitChanges = {};\n\t\t\tthis.noCascade = {};\n\t\t\treturn hash;\n\t\t};\n\n\t\tfunction invalidate( computation ) {\n\t\t\tcomputation.invalidate();\n\t\t}\n\n\t\tfunction getKey( computation ) {\n\t\t\treturn computation.key;\n\t\t}\n\n\t\tfunction notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {\n\t\t\tvar dependants, value;\n\t\t\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\t\t\tvalue = viewmodel.get( keypath );\n\t\t\t\tdependants.forEach( function( d ) {\n\t\t\t\t\t// don't \"set\" the parent value, refine it\n\t\t\t\t\t// i.e. not data = value, but data[foo] = fooValue\n\t\t\t\t\tif ( bindings && d.refineValue ) {\n\t\t\t\t\t\tbindings.push( d );\n\t\t\t\t\t} else {\n\t\t\t\t\t\td.setValue( value );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction notifyBindings( viewmodel, bindings, changes ) {\n\t\t\tbindings.forEach( function( binding ) {\n\t\t\t\tvar useSet = false,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tlength = changes.length,\n\t\t\t\t\trefinements = [];\n\t\t\t\twhile ( i < length ) {\n\t\t\t\t\tvar keypath = changes[ i ];\n\t\t\t\t\tif ( keypath === binding.keypath ) {\n\t\t\t\t\t\tuseSet = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {\n\t\t\t\t\t\trefinements.push( keypath );\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif ( useSet ) {\n\t\t\t\t\tbinding.setValue( viewmodel.get( binding.keypath ) );\n\t\t\t\t}\n\t\t\t\tif ( refinements.length ) {\n\t\t\t\t\tbinding.refineValue( refinements );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tfunction notifyAllDependants( viewmodel, keypaths, groupName ) {\n\t\t\tvar queue = [];\n\t\t\taddKeypaths( keypaths );\n\t\t\tqueue.forEach( dispatch );\n\n\t\t\tfunction addKeypaths( keypaths ) {\n\t\t\t\tkeypaths.forEach( addKeypath );\n\t\t\t\tkeypaths.forEach( cascade );\n\t\t\t}\n\n\t\t\tfunction addKeypath( keypath ) {\n\t\t\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\t\t\t\tif ( deps ) {\n\t\t\t\t\tqueue.push( {\n\t\t\t\t\t\tkeypath: keypath,\n\t\t\t\t\t\tdeps: deps\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cascade( keypath ) {\n\t\t\t\tvar childDeps;\n\t\t\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {\n\t\t\t\t\taddKeypaths( childDeps );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction dispatch( set ) {\n\t\t\t\tvar value = viewmodel.get( set.keypath );\n\t\t\t\tset.deps.forEach( function( d ) {\n\t\t\t\t\treturn d.setValue( value );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction findDependants( viewmodel, keypath, groupName ) {\n\t\t\tvar group = viewmodel.deps[ groupName ];\n\t\t\treturn group ? group[ keypath ] : null;\n\t\t}\n\t\treturn __export;\n\t}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );\n\n\t/* viewmodel/prototype/capture.js */\n\tvar viewmodel$capture = function Viewmodel$capture() {\n\t\tthis.captureGroups.push( [] );\n\t};\n\n\t/* viewmodel/prototype/clearCache.js */\n\tvar viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {\n\t\tvar cacheMap, wrapper;\n\t\tif ( !dontTeardownWrapper ) {\n\t\t\t// Is there a wrapped property at this keypath?\n\t\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t\t// Did we unwrap it?\n\t\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t\t// Is this right?\n\t\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.cache[ keypath ] = undefined;\n\t\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\t\twhile ( cacheMap.length ) {\n\t\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t\t}\n\t\t}\n\t};\n\n\t/* viewmodel/Computation/getComputationSignature.js */\n\tvar getComputationSignature = function() {\n\n\t\tvar __export;\n\t\tvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\t\t__export = function( signature ) {\n\t\t\tif ( typeof signature === 'function' ) {\n\t\t\t\treturn {\n\t\t\t\t\tget: signature\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( typeof signature === 'string' ) {\n\t\t\t\treturn {\n\t\t\t\t\tget: createFunctionFromString( signature )\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( typeof signature === 'object' && typeof signature.get === 'string' ) {\n\t\t\t\tsignature = {\n\t\t\t\t\tget: createFunctionFromString( signature.get ),\n\t\t\t\t\tset: signature.set\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn signature;\n\t\t};\n\n\t\tfunction createFunctionFromString( signature ) {\n\t\t\tvar functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {\n\t\t\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t\t\t} ) + ')';\n\t\t\treturn new Function( functionBody );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/Computation/Computation.js */\n\tvar Computation = function( log, isEqual ) {\n\n\t\tvar Computation = function( ractive, key, signature ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.viewmodel = ractive.viewmodel;\n\t\t\tthis.key = key;\n\t\t\tthis.getter = signature.get;\n\t\t\tthis.setter = signature.set;\n\t\t\tthis.hardDeps = signature.deps || [];\n\t\t\tthis.softDeps = [];\n\t\t\tthis.depValues = {};\n\t\t\tif ( this.hardDeps ) {\n\t\t\t\tthis.hardDeps.forEach( function( d ) {\n\t\t\t\t\treturn ractive.viewmodel.register( d, this$0, 'computed' );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tthis._dirty = this._firstRun = true;\n\t\t};\n\t\tComputation.prototype = {\n\t\t\tconstructor: Computation,\n\t\t\tinit: function() {\n\t\t\t\tvar initial;\n\t\t\t\tthis.bypass = true;\n\t\t\t\tinitial = this.ractive.viewmodel.get( this.key );\n\t\t\t\tthis.ractive.viewmodel.clearCache( this.key );\n\t\t\t\tthis.bypass = false;\n\t\t\t\tif ( this.setter && initial !== undefined ) {\n\t\t\t\t\tthis.set( initial );\n\t\t\t\t}\n\t\t\t},\n\t\t\tinvalidate: function() {\n\t\t\t\tthis._dirty = true;\n\t\t\t},\n\t\t\tget: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\t\t\t\tif ( this.getting ) {\n\t\t\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.getting = true;\n\t\t\t\tif ( this._dirty ) {\n\t\t\t\t\tractive = this.ractive;\n\t\t\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t\t\t// other computed values\n\t\t\t\t\tif ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {\n\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\tvar keypath, value, i;\n\t\t\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = deps.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tkeypath = deps[ i ];\n\t\t\t\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\tif ( !isEqual( value, this$0.depValues[ keypath ] ) ) {\n\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = value;\n\t\t\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\tractive.viewmodel.capture();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.value = this.getter.call( ractive );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\t\tmessage: 'failedComputation',\n\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\tkey: this.key,\n\t\t\t\t\t\t\t\t\terr: err.message || err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tthis.value = void 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewDeps = ractive.viewmodel.release();\n\t\t\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\t\t\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\t\tdeps.forEach( function( keypath ) {\n\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.getting = this._firstRun = false;\n\t\t\t\treturn this.value;\n\t\t\t},\n\t\t\tset: function( value ) {\n\t\t\t\tif ( this.setting ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !this.setter ) {\n\t\t\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t\t\t}\n\t\t\t\tthis.setter.call( this.ractive, value );\n\t\t\t},\n\t\t\tupdateDependencies: function( newDeps ) {\n\t\t\t\tvar i, oldDeps, keypath, dependenciesChanged;\n\t\t\t\toldDeps = this.softDeps;\n\t\t\t\t// remove dependencies that are no longer used\n\t\t\t\ti = oldDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tkeypath = oldDeps[ i ];\n\t\t\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// create references for any new dependencies\n\t\t\t\ti = newDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tkeypath = newDeps[ i ];\n\t\t\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\tthis.softDeps = newDeps.slice();\n\t\t\t\t}\n\t\t\t\treturn dependenciesChanged;\n\t\t\t}\n\t\t};\n\t\treturn Computation;\n\t}( log, isEqual );\n\n\t/* viewmodel/prototype/compute.js */\n\tvar viewmodel$compute = function( getComputationSignature, Computation ) {\n\n\t\treturn function Viewmodel$compute( key, signature ) {\n\t\t\tsignature = getComputationSignature( signature );\n\t\t\treturn this.computations[ key ] = new Computation( this.ractive, key, signature );\n\t\t};\n\t}( getComputationSignature, Computation );\n\n\t/* viewmodel/prototype/get/FAILED_LOOKUP.js */\n\tvar viewmodel$get_FAILED_LOOKUP = {\n\t\tFAILED_LOOKUP: true\n\t};\n\n\t/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */\n\tvar viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {\n\n\t\tvar empty = {};\n\t\tvar UnresolvedImplicitDependency = function( viewmodel, keypath ) {\n\t\t\tthis.viewmodel = viewmodel;\n\t\t\tthis.root = viewmodel.ractive;\n\t\t\t// TODO eliminate this\n\t\t\tthis.ref = keypath;\n\t\t\tthis.parentFragment = empty;\n\t\t\tviewmodel.unresolvedImplicitDependencies[ keypath ] = true;\n\t\t\tviewmodel.unresolvedImplicitDependencies.push( this );\n\t\t\trunloop.addUnresolved( this );\n\t\t};\n\t\tUnresolvedImplicitDependency.prototype = {\n\t\t\tresolve: function() {\n\t\t\t\tthis.viewmodel.mark( this.ref );\n\t\t\t\tthis.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;\n\t\t\t\tremoveFromArray( this.viewmodel.unresolvedImplicitDependencies, this );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t}\n\t\t};\n\t\treturn UnresolvedImplicitDependency;\n\t}( removeFromArray, runloop );\n\n\t/* viewmodel/prototype/get.js */\n\tvar viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {\n\n\t\tvar __export;\n\t\tvar empty = {};\n\t\t__export = function Viewmodel$get( keypath ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = empty;\n\t\t\tvar ractive = this.ractive,\n\t\t\t\tcache = this.cache,\n\t\t\t\tvalue, computation, wrapped, captureGroup;\n\t\t\tif ( keypath[ 0 ] === '@' ) {\n\t\t\t\tvalue = keypath.slice( 1 );\n\t\t\t\treturn isNumeric( value ) ? +value : value;\n\t\t\t}\n\t\t\tif ( cache[ keypath ] === undefined ) {\n\t\t\t\t// Is this a computed property?\n\t\t\t\tif ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {\n\t\t\t\t\tvalue = computation.get();\n\t\t\t\t\tthis.adapt( keypath, value );\n\t\t\t\t} else if ( wrapped = this.wrapped[ keypath ] ) {\n\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t} else if ( !keypath ) {\n\t\t\t\t\tthis.adapt( '', ractive.data );\n\t\t\t\t\tvalue = ractive.data;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = retrieve( this, keypath );\n\t\t\t\t}\n\t\t\t\tcache[ keypath ] = value;\n\t\t\t} else {\n\t\t\t\tvalue = cache[ keypath ];\n\t\t\t}\n\t\t\tif ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {\n\t\t\t\tvalue = wrapped.get();\n\t\t\t}\n\t\t\t// capture the keypath, if we're inside a computation\n\t\t\tif ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {\n\t\t\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\t\t\tcaptureGroup.push( keypath );\n\t\t\t\t\t// if we couldn't resolve the keypath, we need to make it as a failed\n\t\t\t\t\t// lookup, so that the computation updates correctly once we CAN\n\t\t\t\t\t// resolve the keypath\n\t\t\t\t\tif ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {\n\t\t\t\t\t\tnew UnresolvedImplicitDependency( this, keypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value === FAILED_LOOKUP ? void 0 : value;\n\t\t};\n\n\t\tfunction retrieve( viewmodel, keypath ) {\n\t\t\tvar keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tkey = keys.pop();\n\t\t\tparentKeypath = keys.join( '.' );\n\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\tif ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\tparentValue = wrapped.get();\n\t\t\t}\n\t\t\tif ( parentValue === null || parentValue === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// update cache map\n\t\t\tif ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {\n\t\t\t\tviewmodel.cacheMap[ parentKeypath ] = [ keypath ];\n\t\t\t} else {\n\t\t\t\tif ( cacheMap.indexOf( keypath ) === -1 ) {\n\t\t\t\t\tcacheMap.push( keypath );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If this property doesn't exist, we return a sentinel value\n\t\t\t// so that we know to query parent scope (if such there be)\n\t\t\tif ( typeof parentValue === 'object' && !( key in parentValue ) ) {\n\t\t\t\treturn viewmodel.cache[ keypath ] = FAILED_LOOKUP;\n\t\t\t}\n\t\t\tvalue = parentValue[ key ];\n\t\t\t// Do we have an adaptor for this value?\n\t\t\tviewmodel.adapt( keypath, value, false );\n\t\t\t// Update cache\n\t\t\tviewmodel.cache[ keypath ] = value;\n\t\t\treturn value;\n\t\t}\n\t\treturn __export;\n\t}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );\n\n\t/* viewmodel/prototype/init.js */\n\tvar viewmodel$init = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$init() {\n\t\t\tvar key, computation, computations = [];\n\t\t\tfor ( key in this.ractive.computed ) {\n\t\t\t\tcomputation = this.compute( key, this.ractive.computed[ key ] );\n\t\t\t\tcomputations.push( computation );\n\t\t\t}\n\t\t\tcomputations.forEach( init );\n\t\t};\n\n\t\tfunction init( computation ) {\n\t\t\tcomputation.init();\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/mark.js */\n\tvar viewmodel$mark = function Viewmodel$mark( keypath, options ) {\n\t\tvar computation;\n\t\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t\t// should not be picked up by pattern observers\n\t\tif ( options ) {\n\t\t\tif ( options.implicit ) {\n\t\t\t\tthis.implicitChanges[ keypath ] = true;\n\t\t\t}\n\t\t\tif ( options.noCascade ) {\n\t\t\t\tthis.noCascade[ keypath ] = true;\n\t\t\t}\n\t\t}\n\t\tif ( computation = this.computations[ keypath ] ) {\n\t\t\tcomputation.invalidate();\n\t\t}\n\t\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\t\tthis.changes.push( keypath );\n\t\t}\n\t\tthis.clearCache( keypath );\n\t};\n\n\t/* viewmodel/prototype/merge/mapOldToNewIndex.js */\n\tvar viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {\n\t\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\t\tusedIndices = {};\n\t\tfirstUnusedIndex = 0;\n\t\tnewIndices = oldArray.map( function( item, i ) {\n\t\t\tvar index, start, len;\n\t\t\tstart = firstUnusedIndex;\n\t\t\tlen = newArray.length;\n\t\t\tdo {\n\t\t\t\tindex = newArray.indexOf( item, start );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tstart = index + 1;\n\t\t\t} while ( usedIndices[ index ] && start < len );\n\t\t\t// keep track of the first unused index, so we don't search\n\t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\t\tif ( index === firstUnusedIndex ) {\n\t\t\t\tfirstUnusedIndex += 1;\n\t\t\t}\n\t\t\tif ( index !== i ) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tusedIndices[ index ] = true;\n\t\t\treturn index;\n\t\t} );\n\t\treturn newIndices;\n\t};\n\n\t/* viewmodel/prototype/merge.js */\n\tvar viewmodel$merge = function( warn, mapOldToNewIndex ) {\n\n\t\tvar __export;\n\t\tvar comparators = {};\n\t\t__export = function Viewmodel$merge( keypath, currentArray, array, options ) {\n\t\t\tvar oldArray, newArray, comparator, newIndices;\n\t\t\tthis.mark( keypath );\n\t\t\tif ( options && options.compare ) {\n\t\t\t\tcomparator = getComparatorFunction( options.compare );\n\t\t\t\ttry {\n\t\t\t\t\toldArray = currentArray.map( comparator );\n\t\t\t\t\tnewArray = array.map( comparator );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t\t\t// to do more DOM manipulation than we thought...\n\t\t\t\t\t// ...unless we're in debug mode of course\n\t\t\t\t\tif ( this.debug ) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarn( 'Merge operation: comparison failed. Falling back to identity checking' );\n\t\t\t\t\t}\n\t\t\t\t\toldArray = currentArray;\n\t\t\t\t\tnewArray = array;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toldArray = currentArray;\n\t\t\t\tnewArray = array;\n\t\t\t}\n\t\t\t// find new indices for members of oldArray\n\t\t\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\t\t\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n\t\t};\n\n\t\tfunction stringify( item ) {\n\t\t\treturn JSON.stringify( item );\n\t\t}\n\n\t\tfunction getComparatorFunction( comparator ) {\n\t\t\t// If `compare` is `true`, we use JSON.stringify to compare\n\t\t\t// objects that are the same shape, but non-identical - i.e.\n\t\t\t// { foo: 'bar' } !== { foo: 'bar' }\n\t\t\tif ( comparator === true ) {\n\t\t\t\treturn stringify;\n\t\t\t}\n\t\t\tif ( typeof comparator === 'string' ) {\n\t\t\t\tif ( !comparators[ comparator ] ) {\n\t\t\t\t\tcomparators[ comparator ] = function( item ) {\n\t\t\t\t\t\treturn item[ comparator ];\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn comparators[ comparator ];\n\t\t\t}\n\t\t\tif ( typeof comparator === 'function' ) {\n\t\t\t\treturn comparator;\n\t\t\t}\n\t\t\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n\t\t}\n\t\treturn __export;\n\t}( warn, viewmodel$merge_mapOldToNewIndex );\n\n\t/* viewmodel/prototype/register.js */\n\tvar viewmodel$register = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$register( keypath, dependant ) {\n\t\t\tvar group = arguments[ 2 ];\n\t\t\tif ( group === void 0 )\n\t\t\t\tgroup = 'default';\n\t\t\tvar depsByKeypath, deps;\n\t\t\tif ( dependant.isStatic ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\t\tdeps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );\n\t\t\tdeps.push( dependant );\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t};\n\n\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t// update dependants map\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\tmap = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );\n\t\t\t\tparent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );\n\t\t\t\tif ( parent[ keypath ] === undefined ) {\n\t\t\t\t\tparent[ keypath ] = 0;\n\t\t\t\t\tparent.push( keypath );\n\t\t\t\t}\n\t\t\t\tparent[ keypath ] += 1;\n\t\t\t\tkeypath = parentKeypath;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/release.js */\n\tvar viewmodel$release = function Viewmodel$release() {\n\t\treturn this.captureGroups.pop();\n\t};\n\n\t/* viewmodel/prototype/set.js */\n\tvar viewmodel$set = function( isEqual, createBranch ) {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$set( keypath, value, silent ) {\n\t\t\tvar computation, wrapper, dontTeardownWrapper;\n\t\t\tcomputation = this.computations[ keypath ];\n\t\t\tif ( computation ) {\n\t\t\t\tif ( computation.setting ) {\n\t\t\t\t\t// let the other computation set() handle things...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcomputation.set( value );\n\t\t\t\tvalue = computation.get();\n\t\t\t}\n\t\t\tif ( isEqual( this.cache[ keypath ], value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twrapper = this.wrapped[ keypath ];\n\t\t\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t\t\t// `reset()` method returns false, the wrapper should be torn down, and\n\t\t\t// (most likely) a new one should be created later\n\t\t\tif ( wrapper && wrapper.reset ) {\n\t\t\t\tdontTeardownWrapper = wrapper.reset( value ) !== false;\n\t\t\t\tif ( dontTeardownWrapper ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !computation && !dontTeardownWrapper ) {\n\t\t\t\tresolveSet( this, keypath, value );\n\t\t\t}\n\t\t\tif ( !silent ) {\n\t\t\t\tthis.mark( keypath );\n\t\t\t} else {\n\t\t\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t\t\t// not mark it as a change\n\t\t\t\tthis.clearCache( keypath );\n\t\t\t}\n\t\t};\n\n\t\tfunction resolveSet( viewmodel, keypath, value ) {\n\t\t\tvar keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;\n\t\t\twrapperSet = function() {\n\t\t\t\tif ( wrapper.set ) {\n\t\t\t\t\twrapper.set( lastKey, value );\n\t\t\t\t} else {\n\t\t\t\t\tparentValue = wrapper.get();\n\t\t\t\t\tvalueSet();\n\t\t\t\t}\n\t\t\t};\n\t\t\tvalueSet = function() {\n\t\t\t\tif ( !parentValue ) {\n\t\t\t\t\tparentValue = createBranch( lastKey );\n\t\t\t\t\tviewmodel.set( parentKeypath, parentValue, true );\n\t\t\t\t}\n\t\t\t\tparentValue[ lastKey ] = value;\n\t\t\t};\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tlastKey = keys.pop();\n\t\t\tparentKeypath = keys.join( '.' );\n\t\t\twrapper = viewmodel.wrapped[ parentKeypath ];\n\t\t\tif ( wrapper ) {\n\t\t\t\twrapperSet();\n\t\t\t} else {\n\t\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\t\t// may have been wrapped via the above .get()\n\t\t\t\t// call on viewmodel if this is first access via .set()!\n\t\t\t\tif ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\t\twrapperSet();\n\t\t\t\t} else {\n\t\t\t\t\tvalueSet();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( isEqual, createBranch );\n\n\t/* viewmodel/prototype/smartUpdate.js */\n\tvar viewmodel$smartUpdate = function() {\n\n\t\tvar __export;\n\t\tvar implicitOption = {\n\t\t\t\timplicit: true\n\t\t\t},\n\t\t\tnoCascadeOption = {\n\t\t\t\tnoCascade: true\n\t\t\t};\n\t\t__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar dependants, oldLength;\n\t\t\toldLength = newIndices.length;\n\t\t\t// Indices that are being removed should be marked as dirty\n\t\t\tnewIndices.forEach( function( newIndex, oldIndex ) {\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tthis$0.mark( keypath + '.' + oldIndex, noCascadeOption );\n\t\t\t\t}\n\t\t\t} );\n\t\t\t// Update the model\n\t\t\t// TODO allow existing array to be updated in place, rather than replaced?\n\t\t\tthis.set( keypath, array, true );\n\t\t\tif ( dependants = this.deps[ 'default' ][ keypath ] ) {\n\t\t\t\tdependants.filter( canShuffle ).forEach( function( d ) {\n\t\t\t\t\treturn d.shuffle( newIndices, array );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( oldLength !== array.length ) {\n\t\t\t\tthis.mark( keypath + '.length', implicitOption );\n\t\t\t\tfor ( var i = oldLength; i < array.length; i += 1 ) {\n\t\t\t\t\tthis.mark( keypath + '.' + i );\n\t\t\t\t}\n\t\t\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t\t\tfor ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {\n\t\t\t\t\tthis.mark( keypath + '.' + i$0, noCascadeOption );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction canShuffle( dependant ) {\n\t\t\treturn typeof dependant.shuffle === 'function';\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/teardown.js */\n\tvar viewmodel$teardown = function Viewmodel$teardown() {\n\t\tvar this$0 = this;\n\t\tvar unresolvedImplicitDependency;\n\t\t// Clear entire cache - this has the desired side-effect\n\t\t// of unwrapping adapted values (e.g. arrays)\n\t\tObject.keys( this.cache ).forEach( function( keypath ) {\n\t\t\treturn this$0.clearCache( keypath );\n\t\t} );\n\t\t// Teardown any failed lookups - we don't need them to resolve any more\n\t\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\t\tunresolvedImplicitDependency.teardown();\n\t\t}\n\t};\n\n\t/* viewmodel/prototype/unregister.js */\n\tvar viewmodel$unregister = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$unregister( keypath, dependant ) {\n\t\t\tvar group = arguments[ 2 ];\n\t\t\tif ( group === void 0 )\n\t\t\t\tgroup = 'default';\n\t\t\tvar deps, index;\n\t\t\tif ( dependant.isStatic ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdeps = this.deps[ group ][ keypath ];\n\t\t\tindex = deps.indexOf( dependant );\n\t\t\tif ( index === -1 ) {\n\t\t\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t\t\t}\n\t\t\tdeps.splice( index, 1 );\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t};\n\n\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t// update dependants map\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\tmap = viewmodel.depsMap[ group ];\n\t\t\t\tparent = map[ parentKeypath ];\n\t\t\t\tparent[ keypath ] -= 1;\n\t\t\t\tif ( !parent[ keypath ] ) {\n\t\t\t\t\t// remove from parent deps map\n\t\t\t\t\tparent.splice( parent.indexOf( keypath ), 1 );\n\t\t\t\t\tparent[ keypath ] = undefined;\n\t\t\t\t}\n\t\t\t\tkeypath = parentKeypath;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/adaptConfig.js */\n\tvar adaptConfig = function() {\n\n\t\t// should this be combined with prototype/adapt.js?\n\t\tvar configure = {\n\t\t\tlookup: function( target, adaptors ) {\n\t\t\t\tvar i, adapt = target.adapt;\n\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\treturn adapt;\n\t\t\t\t}\n\t\t\t\tif ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar adaptor = adapt[ i ];\n\t\t\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\t\t\tadapt[ i ] = adaptors[ adaptor ] || adaptor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn adapt;\n\t\t\t},\n\t\t\tcombine: function( parent, adapt ) {\n\t\t\t\t// normalize 'Foo' to [ 'Foo' ]\n\t\t\t\tparent = arrayIfString( parent );\n\t\t\t\tadapt = arrayIfString( adapt );\n\t\t\t\t// no parent? return adapt\n\t\t\t\tif ( !parent || !parent.length ) {\n\t\t\t\t\treturn adapt;\n\t\t\t\t}\n\t\t\t\t// no adapt? return 'copy' of parent\n\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\treturn parent.slice();\n\t\t\t\t}\n\t\t\t\t// add parent adaptors to options\n\t\t\t\tparent.forEach( function( a ) {\n\t\t\t\t\t// don't put in duplicates\n\t\t\t\t\tif ( adapt.indexOf( a ) === -1 ) {\n\t\t\t\t\t\tadapt.push( a );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn adapt;\n\t\t\t}\n\t\t};\n\n\t\tfunction arrayIfString( adapt ) {\n\t\t\tif ( typeof adapt === 'string' ) {\n\t\t\t\tadapt = [ adapt ];\n\t\t\t}\n\t\t\treturn adapt;\n\t\t}\n\t\treturn configure;\n\t}();\n\n\t/* viewmodel/Viewmodel.js */\n\tvar Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {\n\n\t\tvar noMagic;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t} catch ( err ) {\n\t\t\tnoMagic = true;\n\t\t}\n\t\tvar Viewmodel = function( ractive ) {\n\t\t\tthis.ractive = ractive;\n\t\t\t// TODO eventually, we shouldn't need this reference\n\t\t\tViewmodel.extend( ractive.constructor, ractive );\n\t\t\tthis.cache = {};\n\t\t\t// we need to be able to use hasOwnProperty, so can't inherit from null\n\t\t\tthis.cacheMap = create( null );\n\t\t\tthis.deps = {\n\t\t\t\tcomputed: {},\n\t\t\t\t'default': {}\n\t\t\t};\n\t\t\tthis.depsMap = {\n\t\t\t\tcomputed: {},\n\t\t\t\t'default': {}\n\t\t\t};\n\t\t\tthis.patternObservers = [];\n\t\t\tthis.wrapped = create( null );\n\t\t\tthis.computations = create( null );\n\t\t\tthis.captureGroups = [];\n\t\t\tthis.unresolvedImplicitDependencies = [];\n\t\t\tthis.changes = [];\n\t\t\tthis.implicitChanges = {};\n\t\t\tthis.noCascade = {};\n\t\t};\n\t\tViewmodel.extend = function( Parent, instance ) {\n\t\t\tif ( instance.magic && noMagic ) {\n\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t}\n\t\t\tinstance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];\n\t\t\tinstance.adapt = adaptConfig.lookup( instance, instance.adaptors );\n\t\t};\n\t\tViewmodel.prototype = {\n\t\t\tadapt: adapt,\n\t\t\tapplyChanges: applyChanges,\n\t\t\tcapture: capture,\n\t\t\tclearCache: clearCache,\n\t\t\tcompute: compute,\n\t\t\tget: get,\n\t\t\tinit: init,\n\t\t\tmark: mark,\n\t\t\tmerge: merge,\n\t\t\tregister: register,\n\t\t\trelease: release,\n\t\t\tset: set,\n\t\t\tsmartUpdate: smartUpdate,\n\t\t\tteardown: teardown,\n\t\t\tunregister: unregister\n\t\t};\n\t\treturn Viewmodel;\n\t}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );\n\n\t/* Ractive/initialise.js */\n\tvar Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {\n\n\t\tvar __export;\n\t\tvar constructHook = new Hook( 'construct' ),\n\t\t\tconfigHook = new Hook( 'config' ),\n\t\t\tinitHook = new HookQueue( 'init' );\n\t\t__export = function initialiseRactiveInstance( ractive ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar el;\n\t\t\tinitialiseProperties( ractive, options );\n\t\t\t// make this option do what would be expected if someone\n\t\t\t// did include it on a new Ractive() or new Component() call.\n\t\t\t// Silly to do so (put a hook on the very options being used),\n\t\t\t// but handle it correctly, consistent with the intent.\n\t\t\tconstructHook.fire( config.getConstructTarget( ractive, options ), options );\n\t\t\t// init config from Parent and options\n\t\t\tconfig.init( ractive.constructor, ractive, options );\n\t\t\tconfigHook.fire( ractive );\n\t\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t\t// avoids certain weird bugs\n\t\t\tif ( el = getElement( ractive.el ) ) {\n\t\t\t\tif ( !ractive.append ) {\n\t\t\t\t\tif ( el.__ractive_instances__ ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tel.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {\n\t\t\t\t\t\t\t\treturn r.teardown();\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\t}\n\t\t\t\t\tel.innerHTML = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tinitHook.begin( ractive );\n\t\t\t// TEMPORARY. This is so we can implement Viewmodel gradually\n\t\t\tractive.viewmodel = new Viewmodel( ractive );\n\t\t\t// hacky circular problem until we get this sorted out\n\t\t\t// if viewmodel immediately processes computed properties,\n\t\t\t// they may call ractive.get, which calls ractive.viewmodel,\n\t\t\t// which hasn't been set till line above finishes.\n\t\t\tractive.viewmodel.init();\n\t\t\t// Render our *root fragment*\n\t\t\tif ( ractive.template ) {\n\t\t\t\tractive.fragment = new Fragment( {\n\t\t\t\t\ttemplate: ractive.template,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: ractive\n\t\t\t\t} );\n\t\t\t}\n\t\t\tinitHook.end( ractive );\n\t\t\t// render automatically ( if `el` is specified )\n\t\t\tif ( el ) {\n\t\t\t\tractive.render( el, ractive.append );\n\t\t\t}\n\t\t};\n\n\t\tfunction initialiseProperties( ractive, options ) {\n\t\t\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t\t\t// existed\n\t\t\tractive._guid = getNextNumber();\n\t\t\t// events\n\t\t\tractive._subs = create( null );\n\t\t\t// storage for item configuration from instantiation to reset,\n\t\t\t// like dynamic functions or original values\n\t\t\tractive._config = {};\n\t\t\t// two-way bindings\n\t\t\tractive._twowayBindings = create( null );\n\t\t\t// animations (so we can stop any in progress at teardown)\n\t\t\tractive._animations = [];\n\t\t\t// nodes registry\n\t\t\tractive.nodes = {};\n\t\t\t// live queries\n\t\t\tractive._liveQueries = [];\n\t\t\tractive._liveComponentQueries = [];\n\t\t\t// If this is a component, store a reference to the parent\n\t\t\tif ( options._parent && options._component ) {\n\t\t\t\tractive._parent = options._parent;\n\t\t\t\tractive.component = options._component;\n\t\t\t\t// And store a reference to the instance on the component\n\t\t\t\toptions._component.instance = ractive;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );\n\n\t/* extend/unwrapExtended.js */\n\tvar unwrapExtended = function( wrap, config, circular ) {\n\n\t\tvar __export;\n\t\tvar Ractive;\n\t\tcircular.push( function() {\n\t\t\tRactive = circular.Ractive;\n\t\t} );\n\t\t__export = function unwrapExtended( Child ) {\n\t\t\tif ( !( Child.prototype instanceof Ractive ) ) {\n\t\t\t\treturn Child;\n\t\t\t}\n\t\t\tvar options = {};\n\t\t\twhile ( Child ) {\n\t\t\t\tconfig.registries.forEach( function( r ) {\n\t\t\t\t\taddRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );\n\t\t\t\t} );\n\t\t\t\tObject.keys( Child.prototype ).forEach( function( key ) {\n\t\t\t\t\tif ( key === 'computed' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar value = Child.prototype[ key ];\n\t\t\t\t\tif ( !( key in options ) ) {\n\t\t\t\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t\t\t\t} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {\n\t\t\t\t\t\tvar result, needsSuper = value._method;\n\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\tvalue = value._method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// rewrap bound directly to parent fn\n\t\t\t\t\t\tresult = wrap( options[ key ]._method, value );\n\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\tresult._method = result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[ key ] = result;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( Child._parent !== Ractive ) {\n\t\t\t\t\tChild = Child._parent;\n\t\t\t\t} else {\n\t\t\t\t\tChild = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t};\n\n\t\tfunction addRegistry( target, options, name ) {\n\t\t\tvar registry, keys = Object.keys( target[ name ] );\n\t\t\tif ( !keys.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !( registry = options[ name ] ) ) {\n\t\t\t\tregistry = options[ name ] = {};\n\t\t\t}\n\t\t\tkeys.filter( function( key ) {\n\t\t\t\treturn !( key in registry );\n\t\t\t} ).forEach( function( key ) {\n\t\t\t\treturn registry[ key ] = target[ name ][ key ];\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( wrapMethod, config, circular );\n\n\t/* extend/_extend.js */\n\tvar Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {\n\n\t\treturn function extend() {\n\t\t\tvar options = arguments[ 0 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar Parent = this,\n\t\t\t\tChild, proto, staticProperties;\n\t\t\t// if we're extending with another Ractive instance, inherit its\n\t\t\t// prototype methods and default options as well\n\t\t\toptions = unwrap( options );\n\t\t\t// create Child constructor\n\t\t\tChild = function( options ) {\n\t\t\t\tinitialise( this, options );\n\t\t\t};\n\t\t\tproto = create( Parent.prototype );\n\t\t\tproto.constructor = Child;\n\t\t\tstaticProperties = {\n\t\t\t\t// each component needs a guid, for managing CSS etc\n\t\t\t\t_guid: {\n\t\t\t\t\tvalue: getGuid()\n\t\t\t\t},\n\t\t\t\t// alias prototype as defaults\n\t\t\t\tdefaults: {\n\t\t\t\t\tvalue: proto\n\t\t\t\t},\n\t\t\t\t// extendable\n\t\t\t\textend: {\n\t\t\t\t\tvalue: extend,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t},\n\t\t\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t\t\t_parent: {\n\t\t\t\t\tvalue: Parent\n\t\t\t\t}\n\t\t\t};\n\t\t\tdefineProperties( Child, staticProperties );\n\t\t\t// extend configuration\n\t\t\tconfig.extend( Parent, proto, options );\n\t\t\tViewmodel.extend( Parent, proto );\n\t\t\tChild.prototype = proto;\n\t\t\treturn Child;\n\t\t};\n\t}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );\n\n\t/* Ractive.js */\n\tvar Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {\n\n\t\tvar Ractive, properties;\n\t\t// Main Ractive required object\n\t\tRactive = function( options ) {\n\t\t\tinitialise( this, options );\n\t\t};\n\t\t// Ractive properties\n\t\tproperties = {\n\t\t\t// static methods:\n\t\t\textend: {\n\t\t\t\tvalue: extend\n\t\t\t},\n\t\t\tparse: {\n\t\t\t\tvalue: parse\n\t\t\t},\n\t\t\t// Namespaced constructors\n\t\t\tPromise: {\n\t\t\t\tvalue: Promise\n\t\t\t},\n\t\t\t// support\n\t\t\tsvg: {\n\t\t\t\tvalue: svg\n\t\t\t},\n\t\t\tmagic: {\n\t\t\t\tvalue: magic\n\t\t\t},\n\t\t\t// version\n\t\t\tVERSION: {\n\t\t\t\tvalue: '0.6.1'\n\t\t\t},\n\t\t\t// Plugins\n\t\t\tadaptors: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tcomponents: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tdecorators: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\teasing: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: easing\n\t\t\t},\n\t\t\tevents: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tinterpolators: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: interpolators\n\t\t\t},\n\t\t\tpartials: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\ttransitions: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t}\n\t\t};\n\t\t// Ractive properties\n\t\tdefineProperties( Ractive, properties );\n\t\tRactive.prototype = extendObj( proto, defaults );\n\t\tRactive.prototype.constructor = Ractive;\n\t\t// alias prototype as defaults\n\t\tRactive.defaults = Ractive.prototype;\n\t\t// Certain modules have circular dependencies. If we were bundling a\n\t\t// module loader, e.g. almond.js, this wouldn't be a problem, but we're\n\t\t// not - we're using amdclean as part of the build process. Because of\n\t\t// this, we need to wait until all modules have loaded before those\n\t\t// circular dependencies can be required.\n\t\tcircular.Ractive = Ractive;\n\t\twhile ( circular.length ) {\n\t\t\tcircular.pop()();\n\t\t}\n\t\t// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t\t// older browsers, these are made available via a shim - here, we do a quick\n\t\t// pre-flight check to make sure that either a) we're not in a shit browser,\n\t\t// or b) we're using a Ractive-legacy.js build\n\t\tvar FUNCTION = 'function';\n\t\tif ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {\n\t\t\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t\t}\n\t\treturn Ractive;\n\t}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );\n\n\n\t// export as Common JS module...\n\tif ( typeof module !== \"undefined\" && module.exports ) {\n\t\tmodule.exports = Ractive;\n\t}\n\n\t// ... or as AMD module\n\telse if ( typeof define === \"function\" && define.amd ) {\n\t\tdefine( function() {\n\t\t\treturn Ractive;\n\t\t} );\n\t}\n\n\t// ... or as browser global\n\tglobal.Ractive = Ractive;\n\n\tRactive.noConflict = function() {\n\t\tglobal.Ractive = noConflict;\n\t\treturn Ractive;\n\t};\n\n}( typeof window !== 'undefined' ? window : this ) );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ractive/ractive.js\n ** module id = 255\n ** module chunks = 3\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!/home/ubuntu/bemuse/node_modules/css-loader/index.js!/home/ubuntu/bemuse/node_modules/autoprefixer-loader/index.js?browsers=last 2 version!/home/ubuntu/bemuse/node_modules/sass-loader/index.js?outputStyle=expanded!/home/ubuntu/bemuse/src/game/loading-scene/style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!/home/ubuntu/bemuse/node_modules/style-loader/addStyles.js\")(content, {});\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tmodule.hot.accept(\"!!/home/ubuntu/bemuse/node_modules/css-loader/index.js!/home/ubuntu/bemuse/node_modules/autoprefixer-loader/index.js?browsers=last 2 version!/home/ubuntu/bemuse/node_modules/sass-loader/index.js?outputStyle=expanded!/home/ubuntu/bemuse/src/game/loading-scene/style.scss\", function() {\n\t\tvar newContent = require(\"!!/home/ubuntu/bemuse/node_modules/css-loader/index.js!/home/ubuntu/bemuse/node_modules/autoprefixer-loader/index.js?browsers=last 2 version!/home/ubuntu/bemuse/node_modules/sass-loader/index.js?outputStyle=expanded!/home/ubuntu/bemuse/src/game/loading-scene/style.scss\");\n\t\tif(typeof newContent === 'string') newContent = [module.id, newContent, ''];\n\t\tupdate(newContent);\n\t});\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./game/loading-scene/style.scss\n ** module id = 276\n ** module chunks = 3\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/events/events.js\n ** module id = 363\n ** module chunks = 3\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 364\n ** module chunks = 3\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/util/~/inherits/inherits_browser.js\n ** module id = 367\n ** module chunks = 3\n **/","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/util/support/isBufferBrowser.js\n ** module id = 368\n ** module chunks = 3\n **/","var View = require(\"bemuse/view\").View; var template = require(\"!!ractive!bemuse/view/template!/home/ubuntu/bemuse/node_modules/jade-loader/index.js!/home/ubuntu/bemuse/src/game/loading-scene/view.jade\"); module.exports = new View(template);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./view/index.loader.js!./game/loading-scene/view.jade\n ** module id = 369\n ** module chunks = 3\n **/"],"sourceRoot":""}